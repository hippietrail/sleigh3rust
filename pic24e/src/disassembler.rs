pub type AddrType = u32;
macro_rules! impl_read_to_type {
    ($ unsigned_type : ty , $ signed_type : ty , $ len : literal , $ read_unsigned : ident , $ read_signed : ident , $ write_unsigned : ident , $ write_signed : ident) => {
        const fn $read_unsigned<const BIG_ENDIAN: bool>(
            data: [u8; $len],
            start_bit: usize,
            len_bits: usize,
        ) -> $unsigned_type {
            const TYPE_BITS: usize = <$unsigned_type>::BITS as usize;
            assert!(TYPE_BITS / 8 == $len);
            assert!(len_bits > 0);
            assert!(len_bits + start_bit <= TYPE_BITS);
            let mut data = if BIG_ENDIAN {
                <$unsigned_type>::from_be_bytes(data)
            } else {
                <$unsigned_type>::from_le_bytes(data)
            };
            let value_mask = <$unsigned_type>::MAX >> (TYPE_BITS - len_bits);
            data = data >> start_bit;
            data = data & value_mask;
            data
        }
        const fn $read_signed<const BIG_ENDIAN: bool>(
            data: [u8; $len],
            start_bit: usize,
            len_bits: usize,
        ) -> $signed_type {
            const TYPE_BITS: usize = <$signed_type>::BITS as usize;
            assert!(len_bits > 1);
            assert!(TYPE_BITS / 8 == $len);
            let data = $read_unsigned::<BIG_ENDIAN>(data, start_bit, len_bits);
            let value_mask =
                <$signed_type>::MAX as $unsigned_type >> (TYPE_BITS - len_bits);
            let sign_mask = !value_mask;
            let value_part = data & value_mask;
            let sign_part = data & sign_mask;
            if sign_part != 0 {
                sign_mask as $signed_type | value_part as $signed_type
            } else {
                data as $signed_type
            }
        }
        const fn $write_unsigned<const BIG_ENDIAN: bool>(
            value: $unsigned_type,
            mem: $unsigned_type,
            start_bit: usize,
            len_bits: usize,
        ) -> [u8; $len] {
            const TYPE_BITS: usize = <$unsigned_type>::BITS as usize;
            assert!(len_bits > 0);
            assert!(len_bits + start_bit <= TYPE_BITS);
            let value_max = <$unsigned_type>::MAX >> (TYPE_BITS - len_bits);
            let mask = value_max << start_bit;
            let mut value = value;
            value <<= start_bit;
            value = (mem & !mask) | value;
            if BIG_ENDIAN {
                value.to_be_bytes()
            } else {
                value.to_le_bytes()
            }
        }
        const fn $write_signed<const BIG_ENDIAN: bool>(
            value: $signed_type,
            mem: $signed_type,
            start_bit: usize,
            len_bits: usize,
        ) -> [u8; $len] {
            const TYPE_BITS: usize = <$unsigned_type>::BITS as usize;
            assert!(len_bits > 0);
            assert!(len_bits + start_bit <= TYPE_BITS);
            let value_max = <$signed_type>::MAX >> (TYPE_BITS - len_bits);
            let value_min = <$signed_type>::MIN >> (TYPE_BITS - len_bits);
            let mask = <$unsigned_type>::MAX >> (TYPE_BITS - len_bits);
            let value = value as $unsigned_type & mask;
            let mem = mem as $unsigned_type;
            $write_unsigned::<BIG_ENDIAN>(value, mem, start_bit, len_bits)
        }
    };
}
impl_read_to_type!(u8, i8, 1, read_u8, read_i8, write_u8, write_i8);
impl_read_to_type!(u16, i16, 2, read_u16, read_i16, write_u16, write_i16);
impl_read_to_type!(u32, i32, 4, read_u32, read_i32, write_u32, write_i32);
impl_read_to_type!(u64, i64, 8, read_u64, read_i64, write_u64, write_i64);
impl_read_to_type!(
    u128, i128, 16, read_u128, read_i128, write_u128, write_i128
);
pub trait GlobalSetTrait {
    fn set_blockEnd(&mut self, address: Option<u32>, value: i64);
    fn set_phase(&mut self, address: Option<u32>, value: i64);
    fn set_repeatInstr(&mut self, address: Option<u32>, value: i64);
    fn set_skipInstr(&mut self, address: Option<u32>, value: i64);
}
pub trait MemoryRead {
    type AddressType;
    fn read(&self, addr: Self::AddressType, buf: &mut [u8]);
}
pub trait MemoryWrite {
    type AddressType;
    fn write(&mut self, addr: Self::AddressType, buf: &[u8]);
}
pub trait ContextregisterTrait:
    MemoryRead<AddressType = u16> + MemoryWrite<AddressType = u16>
{
    fn read_blockEnd_raw(&self) -> u8 {
        let mut work_value = [0u8; 1u64 as usize];
        self.read(0u64 as u16, &mut work_value[0..1]);
        let value = read_u8::<false>(work_value, 0u64 as usize, 1u64 as usize);
        u8::try_from(value).unwrap()
    }
    fn write_blockEnd_raw(&mut self, param: u8) {
        let mut mem = [0u8; 1];
        self.read(0u64 as u16, &mut mem[0..1]);
        let mem = u8::from_le_bytes(mem);
        let mem =
            write_u8::<false>(param as u8, mem, 0u64 as usize, 1u64 as usize);
        self.write(0u64 as u16, &mem[0..1]);
    }
    fn read_blockEnd_disassembly(&self) -> i64 {
        i64::try_from(self.read_blockEnd_raw()).unwrap()
    }
    fn write_blockEnd_disassembly(&mut self, param: i64) {
        self.write_blockEnd_raw(u8::try_from(param).unwrap())
    }
    fn read_blockEnd_execution(&self) -> u8 {
        self.read_blockEnd_raw()
    }
    fn write_blockEnd_execution(&mut self, param: u8) {
        self.write_blockEnd_raw(param)
    }
    fn blockEnd_display(&self) -> DisplayElement {
        meaning_number(true, self.read_blockEnd_raw())
    }
    fn read_phase_raw(&self) -> u8 {
        let mut work_value = [0u8; 1u64 as usize];
        self.read(0u64 as u16, &mut work_value[0..1]);
        let value = read_u8::<false>(work_value, 2u64 as usize, 2u64 as usize);
        u8::try_from(value).unwrap()
    }
    fn write_phase_raw(&mut self, param: u8) {
        let mut mem = [0u8; 1];
        self.read(0u64 as u16, &mut mem[0..1]);
        let mem = u8::from_le_bytes(mem);
        let mem =
            write_u8::<false>(param as u8, mem, 2u64 as usize, 2u64 as usize);
        self.write(0u64 as u16, &mem[0..1]);
    }
    fn read_phase_disassembly(&self) -> i64 {
        i64::try_from(self.read_phase_raw()).unwrap()
    }
    fn write_phase_disassembly(&mut self, param: i64) {
        self.write_phase_raw(u8::try_from(param).unwrap())
    }
    fn read_phase_execution(&self) -> u8 {
        self.read_phase_raw()
    }
    fn write_phase_execution(&mut self, param: u8) {
        self.write_phase_raw(param)
    }
    fn phase_display(&self) -> DisplayElement {
        meaning_number(true, self.read_phase_raw())
    }
    fn read_repeatInstr_raw(&self) -> u8 {
        let mut work_value = [0u8; 1u64 as usize];
        self.read(0u64 as u16, &mut work_value[0..1]);
        let value = read_u8::<false>(work_value, 4u64 as usize, 1u64 as usize);
        u8::try_from(value).unwrap()
    }
    fn write_repeatInstr_raw(&mut self, param: u8) {
        let mut mem = [0u8; 1];
        self.read(0u64 as u16, &mut mem[0..1]);
        let mem = u8::from_le_bytes(mem);
        let mem =
            write_u8::<false>(param as u8, mem, 4u64 as usize, 1u64 as usize);
        self.write(0u64 as u16, &mem[0..1]);
    }
    fn read_repeatInstr_disassembly(&self) -> i64 {
        i64::try_from(self.read_repeatInstr_raw()).unwrap()
    }
    fn write_repeatInstr_disassembly(&mut self, param: i64) {
        self.write_repeatInstr_raw(u8::try_from(param).unwrap())
    }
    fn read_repeatInstr_execution(&self) -> u8 {
        self.read_repeatInstr_raw()
    }
    fn write_repeatInstr_execution(&mut self, param: u8) {
        self.write_repeatInstr_raw(param)
    }
    fn repeatInstr_display(&self) -> DisplayElement {
        meaning_number(true, self.read_repeatInstr_raw())
    }
    fn read_skipInstr_raw(&self) -> u8 {
        let mut work_value = [0u8; 1u64 as usize];
        self.read(0u64 as u16, &mut work_value[0..1]);
        let value = read_u8::<false>(work_value, 5u64 as usize, 1u64 as usize);
        u8::try_from(value).unwrap()
    }
    fn write_skipInstr_raw(&mut self, param: u8) {
        let mut mem = [0u8; 1];
        self.read(0u64 as u16, &mut mem[0..1]);
        let mem = u8::from_le_bytes(mem);
        let mem =
            write_u8::<false>(param as u8, mem, 5u64 as usize, 1u64 as usize);
        self.write(0u64 as u16, &mem[0..1]);
    }
    fn read_skipInstr_disassembly(&self) -> i64 {
        i64::try_from(self.read_skipInstr_raw()).unwrap()
    }
    fn write_skipInstr_disassembly(&mut self, param: i64) {
        self.write_skipInstr_raw(u8::try_from(param).unwrap())
    }
    fn read_skipInstr_execution(&self) -> u8 {
        self.read_skipInstr_raw()
    }
    fn write_skipInstr_execution(&mut self, param: u8) {
        self.write_skipInstr_raw(param)
    }
    fn skipInstr_display(&self) -> DisplayElement {
        meaning_number(true, self.read_skipInstr_raw())
    }
}
pub trait ContextTrait {
    type Typeregister: ContextregisterTrait;
    fn register(&self) -> &Self::Typeregister;
    fn register_mut(&mut self) -> &mut Self::Typeregister;
}
#[derive(Debug, Clone, Copy, Default)]
pub struct ContextregisterStruct {
    pub chunk_0x0: [u8; 4u64 as usize],
}
impl ContextregisterTrait for ContextregisterStruct {}
impl MemoryRead for ContextregisterStruct {
    type AddressType = u16;
    fn read(&self, addr: Self::AddressType, buf: &mut [u8]) {
        let addr = <u64>::try_from(addr).unwrap();
        let buf_len = <u64>::try_from(buf.len()).unwrap();
        let addr_end = addr + buf_len;
        match (addr, addr_end) {
            (0u64..=3u64, 0u64..=4u64) => {
                let start = addr - 0u64;
                let end = usize::try_from(start + buf_len).unwrap();
                let start = usize::try_from(start).unwrap();
                buf.copy_from_slice(&self.chunk_0x0[start..end]);
            }
            _ => panic!("undefined mem {}:{}", addr, buf.len()),
        }
    }
}
impl MemoryWrite for ContextregisterStruct {
    type AddressType = u16;
    fn write(&mut self, addr: Self::AddressType, buf: &[u8]) {
        let addr = <u64>::try_from(addr).unwrap();
        let buf_len = <u64>::try_from(buf.len()).unwrap();
        let addr_end = addr + buf_len;
        match (addr, addr_end) {
            (0u64..=3u64, 0u64..=4u64) => {
                let start = addr - 0u64;
                let end = usize::try_from(start + buf_len).unwrap();
                let start = usize::try_from(start).unwrap();
                self.chunk_0x0[start..end].copy_from_slice(buf);
            }
            _ => panic!("undefined mem {}:{}", addr, buf.len()),
        }
    }
}
#[derive(Debug, Clone, Copy, Default)]
pub struct SpacesStruct {
    pub register: ContextregisterStruct,
}
impl ContextTrait for SpacesStruct {
    type Typeregister = ContextregisterStruct;
    fn register(&self) -> &Self::Typeregister {
        &self.register
    }
    fn register_mut(&mut self) -> &mut Self::Typeregister {
        &mut self.register
    }
}
fn meaning_number<T>(hex: bool, num: T) -> DisplayElement
where
    i64: TryFrom<T>,
    <i64 as TryFrom<T>>::Error: core::fmt::Debug,
{
    DisplayElement::Number(hex, i64::try_from(num).unwrap())
}
fn meaning_0_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_0_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_0_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::W0,
        1 => Register::W1,
        2 => Register::W2,
        3 => Register::W3,
        4 => Register::W4,
        5 => Register::W5,
        6 => Register::W6,
        7 => Register::W7,
        8 => Register::W8,
        9 => Register::W9,
        10 => Register::W10,
        11 => Register::W11,
        12 => Register::W12,
        13 => Register::W13,
        14 => Register::W14,
        15 => Register::W15,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_1_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_1_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_1_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::W0byte,
        1 => Register::W1byte,
        2 => Register::W2byte,
        3 => Register::W3byte,
        4 => Register::W4byte,
        5 => Register::W5byte,
        6 => Register::W6byte,
        7 => Register::W7byte,
        8 => Register::W8byte,
        9 => Register::W9byte,
        10 => Register::W10byte,
        11 => Register::W11byte,
        12 => Register::W12byte,
        13 => Register::W13byte,
        14 => Register::W14byte,
        15 => Register::W15byte,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_2_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_2_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_2_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::W1W0,
        1 => Register::W3W2,
        2 => Register::W5W4,
        3 => Register::W7W6,
        4 => Register::W9W8,
        5 => Register::W11W10,
        6 => Register::W13W12,
        7 => Register::W15W14,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_3_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_3_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_3_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::W0,
        1 => Register::W2,
        2 => Register::W4,
        3 => Register::W6,
        4 => Register::W8,
        5 => Register::W10,
        6 => Register::W12,
        7 => Register::W14,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_4_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_4_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_4_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::W0,
        1 => Register::W1,
        2 => Register::W2,
        3 => Register::W3,
        4 => Register::W4,
        5 => Register::W5,
        6 => Register::W6,
        7 => Register::W7,
        8 => Register::W8,
        9 => Register::W9,
        10 => Register::W10,
        11 => Register::W11,
        12 => Register::W12,
        13 => Register::W13,
        14 => Register::W14,
        15 => Register::W0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_5_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_5_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_5_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        1 => Register::W0,
        2 => Register::W1,
        3 => Register::W2,
        4 => Register::W3,
        5 => Register::W4,
        6 => Register::W5,
        7 => Register::W6,
        8 => Register::W7,
        9 => Register::W8,
        10 => Register::W9,
        11 => Register::W10,
        12 => Register::W11,
        13 => Register::W12,
        14 => Register::W13,
        15 => Register::W14,
        _ => unreachable!("Invalid Attach Value"),
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_padding(u8);
impl TokenField_padding {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_31_0(u32);
impl TokenField_OP_31_0 {
    fn execution(&self) -> u32 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_31_4(u32);
impl TokenField_OP_31_4 {
    fn execution(&self) -> u32 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_23_0(u32);
impl TokenField_OP_23_0 {
    fn execution(&self) -> u32 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_23_1(u32);
impl TokenField_OP_23_1 {
    fn execution(&self) -> u32 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_23_4(u32);
impl TokenField_OP_23_4 {
    fn execution(&self) -> u32 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_23_11(u16);
impl TokenField_OP_23_11 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_23_12(u16);
impl TokenField_OP_23_12 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_23_14(u16);
impl TokenField_OP_23_14 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_23_15(u16);
impl TokenField_OP_23_15 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_23_16(u8);
impl TokenField_OP_23_16 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_23_18(u8);
impl TokenField_OP_23_18 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_23_19(u8);
impl TokenField_OP_23_19 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_23_20(u8);
impl TokenField_OP_23_20 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_21_20(u8);
impl TokenField_OP_21_20 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_19_16(u8);
impl TokenField_OP_19_16 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_19_17(u8);
impl TokenField_OP_19_17 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_19_18(u8);
impl TokenField_OP_19_18 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_15_8(u8);
impl TokenField_OP_15_8 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_15_12(u8);
impl TokenField_OP_15_12 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_15_14(u8);
impl TokenField_OP_15_14 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_14_0(u16);
impl TokenField_OP_14_0 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_14_4(u16);
impl TokenField_OP_14_4 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_14_6(u16);
impl TokenField_OP_14_6 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_14_7(u8);
impl TokenField_OP_14_7 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_14_11(u8);
impl TokenField_OP_14_11 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_14_12(u8);
impl TokenField_OP_14_12 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_13_4(u16);
impl TokenField_OP_13_4 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_11_7(u8);
impl TokenField_OP_11_7 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_11_8(u8);
impl TokenField_OP_11_8 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_11_10(u8);
impl TokenField_OP_11_10 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_10_8(u8);
impl TokenField_OP_10_8 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_10_7(u8);
impl TokenField_OP_10_7 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_10_4(u8);
impl TokenField_OP_10_4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_9_4(u8);
impl TokenField_OP_9_4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_9_8(u8);
impl TokenField_OP_9_8 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_7_0(u8);
impl TokenField_OP_7_0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_7_4(u8);
impl TokenField_OP_7_4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_7_5(u8);
impl TokenField_OP_7_5 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_7_6(u8);
impl TokenField_OP_7_6 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_6_0(u8);
impl TokenField_OP_6_0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_6_4(u8);
impl TokenField_OP_6_4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_6_5(u8);
impl TokenField_OP_6_5 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_5_4(u8);
impl TokenField_OP_5_4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_3_0(u8);
impl TokenField_OP_3_0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_1_0(u8);
impl TokenField_OP_1_0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_19(u8);
impl TokenField_OP_19 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_15(u8);
impl TokenField_OP_15 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_14(u8);
impl TokenField_OP_14 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_13(u8);
impl TokenField_OP_13 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_12(u8);
impl TokenField_OP_12 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_11(u8);
impl TokenField_OP_11 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_7(u8);
impl TokenField_OP_7 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_6(u8);
impl TokenField_OP_6 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_5(u8);
impl TokenField_OP_5 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_3(u8);
impl TokenField_OP_3 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP_0(u8);
impl TokenField_OP_0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_n(u8);
impl TokenField_TOK_n {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_A(u8);
impl TokenField_TOK_A {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_B(u8);
impl TokenField_TOK_B {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_Bb(u8);
impl TokenField_TOK_Bb {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_CCCC(u8);
impl TokenField_TOK_CCCC {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_D(u8);
impl TokenField_TOK_D {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_W(u8);
impl TokenField_TOK_W {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_Z(u8);
impl TokenField_TOK_Z {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_Zb(u8);
impl TokenField_TOK_Zb {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_f12(u16);
impl TokenField_TOK_f12 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_f13(u16);
impl TokenField_TOK_f13 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_f15(u16);
impl TokenField_TOK_f15 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_f15b(u16);
impl TokenField_TOK_f15b {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_k3(u8);
impl TokenField_TOK_k3 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_k4(u8);
impl TokenField_TOK_k4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_k5(u8);
impl TokenField_TOK_k5 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_k6(i8);
impl TokenField_TOK_k6 {
    fn execution(&self) -> i8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_k8a(u8);
impl TokenField_TOK_k8a {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_k4b(u8);
impl TokenField_TOK_k4b {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_k8b(u8);
impl TokenField_TOK_k8b {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_k8c(u8);
impl TokenField_TOK_k8c {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_k10(u16);
impl TokenField_TOK_k10 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_k14(u16);
impl TokenField_TOK_k14 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_k15(u16);
impl TokenField_TOK_k15 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_k16(u16);
impl TokenField_TOK_k16 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_k16t(u16);
impl TokenField_TOK_k16t {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_r4(i8);
impl TokenField_TOK_r4 {
    fn execution(&self) -> i8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_bit4word(u8);
impl TokenField_TOK_bit4word {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_b3(u8);
impl TokenField_TOK_b3 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_b1(u8);
impl TokenField_TOK_b1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_b4(u8);
impl TokenField_TOK_b4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_n6(i8);
impl TokenField_TOK_n6 {
    fn execution(&self) -> i8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_n7(u8);
impl TokenField_TOK_n7 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_n15(u16);
impl TokenField_TOK_n15 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_n16(i16);
impl TokenField_TOK_n16 {
    fn execution(&self) -> i16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_0(u8);
impl TokenField_TOK_0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_7(u8);
impl TokenField_TOK_7 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_13(u8);
impl TokenField_TOK_13 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_3_0_Wreg(u8);
impl TokenField_TOK_3_0_Wreg {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_3_0_Breg(u8);
impl TokenField_TOK_3_0_Breg {
    fn execution(&self) -> Register {
        meaning_1_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_1_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_3_1_Dreg(u8);
impl TokenField_TOK_3_1_Dreg {
    fn execution(&self) -> Register {
        meaning_2_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_2_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_3_1_Dregn(u8);
impl TokenField_TOK_3_1_Dregn {
    fn execution(&self) -> Register {
        meaning_3_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_3_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_4_0_U(u8);
impl TokenField_TOK_4_0_U {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_6_4_U(u8);
impl TokenField_TOK_6_4_U {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_9_0_U(u16);
impl TokenField_TOK_9_0_U {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_10_7_Wreg(u8);
impl TokenField_TOK_10_7_Wreg {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_10_7_Breg(u8);
impl TokenField_TOK_10_7_Breg {
    fn execution(&self) -> Register {
        meaning_1_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_1_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_10_7_Wregp(u8);
impl TokenField_TOK_10_7_Wregp {
    fn execution(&self) -> Register {
        meaning_4_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_4_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_10_8_Dreg(u8);
impl TokenField_TOK_10_8_Dreg {
    fn execution(&self) -> Register {
        meaning_2_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_2_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_10_8_Dregn(u8);
impl TokenField_TOK_10_8_Dregn {
    fn execution(&self) -> Register {
        meaning_3_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_3_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_11_8_Wreg(u8);
impl TokenField_TOK_11_8_Wreg {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_13_11_U(u8);
impl TokenField_TOK_13_11_U {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_14_12_Dreg(u8);
impl TokenField_TOK_14_12_Dreg {
    fn execution(&self) -> Register {
        meaning_2_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_2_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_14_12_Dregn(u8);
impl TokenField_TOK_14_12_Dregn {
    fn execution(&self) -> Register {
        meaning_3_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_3_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_14_11_Wreg(u8);
impl TokenField_TOK_14_11_Wreg {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_14_11_Wregn(u8);
impl TokenField_TOK_14_11_Wregn {
    fn execution(&self) -> Register {
        meaning_5_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_5_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_14_11_Breg(u8);
impl TokenField_TOK_14_11_Breg {
    fn execution(&self) -> Register {
        meaning_1_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_1_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_18_15_Wreg(u8);
impl TokenField_TOK_18_15_Wreg {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_18_15_Breg(u8);
impl TokenField_TOK_18_15_Breg {
    fn execution(&self) -> Register {
        meaning_1_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_1_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_18_15_S(i8);
impl TokenField_TOK_18_15_S {
    fn execution(&self) -> i8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_17_16_mm(u8);
impl TokenField_TOK_17_16_mm {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_18_16_mmm(u8);
impl TokenField_TOK_18_16_mmm {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_13_12_xx(u8);
impl TokenField_TOK_13_12_xx {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_13_12_kk(u8);
impl TokenField_TOK_13_12_kk {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_11_10_yy(u8);
impl TokenField_TOK_11_10_yy {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_11_10_PP(u8);
impl TokenField_TOK_11_10_PP {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_9_6_iiii(u8);
impl TokenField_TOK_9_6_iiii {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_5_2_jjjj(u8);
impl TokenField_TOK_5_2_jjjj {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOK_1_0_aa(u8);
impl TokenField_TOK_1_0_aa {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
struct TokenParser<const LEN: usize>([u8; LEN]);
impl<const LEN: usize> TokenParser<LEN> {
    fn new(data: &[u8]) -> Option<Self> {
        let token_slice: &[u8] = data.get(..LEN)?;
        let token_data = <[u8; LEN]>::try_from(token_slice).unwrap();
        Some(Self(token_data))
    }
    fn padding(&self) -> TokenField_padding {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 0u64 as usize, 8u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_padding(inner_value)
    }
    fn OP_31_0(&self) -> TokenField_OP_31_0 {
        let inner_value = {
            let mut work_value = [0u8; 4u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 4u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u32::<false>(work_value, 0u64 as usize, 32u64 as usize);
            u32::try_from(value).unwrap()
        };
        TokenField_OP_31_0(inner_value)
    }
    fn OP_31_4(&self) -> TokenField_OP_31_4 {
        let inner_value = {
            let mut work_value = [0u8; 4u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 4u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u32::<false>(work_value, 4u64 as usize, 28u64 as usize);
            u32::try_from(value).unwrap()
        };
        TokenField_OP_31_4(inner_value)
    }
    fn OP_23_0(&self) -> TokenField_OP_23_0 {
        let inner_value = {
            let mut work_value = [0u8; 4u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 3u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u32::<false>(work_value, 0u64 as usize, 24u64 as usize);
            u32::try_from(value).unwrap()
        };
        TokenField_OP_23_0(inner_value)
    }
    fn OP_23_1(&self) -> TokenField_OP_23_1 {
        let inner_value = {
            let mut work_value = [0u8; 4u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 3u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u32::<false>(work_value, 1u64 as usize, 23u64 as usize);
            u32::try_from(value).unwrap()
        };
        TokenField_OP_23_1(inner_value)
    }
    fn OP_23_4(&self) -> TokenField_OP_23_4 {
        let inner_value = {
            let mut work_value = [0u8; 4u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 3u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u32::<false>(work_value, 4u64 as usize, 20u64 as usize);
            u32::try_from(value).unwrap()
        };
        TokenField_OP_23_4(inner_value)
    }
    fn OP_23_11(&self) -> TokenField_OP_23_11 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<false>(work_value, 3u64 as usize, 13u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_OP_23_11(inner_value)
    }
    fn OP_23_12(&self) -> TokenField_OP_23_12 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<false>(work_value, 4u64 as usize, 12u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_OP_23_12(inner_value)
    }
    fn OP_23_14(&self) -> TokenField_OP_23_14 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<false>(work_value, 6u64 as usize, 10u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_OP_23_14(inner_value)
    }
    fn OP_23_15(&self) -> TokenField_OP_23_15 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<false>(work_value, 7u64 as usize, 9u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_OP_23_15(inner_value)
    }
    fn OP_23_16(&self) -> TokenField_OP_23_16 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 0u64 as usize, 8u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_23_16(inner_value)
    }
    fn OP_23_18(&self) -> TokenField_OP_23_18 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 2u64 as usize, 6u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_23_18(inner_value)
    }
    fn OP_23_19(&self) -> TokenField_OP_23_19 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_23_19(inner_value)
    }
    fn OP_23_20(&self) -> TokenField_OP_23_20 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 4u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_23_20(inner_value)
    }
    fn OP_21_20(&self) -> TokenField_OP_21_20 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 4u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_21_20(inner_value)
    }
    fn OP_19_16(&self) -> TokenField_OP_19_16 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 0u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_19_16(inner_value)
    }
    fn OP_19_17(&self) -> TokenField_OP_19_17 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 1u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_19_17(inner_value)
    }
    fn OP_19_18(&self) -> TokenField_OP_19_18 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 2u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_19_18(inner_value)
    }
    fn OP_15_8(&self) -> TokenField_OP_15_8 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 0u64 as usize, 8u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_15_8(inner_value)
    }
    fn OP_15_12(&self) -> TokenField_OP_15_12 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 4u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_15_12(inner_value)
    }
    fn OP_15_14(&self) -> TokenField_OP_15_14 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 6u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_15_14(inner_value)
    }
    fn OP_14_0(&self) -> TokenField_OP_14_0 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<false>(work_value, 0u64 as usize, 15u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_OP_14_0(inner_value)
    }
    fn OP_14_4(&self) -> TokenField_OP_14_4 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<false>(work_value, 4u64 as usize, 11u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_OP_14_4(inner_value)
    }
    fn OP_14_6(&self) -> TokenField_OP_14_6 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<false>(work_value, 6u64 as usize, 9u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_OP_14_6(inner_value)
    }
    fn OP_14_7(&self) -> TokenField_OP_14_7 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<false>(work_value, 7u64 as usize, 8u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_14_7(inner_value)
    }
    fn OP_14_11(&self) -> TokenField_OP_14_11 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 3u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_14_11(inner_value)
    }
    fn OP_14_12(&self) -> TokenField_OP_14_12 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 4u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_14_12(inner_value)
    }
    fn OP_13_4(&self) -> TokenField_OP_13_4 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<false>(work_value, 4u64 as usize, 10u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_OP_13_4(inner_value)
    }
    fn OP_11_7(&self) -> TokenField_OP_11_7 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<false>(work_value, 7u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_11_7(inner_value)
    }
    fn OP_11_8(&self) -> TokenField_OP_11_8 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 0u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_11_8(inner_value)
    }
    fn OP_11_10(&self) -> TokenField_OP_11_10 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 2u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_11_10(inner_value)
    }
    fn OP_10_8(&self) -> TokenField_OP_10_8 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 0u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_10_8(inner_value)
    }
    fn OP_10_7(&self) -> TokenField_OP_10_7 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<false>(work_value, 7u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_10_7(inner_value)
    }
    fn OP_10_4(&self) -> TokenField_OP_10_4 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<false>(work_value, 4u64 as usize, 7u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_10_4(inner_value)
    }
    fn OP_9_4(&self) -> TokenField_OP_9_4 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<false>(work_value, 4u64 as usize, 6u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_9_4(inner_value)
    }
    fn OP_9_8(&self) -> TokenField_OP_9_8 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 0u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_9_8(inner_value)
    }
    fn OP_7_0(&self) -> TokenField_OP_7_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 0u64 as usize, 8u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_7_0(inner_value)
    }
    fn OP_7_4(&self) -> TokenField_OP_7_4 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 4u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_7_4(inner_value)
    }
    fn OP_7_5(&self) -> TokenField_OP_7_5 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 5u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_7_5(inner_value)
    }
    fn OP_7_6(&self) -> TokenField_OP_7_6 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 6u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_7_6(inner_value)
    }
    fn OP_6_0(&self) -> TokenField_OP_6_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 0u64 as usize, 7u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_6_0(inner_value)
    }
    fn OP_6_4(&self) -> TokenField_OP_6_4 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 4u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_6_4(inner_value)
    }
    fn OP_6_5(&self) -> TokenField_OP_6_5 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 5u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_6_5(inner_value)
    }
    fn OP_5_4(&self) -> TokenField_OP_5_4 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 4u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_5_4(inner_value)
    }
    fn OP_3_0(&self) -> TokenField_OP_3_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 0u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_3_0(inner_value)
    }
    fn OP_1_0(&self) -> TokenField_OP_1_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 0u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_1_0(inner_value)
    }
    fn OP_19(&self) -> TokenField_OP_19 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 3u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_19(inner_value)
    }
    fn OP_15(&self) -> TokenField_OP_15 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 7u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_15(inner_value)
    }
    fn OP_14(&self) -> TokenField_OP_14 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 6u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_14(inner_value)
    }
    fn OP_13(&self) -> TokenField_OP_13 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 5u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_13(inner_value)
    }
    fn OP_12(&self) -> TokenField_OP_12 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 4u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_12(inner_value)
    }
    fn OP_11(&self) -> TokenField_OP_11 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 3u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_11(inner_value)
    }
    fn OP_7(&self) -> TokenField_OP_7 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 7u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_7(inner_value)
    }
    fn OP_6(&self) -> TokenField_OP_6 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 6u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_6(inner_value)
    }
    fn OP_5(&self) -> TokenField_OP_5 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 5u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_5(inner_value)
    }
    fn OP_3(&self) -> TokenField_OP_3 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 3u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_3(inner_value)
    }
    fn OP_0(&self) -> TokenField_OP_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 0u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP_0(inner_value)
    }
    fn TOK_n(&self) -> TokenField_TOK_n {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 0u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_n(inner_value)
    }
    fn TOK_A(&self) -> TokenField_TOK_A {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 7u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_A(inner_value)
    }
    fn TOK_B(&self) -> TokenField_TOK_B {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 6u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_B(inner_value)
    }
    fn TOK_Bb(&self) -> TokenField_TOK_Bb {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 2u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_Bb(inner_value)
    }
    fn TOK_CCCC(&self) -> TokenField_TOK_CCCC {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 0u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_CCCC(inner_value)
    }
    fn TOK_D(&self) -> TokenField_TOK_D {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 5u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_D(inner_value)
    }
    fn TOK_W(&self) -> TokenField_TOK_W {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 6u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_W(inner_value)
    }
    fn TOK_Z(&self) -> TokenField_TOK_Z {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 7u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_Z(inner_value)
    }
    fn TOK_Zb(&self) -> TokenField_TOK_Zb {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 3u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_Zb(inner_value)
    }
    fn TOK_f12(&self) -> TokenField_TOK_f12 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<false>(work_value, 1u64 as usize, 12u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_TOK_f12(inner_value)
    }
    fn TOK_f13(&self) -> TokenField_TOK_f13 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<false>(work_value, 0u64 as usize, 13u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_TOK_f13(inner_value)
    }
    fn TOK_f15(&self) -> TokenField_TOK_f15 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<false>(work_value, 1u64 as usize, 15u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_TOK_f15(inner_value)
    }
    fn TOK_f15b(&self) -> TokenField_TOK_f15b {
        let inner_value = {
            let mut work_value = [0u8; 4u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 3u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u32::<false>(work_value, 4u64 as usize, 15u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_TOK_f15b(inner_value)
    }
    fn TOK_k3(&self) -> TokenField_TOK_k3 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 0u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_k3(inner_value)
    }
    fn TOK_k4(&self) -> TokenField_TOK_k4 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 0u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_k4(inner_value)
    }
    fn TOK_k5(&self) -> TokenField_TOK_k5 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_k5(inner_value)
    }
    fn TOK_k6(&self) -> TokenField_TOK_k6 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i8::<false>(work_value, 0u64 as usize, 6u64 as usize);
            i8::try_from(value).unwrap()
        };
        TokenField_TOK_k6(inner_value)
    }
    fn TOK_k8a(&self) -> TokenField_TOK_k8a {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_k8a(inner_value)
    }
    fn TOK_k4b(&self) -> TokenField_TOK_k4b {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 4u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_k4b(inner_value)
    }
    fn TOK_k8b(&self) -> TokenField_TOK_k8b {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<false>(work_value, 7u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_k8b(inner_value)
    }
    fn TOK_k8c(&self) -> TokenField_TOK_k8c {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<false>(work_value, 4u64 as usize, 8u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_k8c(inner_value)
    }
    fn TOK_k10(&self) -> TokenField_TOK_k10 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<false>(work_value, 4u64 as usize, 10u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_TOK_k10(inner_value)
    }
    fn TOK_k14(&self) -> TokenField_TOK_k14 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<false>(work_value, 0u64 as usize, 14u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_TOK_k14(inner_value)
    }
    fn TOK_k15(&self) -> TokenField_TOK_k15 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<false>(work_value, 0u64 as usize, 15u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_TOK_k15(inner_value)
    }
    fn TOK_k16(&self) -> TokenField_TOK_k16 {
        let inner_value = {
            let mut work_value = [0u8; 4u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 3u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u32::<false>(work_value, 4u64 as usize, 16u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_TOK_k16(inner_value)
    }
    fn TOK_k16t(&self) -> TokenField_TOK_k16t {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<false>(work_value, 0u64 as usize, 16u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_TOK_k16t(inner_value)
    }
    fn TOK_r4(&self) -> TokenField_TOK_r4 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i16::<false>(work_value, 7u64 as usize, 4u64 as usize);
            i8::try_from(value).unwrap()
        };
        TokenField_TOK_r4(inner_value)
    }
    fn TOK_bit4word(&self) -> TokenField_TOK_bit4word {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 0u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_bit4word(inner_value)
    }
    fn TOK_b3(&self) -> TokenField_TOK_b3 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 5u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_b3(inner_value)
    }
    fn TOK_b1(&self) -> TokenField_TOK_b1 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 0u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_b1(inner_value)
    }
    fn TOK_b4(&self) -> TokenField_TOK_b4 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 4u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_b4(inner_value)
    }
    fn TOK_n6(&self) -> TokenField_TOK_n6 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i16::<false>(work_value, 4u64 as usize, 6u64 as usize);
            i8::try_from(value).unwrap()
        };
        TokenField_TOK_n6(inner_value)
    }
    fn TOK_n7(&self) -> TokenField_TOK_n7 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 0u64 as usize, 7u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_n7(inner_value)
    }
    fn TOK_n15(&self) -> TokenField_TOK_n15 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<false>(work_value, 1u64 as usize, 15u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_TOK_n15(inner_value)
    }
    fn TOK_n16(&self) -> TokenField_TOK_n16 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i16::<false>(work_value, 0u64 as usize, 16u64 as usize);
            i16::try_from(value).unwrap()
        };
        TokenField_TOK_n16(inner_value)
    }
    fn TOK_0(&self) -> TokenField_TOK_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 0u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_0(inner_value)
    }
    fn TOK_7(&self) -> TokenField_TOK_7 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 7u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_7(inner_value)
    }
    fn TOK_13(&self) -> TokenField_TOK_13 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 5u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_13(inner_value)
    }
    fn TOK_3_0_Wreg(&self) -> TokenField_TOK_3_0_Wreg {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 0u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_3_0_Wreg(inner_value)
    }
    fn TOK_3_0_Breg(&self) -> TokenField_TOK_3_0_Breg {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 0u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_3_0_Breg(inner_value)
    }
    fn TOK_3_1_Dreg(&self) -> TokenField_TOK_3_1_Dreg {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 1u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_3_1_Dreg(inner_value)
    }
    fn TOK_3_1_Dregn(&self) -> TokenField_TOK_3_1_Dregn {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 1u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_3_1_Dregn(inner_value)
    }
    fn TOK_4_0_U(&self) -> TokenField_TOK_4_0_U {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_4_0_U(inner_value)
    }
    fn TOK_6_4_U(&self) -> TokenField_TOK_6_4_U {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 4u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_6_4_U(inner_value)
    }
    fn TOK_9_0_U(&self) -> TokenField_TOK_9_0_U {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<false>(work_value, 0u64 as usize, 10u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_TOK_9_0_U(inner_value)
    }
    fn TOK_10_7_Wreg(&self) -> TokenField_TOK_10_7_Wreg {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<false>(work_value, 7u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_10_7_Wreg(inner_value)
    }
    fn TOK_10_7_Breg(&self) -> TokenField_TOK_10_7_Breg {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<false>(work_value, 7u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_10_7_Breg(inner_value)
    }
    fn TOK_10_7_Wregp(&self) -> TokenField_TOK_10_7_Wregp {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<false>(work_value, 7u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_10_7_Wregp(inner_value)
    }
    fn TOK_10_8_Dreg(&self) -> TokenField_TOK_10_8_Dreg {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 0u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_10_8_Dreg(inner_value)
    }
    fn TOK_10_8_Dregn(&self) -> TokenField_TOK_10_8_Dregn {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 0u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_10_8_Dregn(inner_value)
    }
    fn TOK_11_8_Wreg(&self) -> TokenField_TOK_11_8_Wreg {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 0u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_11_8_Wreg(inner_value)
    }
    fn TOK_13_11_U(&self) -> TokenField_TOK_13_11_U {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 3u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_13_11_U(inner_value)
    }
    fn TOK_14_12_Dreg(&self) -> TokenField_TOK_14_12_Dreg {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 4u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_14_12_Dreg(inner_value)
    }
    fn TOK_14_12_Dregn(&self) -> TokenField_TOK_14_12_Dregn {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 4u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_14_12_Dregn(inner_value)
    }
    fn TOK_14_11_Wreg(&self) -> TokenField_TOK_14_11_Wreg {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 3u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_14_11_Wreg(inner_value)
    }
    fn TOK_14_11_Wregn(&self) -> TokenField_TOK_14_11_Wregn {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 3u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_14_11_Wregn(inner_value)
    }
    fn TOK_14_11_Breg(&self) -> TokenField_TOK_14_11_Breg {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 3u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_14_11_Breg(inner_value)
    }
    fn TOK_18_15_Wreg(&self) -> TokenField_TOK_18_15_Wreg {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<false>(work_value, 7u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_18_15_Wreg(inner_value)
    }
    fn TOK_18_15_Breg(&self) -> TokenField_TOK_18_15_Breg {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<false>(work_value, 7u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_18_15_Breg(inner_value)
    }
    fn TOK_18_15_S(&self) -> TokenField_TOK_18_15_S {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i16::<false>(work_value, 7u64 as usize, 4u64 as usize);
            i8::try_from(value).unwrap()
        };
        TokenField_TOK_18_15_S(inner_value)
    }
    fn TOK_17_16_mm(&self) -> TokenField_TOK_17_16_mm {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 0u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_17_16_mm(inner_value)
    }
    fn TOK_18_16_mmm(&self) -> TokenField_TOK_18_16_mmm {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 0u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_18_16_mmm(inner_value)
    }
    fn TOK_13_12_xx(&self) -> TokenField_TOK_13_12_xx {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 4u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_13_12_xx(inner_value)
    }
    fn TOK_13_12_kk(&self) -> TokenField_TOK_13_12_kk {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 4u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_13_12_kk(inner_value)
    }
    fn TOK_11_10_yy(&self) -> TokenField_TOK_11_10_yy {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 2u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_11_10_yy(inner_value)
    }
    fn TOK_11_10_PP(&self) -> TokenField_TOK_11_10_PP {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 2u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_11_10_PP(inner_value)
    }
    fn TOK_9_6_iiii(&self) -> TokenField_TOK_9_6_iiii {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<false>(work_value, 6u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_9_6_iiii(inner_value)
    }
    fn TOK_5_2_jjjj(&self) -> TokenField_TOK_5_2_jjjj {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 2u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_5_2_jjjj(inner_value)
    }
    fn TOK_1_0_aa(&self) -> TokenField_TOK_1_0_aa {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<false>(work_value, 0u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOK_1_0_aa(inner_value)
    }
}
#[derive(Clone, Copy, Debug)]
pub enum Register {
    W0,
    W1,
    W2,
    W3,
    W4,
    W5,
    W6,
    W7,
    W8,
    W9,
    W10,
    W11,
    W12,
    W13,
    W14,
    W15,
    W1W0,
    W3W2,
    W5W4,
    W7W6,
    W9W8,
    W11W10,
    W13W12,
    W15W14,
    W0byte,
    W1byte,
    W2byte,
    W3byte,
    W4byte,
    W5byte,
    W6byte,
    W7byte,
    W8byte,
    W9byte,
    W10byte,
    W11byte,
    W12byte,
    W13byte,
    W14byte,
    W15byte,
    SHADOW_W0,
    SHADOW_W1,
    SHADOW_W2,
    SHADOW_W3,
    SPLIM,
    ACCAL,
    ACCAH,
    ACCAU,
    ACCBL,
    ACCBH,
    ACCBU,
    ACCA,
    ACCB,
    PC,
    DSRPAG,
    DSWPAG,
    RCOUNT,
    TBLPAG,
    CORCON,
    MODCON,
    XMODSRT,
    XMODEND,
    YMODSRT,
    YMODEND,
    XBREV,
    DISICNT,
    SRL,
    SRH,
    SRH_OA,
    SRH_OB,
    SRH_SA,
    SRH_SB,
    SRH_OAB,
    SRH_SAB,
    SRH_DA,
    SRH_DC,
    SRL_IPL2,
    SRL_IPL1,
    SRL_IPL0,
    SRL_RA,
    SRL_N,
    SRL_OV,
    SRL_Z,
    SRL_C,
    DISI,
    SHADOW_SRH_DC,
    SHADOW_SRL_N,
    SHADOW_SRL_OV,
    SHADOW_SRL_Z,
    SHADOW_SRL_C,
    DOSTART_SHADOW,
    DOEND_SHADOW,
    WDTcount,
    WDTprescalarA,
    WDTprescalarB,
    CORCON_VAR,
    CORCON_IPL3,
    CORCON_PSV,
    CORCON_SFA,
    DCOUNT_SHADOW,
    SkipNextFlag,
    contextreg,
}
impl core::fmt::Display for Register {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::W0 => write!(f, "W0"),
            Self::W1 => write!(f, "W1"),
            Self::W2 => write!(f, "W2"),
            Self::W3 => write!(f, "W3"),
            Self::W4 => write!(f, "W4"),
            Self::W5 => write!(f, "W5"),
            Self::W6 => write!(f, "W6"),
            Self::W7 => write!(f, "W7"),
            Self::W8 => write!(f, "W8"),
            Self::W9 => write!(f, "W9"),
            Self::W10 => write!(f, "W10"),
            Self::W11 => write!(f, "W11"),
            Self::W12 => write!(f, "W12"),
            Self::W13 => write!(f, "W13"),
            Self::W14 => write!(f, "W14"),
            Self::W15 => write!(f, "W15"),
            Self::W1W0 => write!(f, "W1W0"),
            Self::W3W2 => write!(f, "W3W2"),
            Self::W5W4 => write!(f, "W5W4"),
            Self::W7W6 => write!(f, "W7W6"),
            Self::W9W8 => write!(f, "W9W8"),
            Self::W11W10 => write!(f, "W11W10"),
            Self::W13W12 => write!(f, "W13W12"),
            Self::W15W14 => write!(f, "W15W14"),
            Self::W0byte => write!(f, "W0byte"),
            Self::W1byte => write!(f, "W1byte"),
            Self::W2byte => write!(f, "W2byte"),
            Self::W3byte => write!(f, "W3byte"),
            Self::W4byte => write!(f, "W4byte"),
            Self::W5byte => write!(f, "W5byte"),
            Self::W6byte => write!(f, "W6byte"),
            Self::W7byte => write!(f, "W7byte"),
            Self::W8byte => write!(f, "W8byte"),
            Self::W9byte => write!(f, "W9byte"),
            Self::W10byte => write!(f, "W10byte"),
            Self::W11byte => write!(f, "W11byte"),
            Self::W12byte => write!(f, "W12byte"),
            Self::W13byte => write!(f, "W13byte"),
            Self::W14byte => write!(f, "W14byte"),
            Self::W15byte => write!(f, "W15byte"),
            Self::SHADOW_W0 => write!(f, "SHADOW_W0"),
            Self::SHADOW_W1 => write!(f, "SHADOW_W1"),
            Self::SHADOW_W2 => write!(f, "SHADOW_W2"),
            Self::SHADOW_W3 => write!(f, "SHADOW_W3"),
            Self::SPLIM => write!(f, "SPLIM"),
            Self::ACCAL => write!(f, "ACCAL"),
            Self::ACCAH => write!(f, "ACCAH"),
            Self::ACCAU => write!(f, "ACCAU"),
            Self::ACCBL => write!(f, "ACCBL"),
            Self::ACCBH => write!(f, "ACCBH"),
            Self::ACCBU => write!(f, "ACCBU"),
            Self::ACCA => write!(f, "ACCA"),
            Self::ACCB => write!(f, "ACCB"),
            Self::PC => write!(f, "PC"),
            Self::DSRPAG => write!(f, "DSRPAG"),
            Self::DSWPAG => write!(f, "DSWPAG"),
            Self::RCOUNT => write!(f, "RCOUNT"),
            Self::TBLPAG => write!(f, "TBLPAG"),
            Self::CORCON => write!(f, "CORCON"),
            Self::MODCON => write!(f, "MODCON"),
            Self::XMODSRT => write!(f, "XMODSRT"),
            Self::XMODEND => write!(f, "XMODEND"),
            Self::YMODSRT => write!(f, "YMODSRT"),
            Self::YMODEND => write!(f, "YMODEND"),
            Self::XBREV => write!(f, "XBREV"),
            Self::DISICNT => write!(f, "DISICNT"),
            Self::SRL => write!(f, "SRL"),
            Self::SRH => write!(f, "SRH"),
            Self::SRH_OA => write!(f, "SRH_OA"),
            Self::SRH_OB => write!(f, "SRH_OB"),
            Self::SRH_SA => write!(f, "SRH_SA"),
            Self::SRH_SB => write!(f, "SRH_SB"),
            Self::SRH_OAB => write!(f, "SRH_OAB"),
            Self::SRH_SAB => write!(f, "SRH_SAB"),
            Self::SRH_DA => write!(f, "SRH_DA"),
            Self::SRH_DC => write!(f, "SRH_DC"),
            Self::SRL_IPL2 => write!(f, "SRL_IPL2"),
            Self::SRL_IPL1 => write!(f, "SRL_IPL1"),
            Self::SRL_IPL0 => write!(f, "SRL_IPL0"),
            Self::SRL_RA => write!(f, "SRL_RA"),
            Self::SRL_N => write!(f, "SRL_N"),
            Self::SRL_OV => write!(f, "SRL_OV"),
            Self::SRL_Z => write!(f, "SRL_Z"),
            Self::SRL_C => write!(f, "SRL_C"),
            Self::DISI => write!(f, "DISI"),
            Self::SHADOW_SRH_DC => write!(f, "SHADOW_SRH_DC"),
            Self::SHADOW_SRL_N => write!(f, "SHADOW_SRL_N"),
            Self::SHADOW_SRL_OV => write!(f, "SHADOW_SRL_OV"),
            Self::SHADOW_SRL_Z => write!(f, "SHADOW_SRL_Z"),
            Self::SHADOW_SRL_C => write!(f, "SHADOW_SRL_C"),
            Self::DOSTART_SHADOW => write!(f, "DOSTART_SHADOW"),
            Self::DOEND_SHADOW => write!(f, "DOEND_SHADOW"),
            Self::WDTcount => write!(f, "WDTcount"),
            Self::WDTprescalarA => write!(f, "WDTprescalarA"),
            Self::WDTprescalarB => write!(f, "WDTprescalarB"),
            Self::CORCON_VAR => write!(f, "CORCON_VAR"),
            Self::CORCON_IPL3 => write!(f, "CORCON_IPL3"),
            Self::CORCON_PSV => write!(f, "CORCON_PSV"),
            Self::CORCON_SFA => write!(f, "CORCON_SFA"),
            Self::DCOUNT_SHADOW => write!(f, "DCOUNT_SHADOW"),
            Self::SkipNextFlag => write!(f, "SkipNextFlag"),
            Self::contextreg => write!(f, "contextreg"),
        }
    }
}
#[derive(Clone, Copy, Debug)]
pub enum DisplayElement {
    Literal(&'static str),
    Register(Register),
    Number(bool, i64),
}
impl core::fmt::Display for DisplayElement {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Literal(lit) => lit.fmt(f),
            Self::Register(reg) => reg.fmt(f),
            Self::Number(hex, value) => match (*hex, value.is_negative()) {
                (true, true) => write!(f, "-0x{:x}", value.abs()),
                (true, false) => write!(f, "0x{:x}", value),
                (false, _) => value.fmt(f),
            },
        }
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1490:1"]
#[derive(Clone, Debug)]
struct instructionVar0 {
    instruction: Box<instruction>,
}
impl instructionVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 0 {
            return None;
        }
        let tmp = (1u64 as i64);
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = instruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1496:1"]
#[derive(Clone, Debug)]
struct instructionVar1 {
    instruction: Box<instruction>,
}
impl instructionVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 1 {
            return None;
        }
        if context_instance.register().read_repeatInstr_disassembly() != 1 {
            return None;
        }
        let tmp = (2u64 as i64);
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = instruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1510:1"]
#[derive(Clone, Debug)]
struct instructionVar2 {
    instruction: Box<instruction>,
}
impl instructionVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 1 {
            return None;
        }
        if context_instance.register().read_skipInstr_disassembly() != 1 {
            return None;
        }
        let tmp = (2u64 as i64);
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = instruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1517:1"]
#[derive(Clone, Debug)]
struct instructionVar3 {
    instruction: Box<instruction>,
}
impl instructionVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        self.instruction.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 1 {
            return None;
        }
        let tmp = (2u64 as i64);
        context_instance.register_mut().write_phase_disassembly(tmp);
        let instruction = if let Some((len, table)) = instruction::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2781:1"]
#[derive(Clone, Debug)]
struct instructionVar4 {}
impl instructionVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("clrwdt")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 15 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_15_12().disassembly() != 6 {
            return None;
        }
        if token_parser.OP_11_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7_4().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_3_0().disassembly() != 0 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6762:1"]
#[derive(Clone, Debug)]
struct instructionVar5 {}
impl instructionVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("pop.s")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 15 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_15_12().disassembly() != 8 {
            return None;
        }
        if token_parser.OP_11_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7_4().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_3_0().disassembly() != 0 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6798:1"]
#[derive(Clone, Debug)]
struct instructionVar6 {}
impl instructionVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("push.s")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 15 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_15_12().disassembly() != 10 {
            return None;
        }
        if token_parser.OP_11_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7_4().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_3_0().disassembly() != 0 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6898:1"]
#[derive(Clone, Debug)]
struct instructionVar7 {}
impl instructionVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("reset")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_0().disassembly() != 16646144 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6934:1"]
#[derive(Clone, Debug)]
struct instructionVar8 {}
impl instructionVar8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("retfie")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 6 {
            return None;
        }
        if token_parser.OP_15_12().disassembly() != 4 {
            return None;
        }
        if token_parser.OP_11_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7_4().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_3_0().disassembly() != 0 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7006:1"]
#[derive(Clone, Debug)]
struct instructionVar9 {}
impl instructionVar9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("return")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 6 {
            return None;
        }
        if token_parser.OP_15_12().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_11_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7_4().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_3_0().disassembly() != 0 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7927:1"]
#[derive(Clone, Debug)]
struct instructionVar10 {}
impl instructionVar10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ulnk")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 15 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 10 {
            return None;
        }
        if token_parser.OP_15_12().disassembly() != 8 {
            return None;
        }
        if token_parser.OP_11_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7_4().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_3_0().disassembly() != 0 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7939:1"]
#[derive(Clone, Debug)]
struct instructionVar11 {}
impl instructionVar11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("urun")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_0().disassembly() != 14336000 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:8025:1"]
#[derive(Clone, Debug)]
struct instructionVar12 {}
impl instructionVar12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("break")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_0().disassembly() != 14303232 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6791:1"]
#[derive(Clone, Debug)]
struct instructionVar13 {
    TOK_3_1_Dregn: TokenField_TOK_3_1_Dregn,
}
impl instructionVar13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("push.d"),
            DisplayElement::Literal(" "),
            self.TOK_3_1_Dregn.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_15_12().disassembly() != 9 {
            return None;
        }
        if token_parser.OP_11_8().disassembly() != 15 {
            return None;
        }
        if token_parser.OP_7_4().disassembly() != 8 {
            return None;
        }
        if token_parser.OP_0().disassembly() != 0 {
            return None;
        }
        let TOK_3_1_Dreg = token_parser.TOK_3_1_Dreg();
        let TOK_3_1_Dregn = token_parser.TOK_3_1_Dregn();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_1_Dregn }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6815:1"]
#[derive(Clone, Debug)]
struct instructionVar14 {
    OP_0: TokenField_OP_0,
}
impl instructionVar14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("pwrsav"),
            DisplayElement::Literal(" "),
            self.OP_0.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_1().disassembly() != 8331264 {
            return None;
        }
        let OP_0 = token_parser.OP_0();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { OP_0 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2036:1"]
#[derive(Clone, Debug)]
struct instructionVar15 {
    Wns_t: Wns_t,
}
impl instructionVar15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("bra"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Wns_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_15_12().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_11_8().disassembly() != 6 {
            return None;
        }
        if token_parser.OP_7_4().disassembly() != 0 {
            return None;
        }
        let Wns_t = if let Some((len, table)) =
            Wns_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wns_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2312:1"]
#[derive(Clone, Debug)]
struct instructionVar16 {
    WnDest_t: WnDest_t,
    WordInstNext4: WordInstNext4,
}
impl instructionVar16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("call"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.WnDest_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_15_12().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_11_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7_4().disassembly() != 0 {
            return None;
        }
        let WnDest_t = if let Some((len, table)) =
            WnDest_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let WordInstNext4 = if let Some((len, table)) = WordInstNext4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                WnDest_t,
                WordInstNext4,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6755:1"]
#[derive(Clone, Debug)]
struct instructionVar17 {
    Wndd_t: Wndd_t,
}
impl instructionVar17 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("pop.d"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Wndd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_15_12().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_11().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7_4().disassembly() != 4 {
            return None;
        }
        if token_parser.OP_3_0().disassembly() != 15 {
            return None;
        }
        let Wndd_t = if let Some((len, table)) =
            Wndd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wndd_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2357:1"]
#[derive(Clone, Debug)]
struct instructionVar18 {
    Wd_t: Wd_t,
}
impl instructionVar18 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("clr.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_6_4().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_3_0().disassembly() != 0 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wd_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2363:1"]
#[derive(Clone, Debug)]
struct instructionVar19 {
    Wdbyte_t: Wdbyte_t,
}
impl instructionVar19 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("clr.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_6_4().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_3_0().disassembly() != 0 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wdbyte_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3310:1"]
#[derive(Clone, Debug)]
struct instructionVar20 {
    Wnsbyte_t: Wnsbyte_t,
}
impl instructionVar20 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("daw.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Wnsbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 15 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_15_12().disassembly() != 4 {
            return None;
        }
        if token_parser.OP_11_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7_4().disassembly() != 0 {
            return None;
        }
        let Wnsbyte_t = if let Some((len, table)) =
            Wnsbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wnsbyte_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:4010:1"]
#[derive(Clone, Debug)]
struct instructionVar21 {
    WnDest_t: WnDest_t,
}
impl instructionVar21 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("goto"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.WnDest_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_15_12().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_11_8().disassembly() != 4 {
            return None;
        }
        if token_parser.OP_7_4().disassembly() != 0 {
            return None;
        }
        let WnDest_t = if let Some((len, table)) =
            WnDest_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WnDest_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:5209:1"]
#[derive(Clone, Debug)]
struct instructionVar22 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl instructionVar22 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("movpag"),
            DisplayElement::Literal(" "),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::DSRPAG),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 15 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_15_12().disassembly() != 13 {
            return None;
        }
        if token_parser.TOK_11_10_PP().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_9_4().disassembly() != 0 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:5212:1"]
#[derive(Clone, Debug)]
struct instructionVar23 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl instructionVar23 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("movpag"),
            DisplayElement::Literal(" "),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::DSWPAG),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 15 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_15_12().disassembly() != 13 {
            return None;
        }
        if token_parser.TOK_11_10_PP().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_9_4().disassembly() != 0 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:5215:1"]
#[derive(Clone, Debug)]
struct instructionVar24 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl instructionVar24 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("movpag"),
            DisplayElement::Literal(" "),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::TBLPAG),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 15 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_15_12().disassembly() != 13 {
            return None;
        }
        if token_parser.TOK_11_10_PP().disassembly() != 2 {
            return None;
        }
        if token_parser.OP_9_4().disassembly() != 0 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6852:1"]
#[derive(Clone, Debug)]
struct instructionVar25 {
    WnRDest_t: WnRDest_t,
    WordInstNext4: WordInstNext4,
}
impl instructionVar25 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("rcall"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.WnRDest_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_15_12().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_11_8().disassembly() != 2 {
            return None;
        }
        if token_parser.OP_7_4().disassembly() != 0 {
            return None;
        }
        let WnRDest_t = if let Some((len, table)) =
            WnRDest_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let WordInstNext4 = if let Some((len, table)) = WordInstNext4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                WnRDest_t,
                WordInstNext4,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6890:1"]
#[derive(Clone, Debug)]
struct instructionVar26 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl instructionVar26 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_repeatInstr(
            Some(inst_next),
            context.register().read_repeatInstr_disassembly(),
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("repeat"),
            DisplayElement::Literal(" "),
            self.TOK_3_0_Wreg.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_4().disassembly() != 38912 {
            return None;
        }
        let tmp = (1u64 as i64);
        context_instance
            .register_mut()
            .write_repeatInstr_disassembly(tmp);
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7790:1"]
#[derive(Clone, Debug)]
struct instructionVar27 {
    Wn_t: Wn_t,
}
impl instructionVar27 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("swap.w"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Wn_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 15 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_13_4().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        let Wn_t = if let Some((len, table)) =
            Wn_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wn_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7796:1"]
#[derive(Clone, Debug)]
struct instructionVar28 {
    Wnbyte_t: Wnbyte_t,
}
impl instructionVar28 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("swap.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Wnbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 15 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_13_4().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        let Wnbyte_t = if let Some((len, table)) =
            Wnbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wnbyte_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2958:1"]
#[derive(Clone, Debug)]
struct instructionVar29 {
    Wsb_t: Wsb_t,
}
impl instructionVar29 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("cp0.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Wsb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_15_12().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_11().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_Bb().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_9_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 0 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsb_t = if let Some((len, table)) =
            Wsb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wsb_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2970:1"]
#[derive(Clone, Debug)]
struct instructionVar30 {
    Wsbbyte_t: Wsbbyte_t,
}
impl instructionVar30 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("cp0.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wsbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_15_12().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_11().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_Bb().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_9_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 0 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsbbyte_t = if let Some((len, table)) =
            Wsbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wsbbyte_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3898:1"]
#[derive(Clone, Debug)]
struct instructionVar31 {
    Wnd_t: Wnd_t,
    Wns_t: Wns_t,
}
impl instructionVar31 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("exch"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Wns_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 15 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_15_12().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_11().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_6_4().disassembly() != 0 {
            return None;
        }
        let Wnd_t = if let Some((len, table)) =
            Wnd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wns_t = if let Some((len, table)) =
            Wns_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wnd_t, Wns_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:5178:1"]
#[derive(Clone, Debug)]
struct instructionVar32 {
    Wndd_t: Wndd_t,
    Wsd_t: Wsd_t,
}
impl instructionVar32 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("mov.d"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Wsd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wndd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_15_12().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_11().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 0 {
            return None;
        }
        let Wndd_t = if let Some((len, table)) =
            Wndd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsd_t = if let Some((len, table)) =
            Wsd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wndd_t, Wsd_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:5197:1"]
#[derive(Clone, Debug)]
struct instructionVar33 {
    TOK_9_0_U_t: TOK_9_0_U_t,
}
impl instructionVar33 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("movpag"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.TOK_9_0_U_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::DSRPAG),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 15 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_15_12().disassembly() != 12 {
            return None;
        }
        if token_parser.TOK_11_10_PP().disassembly() != 0 {
            return None;
        }
        let TOK_9_0_U_t = if let Some((len, table)) = TOK_9_0_U_t::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_9_0_U_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:5201:1"]
#[derive(Clone, Debug)]
struct instructionVar34 {
    TOK_9_0_U_t: TOK_9_0_U_t,
}
impl instructionVar34 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("movpag"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.TOK_9_0_U_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::DSWPAG),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 15 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_15_12().disassembly() != 12 {
            return None;
        }
        if token_parser.TOK_11_10_PP().disassembly() != 1 {
            return None;
        }
        let TOK_9_0_U_t = if let Some((len, table)) = TOK_9_0_U_t::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_9_0_U_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:5205:1"]
#[derive(Clone, Debug)]
struct instructionVar35 {
    TOK_9_0_U_t: TOK_9_0_U_t,
}
impl instructionVar35 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("movpag"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.TOK_9_0_U_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::TBLPAG),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 15 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_15_12().disassembly() != 12 {
            return None;
        }
        if token_parser.TOK_11_10_PP().disassembly() != 2 {
            return None;
        }
        let TOK_9_0_U_t = if let Some((len, table)) = TOK_9_0_U_t::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_9_0_U_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3908:1"]
#[derive(Clone, Debug)]
struct instructionVar36 {
    Wnd_t: Wnd_t,
    Ws_t: Ws_t,
}
impl instructionVar36 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("fbcl"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Ws_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 15 {
            return None;
        }
        if token_parser.OP_15_12().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_11().disassembly() != 0 {
            return None;
        }
        let Wnd_t = if let Some((len, table)) =
            Wnd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ws_t = if let Some((len, table)) =
            Ws_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wnd_t, Ws_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3931:1"]
#[derive(Clone, Debug)]
struct instructionVar37 {
    Wnd_t: Wnd_t,
    Ws_t: Ws_t,
}
impl instructionVar37 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ff1l"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Ws_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 12 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 15 {
            return None;
        }
        if token_parser.OP_15_12().disassembly() != 8 {
            return None;
        }
        if token_parser.OP_11().disassembly() != 0 {
            return None;
        }
        let Wnd_t = if let Some((len, table)) =
            Wnd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ws_t = if let Some((len, table)) =
            Ws_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wnd_t, Ws_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3956:1"]
#[derive(Clone, Debug)]
struct instructionVar38 {
    Wnd_t: Wnd_t,
    Ws_t: Ws_t,
}
impl instructionVar38 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ff1r"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Ws_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 12 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 15 {
            return None;
        }
        if token_parser.OP_15_12().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_11().disassembly() != 0 {
            return None;
        }
        let Wnd_t = if let Some((len, table)) =
            Wnd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ws_t = if let Some((len, table)) =
            Ws_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wnd_t, Ws_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7253:1"]
#[derive(Clone, Debug)]
struct instructionVar39 {
    Wd_t: Wd_t,
}
impl instructionVar39 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("setm.w"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 235 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_6_0().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wd_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7259:1"]
#[derive(Clone, Debug)]
struct instructionVar40 {
    Wdbyte_t: Wdbyte_t,
}
impl instructionVar40 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("setm.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 235 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_6_0().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wdbyte_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:5185:1"]
#[derive(Clone, Debug)]
struct instructionVar41 {
    TOK_3_1_Dregn: TokenField_TOK_3_1_Dregn,
    Wdd_t: Wdd_t,
}
impl instructionVar41 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("mov.d"),
            DisplayElement::Literal(" "),
            self.TOK_3_1_Dregn.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Wdd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_15_14().disassembly() != 2 {
            return None;
        }
        if token_parser.OP_6_4().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_0().disassembly() != 0 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdd_t = if let Some((len, table)) =
            Wdd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let TOK_3_1_Dreg = token_parser.TOK_3_1_Dreg();
        let TOK_3_1_Dregn = token_parser.TOK_3_1_Dregn();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wdd_t,
                TOK_3_1_Dregn,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:4288:1"]
#[derive(Clone, Debug)]
struct instructionVar42 {
    k14_t: k14_t,
}
impl instructionVar42 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("lnk"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.k14_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 15 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 10 {
            return None;
        }
        if token_parser.OP_15_14().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_0().disassembly() != 0 {
            return None;
        }
        let k14_t = if let Some((len, table)) =
            k14_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { k14_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7233:1"]
#[derive(Clone, Debug)]
struct instructionVar43 {
    Wnd_t: Wnd_t,
    Ws_t: Ws_t,
}
impl instructionVar43 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("se"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Ws_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_11().disassembly() != 8032 {
            return None;
        }
        let Wnd_t = if let Some((len, table)) =
            Wnd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ws_t = if let Some((len, table)) =
            Ws_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wnd_t, Ws_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:8009:1"]
#[derive(Clone, Debug)]
struct instructionVar44 {
    Wnd_t: Wnd_t,
    Ws_t: Ws_t,
}
impl instructionVar44 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("ze"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Ws_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 15 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_15_12().disassembly() != 8 {
            return None;
        }
        if token_parser.OP_11().disassembly() != 0 {
            return None;
        }
        let Wnd_t = if let Some((len, table)) =
            Wnd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ws_t = if let Some((len, table)) =
            Ws_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wnd_t, Ws_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:5128:1"]
#[derive(Clone, Debug)]
struct instructionVar45 {
    TOK_k8c: TokenField_TOK_k8c,
    Wndbyte_t: Wndbyte_t,
}
impl instructionVar45 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("mov.b"),
            DisplayElement::Literal(" "),
            self.TOK_k8c.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Wndbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 3 {
            return None;
        }
        if token_parser.OP_15_12().disassembly() != 12 {
            return None;
        }
        let Wndbyte_t = if let Some((len, table)) =
            Wndbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let TOK_k8c = token_parser.TOK_k8c();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wndbyte_t, TOK_k8c }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6507:1"]
#[derive(Clone, Debug)]
struct instructionVar46 {
    f13_t: f13_t,
}
impl instructionVar46 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("mul.w"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 188 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_13().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_14().disassembly() != 0 {
            return None;
        }
        let f13_t = if let Some((len, table)) =
            f13_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { f13_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6511:1"]
#[derive(Clone, Debug)]
struct instructionVar47 {
    f13byte_t: f13byte_t,
}
impl instructionVar47 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("mul.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 188 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_13().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_14().disassembly() != 1 {
            return None;
        }
        let f13byte_t = if let Some((len, table)) =
            f13byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { f13byte_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1892:1"]
#[derive(Clone, Debug)]
struct instructionVar48 {
    Wd_t: Wd_t,
    Ws_t: Ws_t,
}
impl instructionVar48 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("asr.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Ws_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ws_t = if let Some((len, table)) =
            Ws_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wd_t, Ws_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1906:1"]
#[derive(Clone, Debug)]
struct instructionVar49 {
    Wdbyte_t: Wdbyte_t,
    Wsbyte_t: Wsbyte_t,
}
impl instructionVar49 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("asr.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wsbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsbyte_t = if let Some((len, table)) =
            Wsbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wdbyte_t, Wsbyte_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2323:1"]
#[derive(Clone, Debug)]
struct instructionVar50 {
    WnWn1_t: WnWn1_t,
    WordInstNext4: WordInstNext4,
}
impl instructionVar50 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("call.l"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.WnWn1_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_10_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7_4().disassembly() != 0 {
            return None;
        }
        let WnWn1_t = if let Some((len, table)) =
            WnWn1_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let WordInstNext4 = if let Some((len, table)) = WordInstNext4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                WnWn1_t,
                WordInstNext4,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3174:1"]
#[derive(Clone, Debug)]
struct instructionVar51 {
    Wbb_t: Wbb_t,
    Wnb_t: Wnb_t,
}
impl instructionVar51 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_skipInstr(
            Some(inst_next),
            context.register().read_skipInstr_disassembly(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("cpseq.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Wbb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 7 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_Bb().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_9_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7_4().disassembly() != 1 {
            return None;
        }
        let tmp = (1u64 as i64);
        context_instance
            .register_mut()
            .write_skipInstr_disassembly(tmp);
        let Wbb_t = if let Some((len, table)) =
            Wbb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wnb_t = if let Some((len, table)) =
            Wnb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wbb_t, Wnb_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3182:1"]
#[derive(Clone, Debug)]
struct instructionVar52 {
    Wbbbyte_t: Wbbbyte_t,
    Wnbbyte_t: Wnbbyte_t,
}
impl instructionVar52 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_skipInstr(
            Some(inst_next),
            context.register().read_skipInstr_disassembly(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("cpseq.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wbbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 7 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_Bb().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_9_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7_4().disassembly() != 1 {
            return None;
        }
        let tmp = (1u64 as i64);
        context_instance
            .register_mut()
            .write_skipInstr_disassembly(tmp);
        let Wbbbyte_t = if let Some((len, table)) =
            Wbbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wnbbyte_t = if let Some((len, table)) =
            Wnbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbbbyte_t,
                Wnbbyte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3210:1"]
#[derive(Clone, Debug)]
struct instructionVar53 {
    Wbb_t: Wbb_t,
    Wnb_t: Wnb_t,
}
impl instructionVar53 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_skipInstr(
            Some(inst_next),
            context.register().read_skipInstr_disassembly(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("cpsgt.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Wbb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 6 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_Bb().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_9_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7_4().disassembly() != 1 {
            return None;
        }
        let tmp = (1u64 as i64);
        context_instance
            .register_mut()
            .write_skipInstr_disassembly(tmp);
        let Wbb_t = if let Some((len, table)) =
            Wbb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wnb_t = if let Some((len, table)) =
            Wnb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wbb_t, Wnb_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3218:1"]
#[derive(Clone, Debug)]
struct instructionVar54 {
    Wbbbyte_t: Wbbbyte_t,
    Wnbbyte_t: Wnbbyte_t,
}
impl instructionVar54 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_skipInstr(
            Some(inst_next),
            context.register().read_skipInstr_disassembly(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("cpsgt.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wbbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 6 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_Bb().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_9_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7_4().disassembly() != 1 {
            return None;
        }
        let tmp = (1u64 as i64);
        context_instance
            .register_mut()
            .write_skipInstr_disassembly(tmp);
        let Wbbbyte_t = if let Some((len, table)) =
            Wbbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wnbbyte_t = if let Some((len, table)) =
            Wnbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbbbyte_t,
                Wnbbyte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3246:1"]
#[derive(Clone, Debug)]
struct instructionVar55 {
    Wbb_t: Wbb_t,
    Wnb_t: Wnb_t,
}
impl instructionVar55 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_skipInstr(
            Some(inst_next),
            context.register().read_skipInstr_disassembly(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("cpslt.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Wbb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 6 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_Bb().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_9_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7_4().disassembly() != 1 {
            return None;
        }
        let tmp = (1u64 as i64);
        context_instance
            .register_mut()
            .write_skipInstr_disassembly(tmp);
        let Wbb_t = if let Some((len, table)) =
            Wbb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wnb_t = if let Some((len, table)) =
            Wnb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wbb_t, Wnb_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3254:1"]
#[derive(Clone, Debug)]
struct instructionVar56 {
    Wbbbyte_t: Wbbbyte_t,
    Wnbbyte_t: Wnbbyte_t,
}
impl instructionVar56 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_skipInstr(
            Some(inst_next),
            context.register().read_skipInstr_disassembly(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("cpslt.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wbbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 6 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_Bb().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_9_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7_4().disassembly() != 1 {
            return None;
        }
        let tmp = (1u64 as i64);
        context_instance
            .register_mut()
            .write_skipInstr_disassembly(tmp);
        let Wbbbyte_t = if let Some((len, table)) =
            Wbbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wnbbyte_t = if let Some((len, table)) =
            Wnbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbbbyte_t,
                Wnbbyte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3282:1"]
#[derive(Clone, Debug)]
struct instructionVar57 {
    Wbb_t: Wbb_t,
    Wnb_t: Wnb_t,
}
impl instructionVar57 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_skipInstr(
            Some(inst_next),
            context.register().read_skipInstr_disassembly(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("cpsne.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Wbb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 7 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_Bb().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_9_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7_4().disassembly() != 1 {
            return None;
        }
        let tmp = (1u64 as i64);
        context_instance
            .register_mut()
            .write_skipInstr_disassembly(tmp);
        let Wbb_t = if let Some((len, table)) =
            Wbb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wnb_t = if let Some((len, table)) =
            Wnb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wbb_t, Wnb_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3290:1"]
#[derive(Clone, Debug)]
struct instructionVar58 {
    Wbbbyte_t: Wbbbyte_t,
    Wnbbyte_t: Wnbbyte_t,
}
impl instructionVar58 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_skipInstr(
            Some(inst_next),
            context.register().read_skipInstr_disassembly(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("cpsne.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wbbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 7 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_Bb().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_9_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7_4().disassembly() != 1 {
            return None;
        }
        let tmp = (1u64 as i64);
        context_instance
            .register_mut()
            .write_skipInstr_disassembly(tmp);
        let Wbbbyte_t = if let Some((len, table)) =
            Wbbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wnbbyte_t = if let Some((len, table)) =
            Wnbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbbbyte_t,
                Wnbbyte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:4018:1"]
#[derive(Clone, Debug)]
struct instructionVar59 {
    WnWn1_t: WnWn1_t,
}
impl instructionVar59 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("goto.l"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.WnWn1_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_10_8().disassembly() != 4 {
            return None;
        }
        if token_parser.OP_7_4().disassembly() != 0 {
            return None;
        }
        let WnWn1_t = if let Some((len, table)) =
            WnWn1_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WnWn1_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3517:1"]
#[derive(Clone, Debug)]
struct instructionVar60 {
    TOK_10_8_Dregn: TokenField_TOK_10_8_Dregn,
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl instructionVar60 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("div.sd"),
            DisplayElement::Literal("  "),
            self.TOK_10_8_Dregn.display(),
            DisplayElement::Literal(","),
            self.TOK_3_0_Wreg.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 8 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_W().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_5_4().disassembly() != 0 {
            return None;
        }
        let TOK_10_8_Dreg = token_parser.TOK_10_8_Dreg();
        let TOK_10_8_Dregn = token_parser.TOK_10_8_Dregn();
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                TOK_10_8_Dregn,
                TOK_3_0_Wreg,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3604:1"]
#[derive(Clone, Debug)]
struct instructionVar61 {
    TOK_10_8_Dregn: TokenField_TOK_10_8_Dregn,
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl instructionVar61 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("div.ud"),
            DisplayElement::Literal("  "),
            self.TOK_10_8_Dregn.display(),
            DisplayElement::Literal(","),
            self.TOK_3_0_Wreg.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 8 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_W().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_5_4().disassembly() != 0 {
            return None;
        }
        let TOK_10_8_Dreg = token_parser.TOK_10_8_Dreg();
        let TOK_10_8_Dregn = token_parser.TOK_10_8_Dregn();
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                TOK_10_8_Dregn,
                TOK_3_0_Wreg,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1920:1"]
#[derive(Clone, Debug)]
struct instructionVar62 {
    Wbd_t: Wbd_t,
    Wnd_t: Wnd_t,
    k4_t: k4_t,
}
impl instructionVar62 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("asr.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Wbd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.k4_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_6_4().disassembly() != 4 {
            return None;
        }
        let Wbd_t = if let Some((len, table)) =
            Wbd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wnd_t = if let Some((len, table)) =
            Wnd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let k4_t = if let Some((len, table)) =
            k4_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wbd_t, Wnd_t, k4_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1929:1"]
#[derive(Clone, Debug)]
struct instructionVar63 {
    Wbd_t: Wbd_t,
    Wnd_t: Wnd_t,
    Wns_t: Wns_t,
}
impl instructionVar63 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("asr.w"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wbd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wns_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_6_4().disassembly() != 0 {
            return None;
        }
        let Wbd_t = if let Some((len, table)) =
            Wbd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wnd_t = if let Some((len, table)) =
            Wnd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wns_t = if let Some((len, table)) =
            Wns_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbd_t,
                Wnd_t,
                Wns_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2120:1"]
#[derive(Clone, Debug)]
struct instructionVar64 {
    Wbd_t: Wbd_t,
    Ws_t: Ws_t,
}
impl instructionVar64 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("bsw.c"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Ws_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wbd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 10 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 13 {
            return None;
        }
        if token_parser.TOK_Z().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_10_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 0 {
            return None;
        }
        let Wbd_t = if let Some((len, table)) =
            Wbd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ws_t = if let Some((len, table)) =
            Ws_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wbd_t, Ws_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2128:1"]
#[derive(Clone, Debug)]
struct instructionVar65 {
    Wbd_t: Wbd_t,
    Ws_t: Ws_t,
}
impl instructionVar65 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("bsw.z"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Ws_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wbd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 10 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 13 {
            return None;
        }
        if token_parser.TOK_Z().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_10_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 0 {
            return None;
        }
        let Wbd_t = if let Some((len, table)) =
            Wbd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ws_t = if let Some((len, table)) =
            Ws_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wbd_t, Ws_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2223:1"]
#[derive(Clone, Debug)]
struct instructionVar66 {
    Wbd_t: Wbd_t,
    Ws_t: Ws_t,
}
impl instructionVar66 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("btst.c"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Ws_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wbd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 10 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 5 {
            return None;
        }
        if token_parser.TOK_Z().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_10_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 0 {
            return None;
        }
        let Wbd_t = if let Some((len, table)) =
            Wbd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ws_t = if let Some((len, table)) =
            Ws_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wbd_t, Ws_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2230:1"]
#[derive(Clone, Debug)]
struct instructionVar67 {
    Wbd_t: Wbd_t,
    Ws_t: Ws_t,
}
impl instructionVar67 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("btst.z"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Ws_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wbd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 10 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 5 {
            return None;
        }
        if token_parser.TOK_Z().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_10_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 0 {
            return None;
        }
        let Wbd_t = if let Some((len, table)) =
            Wbd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ws_t = if let Some((len, table)) =
            Ws_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wbd_t, Ws_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2806:1"]
#[derive(Clone, Debug)]
struct instructionVar68 {
    Wd_t: Wd_t,
    Ws_t: Ws_t,
}
impl instructionVar68 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("com.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Ws_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 10 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ws_t = if let Some((len, table)) =
            Ws_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wd_t, Ws_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2817:1"]
#[derive(Clone, Debug)]
struct instructionVar69 {
    Wdbyte_t: Wdbyte_t,
    Wsbyte_t: Wsbyte_t,
}
impl instructionVar69 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("com.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wsbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 10 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsbyte_t = if let Some((len, table)) =
            Wsbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wdbyte_t, Wsbyte_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2828:1"]
#[derive(Clone, Debug)]
struct instructionVar70 {
    f13_t: f13_t,
}
impl instructionVar70 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("cp.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.f13_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 3 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_13().disassembly() != 0 {
            return None;
        }
        let f13_t = if let Some((len, table)) =
            f13_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { f13_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2841:1"]
#[derive(Clone, Debug)]
struct instructionVar71 {
    f13byte_t: f13byte_t,
}
impl instructionVar71 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("cp.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 3 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_13().disassembly() != 0 {
            return None;
        }
        let f13byte_t = if let Some((len, table)) =
            f13byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { f13byte_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2882:1"]
#[derive(Clone, Debug)]
struct instructionVar72 {
    Wbb_t: Wbb_t,
    k8_t: k8_t,
}
impl instructionVar72 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("cp.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Wbb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.k8_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_Bb().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_6_5().disassembly() != 3 {
            return None;
        }
        let Wbb_t = if let Some((len, table)) =
            Wbb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let k8_t = if let Some((len, table)) =
            k8_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wbb_t, k8_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2894:1"]
#[derive(Clone, Debug)]
struct instructionVar73 {
    Wbbbyte_t: Wbbbyte_t,
    k8byte_t: k8byte_t,
}
impl instructionVar73 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("cp.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wbbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.k8byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_Bb().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_6_5().disassembly() != 3 {
            return None;
        }
        let Wbbbyte_t = if let Some((len, table)) =
            Wbbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let k8byte_t = if let Some((len, table)) =
            k8byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbbbyte_t,
                k8byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2907:1"]
#[derive(Clone, Debug)]
struct instructionVar74 {
    Wbb_t: Wbb_t,
    Wsb_t: Wsb_t,
}
impl instructionVar74 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("cp.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Wbb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wsb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_Bb().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_9_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 0 {
            return None;
        }
        let Wbb_t = if let Some((len, table)) =
            Wbb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsb_t = if let Some((len, table)) =
            Wsb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wbb_t, Wsb_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2920:1"]
#[derive(Clone, Debug)]
struct instructionVar75 {
    Wbbbyte_t: Wbbbyte_t,
    Wsbbyte_t: Wsbbyte_t,
}
impl instructionVar75 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("cp.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wbbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wsbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_Bb().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_9_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 0 {
            return None;
        }
        let Wbbbyte_t = if let Some((len, table)) =
            Wbbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsbbyte_t = if let Some((len, table)) =
            Wsbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbbbyte_t,
                Wsbbyte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2934:1"]
#[derive(Clone, Debug)]
struct instructionVar76 {
    f13_t: f13_t,
}
impl instructionVar76 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("cp0.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.f13_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 2 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_13().disassembly() != 0 {
            return None;
        }
        let f13_t = if let Some((len, table)) =
            f13_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { f13_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2946:1"]
#[derive(Clone, Debug)]
struct instructionVar77 {
    f13byte_t: f13byte_t,
}
impl instructionVar77 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("cp0.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 2 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_13().disassembly() != 0 {
            return None;
        }
        let f13byte_t = if let Some((len, table)) =
            f13byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { f13byte_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2982:1"]
#[derive(Clone, Debug)]
struct instructionVar78 {
    f13_t: f13_t,
}
impl instructionVar78 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("cpb.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.f13_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 3 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_13().disassembly() != 0 {
            return None;
        }
        let f13_t = if let Some((len, table)) =
            f13_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { f13_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2996:1"]
#[derive(Clone, Debug)]
struct instructionVar79 {
    f13byte_t: f13byte_t,
}
impl instructionVar79 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("cpb.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 3 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_13().disassembly() != 0 {
            return None;
        }
        let f13byte_t = if let Some((len, table)) =
            f13byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { f13byte_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3040:1"]
#[derive(Clone, Debug)]
struct instructionVar80 {
    Wbb_t: Wbb_t,
    k8_t: k8_t,
}
impl instructionVar80 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("cpb.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Wbb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.k8_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_Bb().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_6_5().disassembly() != 3 {
            return None;
        }
        let Wbb_t = if let Some((len, table)) =
            Wbb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let k8_t = if let Some((len, table)) =
            k8_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wbb_t, k8_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3053:1"]
#[derive(Clone, Debug)]
struct instructionVar81 {
    Wbbbyte_t: Wbbbyte_t,
    k8byte_t: k8byte_t,
}
impl instructionVar81 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("cpb.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wbbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.k8byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_Bb().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_6_5().disassembly() != 3 {
            return None;
        }
        let Wbbbyte_t = if let Some((len, table)) =
            Wbbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let k8byte_t = if let Some((len, table)) =
            k8byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbbbyte_t,
                k8byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3067:1"]
#[derive(Clone, Debug)]
struct instructionVar82 {
    Wbb_t: Wbb_t,
    Wsb_t: Wsb_t,
}
impl instructionVar82 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("cpb.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Wbb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wsb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_Bb().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_9_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 0 {
            return None;
        }
        let Wbb_t = if let Some((len, table)) =
            Wbb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsb_t = if let Some((len, table)) =
            Wsb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wbb_t, Wsb_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3081:1"]
#[derive(Clone, Debug)]
struct instructionVar83 {
    Wbbbyte_t: Wbbbyte_t,
    Wsbbyte_t: Wsbbyte_t,
}
impl instructionVar83 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("cpb.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wbbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wsbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_Bb().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_9_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 0 {
            return None;
        }
        let Wbbbyte_t = if let Some((len, table)) =
            Wbbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsbbyte_t = if let Some((len, table)) =
            Wsbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbbbyte_t,
                Wsbbyte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3097:1"]
#[derive(Clone, Debug)]
struct instructionVar84 {
    Wbb_t: Wbb_t,
    n6_t: n6_t,
    Wnb_t: Wnb_t,
}
impl instructionVar84 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("cpbeq.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Wbb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.n6_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 7 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_Bb().disassembly() != 0 {
            return None;
        }
        let Wbb_t = if let Some((len, table)) =
            Wbb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let n6_t = if let Some((len, table)) =
            n6_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wnb_t = if let Some((len, table)) =
            Wnb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wbb_t, n6_t, Wnb_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3103:1"]
#[derive(Clone, Debug)]
struct instructionVar85 {
    Wbbbyte_t: Wbbbyte_t,
    n6_t: n6_t,
    Wnbbyte_t: Wnbbyte_t,
}
impl instructionVar85 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("cpbeq.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wbbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.n6_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 7 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_Bb().disassembly() != 1 {
            return None;
        }
        let Wbbbyte_t = if let Some((len, table)) =
            Wbbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let n6_t = if let Some((len, table)) =
            n6_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wnbbyte_t = if let Some((len, table)) =
            Wnbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbbbyte_t,
                n6_t,
                Wnbbyte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3112:1"]
#[derive(Clone, Debug)]
struct instructionVar86 {
    Wbb_t: Wbb_t,
    n6_t: n6_t,
    Wnb_t: Wnb_t,
}
impl instructionVar86 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("cpbgt.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Wbb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.n6_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 6 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_Bb().disassembly() != 0 {
            return None;
        }
        let Wbb_t = if let Some((len, table)) =
            Wbb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let n6_t = if let Some((len, table)) =
            n6_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wnb_t = if let Some((len, table)) =
            Wnb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wbb_t, n6_t, Wnb_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3118:1"]
#[derive(Clone, Debug)]
struct instructionVar87 {
    Wbbbyte_t: Wbbbyte_t,
    n6_t: n6_t,
    Wnbbyte_t: Wnbbyte_t,
}
impl instructionVar87 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("cpbgt.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wbbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.n6_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 6 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_Bb().disassembly() != 1 {
            return None;
        }
        let Wbbbyte_t = if let Some((len, table)) =
            Wbbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let n6_t = if let Some((len, table)) =
            n6_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wnbbyte_t = if let Some((len, table)) =
            Wnbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbbbyte_t,
                n6_t,
                Wnbbyte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3127:1"]
#[derive(Clone, Debug)]
struct instructionVar88 {
    Wbb_t: Wbb_t,
    n6_t: n6_t,
    Wnb_t: Wnb_t,
}
impl instructionVar88 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("cpblt.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Wbb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.n6_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 6 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_Bb().disassembly() != 0 {
            return None;
        }
        let Wbb_t = if let Some((len, table)) =
            Wbb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let n6_t = if let Some((len, table)) =
            n6_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wnb_t = if let Some((len, table)) =
            Wnb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wbb_t, n6_t, Wnb_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3133:1"]
#[derive(Clone, Debug)]
struct instructionVar89 {
    Wbbbyte_t: Wbbbyte_t,
    n6_t: n6_t,
    Wnbbyte_t: Wnbbyte_t,
}
impl instructionVar89 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("cpblt.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wbbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.n6_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 6 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_Bb().disassembly() != 1 {
            return None;
        }
        let Wbbbyte_t = if let Some((len, table)) =
            Wbbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let n6_t = if let Some((len, table)) =
            n6_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wnbbyte_t = if let Some((len, table)) =
            Wnbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbbbyte_t,
                n6_t,
                Wnbbyte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3142:1"]
#[derive(Clone, Debug)]
struct instructionVar90 {
    Wbb_t: Wbb_t,
    n6_t: n6_t,
    Wnb_t: Wnb_t,
}
impl instructionVar90 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("cpbne.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Wbb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.n6_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 7 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_Bb().disassembly() != 0 {
            return None;
        }
        let Wbb_t = if let Some((len, table)) =
            Wbb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let n6_t = if let Some((len, table)) =
            n6_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wnb_t = if let Some((len, table)) =
            Wnb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wbb_t, n6_t, Wnb_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3148:1"]
#[derive(Clone, Debug)]
struct instructionVar91 {
    Wbbbyte_t: Wbbbyte_t,
    n6_t: n6_t,
    Wnbbyte_t: Wnbbyte_t,
}
impl instructionVar91 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("cpbne.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wbbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.n6_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 7 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_Bb().disassembly() != 1 {
            return None;
        }
        let Wbbbyte_t = if let Some((len, table)) =
            Wbbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let n6_t = if let Some((len, table)) =
            n6_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wnbbyte_t = if let Some((len, table)) =
            Wnbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbbbyte_t,
                n6_t,
                Wnbbyte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3351:1"]
#[derive(Clone, Debug)]
struct instructionVar92 {
    Wd_t: Wd_t,
    Ws_t: Ws_t,
}
impl instructionVar92 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("dec.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Ws_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 9 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ws_t = if let Some((len, table)) =
            Ws_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wd_t, Ws_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3367:1"]
#[derive(Clone, Debug)]
struct instructionVar93 {
    Wdbyte_t: Wdbyte_t,
    Wsbyte_t: Wsbyte_t,
}
impl instructionVar93 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("dec.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wsbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 9 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsbyte_t = if let Some((len, table)) =
            Wsbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wdbyte_t, Wsbyte_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3411:1"]
#[derive(Clone, Debug)]
struct instructionVar94 {
    Wd_t: Wd_t,
    Ws_t: Ws_t,
}
impl instructionVar94 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("dec2.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Ws_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 9 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ws_t = if let Some((len, table)) =
            Ws_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wd_t, Ws_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3427:1"]
#[derive(Clone, Debug)]
struct instructionVar95 {
    Wdbyte_t: Wdbyte_t,
    Wsbyte_t: Wsbyte_t,
}
impl instructionVar95 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("dec2.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wsbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 9 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsbyte_t = if let Some((len, table)) =
            Wsbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wdbyte_t, Wsbyte_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3443:1"]
#[derive(Clone, Debug)]
struct instructionVar96 {
    k14_t: k14_t,
}
impl instructionVar96 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("disi"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.k14_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 15 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 12 {
            return None;
        }
        if token_parser.OP_15_14().disassembly() != 0 {
            return None;
        }
        let k14_t = if let Some((len, table)) =
            k14_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { k14_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3476:1"]
#[derive(Clone, Debug)]
struct instructionVar97 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl instructionVar97 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("div.sw"),
            DisplayElement::Literal("   "),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal(","),
            self.TOK_3_0_Wreg.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 8 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_W().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_5_4().disassembly() != 0 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                TOK_10_7_Wreg,
                TOK_3_0_Wreg,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3562:1"]
#[derive(Clone, Debug)]
struct instructionVar98 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl instructionVar98 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("div.uw"),
            DisplayElement::Literal("   "),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal(","),
            self.TOK_3_0_Wreg.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 8 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_W().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_5_4().disassembly() != 0 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                TOK_10_7_Wreg,
                TOK_3_0_Wreg,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:4053:1"]
#[derive(Clone, Debug)]
struct instructionVar99 {
    Wd_t: Wd_t,
    Ws_t: Ws_t,
}
impl instructionVar99 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("inc.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Ws_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 8 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ws_t = if let Some((len, table)) =
            Ws_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wd_t, Ws_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:4068:1"]
#[derive(Clone, Debug)]
struct instructionVar100 {
    Wdbyte_t: Wdbyte_t,
    Wsbyte_t: Wsbyte_t,
}
impl instructionVar100 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("inc.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wsbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 8 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsbyte_t = if let Some((len, table)) =
            Wsbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wdbyte_t, Wsbyte_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:4112:1"]
#[derive(Clone, Debug)]
struct instructionVar101 {
    Wd_t: Wd_t,
    Ws_t: Ws_t,
}
impl instructionVar101 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("inc2.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Ws_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 232 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ws_t = if let Some((len, table)) =
            Ws_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wd_t, Ws_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:4127:1"]
#[derive(Clone, Debug)]
struct instructionVar102 {
    Wdbyte_t: Wdbyte_t,
    Wsbyte_t: Wsbyte_t,
}
impl instructionVar102 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("inc2.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wsbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 232 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsbyte_t = if let Some((len, table)) =
            Wsbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wdbyte_t, Wsbyte_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:4324:1"]
#[derive(Clone, Debug)]
struct instructionVar103 {
    Wd_t: Wd_t,
    Ws_t: Ws_t,
}
impl instructionVar103 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("lsr.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Ws_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ws_t = if let Some((len, table)) =
            Ws_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wd_t, Ws_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:4337:1"]
#[derive(Clone, Debug)]
struct instructionVar104 {
    Wdbyte_t: Wdbyte_t,
    Wsbyte_t: Wsbyte_t,
}
impl instructionVar104 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("lsr.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wsbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsbyte_t = if let Some((len, table)) =
            Wsbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wdbyte_t, Wsbyte_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:4351:1"]
#[derive(Clone, Debug)]
struct instructionVar105 {
    Wbd_t: Wbd_t,
    Wnd_t: Wnd_t,
    k4_t: k4_t,
}
impl instructionVar105 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("lsr.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Wbd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.k4_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_6_4().disassembly() != 4 {
            return None;
        }
        let Wbd_t = if let Some((len, table)) =
            Wbd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wnd_t = if let Some((len, table)) =
            Wnd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let k4_t = if let Some((len, table)) =
            k4_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wbd_t, Wnd_t, k4_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:4360:1"]
#[derive(Clone, Debug)]
struct instructionVar106 {
    Wbd_t: Wbd_t,
    Wnd_t: Wnd_t,
    Wns_t: Wns_t,
}
impl instructionVar106 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("lsr.w"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wbd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wns_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_6_4().disassembly() != 0 {
            return None;
        }
        let Wbd_t = if let Some((len, table)) =
            Wbd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wnd_t = if let Some((len, table)) =
            Wnd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wns_t = if let Some((len, table)) =
            Wns_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbd_t,
                Wnd_t,
                Wns_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:5104:1"]
#[derive(Clone, Debug)]
struct instructionVar107 {
    WREG_W0_t: WREG_W0_t,
    f13_t: f13_t,
}
impl instructionVar107 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("mov.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.WREG_W0_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.f13_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 7 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_13().disassembly() != 1 {
            return None;
        }
        let WREG_W0_t = if let Some((len, table)) =
            WREG_W0_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13_t = if let Some((len, table)) =
            f13_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WREG_W0_t, f13_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:5110:1"]
#[derive(Clone, Debug)]
struct instructionVar108 {
    WREG_W0byte_t: WREG_W0byte_t,
    f13byte_t: f13byte_t,
}
impl instructionVar108 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("mov.b"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.WREG_W0byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.f13byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 7 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_13().disassembly() != 1 {
            return None;
        }
        let WREG_W0byte_t = if let Some((len, table)) = WREG_W0byte_t::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13byte_t = if let Some((len, table)) =
            f13byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                WREG_W0byte_t,
                f13byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6538:1"]
#[derive(Clone, Debug)]
struct instructionVar109 {
    Wbd_t: Wbd_t,
    Wndd_t: Wndd_t,
    k5: k5,
}
impl instructionVar109 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("mul.su"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Wbd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.k5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wndd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 9 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_6_5().disassembly() != 3 {
            return None;
        }
        let Wbd_t = if let Some((len, table)) =
            Wbd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wndd_t = if let Some((len, table)) =
            Wndd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let k5 = if let Some((len, table)) =
            k5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wbd_t, Wndd_t, k5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6581:1"]
#[derive(Clone, Debug)]
struct instructionVar110 {
    Wbd_t: Wbd_t,
    Wndd_t: Wndd_t,
    k5: k5,
}
impl instructionVar110 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("mul.uu"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Wbd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.k5.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wndd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 8 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_6_5().disassembly() != 3 {
            return None;
        }
        let Wbd_t = if let Some((len, table)) =
            Wbd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wndd_t = if let Some((len, table)) =
            Wndd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let k5 = if let Some((len, table)) =
            k5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wbd_t, Wndd_t, k5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6626:1"]
#[derive(Clone, Debug)]
struct instructionVar111 {
    Wbd_t: Wbd_t,
    Wndd_t: Wndd_t,
    k5_t: k5_t,
}
impl instructionVar111 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("mulw.su"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Wbd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.k5_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wndd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 9 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_6_5().disassembly() != 3 {
            return None;
        }
        let Wbd_t = if let Some((len, table)) =
            Wbd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wndd_t = if let Some((len, table)) =
            Wndd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let k5_t = if let Some((len, table)) =
            k5_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbd_t,
                Wndd_t,
                k5_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6651:1"]
#[derive(Clone, Debug)]
struct instructionVar112 {
    Wbd_t: Wbd_t,
    Wndd_t: Wndd_t,
    k5_t: k5_t,
}
impl instructionVar112 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("mulw.uu"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Wbd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.k5_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wndd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 8 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_6_5().disassembly() != 3 {
            return None;
        }
        let Wbd_t = if let Some((len, table)) =
            Wbd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wndd_t = if let Some((len, table)) =
            Wndd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let k5_t = if let Some((len, table)) =
            k5_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbd_t,
                Wndd_t,
                k5_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6517:1"]
#[derive(Clone, Debug)]
struct instructionVar113 {
    Wbd_t: Wbd_t,
    Wndd_t: Wndd_t,
    WsMUL_t: WsMUL_t,
}
impl instructionVar113 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("mul.ss"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Wbd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.WsMUL_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wndd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 9 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 0 {
            return None;
        }
        let Wbd_t = if let Some((len, table)) =
            Wbd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wndd_t = if let Some((len, table)) =
            Wndd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let WsMUL_t = if let Some((len, table)) =
            WsMUL_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbd_t,
                Wndd_t,
                WsMUL_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6543:1"]
#[derive(Clone, Debug)]
struct instructionVar114 {
    Wbd_t: Wbd_t,
    Wndd_t: Wndd_t,
    WsMUL_t: WsMUL_t,
}
impl instructionVar114 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("mul.su"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Wbd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.WsMUL_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wndd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 9 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 0 {
            return None;
        }
        let Wbd_t = if let Some((len, table)) =
            Wbd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wndd_t = if let Some((len, table)) =
            Wndd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let WsMUL_t = if let Some((len, table)) =
            WsMUL_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbd_t,
                Wndd_t,
                WsMUL_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6565:1"]
#[derive(Clone, Debug)]
struct instructionVar115 {
    Wbd_t: Wbd_t,
    Wndd_t: Wndd_t,
    WsMUL_t: WsMUL_t,
}
impl instructionVar115 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("mul.us"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Wbd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.WsMUL_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wndd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 8 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 0 {
            return None;
        }
        let Wbd_t = if let Some((len, table)) =
            Wbd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wndd_t = if let Some((len, table)) =
            Wndd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let WsMUL_t = if let Some((len, table)) =
            WsMUL_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbd_t,
                Wndd_t,
                WsMUL_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6587:1"]
#[derive(Clone, Debug)]
struct instructionVar116 {
    Wbd_t: Wbd_t,
    Wndd_t: Wndd_t,
    WsMUL_t: WsMUL_t,
}
impl instructionVar116 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("mul.uu"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Wbd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.WsMUL_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wndd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 8 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 0 {
            return None;
        }
        let Wbd_t = if let Some((len, table)) =
            Wbd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wndd_t = if let Some((len, table)) =
            Wndd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let WsMUL_t = if let Some((len, table)) =
            WsMUL_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbd_t,
                Wndd_t,
                WsMUL_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6610:1"]
#[derive(Clone, Debug)]
struct instructionVar117 {
    Wbd_t: Wbd_t,
    Wndd_t: Wndd_t,
    WsMUL_t: WsMUL_t,
}
impl instructionVar117 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("mulw.ss"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Wbd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.WsMUL_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wndd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 9 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 1 {
            return None;
        }
        let Wbd_t = if let Some((len, table)) =
            Wbd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wndd_t = if let Some((len, table)) =
            Wndd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let WsMUL_t = if let Some((len, table)) =
            WsMUL_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbd_t,
                Wndd_t,
                WsMUL_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6619:1"]
#[derive(Clone, Debug)]
struct instructionVar118 {
    Wbd_t: Wbd_t,
    Wndd_t: Wndd_t,
    WsMUL_t: WsMUL_t,
}
impl instructionVar118 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("mulw.su"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Wbd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.WsMUL_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wndd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 9 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 1 {
            return None;
        }
        let Wbd_t = if let Some((len, table)) =
            Wbd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wndd_t = if let Some((len, table)) =
            Wndd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let WsMUL_t = if let Some((len, table)) =
            WsMUL_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbd_t,
                Wndd_t,
                WsMUL_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6635:1"]
#[derive(Clone, Debug)]
struct instructionVar119 {
    Wbd_t: Wbd_t,
    Wndd_t: Wndd_t,
    WsMUL_t: WsMUL_t,
}
impl instructionVar119 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("mulw.us"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Wbd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.WsMUL_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wndd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 8 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 1 {
            return None;
        }
        let Wbd_t = if let Some((len, table)) =
            Wbd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wndd_t = if let Some((len, table)) =
            Wndd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let WsMUL_t = if let Some((len, table)) =
            WsMUL_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbd_t,
                Wndd_t,
                WsMUL_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6644:1"]
#[derive(Clone, Debug)]
struct instructionVar120 {
    Wbd_t: Wbd_t,
    Wndd_t: Wndd_t,
    WsMUL_t: WsMUL_t,
}
impl instructionVar120 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("mulw.uu"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Wbd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.WsMUL_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wndd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 8 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 1 {
            return None;
        }
        let Wbd_t = if let Some((len, table)) =
            Wbd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wndd_t = if let Some((len, table)) =
            Wndd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let WsMUL_t = if let Some((len, table)) =
            WsMUL_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbd_t,
                Wndd_t,
                WsMUL_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6659:1"]
#[derive(Clone, Debug)]
struct instructionVar121 {
    WREG_t: WREG_t,
    f13_t: f13_t,
}
impl instructionVar121 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("neg.w"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREG_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 238 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_14().disassembly() != 0 {
            return None;
        }
        let WREG_t = if let Some((len, table)) =
            WREG_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13_t = if let Some((len, table)) =
            f13_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WREG_t, f13_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6670:1"]
#[derive(Clone, Debug)]
struct instructionVar122 {
    WREGbyte_t: WREGbyte_t,
    f13byte_t: f13byte_t,
}
impl instructionVar122 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("neg.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREGbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 238 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_14().disassembly() != 1 {
            return None;
        }
        let WREGbyte_t = if let Some((len, table)) =
            WREGbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13byte_t = if let Some((len, table)) =
            f13byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                WREGbyte_t,
                f13byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6682:1"]
#[derive(Clone, Debug)]
struct instructionVar123 {
    Wd_t: Wd_t,
    Ws_t: Ws_t,
}
impl instructionVar123 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("neg.w"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Ws_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 234 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_14().disassembly() != 0 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ws_t = if let Some((len, table)) =
            Ws_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wd_t, Ws_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6695:1"]
#[derive(Clone, Debug)]
struct instructionVar124 {
    Wdbyte_t: Wdbyte_t,
    Wsbyte_t: Wsbyte_t,
}
impl instructionVar124 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("neg.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Wsbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 234 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_14().disassembly() != 1 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsbyte_t = if let Some((len, table)) =
            Wsbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wdbyte_t, Wsbyte_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7035:1"]
#[derive(Clone, Debug)]
struct instructionVar125 {
    Wd_t: Wd_t,
    Ws_t: Ws_t,
}
impl instructionVar125 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("rlc.w"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Ws_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 210 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ws_t = if let Some((len, table)) =
            Ws_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wd_t, Ws_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7048:1"]
#[derive(Clone, Debug)]
struct instructionVar126 {
    Wdbyte_t: Wdbyte_t,
    Wsbyte_t: Wsbyte_t,
}
impl instructionVar126 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("rlc.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Wsbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 210 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsbyte_t = if let Some((len, table)) =
            Wsbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wdbyte_t, Wsbyte_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7077:1"]
#[derive(Clone, Debug)]
struct instructionVar127 {
    Wd_t: Wd_t,
    Ws_t: Ws_t,
}
impl instructionVar127 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("rlnc.w"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Ws_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 210 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ws_t = if let Some((len, table)) =
            Ws_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wd_t, Ws_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7088:1"]
#[derive(Clone, Debug)]
struct instructionVar128 {
    Wdbyte_t: Wdbyte_t,
    Wsbyte_t: Wsbyte_t,
}
impl instructionVar128 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("rlnc.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Wsbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 210 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsbyte_t = if let Some((len, table)) =
            Wsbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wdbyte_t, Wsbyte_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7120:1"]
#[derive(Clone, Debug)]
struct instructionVar129 {
    Wd_t: Wd_t,
    Ws_t: Ws_t,
}
impl instructionVar129 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("rrc.w"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Ws_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 211 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ws_t = if let Some((len, table)) =
            Ws_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wd_t, Ws_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7133:1"]
#[derive(Clone, Debug)]
struct instructionVar130 {
    Wdbyte_t: Wdbyte_t,
    Wsbyte_t: Wsbyte_t,
}
impl instructionVar130 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("rrc.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Wsbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 211 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsbyte_t = if let Some((len, table)) =
            Wsbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wdbyte_t, Wsbyte_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7146:1"]
#[derive(Clone, Debug)]
struct instructionVar131 {
    WREG_t: WREG_t,
    f13_t: f13_t,
}
impl instructionVar131 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("rrnc.w"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREG_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 215 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        let WREG_t = if let Some((len, table)) =
            WREG_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13_t = if let Some((len, table)) =
            f13_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WREG_t, f13_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7155:1"]
#[derive(Clone, Debug)]
struct instructionVar132 {
    WREGbyte_t: WREGbyte_t,
    f13byte_t: f13byte_t,
}
impl instructionVar132 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("rrnc.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREGbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 215 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        let WREGbyte_t = if let Some((len, table)) =
            WREGbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13byte_t = if let Some((len, table)) =
            f13byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                WREGbyte_t,
                f13byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7164:1"]
#[derive(Clone, Debug)]
struct instructionVar133 {
    Wd_t: Wd_t,
    Ws_t: Ws_t,
}
impl instructionVar133 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("rrnc.w"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Ws_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 211 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ws_t = if let Some((len, table)) =
            Ws_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wd_t, Ws_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7176:1"]
#[derive(Clone, Debug)]
struct instructionVar134 {
    Wdbyte_t: Wdbyte_t,
    Wsbyte_t: Wsbyte_t,
}
impl instructionVar134 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("rrnc.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Wsbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 211 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsbyte_t = if let Some((len, table)) =
            Wsbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wdbyte_t, Wsbyte_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7327:1"]
#[derive(Clone, Debug)]
struct instructionVar135 {
    Wd_t: Wd_t,
    Ws_t: Ws_t,
}
impl instructionVar135 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("sl.w"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Ws_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ws_t = if let Some((len, table)) =
            Ws_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wd_t, Ws_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7339:1"]
#[derive(Clone, Debug)]
struct instructionVar136 {
    Wdbyte_t: Wdbyte_t,
    Wsbyte_t: Wsbyte_t,
}
impl instructionVar136 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("sl.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Wsbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsbyte_t = if let Some((len, table)) =
            Wsbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wdbyte_t, Wsbyte_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7352:1"]
#[derive(Clone, Debug)]
struct instructionVar137 {
    Wbd_t: Wbd_t,
    Wnd_t: Wnd_t,
    k4_t: k4_t,
}
impl instructionVar137 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("sl"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Wbd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.k4_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_6_4().disassembly() != 4 {
            return None;
        }
        let Wbd_t = if let Some((len, table)) =
            Wbd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wnd_t = if let Some((len, table)) =
            Wnd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let k4_t = if let Some((len, table)) =
            k4_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wbd_t, Wnd_t, k4_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7360:1"]
#[derive(Clone, Debug)]
struct instructionVar138 {
    Wbd_t: Wbd_t,
    Wnd_t: Wnd_t,
    Wns_t: Wns_t,
}
impl instructionVar138 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("sl"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Wbd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wns_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_6_4().disassembly() != 0 {
            return None;
        }
        let Wbd_t = if let Some((len, table)) =
            Wbd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wnd_t = if let Some((len, table)) =
            Wnd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wns_t = if let Some((len, table)) =
            Wns_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbd_t,
                Wnd_t,
                Wns_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7803:1"]
#[derive(Clone, Debug)]
struct instructionVar139 {
    Wd_t: Wd_t,
    WsROM_t: WsROM_t,
}
impl instructionVar139 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("tblrdh.w"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.WsROM_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 10 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let WsROM_t = if let Some((len, table)) =
            WsROM_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wd_t, WsROM_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7811:1"]
#[derive(Clone, Debug)]
struct instructionVar140 {
    Wdbyte_t: Wdbyte_t,
    WsROM_t: WsROM_t,
}
impl instructionVar140 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("tblrdh.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.WsROM_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 10 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let WsROM_t = if let Some((len, table)) =
            WsROM_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wdbyte_t, WsROM_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7826:1"]
#[derive(Clone, Debug)]
struct instructionVar141 {
    Wd_t: Wd_t,
    WsROM_t: WsROM_t,
}
impl instructionVar141 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("tblrdl.w"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.WsROM_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 10 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let WsROM_t = if let Some((len, table)) =
            WsROM_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wd_t, WsROM_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7833:1"]
#[derive(Clone, Debug)]
struct instructionVar142 {
    Wdbyte_t: Wdbyte_t,
    WsROM_t: WsROM_t,
}
impl instructionVar142 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("tblrdl.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.WsROM_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 10 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let WsROM_t = if let Some((len, table)) =
            WsROM_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wdbyte_t, WsROM_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7846:1"]
#[derive(Clone, Debug)]
struct instructionVar143 {
    WdROM_t: WdROM_t,
    Ws_t: Ws_t,
}
impl instructionVar143 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("tblwth.w"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Ws_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.WdROM_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let WdROM_t = if let Some((len, table)) =
            WdROM_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ws_t = if let Some((len, table)) =
            Ws_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WdROM_t, Ws_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7854:1"]
#[derive(Clone, Debug)]
struct instructionVar144 {
    WdROM_t: WdROM_t,
    Wsbyte_t: Wsbyte_t,
}
impl instructionVar144 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("tblwth.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Wsbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.WdROM_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let WdROM_t = if let Some((len, table)) =
            WdROM_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsbyte_t = if let Some((len, table)) =
            Wsbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WdROM_t, Wsbyte_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7868:1"]
#[derive(Clone, Debug)]
struct instructionVar145 {
    WdROM_t: WdROM_t,
    Ws_t: Ws_t,
}
impl instructionVar145 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("tblwtl.w"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Ws_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.WdROM_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let WdROM_t = if let Some((len, table)) =
            WdROM_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ws_t = if let Some((len, table)) =
            Ws_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WdROM_t, Ws_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7875:1"]
#[derive(Clone, Debug)]
struct instructionVar146 {
    WdROM_t: WdROM_t,
    Wsbyte_t: Wsbyte_t,
}
impl instructionVar146 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("tblwtl.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Wsbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.WdROM_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let WdROM_t = if let Some((len, table)) =
            WdROM_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsbyte_t = if let Some((len, table)) =
            Wsbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WdROM_t, Wsbyte_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1525:1"]
#[derive(Clone, Debug)]
struct instructionVar147 {
    WREG_t: WREG_t,
    f13_t: f13_t,
}
impl instructionVar147 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("add.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.f13_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREG_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 4 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let WREG_t = if let Some((len, table)) =
            WREG_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13_t = if let Some((len, table)) =
            f13_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WREG_t, f13_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1539:1"]
#[derive(Clone, Debug)]
struct instructionVar148 {
    WREGbyte_t: WREGbyte_t,
    f13byte_t: f13byte_t,
}
impl instructionVar148 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("add.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREGbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 4 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let WREGbyte_t = if let Some((len, table)) =
            WREGbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13byte_t = if let Some((len, table)) =
            f13byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                WREGbyte_t,
                f13byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1553:1"]
#[derive(Clone, Debug)]
struct instructionVar149 {
    k10_t: k10_t,
    Wn_t: Wn_t,
}
impl instructionVar149 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("add.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.k10_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wn_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let k10_t = if let Some((len, table)) =
            k10_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wn_t = if let Some((len, table)) =
            Wn_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { k10_t, Wn_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1567:1"]
#[derive(Clone, Debug)]
struct instructionVar150 {
    k10byte_t: k10byte_t,
    Wnbyte_t: Wnbyte_t,
}
impl instructionVar150 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("add.b"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.k10byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let k10byte_t = if let Some((len, table)) =
            k10byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wnbyte_t = if let Some((len, table)) =
            Wnbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                k10byte_t,
                Wnbyte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6746:1"]
#[derive(Clone, Debug)]
struct instructionVar151 {
    movWd: movWd,
}
impl instructionVar151 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("pop"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.movWd.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 7 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_14().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_6_4().disassembly() != 4 {
            return None;
        }
        if token_parser.OP_3_0().disassembly() != 15 {
            return None;
        }
        let movWd = if let Some((len, table)) =
            movWd::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { movWd }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1581:1"]
#[derive(Clone, Debug)]
struct instructionVar152 {
    Wb_t: Wb_t,
    Wd_t: Wd_t,
    k5_t: k5_t,
}
impl instructionVar152 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("add.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Wb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.k5_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 4 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_6_5().disassembly() != 3 {
            return None;
        }
        let Wb_t = if let Some((len, table)) =
            Wb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let k5_t = if let Some((len, table)) =
            k5_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wb_t, Wd_t, k5_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1595:1"]
#[derive(Clone, Debug)]
struct instructionVar153 {
    Wbbyte_t: Wbbyte_t,
    Wdbyte_t: Wdbyte_t,
    k5byte_t: k5byte_t,
}
impl instructionVar153 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("add.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.k5byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 4 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_6_5().disassembly() != 3 {
            return None;
        }
        let Wbbyte_t = if let Some((len, table)) =
            Wbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let k5byte_t = if let Some((len, table)) =
            k5byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbbyte_t,
                Wdbyte_t,
                k5byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6784:1"]
#[derive(Clone, Debug)]
struct instructionVar154 {
    movWs: movWs,
}
impl instructionVar154 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("push"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.movWs.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 7 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_14_12().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_11_8().disassembly() != 15 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 1 {
            return None;
        }
        let movWs = if let Some((len, table)) =
            movWs::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { movWs }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1610:1"]
#[derive(Clone, Debug)]
struct instructionVar155 {
    Wb_t: Wb_t,
    Wd_t: Wd_t,
    Ws_t: Ws_t,
}
impl instructionVar155 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("add.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Wb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Ws_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 4 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        let Wb_t = if let Some((len, table)) =
            Wb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ws_t = if let Some((len, table)) =
            Ws_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wb_t, Wd_t, Ws_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1624:1"]
#[derive(Clone, Debug)]
struct instructionVar156 {
    Wbbyte_t: Wbbyte_t,
    Wdbyte_t: Wdbyte_t,
    Wsbyte_t: Wsbyte_t,
}
impl instructionVar156 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("add.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wsbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 4 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        let Wbbyte_t = if let Some((len, table)) =
            Wbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsbyte_t = if let Some((len, table)) =
            Wsbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbbyte_t,
                Wdbyte_t,
                Wsbyte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1673:1"]
#[derive(Clone, Debug)]
struct instructionVar157 {
    WREG_t: WREG_t,
    f13_t: f13_t,
}
impl instructionVar157 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("addc.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.f13_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREG_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 4 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        let WREG_t = if let Some((len, table)) =
            WREG_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13_t = if let Some((len, table)) =
            f13_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WREG_t, f13_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1687:1"]
#[derive(Clone, Debug)]
struct instructionVar158 {
    WREGbyte_t: WREGbyte_t,
    f13byte_t: f13byte_t,
}
impl instructionVar158 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("addc.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREGbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 4 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        let WREGbyte_t = if let Some((len, table)) =
            WREGbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13byte_t = if let Some((len, table)) =
            f13byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                WREGbyte_t,
                f13byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1702:1"]
#[derive(Clone, Debug)]
struct instructionVar159 {
    k10_t: k10_t,
    Wn_t: Wn_t,
}
impl instructionVar159 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("addc.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.k10_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wn_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        let k10_t = if let Some((len, table)) =
            k10_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wn_t = if let Some((len, table)) =
            Wn_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { k10_t, Wn_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1715:1"]
#[derive(Clone, Debug)]
struct instructionVar160 {
    k10byte_t: k10byte_t,
    Wnbyte_t: Wnbyte_t,
}
impl instructionVar160 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("addc.b"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.k10byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        let k10byte_t = if let Some((len, table)) =
            k10byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wnbyte_t = if let Some((len, table)) =
            Wnbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                k10byte_t,
                Wnbyte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1728:1"]
#[derive(Clone, Debug)]
struct instructionVar161 {
    Wb_t: Wb_t,
    Wd_t: Wd_t,
    k5_t: k5_t,
}
impl instructionVar161 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("addc.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Wb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.k5_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 4 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_6_5().disassembly() != 3 {
            return None;
        }
        let Wb_t = if let Some((len, table)) =
            Wb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let k5_t = if let Some((len, table)) =
            k5_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wb_t, Wd_t, k5_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1743:1"]
#[derive(Clone, Debug)]
struct instructionVar162 {
    Wbbyte_t: Wbbyte_t,
    Wdbyte_t: Wdbyte_t,
    k5byte_t: k5byte_t,
}
impl instructionVar162 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("addc.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.k5byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 4 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_6_5().disassembly() != 3 {
            return None;
        }
        let Wbbyte_t = if let Some((len, table)) =
            Wbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let k5byte_t = if let Some((len, table)) =
            k5byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbbyte_t,
                Wdbyte_t,
                k5byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1759:1"]
#[derive(Clone, Debug)]
struct instructionVar163 {
    Wb_t: Wb_t,
    Wd_t: Wd_t,
    Ws_t: Ws_t,
}
impl instructionVar163 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("addc.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Wb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Ws_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 4 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        let Wb_t = if let Some((len, table)) =
            Wb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ws_t = if let Some((len, table)) =
            Ws_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wb_t, Wd_t, Ws_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1775:1"]
#[derive(Clone, Debug)]
struct instructionVar164 {
    Wbbyte_t: Wbbyte_t,
    Wdbyte_t: Wdbyte_t,
    Wsbyte_t: Wsbyte_t,
}
impl instructionVar164 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("addc.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wsbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 4 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        let Wbbyte_t = if let Some((len, table)) =
            Wbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsbyte_t = if let Some((len, table)) =
            Wsbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbbyte_t,
                Wdbyte_t,
                Wsbyte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1791:1"]
#[derive(Clone, Debug)]
struct instructionVar165 {
    WREG_t: WREG_t,
    f13_t: f13_t,
}
impl instructionVar165 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("and.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.f13_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREG_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 6 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let WREG_t = if let Some((len, table)) =
            WREG_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13_t = if let Some((len, table)) =
            f13_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WREG_t, f13_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1800:1"]
#[derive(Clone, Debug)]
struct instructionVar166 {
    WREGbyte_t: WREGbyte_t,
    f13byte_t: f13byte_t,
}
impl instructionVar166 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("and.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREGbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 6 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let WREGbyte_t = if let Some((len, table)) =
            WREGbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13byte_t = if let Some((len, table)) =
            f13byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                WREGbyte_t,
                f13byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1809:1"]
#[derive(Clone, Debug)]
struct instructionVar167 {
    k10_t: k10_t,
    Wn_t: Wn_t,
}
impl instructionVar167 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("and.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.k10_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wn_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 2 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let k10_t = if let Some((len, table)) =
            k10_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wn_t = if let Some((len, table)) =
            Wn_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { k10_t, Wn_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1818:1"]
#[derive(Clone, Debug)]
struct instructionVar168 {
    k10byte_t: k10byte_t,
    Wnbyte_t: Wnbyte_t,
}
impl instructionVar168 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("and.b"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.k10byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 2 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let k10byte_t = if let Some((len, table)) =
            k10byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wnbyte_t = if let Some((len, table)) =
            Wnbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                k10byte_t,
                Wnbyte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1827:1"]
#[derive(Clone, Debug)]
struct instructionVar169 {
    Wb_t: Wb_t,
    Wd_t: Wd_t,
    k5_t: k5_t,
}
impl instructionVar169 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("and.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Wb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.k5_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 6 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_6_5().disassembly() != 3 {
            return None;
        }
        let Wb_t = if let Some((len, table)) =
            Wb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let k5_t = if let Some((len, table)) =
            k5_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wb_t, Wd_t, k5_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1837:1"]
#[derive(Clone, Debug)]
struct instructionVar170 {
    Wbbyte_t: Wbbyte_t,
    Wdbyte_t: Wdbyte_t,
    k5byte_t: k5byte_t,
}
impl instructionVar170 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("and.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.k5byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 6 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_6_5().disassembly() != 3 {
            return None;
        }
        let Wbbyte_t = if let Some((len, table)) =
            Wbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let k5byte_t = if let Some((len, table)) =
            k5byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbbyte_t,
                Wdbyte_t,
                k5byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1848:1"]
#[derive(Clone, Debug)]
struct instructionVar171 {
    Wb_t: Wb_t,
    Wd_t: Wd_t,
    Ws_t: Ws_t,
}
impl instructionVar171 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("and.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Wb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Ws_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 6 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        let Wb_t = if let Some((len, table)) =
            Wb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ws_t = if let Some((len, table)) =
            Ws_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wb_t, Wd_t, Ws_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1859:1"]
#[derive(Clone, Debug)]
struct instructionVar172 {
    Wbbyte_t: Wbbyte_t,
    Wdbyte_t: Wdbyte_t,
    Wsbyte_t: Wsbyte_t,
}
impl instructionVar172 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("and.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wsbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 6 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        let Wbbyte_t = if let Some((len, table)) =
            Wbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsbyte_t = if let Some((len, table)) =
            Wsbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbbyte_t,
                Wdbyte_t,
                Wsbyte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1870:1"]
#[derive(Clone, Debug)]
struct instructionVar173 {
    WREG_t: WREG_t,
    f13_t: f13_t,
}
impl instructionVar173 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("asr.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.f13_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREG_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 5 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        let WREG_t = if let Some((len, table)) =
            WREG_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13_t = if let Some((len, table)) =
            f13_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WREG_t, f13_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1881:1"]
#[derive(Clone, Debug)]
struct instructionVar174 {
    WREGbyte_t: WREGbyte_t,
    f13byte_t: f13byte_t,
}
impl instructionVar174 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("asr.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREGbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 5 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        let WREGbyte_t = if let Some((len, table)) =
            WREGbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13byte_t = if let Some((len, table)) =
            f13byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                WREGbyte_t,
                f13byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1949:1"]
#[derive(Clone, Debug)]
struct instructionVar175 {
    Bbit4_t: Bbit4_t,
    Wsb_t: Wsb_t,
}
impl instructionVar175 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("bclr.w"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wsb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Bbit4_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 10 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_11().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_Bb().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_9_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 0 {
            return None;
        }
        let Bbit4_t = if let Some((len, table)) =
            Bbit4_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsb_t = if let Some((len, table)) =
            Wsb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Bbit4_t, Wsb_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1957:1"]
#[derive(Clone, Debug)]
struct instructionVar176 {
    Bbit4_t: Bbit4_t,
    Wsbbyte_t: Wsbbyte_t,
}
impl instructionVar176 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("bclr.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wsbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Bbit4_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 10 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_11().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_Bb().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_9_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 0 {
            return None;
        }
        let Bbit4_t = if let Some((len, table)) =
            Bbit4_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsbbyte_t = if let Some((len, table)) =
            Wsbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Bbit4_t, Wsbbyte_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2104:1"]
#[derive(Clone, Debug)]
struct instructionVar177 {
    Bbit4_t: Bbit4_t,
    Wsb_t: Wsb_t,
}
impl instructionVar177 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("bset.w"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wsb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Bbit4_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 10 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_11().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_Bb().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_9_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 0 {
            return None;
        }
        let Bbit4_t = if let Some((len, table)) =
            Bbit4_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsb_t = if let Some((len, table)) =
            Wsb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Bbit4_t, Wsb_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2112:1"]
#[derive(Clone, Debug)]
struct instructionVar178 {
    Bbit4_t: Bbit4_t,
    Wsbbyte_t: Wsbbyte_t,
}
impl instructionVar178 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("bset.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wsbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Bbit4_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 10 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_11().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_Bb().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_9_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 0 {
            return None;
        }
        let Bbit4_t = if let Some((len, table)) =
            Bbit4_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsbbyte_t = if let Some((len, table)) =
            Wsbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Bbit4_t, Wsbbyte_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2144:1"]
#[derive(Clone, Debug)]
struct instructionVar179 {
    Bbit4_t: Bbit4_t,
    Wsb_t: Wsb_t,
}
impl instructionVar179 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("btg.w"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wsb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Bbit4_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 10 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 2 {
            return None;
        }
        if token_parser.OP_11().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_Bb().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_9_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 0 {
            return None;
        }
        let Bbit4_t = if let Some((len, table)) =
            Bbit4_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsb_t = if let Some((len, table)) =
            Wsb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Bbit4_t, Wsb_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2152:1"]
#[derive(Clone, Debug)]
struct instructionVar180 {
    Bbit4_t: Bbit4_t,
    Wsbbyte_t: Wsbbyte_t,
}
impl instructionVar180 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("btg.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wsbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Bbit4_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 10 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 2 {
            return None;
        }
        if token_parser.OP_11().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_Bb().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_9_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 0 {
            return None;
        }
        let Bbit4_t = if let Some((len, table)) =
            Bbit4_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsbbyte_t = if let Some((len, table)) =
            Wsbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Bbit4_t, Wsbbyte_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2168:1"]
#[derive(Clone, Debug)]
struct instructionVar181 {
    Bbit4_t: Bbit4_t,
    Wsb_t: Wsb_t,
}
impl instructionVar181 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_skipInstr(
            Some(inst_next),
            context.register().read_skipInstr_disassembly(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("btsc.w"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wsb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Bbit4_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 167 {
            return None;
        }
        if token_parser.OP_11_7().disassembly() != 0 {
            return None;
        }
        let tmp = (1u64 as i64);
        context_instance
            .register_mut()
            .write_skipInstr_disassembly(tmp);
        let Bbit4_t = if let Some((len, table)) =
            Bbit4_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsb_t = if let Some((len, table)) =
            Wsb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Bbit4_t, Wsb_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2184:1"]
#[derive(Clone, Debug)]
struct instructionVar182 {
    Bbit4_t: Bbit4_t,
    Wsb_t: Wsb_t,
}
impl instructionVar182 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_skipInstr(
            Some(inst_next),
            context.register().read_skipInstr_disassembly(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("btss.w"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wsb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Bbit4_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 166 {
            return None;
        }
        if token_parser.OP_11_7().disassembly() != 0 {
            return None;
        }
        let tmp = (1u64 as i64);
        context_instance
            .register_mut()
            .write_skipInstr_disassembly(tmp);
        let Bbit4_t = if let Some((len, table)) =
            Bbit4_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsb_t = if let Some((len, table)) =
            Wsb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Bbit4_t, Wsb_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2200:1"]
#[derive(Clone, Debug)]
struct instructionVar183 {
    Bbit4_t: Bbit4_t,
    Wsb_t: Wsb_t,
}
impl instructionVar183 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("btst.c"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wsb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Bbit4_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 163 {
            return None;
        }
        if token_parser.OP_10_7().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_Zb().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_10_8().disassembly() != 0 {
            return None;
        }
        let Bbit4_t = if let Some((len, table)) =
            Bbit4_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsb_t = if let Some((len, table)) =
            Wsb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Bbit4_t, Wsb_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2212:1"]
#[derive(Clone, Debug)]
struct instructionVar184 {
    Bbit4_t: Bbit4_t,
    Wsb_t: Wsb_t,
}
impl instructionVar184 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("btst.z"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wsb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Bbit4_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 10 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 3 {
            return None;
        }
        if token_parser.TOK_Zb().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_10_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 0 {
            return None;
        }
        let Bbit4_t = if let Some((len, table)) =
            Bbit4_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsb_t = if let Some((len, table)) =
            Wsb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Bbit4_t, Wsb_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2250:1"]
#[derive(Clone, Debug)]
struct instructionVar185 {
    Bbit4_t: Bbit4_t,
    Wsb_t: Wsb_t,
}
impl instructionVar185 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("btsts.c"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wsb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Bbit4_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 10 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 4 {
            return None;
        }
        if token_parser.TOK_Zb().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_10_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 0 {
            return None;
        }
        let Bbit4_t = if let Some((len, table)) =
            Bbit4_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsb_t = if let Some((len, table)) =
            Wsb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Bbit4_t, Wsb_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2263:1"]
#[derive(Clone, Debug)]
struct instructionVar186 {
    Bbit4_t: Bbit4_t,
    Wsb_t: Wsb_t,
}
impl instructionVar186 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("btsts.z"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wsb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Bbit4_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 10 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 4 {
            return None;
        }
        if token_parser.TOK_Zb().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_10_8().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 0 {
            return None;
        }
        let Bbit4_t = if let Some((len, table)) =
            Bbit4_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsb_t = if let Some((len, table)) =
            Wsb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Bbit4_t, Wsb_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2333:1"]
#[derive(Clone, Debug)]
struct instructionVar187 {
    f13b_t: f13b_t,
}
impl instructionVar187 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("clr.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.f13b_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 15 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let f13b_t = if let Some((len, table)) =
            f13b_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { f13b_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2339:1"]
#[derive(Clone, Debug)]
struct instructionVar188 {
    WREGb_t: WREGb_t,
}
impl instructionVar188 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("clr.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.WREGb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 15 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let WREGb_t = if let Some((len, table)) =
            WREGb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WREGb_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2345:1"]
#[derive(Clone, Debug)]
struct instructionVar189 {
    f13bbyte_t: f13bbyte_t,
}
impl instructionVar189 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("clr.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13bbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 15 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let f13bbyte_t = if let Some((len, table)) =
            f13bbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { f13bbyte_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2351:1"]
#[derive(Clone, Debug)]
struct instructionVar190 {
    WREGbbyte_t: WREGbbyte_t,
}
impl instructionVar190 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("clr.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.WREGbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 15 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let WREGbbyte_t = if let Some((len, table)) = WREGbbyte_t::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WREGbbyte_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2789:1"]
#[derive(Clone, Debug)]
struct instructionVar191 {
    WREG_t: WREG_t,
    f13_t: f13_t,
}
impl instructionVar191 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("com.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.f13_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREG_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        let WREG_t = if let Some((len, table)) =
            WREG_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13_t = if let Some((len, table)) =
            f13_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WREG_t, f13_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2797:1"]
#[derive(Clone, Debug)]
struct instructionVar192 {
    WREGbyte_t: WREGbyte_t,
    f13byte_t: f13byte_t,
}
impl instructionVar192 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("com.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREGbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        let WREGbyte_t = if let Some((len, table)) =
            WREGbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13byte_t = if let Some((len, table)) =
            f13byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                WREGbyte_t,
                f13byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3323:1"]
#[derive(Clone, Debug)]
struct instructionVar193 {
    WREG_t: WREG_t,
    f13_t: f13_t,
}
impl instructionVar193 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("dec.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.f13_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.WREG_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let WREG_t = if let Some((len, table)) =
            WREG_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13_t = if let Some((len, table)) =
            f13_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WREG_t, f13_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3337:1"]
#[derive(Clone, Debug)]
struct instructionVar194 {
    WREGbyte_t: WREGbyte_t,
    f13byte_t: f13byte_t,
}
impl instructionVar194 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("dec.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREGbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let WREGbyte_t = if let Some((len, table)) =
            WREGbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13byte_t = if let Some((len, table)) =
            f13byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                WREGbyte_t,
                f13byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3383:1"]
#[derive(Clone, Debug)]
struct instructionVar195 {
    WREG_t: WREG_t,
    f13_t: f13_t,
}
impl instructionVar195 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("dec2.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.f13_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREG_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        let WREG_t = if let Some((len, table)) =
            WREG_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13_t = if let Some((len, table)) =
            f13_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WREG_t, f13_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3397:1"]
#[derive(Clone, Debug)]
struct instructionVar196 {
    WREGbyte_t: WREGbyte_t,
    f13byte_t: f13byte_t,
}
impl instructionVar196 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("dec2.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREGbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        let WREGbyte_t = if let Some((len, table)) =
            WREGbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13byte_t = if let Some((len, table)) =
            f13byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                WREGbyte_t,
                f13byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:4025:1"]
#[derive(Clone, Debug)]
struct instructionVar197 {
    WREG_t: WREG_t,
    f13_t: f13_t,
}
impl instructionVar197 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("inc.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.f13_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREG_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 12 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let WREG_t = if let Some((len, table)) =
            WREG_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13_t = if let Some((len, table)) =
            f13_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WREG_t, f13_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:4039:1"]
#[derive(Clone, Debug)]
struct instructionVar198 {
    WREGbyte_t: WREGbyte_t,
    f13byte_t: f13byte_t,
}
impl instructionVar198 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("inc.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREGbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 14 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 12 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let WREGbyte_t = if let Some((len, table)) =
            WREGbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13byte_t = if let Some((len, table)) =
            f13byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                WREGbyte_t,
                f13byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:4084:1"]
#[derive(Clone, Debug)]
struct instructionVar199 {
    WREG_t: WREG_t,
    f13_t: f13_t,
}
impl instructionVar199 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("inc2.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.f13_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREG_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 236 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        let WREG_t = if let Some((len, table)) =
            WREG_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13_t = if let Some((len, table)) =
            f13_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WREG_t, f13_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:4098:1"]
#[derive(Clone, Debug)]
struct instructionVar200 {
    WREGbyte_t: WREGbyte_t,
    f13byte_t: f13byte_t,
}
impl instructionVar200 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("inc2.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREGbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 236 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        let WREGbyte_t = if let Some((len, table)) =
            WREGbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13byte_t = if let Some((len, table)) =
            f13byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                WREGbyte_t,
                f13byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:4143:1"]
#[derive(Clone, Debug)]
struct instructionVar201 {
    WREG_t: WREG_t,
    f13_t: f13_t,
}
impl instructionVar201 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ior.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.f13_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREG_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 7 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let WREG_t = if let Some((len, table)) =
            WREG_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13_t = if let Some((len, table)) =
            f13_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WREG_t, f13_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:4152:1"]
#[derive(Clone, Debug)]
struct instructionVar202 {
    WREGbyte_t: WREGbyte_t,
    f13byte_t: f13byte_t,
}
impl instructionVar202 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ior.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREGbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 7 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let WREGbyte_t = if let Some((len, table)) =
            WREGbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13byte_t = if let Some((len, table)) =
            f13byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                WREGbyte_t,
                f13byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:4161:1"]
#[derive(Clone, Debug)]
struct instructionVar203 {
    k10_t: k10_t,
    Wn_t: Wn_t,
}
impl instructionVar203 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ior.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.k10_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wn_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 3 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let k10_t = if let Some((len, table)) =
            k10_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wn_t = if let Some((len, table)) =
            Wn_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { k10_t, Wn_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:4170:1"]
#[derive(Clone, Debug)]
struct instructionVar204 {
    k10byte_t: k10byte_t,
    Wnbyte_t: Wnbyte_t,
}
impl instructionVar204 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ior.b"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.k10byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 3 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let k10byte_t = if let Some((len, table)) =
            k10byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wnbyte_t = if let Some((len, table)) =
            Wnbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                k10byte_t,
                Wnbyte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:4300:1"]
#[derive(Clone, Debug)]
struct instructionVar205 {
    WREG_t: WREG_t,
    f13_t: f13_t,
}
impl instructionVar205 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("lsr.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.f13_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREG_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 5 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let WREG_t = if let Some((len, table)) =
            WREG_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13_t = if let Some((len, table)) =
            f13_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WREG_t, f13_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:4312:1"]
#[derive(Clone, Debug)]
struct instructionVar206 {
    WREGbyte_t: WREGbyte_t,
    f13byte_t: f13byte_t,
}
impl instructionVar206 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("lsr.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREGbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 5 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let WREGbyte_t = if let Some((len, table)) =
            WREGbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13byte_t = if let Some((len, table)) =
            f13byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                WREGbyte_t,
                f13byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:5086:1"]
#[derive(Clone, Debug)]
struct instructionVar207 {
    WREG_t: WREG_t,
    f13_t: f13_t,
}
impl instructionVar207 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("mov.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.f13_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREG_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 15 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        let WREG_t = if let Some((len, table)) =
            WREG_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13_t = if let Some((len, table)) =
            f13_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WREG_t, f13_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:5095:1"]
#[derive(Clone, Debug)]
struct instructionVar208 {
    WREGbyte_t: WREGbyte_t,
    f13byte_t: f13byte_t,
}
impl instructionVar208 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("mov.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREGbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 15 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        let WREGbyte_t = if let Some((len, table)) =
            WREGbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13byte_t = if let Some((len, table)) =
            f13byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                WREGbyte_t,
                f13byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6739:1"]
#[derive(Clone, Debug)]
struct instructionVar209 {
    f15_t: f15_t,
}
impl instructionVar209 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("pop"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.f15_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 15 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 9 {
            return None;
        }
        if token_parser.OP_0().disassembly() != 0 {
            return None;
        }
        let f15_t = if let Some((len, table)) =
            f15_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { f15_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6777:1"]
#[derive(Clone, Debug)]
struct instructionVar210 {
    f15_t: f15_t,
}
impl instructionVar210 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("push"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f15_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 15 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 8 {
            return None;
        }
        if token_parser.OP_0().disassembly() != 0 {
            return None;
        }
        let f15_t = if let Some((len, table)) =
            f15_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { f15_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6872:1"]
#[derive(Clone, Debug)]
struct instructionVar211 {
    k15_t: k15_t,
}
impl instructionVar211 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_repeatInstr(
            Some(inst_next),
            context.register().read_repeatInstr_disassembly(),
        );
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("repeat"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.k15_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 9 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let tmp = (1u64 as i64);
        context_instance
            .register_mut()
            .write_repeatInstr_disassembly(tmp);
        let k15_t = if let Some((len, table)) =
            k15_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { k15_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6971:1"]
#[derive(Clone, Debug)]
struct instructionVar212 {
    k10_t: k10_t,
    Wn_t: Wn_t,
}
impl instructionVar212 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("retlw.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.k10_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wn_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 5 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let k10_t = if let Some((len, table)) =
            k10_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wn_t = if let Some((len, table)) =
            Wn_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { k10_t, Wn_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6983:1"]
#[derive(Clone, Debug)]
struct instructionVar213 {
    k10byte_t: k10byte_t,
    Wnbyte_t: Wnbyte_t,
}
impl instructionVar213 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("retlw.b"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.k10byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 5 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let k10byte_t = if let Some((len, table)) =
            k10byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wnbyte_t = if let Some((len, table)) =
            Wnbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                k10byte_t,
                Wnbyte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7016:1"]
#[derive(Clone, Debug)]
struct instructionVar214 {
    WREG_t: WREG_t,
    f13_t: f13_t,
}
impl instructionVar214 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("rlc.w"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREG_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 214 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        let WREG_t = if let Some((len, table)) =
            WREG_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13_t = if let Some((len, table)) =
            f13_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WREG_t, f13_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7025:1"]
#[derive(Clone, Debug)]
struct instructionVar215 {
    WREGbyte_t: WREGbyte_t,
    f13byte_t: f13byte_t,
}
impl instructionVar215 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("rlc.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREGbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 214 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        let WREGbyte_t = if let Some((len, table)) =
            WREGbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13byte_t = if let Some((len, table)) =
            f13byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                WREGbyte_t,
                f13byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7061:1"]
#[derive(Clone, Debug)]
struct instructionVar216 {
    WREG_t: WREG_t,
    f13_t: f13_t,
}
impl instructionVar216 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("rlnc.w"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREG_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 214 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let WREG_t = if let Some((len, table)) =
            WREG_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13_t = if let Some((len, table)) =
            f13_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WREG_t, f13_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7068:1"]
#[derive(Clone, Debug)]
struct instructionVar217 {
    WREGbyte_t: WREGbyte_t,
    f13byte_t: f13byte_t,
}
impl instructionVar217 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("rlnc.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREGbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 214 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let WREGbyte_t = if let Some((len, table)) =
            WREGbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13byte_t = if let Some((len, table)) =
            f13byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                WREGbyte_t,
                f13byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7100:1"]
#[derive(Clone, Debug)]
struct instructionVar218 {
    WREG_t: WREG_t,
    f13_t: f13_t,
}
impl instructionVar218 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("rrc.w"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREG_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 215 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        let WREG_t = if let Some((len, table)) =
            WREG_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13_t = if let Some((len, table)) =
            f13_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WREG_t, f13_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7110:1"]
#[derive(Clone, Debug)]
struct instructionVar219 {
    WREGbyte_t: WREGbyte_t,
    f13byte_t: f13byte_t,
}
impl instructionVar219 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("rrc.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREGbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 215 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        let WREGbyte_t = if let Some((len, table)) =
            WREGbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13byte_t = if let Some((len, table)) =
            f13byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                WREGbyte_t,
                f13byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7242:1"]
#[derive(Clone, Debug)]
struct instructionVar220 {
    WREG_t: WREG_t,
    f13_t: f13_t,
}
impl instructionVar220 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("setm.w"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREG_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 239 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        let WREG_t = if let Some((len, table)) =
            WREG_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13_t = if let Some((len, table)) =
            f13_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WREG_t, f13_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7247:1"]
#[derive(Clone, Debug)]
struct instructionVar221 {
    WREGbyte_t: WREGbyte_t,
    f13byte_t: f13byte_t,
}
impl instructionVar221 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("setm.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREGbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 239 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        let WREGbyte_t = if let Some((len, table)) =
            WREGbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13byte_t = if let Some((len, table)) =
            f13byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                WREGbyte_t,
                f13byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7307:1"]
#[derive(Clone, Debug)]
struct instructionVar222 {
    WREG_t: WREG_t,
    f13_t: f13_t,
}
impl instructionVar222 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("sl.w"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREG_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 4 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let WREG_t = if let Some((len, table)) =
            WREG_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13_t = if let Some((len, table)) =
            f13_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WREG_t, f13_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7317:1"]
#[derive(Clone, Debug)]
struct instructionVar223 {
    WREGbyte_t: WREGbyte_t,
    f13byte_t: f13byte_t,
}
impl instructionVar223 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("sl.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREGbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 4 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let WREGbyte_t = if let Some((len, table)) =
            WREGbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13byte_t = if let Some((len, table)) =
            f13byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                WREGbyte_t,
                f13byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7374:1"]
#[derive(Clone, Debug)]
struct instructionVar224 {
    WREG_t: WREG_t,
    f13_t: f13_t,
}
impl instructionVar224 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("sub.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.f13_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREG_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 5 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let WREG_t = if let Some((len, table)) =
            WREG_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13_t = if let Some((len, table)) =
            f13_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WREG_t, f13_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7387:1"]
#[derive(Clone, Debug)]
struct instructionVar225 {
    WREGbyte_t: WREGbyte_t,
    f13byte_t: f13byte_t,
}
impl instructionVar225 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("sub.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREGbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 5 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let WREGbyte_t = if let Some((len, table)) =
            WREGbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13byte_t = if let Some((len, table)) =
            f13byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                WREGbyte_t,
                f13byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7400:1"]
#[derive(Clone, Debug)]
struct instructionVar226 {
    k10_t: k10_t,
    Wn_t: Wn_t,
}
impl instructionVar226 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("sub.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.k10_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wn_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let k10_t = if let Some((len, table)) =
            k10_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wn_t = if let Some((len, table)) =
            Wn_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { k10_t, Wn_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7412:1"]
#[derive(Clone, Debug)]
struct instructionVar227 {
    k10byte_t: k10byte_t,
    Wnbyte_t: Wnbyte_t,
}
impl instructionVar227 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("sub.b"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.k10byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let k10byte_t = if let Some((len, table)) =
            k10byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wnbyte_t = if let Some((len, table)) =
            Wnbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                k10byte_t,
                Wnbyte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7502:1"]
#[derive(Clone, Debug)]
struct instructionVar228 {
    WREG_t: WREG_t,
    f13_t: f13_t,
}
impl instructionVar228 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("subb.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.f13_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREG_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 5 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        let WREG_t = if let Some((len, table)) =
            WREG_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13_t = if let Some((len, table)) =
            f13_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WREG_t, f13_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7514:1"]
#[derive(Clone, Debug)]
struct instructionVar229 {
    WREGbyte_t: WREGbyte_t,
    f13byte_t: f13byte_t,
}
impl instructionVar229 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("subb.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREGbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 5 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        let WREGbyte_t = if let Some((len, table)) =
            WREGbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13byte_t = if let Some((len, table)) =
            f13byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                WREGbyte_t,
                f13byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7527:1"]
#[derive(Clone, Debug)]
struct instructionVar230 {
    k10_t: k10_t,
    Wn_t: Wn_t,
}
impl instructionVar230 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("subb.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.k10_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wn_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        let k10_t = if let Some((len, table)) =
            k10_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wn_t = if let Some((len, table)) =
            Wn_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { k10_t, Wn_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7540:1"]
#[derive(Clone, Debug)]
struct instructionVar231 {
    k10byte_t: k10byte_t,
    Wnbyte_t: Wnbyte_t,
}
impl instructionVar231 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("subb.b"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.k10byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        let k10byte_t = if let Some((len, table)) =
            k10byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wnbyte_t = if let Some((len, table)) =
            Wnbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                k10byte_t,
                Wnbyte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7615:1"]
#[derive(Clone, Debug)]
struct instructionVar232 {
    WREG_t: WREG_t,
    f13_t: f13_t,
}
impl instructionVar232 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("subbr.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.f13_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREG_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        let WREG_t = if let Some((len, table)) =
            WREG_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13_t = if let Some((len, table)) =
            f13_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WREG_t, f13_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7628:1"]
#[derive(Clone, Debug)]
struct instructionVar233 {
    WREGbyte_t: WREGbyte_t,
    f13byte_t: f13byte_t,
}
impl instructionVar233 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("subbr.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREGbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        let WREGbyte_t = if let Some((len, table)) =
            WREGbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13byte_t = if let Some((len, table)) =
            f13byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                WREGbyte_t,
                f13byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7705:1"]
#[derive(Clone, Debug)]
struct instructionVar234 {
    WREG_t: WREG_t,
    f13_t: f13_t,
}
impl instructionVar234 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("subr.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.f13_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREG_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let WREG_t = if let Some((len, table)) =
            WREG_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13_t = if let Some((len, table)) =
            f13_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WREG_t, f13_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7718:1"]
#[derive(Clone, Debug)]
struct instructionVar235 {
    WREGbyte_t: WREGbyte_t,
    f13byte_t: f13byte_t,
}
impl instructionVar235 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("subr.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREGbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        let WREGbyte_t = if let Some((len, table)) =
            WREGbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13byte_t = if let Some((len, table)) =
            f13byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                WREGbyte_t,
                f13byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7943:1"]
#[derive(Clone, Debug)]
struct instructionVar236 {
    WREG_t: WREG_t,
    f13_t: f13_t,
}
impl instructionVar236 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("xor.w"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREG_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 6 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        let WREG_t = if let Some((len, table)) =
            WREG_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13_t = if let Some((len, table)) =
            f13_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WREG_t, f13_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7950:1"]
#[derive(Clone, Debug)]
struct instructionVar237 {
    WREGbyte_t: WREGbyte_t,
    f13byte_t: f13byte_t,
}
impl instructionVar237 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("xor.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f13byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.WREGbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 6 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        let WREGbyte_t = if let Some((len, table)) =
            WREGbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f13byte_t = if let Some((len, table)) =
            f13byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                WREGbyte_t,
                f13byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7958:1"]
#[derive(Clone, Debug)]
struct instructionVar238 {
    k10_t: k10_t,
    Wn_t: Wn_t,
}
impl instructionVar238 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("xor.w"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.k10_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wn_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 2 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        let k10_t = if let Some((len, table)) =
            k10_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wn_t = if let Some((len, table)) =
            Wn_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { k10_t, Wn_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7965:1"]
#[derive(Clone, Debug)]
struct instructionVar239 {
    k10byte_t: k10byte_t,
    Wnbyte_t: Wnbyte_t,
}
impl instructionVar239 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("xor.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.k10byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 11 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 2 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        let k10byte_t = if let Some((len, table)) =
            k10byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wnbyte_t = if let Some((len, table)) =
            Wnbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                k10byte_t,
                Wnbyte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1941:1"]
#[derive(Clone, Debug)]
struct instructionVar240 {
    bit4_t: bit4_t,
    f12_t: f12_t,
}
impl instructionVar240 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("bclr.w"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.f12_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.bit4_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 10 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 9 {
            return None;
        }
        let bit4_t = if let Some((len, table)) =
            bit4_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f12_t = if let Some((len, table)) =
            f12_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { bit4_t, f12_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2019:1"]
#[derive(Clone, Debug)]
struct instructionVar241 {
    n16_t: n16_t,
}
impl instructionVar241 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("bra"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.n16_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 3 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 7 {
            return None;
        }
        let n16_t = if let Some((len, table)) =
            n16_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { n16_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2097:1"]
#[derive(Clone, Debug)]
struct instructionVar242 {
    bit4byte_t: bit4byte_t,
    bit4_t: bit4_t,
    f12_t: f12_t,
}
impl instructionVar242 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("bset.w"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.f12_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.bit4_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 10 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 8 {
            return None;
        }
        let bit4byte_t = if let Some((len, table)) =
            bit4byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let bit4_t = if let Some((len, table)) =
            bit4_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f12_t = if let Some((len, table)) =
            f12_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bit4byte_t,
                bit4_t,
                f12_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2136:1"]
#[derive(Clone, Debug)]
struct instructionVar243 {
    bit4byte_t: bit4byte_t,
    bit4_t: bit4_t,
    f12_t: f12_t,
}
impl instructionVar243 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("btg")];
        display.extend_from_slice(&extend);
        self.bit4byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("  ")];
        display.extend_from_slice(&extend);
        self.f12_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.bit4_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 10 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 10 {
            return None;
        }
        let bit4byte_t = if let Some((len, table)) =
            bit4byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let bit4_t = if let Some((len, table)) =
            bit4_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f12_t = if let Some((len, table)) =
            f12_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bit4byte_t,
                bit4_t,
                f12_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2160:1"]
#[derive(Clone, Debug)]
struct instructionVar244 {
    bit4byte_t: bit4byte_t,
    bit4_t: bit4_t,
    f12_t: f12_t,
}
impl instructionVar244 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_skipInstr(
            Some(inst_next),
            context.register().read_skipInstr_disassembly(),
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("btsc")];
        display.extend_from_slice(&extend);
        self.bit4byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("  ")];
        display.extend_from_slice(&extend);
        self.f12_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.bit4_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 10 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 15 {
            return None;
        }
        let tmp = (1u64 as i64);
        context_instance
            .register_mut()
            .write_skipInstr_disassembly(tmp);
        let bit4byte_t = if let Some((len, table)) =
            bit4byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let bit4_t = if let Some((len, table)) =
            bit4_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f12_t = if let Some((len, table)) =
            f12_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bit4byte_t,
                bit4_t,
                f12_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2176:1"]
#[derive(Clone, Debug)]
struct instructionVar245 {
    bit4byte_t: bit4byte_t,
    bit4_t: bit4_t,
    f12_t: f12_t,
}
impl instructionVar245 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_skipInstr(
            Some(inst_next),
            context.register().read_skipInstr_disassembly(),
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("btss")];
        display.extend_from_slice(&extend);
        self.bit4byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("  ")];
        display.extend_from_slice(&extend);
        self.f12_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.bit4_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 10 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 14 {
            return None;
        }
        let tmp = (1u64 as i64);
        context_instance
            .register_mut()
            .write_skipInstr_disassembly(tmp);
        let bit4byte_t = if let Some((len, table)) =
            bit4byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let bit4_t = if let Some((len, table)) =
            bit4_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f12_t = if let Some((len, table)) =
            f12_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bit4byte_t,
                bit4_t,
                f12_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2192:1"]
#[derive(Clone, Debug)]
struct instructionVar246 {
    bit4byte_t: bit4byte_t,
    bit4_t: bit4_t,
    f12_t: f12_t,
}
impl instructionVar246 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("btst.w"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.f12_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.bit4_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 10 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 11 {
            return None;
        }
        let bit4byte_t = if let Some((len, table)) =
            bit4byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let bit4_t = if let Some((len, table)) =
            bit4_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f12_t = if let Some((len, table)) =
            f12_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bit4byte_t,
                bit4_t,
                f12_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2237:1"]
#[derive(Clone, Debug)]
struct instructionVar247 {
    bit4byte_t: bit4byte_t,
    bit4_t: bit4_t,
    f12_t: f12_t,
}
impl instructionVar247 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("btsts")];
        display.extend_from_slice(&extend);
        self.bit4byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("  ")];
        display.extend_from_slice(&extend);
        self.f12_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.bit4_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 10 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 12 {
            return None;
        }
        let bit4byte_t = if let Some((len, table)) =
            bit4byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let bit4_t = if let Some((len, table)) =
            bit4_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let f12_t = if let Some((len, table)) =
            f12_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bit4byte_t,
                bit4_t,
                f12_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:4179:1"]
#[derive(Clone, Debug)]
struct instructionVar248 {
    Wb_t: Wb_t,
    Wd_t: Wd_t,
    k5_t: k5_t,
}
impl instructionVar248 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ior.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Wb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.k5_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 7 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_6_5().disassembly() != 3 {
            return None;
        }
        let Wb_t = if let Some((len, table)) =
            Wb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let k5_t = if let Some((len, table)) =
            k5_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wb_t, Wd_t, k5_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:4190:1"]
#[derive(Clone, Debug)]
struct instructionVar249 {
    Wbbyte_t: Wbbyte_t,
    Wdbyte_t: Wdbyte_t,
    k5byte_t: k5byte_t,
}
impl instructionVar249 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ior.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.k5byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 7 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_6_5().disassembly() != 3 {
            return None;
        }
        let Wbbyte_t = if let Some((len, table)) =
            Wbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let k5byte_t = if let Some((len, table)) =
            k5byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbbyte_t,
                Wdbyte_t,
                k5byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:4202:1"]
#[derive(Clone, Debug)]
struct instructionVar250 {
    Wb_t: Wb_t,
    Wd_t: Wd_t,
    Ws_t: Ws_t,
}
impl instructionVar250 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ior.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Wb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Ws_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 7 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        let Wb_t = if let Some((len, table)) =
            Wb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ws_t = if let Some((len, table)) =
            Ws_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wb_t, Wd_t, Ws_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:4212:1"]
#[derive(Clone, Debug)]
struct instructionVar251 {
    Wbbyte_t: Wbbyte_t,
    Wdbyte_t: Wdbyte_t,
    Wsbyte_t: Wsbyte_t,
}
impl instructionVar251 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("ior.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wsbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 7 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        let Wbbyte_t = if let Some((len, table)) =
            Wbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsbyte_t = if let Some((len, table)) =
            Wsbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbbyte_t,
                Wdbyte_t,
                Wsbyte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:5140:1"]
#[derive(Clone, Debug)]
struct instructionVar252 {
    WsSlit10_t: WsSlit10_t,
    Wnda_t: Wnda_t,
}
impl instructionVar252 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("mov.w"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.WsSlit10_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wnda_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 9 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        let WsSlit10_t = if let Some((len, table)) =
            WsSlit10_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wnda_t = if let Some((len, table)) =
            Wnda_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WsSlit10_t, Wnda_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:5145:1"]
#[derive(Clone, Debug)]
struct instructionVar253 {
    WsSlit10byte_t: WsSlit10byte_t,
    Wndabyte_t: Wndabyte_t,
}
impl instructionVar253 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("mov.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.WsSlit10byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wndabyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 9 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        let WsSlit10byte_t = if let Some((len, table)) = WsSlit10byte_t::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wndabyte_t = if let Some((len, table)) =
            Wndabyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                WsSlit10byte_t,
                Wndabyte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:5151:1"]
#[derive(Clone, Debug)]
struct instructionVar254 {
    WdSlit10_t: WdSlit10_t,
    Wn_t: Wn_t,
}
impl instructionVar254 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("mov.w"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Wn_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.WdSlit10_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 9 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        let WdSlit10_t = if let Some((len, table)) =
            WdSlit10_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wn_t = if let Some((len, table)) =
            Wn_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { WdSlit10_t, Wn_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:5156:1"]
#[derive(Clone, Debug)]
struct instructionVar255 {
    WdSlit10byte_t: WdSlit10byte_t,
    Wnbyte_t: Wnbyte_t,
}
impl instructionVar255 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("mov.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Wnbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.WdSlit10byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 9 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        let WdSlit10byte_t = if let Some((len, table)) = WdSlit10byte_t::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wnbyte_t = if let Some((len, table)) =
            Wnbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                WdSlit10byte_t,
                Wnbyte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:5162:1"]
#[derive(Clone, Debug)]
struct instructionVar256 {
    movWd: movWd,
    movWs: movWs,
}
impl instructionVar256 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("mov.w"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.movWs.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.movWd.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 7 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        let movWd = if let Some((len, table)) =
            movWd::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let movWs = if let Some((len, table)) =
            movWs::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { movWd, movWs }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:5170:1"]
#[derive(Clone, Debug)]
struct instructionVar257 {
    movWdbyte: movWdbyte,
    movWsbyte: movWsbyte,
}
impl instructionVar257 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("mov.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.movWsbyte.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.movWdbyte.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 7 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        let movWdbyte = if let Some((len, table)) =
            movWdbyte::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let movWsbyte = if let Some((len, table)) =
            movWsbyte::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                movWdbyte,
                movWsbyte,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6728:1"]
#[derive(Clone, Debug)]
struct instructionVar258 {}
impl instructionVar258 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("nop")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 0 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6734:1"]
#[derive(Clone, Debug)]
struct instructionVar259 {}
impl instructionVar259 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("nopr")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_16().disassembly() != 255 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:6831:1"]
#[derive(Clone, Debug)]
struct instructionVar260 {
    n16_t: n16_t,
    WordInstNext4: WordInstNext4,
}
impl instructionVar260 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("rcall"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.n16_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 7 {
            return None;
        }
        let n16_t = if let Some((len, table)) =
            n16_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let WordInstNext4 = if let Some((len, table)) = WordInstNext4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                n16_t,
                WordInstNext4,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7424:1"]
#[derive(Clone, Debug)]
struct instructionVar261 {
    Wb_t: Wb_t,
    Wd_t: Wd_t,
    k5_t: k5_t,
}
impl instructionVar261 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("sub.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Wb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.k5_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 5 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_6_5().disassembly() != 3 {
            return None;
        }
        let Wb_t = if let Some((len, table)) =
            Wb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let k5_t = if let Some((len, table)) =
            k5_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wb_t, Wd_t, k5_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7438:1"]
#[derive(Clone, Debug)]
struct instructionVar262 {
    Wbbyte_t: Wbbyte_t,
    Wdbyte_t: Wdbyte_t,
    k5byte_t: k5byte_t,
}
impl instructionVar262 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("sub.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.k5byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 5 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_6_5().disassembly() != 3 {
            return None;
        }
        let Wbbyte_t = if let Some((len, table)) =
            Wbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let k5byte_t = if let Some((len, table)) =
            k5byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbbyte_t,
                Wdbyte_t,
                k5byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7453:1"]
#[derive(Clone, Debug)]
struct instructionVar263 {
    Wb_t: Wb_t,
    Wd_t: Wd_t,
    Ws_t: Ws_t,
}
impl instructionVar263 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("sub.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Wb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Ws_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 5 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        let Wb_t = if let Some((len, table)) =
            Wb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ws_t = if let Some((len, table)) =
            Ws_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wb_t, Wd_t, Ws_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7468:1"]
#[derive(Clone, Debug)]
struct instructionVar264 {
    Wbbyte_t: Wbbyte_t,
    Wdbyte_t: Wdbyte_t,
    Wsbyte_t: Wsbyte_t,
}
impl instructionVar264 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("sub.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wsbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 5 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        let Wbbyte_t = if let Some((len, table)) =
            Wbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsbyte_t = if let Some((len, table)) =
            Wsbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbbyte_t,
                Wdbyte_t,
                Wsbyte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7553:1"]
#[derive(Clone, Debug)]
struct instructionVar265 {
    Wb_t: Wb_t,
    Wd_t: Wd_t,
    k5_t: k5_t,
}
impl instructionVar265 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("subb.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Wb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.k5_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 5 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_6_5().disassembly() != 3 {
            return None;
        }
        let Wb_t = if let Some((len, table)) =
            Wb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let k5_t = if let Some((len, table)) =
            k5_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wb_t, Wd_t, k5_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7567:1"]
#[derive(Clone, Debug)]
struct instructionVar266 {
    Wbbyte_t: Wbbyte_t,
    Wdbyte_t: Wdbyte_t,
    k5byte_t: k5byte_t,
}
impl instructionVar266 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("subb.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.k5byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 5 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_6_5().disassembly() != 3 {
            return None;
        }
        let Wbbyte_t = if let Some((len, table)) =
            Wbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let k5byte_t = if let Some((len, table)) =
            k5byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbbyte_t,
                Wdbyte_t,
                k5byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7583:1"]
#[derive(Clone, Debug)]
struct instructionVar267 {
    Wb_t: Wb_t,
    Wd_t: Wd_t,
    Ws_t: Ws_t,
}
impl instructionVar267 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("subb.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Wb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Ws_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 5 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        let Wb_t = if let Some((len, table)) =
            Wb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ws_t = if let Some((len, table)) =
            Ws_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wb_t, Wd_t, Ws_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7599:1"]
#[derive(Clone, Debug)]
struct instructionVar268 {
    Wbbyte_t: Wbbyte_t,
    Wdbyte_t: Wdbyte_t,
    Wsbyte_t: Wsbyte_t,
}
impl instructionVar268 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("subb.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wsbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 5 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        let Wbbyte_t = if let Some((len, table)) =
            Wbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsbyte_t = if let Some((len, table)) =
            Wsbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbbyte_t,
                Wdbyte_t,
                Wsbyte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7642:1"]
#[derive(Clone, Debug)]
struct instructionVar269 {
    Wb_t: Wb_t,
    Wd_t: Wd_t,
    k5_t: k5_t,
}
impl instructionVar269 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("subbr.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Wb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.k5_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_6_5().disassembly() != 3 {
            return None;
        }
        let Wb_t = if let Some((len, table)) =
            Wb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let k5_t = if let Some((len, table)) =
            k5_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wb_t, Wd_t, k5_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7657:1"]
#[derive(Clone, Debug)]
struct instructionVar270 {
    Wbbyte_t: Wbbyte_t,
    Wdbyte_t: Wdbyte_t,
    k5byte_t: k5byte_t,
}
impl instructionVar270 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("subbr.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.k5byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_6_5().disassembly() != 3 {
            return None;
        }
        let Wbbyte_t = if let Some((len, table)) =
            Wbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let k5byte_t = if let Some((len, table)) =
            k5byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbbyte_t,
                Wdbyte_t,
                k5byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7673:1"]
#[derive(Clone, Debug)]
struct instructionVar271 {
    Wb_t: Wb_t,
    Wd_t: Wd_t,
    Ws_t: Ws_t,
}
impl instructionVar271 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("subbr.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Wb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Ws_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        let Wb_t = if let Some((len, table)) =
            Wb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ws_t = if let Some((len, table)) =
            Ws_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wb_t, Wd_t, Ws_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7689:1"]
#[derive(Clone, Debug)]
struct instructionVar272 {
    Wbbyte_t: Wbbyte_t,
    Wdbyte_t: Wdbyte_t,
    Wsbyte_t: Wsbyte_t,
}
impl instructionVar272 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("subbr.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wsbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        let Wbbyte_t = if let Some((len, table)) =
            Wbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsbyte_t = if let Some((len, table)) =
            Wsbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbbyte_t,
                Wdbyte_t,
                Wsbyte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7731:1"]
#[derive(Clone, Debug)]
struct instructionVar273 {
    Wb_t: Wb_t,
    Wd_t: Wd_t,
    k5_t: k5_t,
}
impl instructionVar273 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("subr.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Wb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.k5_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_6_5().disassembly() != 3 {
            return None;
        }
        let Wb_t = if let Some((len, table)) =
            Wb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let k5_t = if let Some((len, table)) =
            k5_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wb_t, Wd_t, k5_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7745:1"]
#[derive(Clone, Debug)]
struct instructionVar274 {
    Wbbyte_t: Wbbyte_t,
    Wdbyte_t: Wdbyte_t,
    k5byte_t: k5byte_t,
}
impl instructionVar274 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("subr.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.k5byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_6_5().disassembly() != 3 {
            return None;
        }
        let Wbbyte_t = if let Some((len, table)) =
            Wbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let k5byte_t = if let Some((len, table)) =
            k5byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbbyte_t,
                Wdbyte_t,
                k5byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7760:1"]
#[derive(Clone, Debug)]
struct instructionVar275 {
    Wb_t: Wb_t,
    Wd_t: Wd_t,
    Ws_t: Ws_t,
}
impl instructionVar275 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("subr.w"),
            DisplayElement::Literal("   "),
        ];
        display.extend_from_slice(&extend);
        self.Wb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Ws_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        let Wb_t = if let Some((len, table)) =
            Wb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ws_t = if let Some((len, table)) =
            Ws_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wb_t, Wd_t, Ws_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7775:1"]
#[derive(Clone, Debug)]
struct instructionVar276 {
    Wbbyte_t: Wbbyte_t,
    Wdbyte_t: Wdbyte_t,
    Wsbyte_t: Wsbyte_t,
}
impl instructionVar276 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("subr.b"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wsbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        let Wbbyte_t = if let Some((len, table)) =
            Wbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsbyte_t = if let Some((len, table)) =
            Wsbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbbyte_t,
                Wdbyte_t,
                Wsbyte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7973:1"]
#[derive(Clone, Debug)]
struct instructionVar277 {
    Wb_t: Wb_t,
    Wd_t: Wd_t,
    k5_t: k5_t,
}
impl instructionVar277 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("xor.w"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.Wb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.k5_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 6 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_6_5().disassembly() != 3 {
            return None;
        }
        let Wb_t = if let Some((len, table)) =
            Wb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let k5_t = if let Some((len, table)) =
            k5_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wb_t, Wd_t, k5_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7980:1"]
#[derive(Clone, Debug)]
struct instructionVar278 {
    Wbbyte_t: Wbbyte_t,
    Wdbyte_t: Wdbyte_t,
    k5byte_t: k5byte_t,
}
impl instructionVar278 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("xor.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Wbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.k5byte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 6 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_6_5().disassembly() != 3 {
            return None;
        }
        let Wbbyte_t = if let Some((len, table)) =
            Wbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let k5byte_t = if let Some((len, table)) =
            k5byte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbbyte_t,
                Wdbyte_t,
                k5byte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7988:1"]
#[derive(Clone, Debug)]
struct instructionVar279 {
    Wb_t: Wb_t,
    Wd_t: Wd_t,
    Ws_t: Ws_t,
}
impl instructionVar279 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("xor.w"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Wb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Ws_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wd_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 6 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        let Wb_t = if let Some((len, table)) =
            Wb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wd_t = if let Some((len, table)) =
            Wd_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Ws_t = if let Some((len, table)) =
            Ws_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Wb_t, Wd_t, Ws_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:7998:1"]
#[derive(Clone, Debug)]
struct instructionVar280 {
    Wbbyte_t: Wbbyte_t,
    Wdbyte_t: Wdbyte_t,
    Wsbyte_t: Wsbyte_t,
}
impl instructionVar280 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("xor.b"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Wbbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wsbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wdbyte_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 6 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        let Wbbyte_t = if let Some((len, table)) =
            Wbbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_13().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_12().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wdbyte_t = if let Some((len, table)) =
            Wdbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c3 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_6().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.OP_5().disassembly() == 0 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c3(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Wsbyte_t = if let Some((len, table)) =
            Wsbyte_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Wbbyte_t,
                Wdbyte_t,
                Wsbyte_t,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:5116:1"]
#[derive(Clone, Debug)]
struct instructionVar281 {
    f15b_t: f15b_t,
    Wndb_t: Wndb_t,
}
impl instructionVar281 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("mov.w"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.f15b_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wndb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 8 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 0 {
            return None;
        }
        let f15b_t = if let Some((len, table)) =
            f15b_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wndb_t = if let Some((len, table)) =
            Wndb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { f15b_t, Wndb_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:5122:1"]
#[derive(Clone, Debug)]
struct instructionVar282 {
    f15b_t: f15b_t,
    Wns_t: Wns_t,
}
impl instructionVar282 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("mov.w"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.Wns_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.f15b_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 8 {
            return None;
        }
        if token_parser.OP_19().disassembly() != 1 {
            return None;
        }
        let f15b_t = if let Some((len, table)) =
            f15b_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wns_t = if let Some((len, table)) =
            Wns_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { f15b_t, Wns_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2078:1"]
#[derive(Clone, Debug)]
struct instructionVar283 {
    cond1: cond1,
    n16_t: n16_t,
}
impl instructionVar283 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("bra"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.cond1.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.n16_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 3 {
            return None;
        }
        let cond1 = if let Some((len, table)) =
            cond1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let n16_t = if let Some((len, table)) =
            n16_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cond1, n16_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2091:1"]
#[derive(Clone, Debug)]
struct instructionVar284 {
    cond2: cond2,
    n16_t: n16_t,
}
impl instructionVar284 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("bra"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.cond2.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.n16_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 0 {
            return None;
        }
        let cond2 = if let Some((len, table)) =
            cond2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let n16_t = if let Some((len, table)) =
            n16_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cond2, n16_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2289:1"]
#[derive(Clone, Debug)]
struct instructionVar285 {
    dest24_t: dest24_t,
}
impl instructionVar285 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("call"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.dest24_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        let mut sub_pattern_c22 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 4u64 as u32;
            let token_parser = <TokenParser<4usize>>::new(tokens)?;
            if token_parser.OP_23_20().disassembly() != 0 {
                return None;
            }
            if token_parser.OP_19_16().disassembly() != 2 {
                return None;
            }
            if token_parser.OP_0().disassembly() != 0 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 4u64 as u32;
            let token_parser = <TokenParser<4usize>>::new(tokens)?;
            if token_parser.OP_23_20().disassembly() != 0 {
                return None;
            }
            if token_parser.OP_19_16().disassembly() != 0 {
                return None;
            }
            if token_parser.OP_15_12().disassembly() != 0 {
                return None;
            }
            if token_parser.OP_11_8().disassembly() != 0 {
                return None;
            }
            if token_parser.OP_7().disassembly() != 0 {
                return None;
            }
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c22(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let dest24_t = if let Some((len, table)) =
            dest24_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { dest24_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3495:1"]
#[derive(Clone, Debug)]
struct instructionVar286 {
    TOK_10_8_Dregn: TokenField_TOK_10_8_Dregn,
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl instructionVar286 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("repeat"),
            DisplayElement::Literal(" 0x11 div.sd"),
            DisplayElement::Literal("  "),
            self.TOK_10_8_Dregn.display(),
            DisplayElement::Literal(","),
            self.TOK_3_0_Wreg.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_31_0().disassembly() != 589841 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.OP_23_20().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 8 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_W().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_5_4().disassembly() != 0 {
            return None;
        }
        let TOK_10_8_Dreg = token_parser.TOK_10_8_Dreg();
        let TOK_10_8_Dregn = token_parser.TOK_10_8_Dregn();
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                TOK_10_8_Dregn,
                TOK_3_0_Wreg,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3582:1"]
#[derive(Clone, Debug)]
struct instructionVar287 {
    TOK_10_8_Dregn: TokenField_TOK_10_8_Dregn,
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl instructionVar287 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("repeat"),
            DisplayElement::Literal(" 0x11 div.ud"),
            DisplayElement::Literal("  "),
            self.TOK_10_8_Dregn.display(),
            DisplayElement::Literal(","),
            self.TOK_3_0_Wreg.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_31_0().disassembly() != 589841 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.OP_23_20().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 8 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_W().disassembly() != 1 {
            return None;
        }
        if token_parser.OP_5_4().disassembly() != 0 {
            return None;
        }
        let TOK_10_8_Dreg = token_parser.TOK_10_8_Dreg();
        let TOK_10_8_Dregn = token_parser.TOK_10_8_Dregn();
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                TOK_10_8_Dregn,
                TOK_3_0_Wreg,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3450:1"]
#[derive(Clone, Debug)]
struct instructionVar288 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl instructionVar288 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("repeat"),
            DisplayElement::Literal(" 0x11 div.sw"),
            DisplayElement::Literal("   "),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal(","),
            self.TOK_3_0_Wreg.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_31_0().disassembly() != 589841 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.OP_23_20().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 8 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_W().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_5_4().disassembly() != 0 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                TOK_10_7_Wreg,
                TOK_3_0_Wreg,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3538:1"]
#[derive(Clone, Debug)]
struct instructionVar289 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl instructionVar289 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("repeat"),
            DisplayElement::Literal(" 0x11 div.uw"),
            DisplayElement::Literal("   "),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal(","),
            self.TOK_3_0_Wreg.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_31_0().disassembly() != 589841 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.OP_23_20().disassembly() != 13 {
            return None;
        }
        if token_parser.OP_19_16().disassembly() != 8 {
            return None;
        }
        if token_parser.OP_15().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_W().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_5_4().disassembly() != 0 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                TOK_10_7_Wreg,
                TOK_3_0_Wreg,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:3994:1"]
#[derive(Clone, Debug)]
struct instructionVar290 {
    dest24_t: dest24_t,
}
impl instructionVar290 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("goto"),
            DisplayElement::Literal("  "),
        ];
        display.extend_from_slice(&extend);
        self.dest24_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        let mut sub_pattern_c22 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 4u64 as u32;
            let token_parser = <TokenParser<4usize>>::new(tokens)?;
            if token_parser.OP_23_20().disassembly() != 0 {
                return None;
            }
            if token_parser.OP_19_16().disassembly() != 4 {
                return None;
            }
            if token_parser.OP_0().disassembly() != 0 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 4u64 as u32;
            let token_parser = <TokenParser<4usize>>::new(tokens)?;
            if token_parser.OP_23_20().disassembly() != 0 {
                return None;
            }
            if token_parser.OP_19_16().disassembly() != 0 {
                return None;
            }
            if token_parser.OP_15_12().disassembly() != 0 {
                return None;
            }
            if token_parser.OP_11_8().disassembly() != 0 {
                return None;
            }
            if token_parser.OP_7().disassembly() != 0 {
                return None;
            }
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c22(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let dest24_t = if let Some((len, table)) =
            dest24_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { dest24_t }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:5134:1"]
#[derive(Clone, Debug)]
struct instructionVar291 {
    k16_t: k16_t,
    Wndb_t: Wndb_t,
}
impl instructionVar291 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("mov.w"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.k16_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.Wndb_t.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.OP_23_20().disassembly() != 2 {
            return None;
        }
        let k16_t = if let Some((len, table)) =
            k16_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let Wndb_t = if let Some((len, table)) =
            Wndb_t::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { k16_t, Wndb_t }))
    }
}
#[derive(Clone, Debug)]
enum instruction {
    Var0(instructionVar0),
    Var1(instructionVar1),
    Var2(instructionVar2),
    Var3(instructionVar3),
    Var4(instructionVar4),
    Var5(instructionVar5),
    Var6(instructionVar6),
    Var7(instructionVar7),
    Var8(instructionVar8),
    Var9(instructionVar9),
    Var10(instructionVar10),
    Var11(instructionVar11),
    Var12(instructionVar12),
    Var13(instructionVar13),
    Var14(instructionVar14),
    Var15(instructionVar15),
    Var16(instructionVar16),
    Var17(instructionVar17),
    Var18(instructionVar18),
    Var19(instructionVar19),
    Var20(instructionVar20),
    Var21(instructionVar21),
    Var22(instructionVar22),
    Var23(instructionVar23),
    Var24(instructionVar24),
    Var25(instructionVar25),
    Var26(instructionVar26),
    Var27(instructionVar27),
    Var28(instructionVar28),
    Var29(instructionVar29),
    Var30(instructionVar30),
    Var31(instructionVar31),
    Var32(instructionVar32),
    Var33(instructionVar33),
    Var34(instructionVar34),
    Var35(instructionVar35),
    Var36(instructionVar36),
    Var37(instructionVar37),
    Var38(instructionVar38),
    Var39(instructionVar39),
    Var40(instructionVar40),
    Var41(instructionVar41),
    Var42(instructionVar42),
    Var43(instructionVar43),
    Var44(instructionVar44),
    Var45(instructionVar45),
    Var46(instructionVar46),
    Var47(instructionVar47),
    Var48(instructionVar48),
    Var49(instructionVar49),
    Var50(instructionVar50),
    Var51(instructionVar51),
    Var52(instructionVar52),
    Var53(instructionVar53),
    Var54(instructionVar54),
    Var55(instructionVar55),
    Var56(instructionVar56),
    Var57(instructionVar57),
    Var58(instructionVar58),
    Var59(instructionVar59),
    Var60(instructionVar60),
    Var61(instructionVar61),
    Var62(instructionVar62),
    Var63(instructionVar63),
    Var64(instructionVar64),
    Var65(instructionVar65),
    Var66(instructionVar66),
    Var67(instructionVar67),
    Var68(instructionVar68),
    Var69(instructionVar69),
    Var70(instructionVar70),
    Var71(instructionVar71),
    Var72(instructionVar72),
    Var73(instructionVar73),
    Var74(instructionVar74),
    Var75(instructionVar75),
    Var76(instructionVar76),
    Var77(instructionVar77),
    Var78(instructionVar78),
    Var79(instructionVar79),
    Var80(instructionVar80),
    Var81(instructionVar81),
    Var82(instructionVar82),
    Var83(instructionVar83),
    Var84(instructionVar84),
    Var85(instructionVar85),
    Var86(instructionVar86),
    Var87(instructionVar87),
    Var88(instructionVar88),
    Var89(instructionVar89),
    Var90(instructionVar90),
    Var91(instructionVar91),
    Var92(instructionVar92),
    Var93(instructionVar93),
    Var94(instructionVar94),
    Var95(instructionVar95),
    Var96(instructionVar96),
    Var97(instructionVar97),
    Var98(instructionVar98),
    Var99(instructionVar99),
    Var100(instructionVar100),
    Var101(instructionVar101),
    Var102(instructionVar102),
    Var103(instructionVar103),
    Var104(instructionVar104),
    Var105(instructionVar105),
    Var106(instructionVar106),
    Var107(instructionVar107),
    Var108(instructionVar108),
    Var109(instructionVar109),
    Var110(instructionVar110),
    Var111(instructionVar111),
    Var112(instructionVar112),
    Var113(instructionVar113),
    Var114(instructionVar114),
    Var115(instructionVar115),
    Var116(instructionVar116),
    Var117(instructionVar117),
    Var118(instructionVar118),
    Var119(instructionVar119),
    Var120(instructionVar120),
    Var121(instructionVar121),
    Var122(instructionVar122),
    Var123(instructionVar123),
    Var124(instructionVar124),
    Var125(instructionVar125),
    Var126(instructionVar126),
    Var127(instructionVar127),
    Var128(instructionVar128),
    Var129(instructionVar129),
    Var130(instructionVar130),
    Var131(instructionVar131),
    Var132(instructionVar132),
    Var133(instructionVar133),
    Var134(instructionVar134),
    Var135(instructionVar135),
    Var136(instructionVar136),
    Var137(instructionVar137),
    Var138(instructionVar138),
    Var139(instructionVar139),
    Var140(instructionVar140),
    Var141(instructionVar141),
    Var142(instructionVar142),
    Var143(instructionVar143),
    Var144(instructionVar144),
    Var145(instructionVar145),
    Var146(instructionVar146),
    Var147(instructionVar147),
    Var148(instructionVar148),
    Var149(instructionVar149),
    Var150(instructionVar150),
    Var151(instructionVar151),
    Var152(instructionVar152),
    Var153(instructionVar153),
    Var154(instructionVar154),
    Var155(instructionVar155),
    Var156(instructionVar156),
    Var157(instructionVar157),
    Var158(instructionVar158),
    Var159(instructionVar159),
    Var160(instructionVar160),
    Var161(instructionVar161),
    Var162(instructionVar162),
    Var163(instructionVar163),
    Var164(instructionVar164),
    Var165(instructionVar165),
    Var166(instructionVar166),
    Var167(instructionVar167),
    Var168(instructionVar168),
    Var169(instructionVar169),
    Var170(instructionVar170),
    Var171(instructionVar171),
    Var172(instructionVar172),
    Var173(instructionVar173),
    Var174(instructionVar174),
    Var175(instructionVar175),
    Var176(instructionVar176),
    Var177(instructionVar177),
    Var178(instructionVar178),
    Var179(instructionVar179),
    Var180(instructionVar180),
    Var181(instructionVar181),
    Var182(instructionVar182),
    Var183(instructionVar183),
    Var184(instructionVar184),
    Var185(instructionVar185),
    Var186(instructionVar186),
    Var187(instructionVar187),
    Var188(instructionVar188),
    Var189(instructionVar189),
    Var190(instructionVar190),
    Var191(instructionVar191),
    Var192(instructionVar192),
    Var193(instructionVar193),
    Var194(instructionVar194),
    Var195(instructionVar195),
    Var196(instructionVar196),
    Var197(instructionVar197),
    Var198(instructionVar198),
    Var199(instructionVar199),
    Var200(instructionVar200),
    Var201(instructionVar201),
    Var202(instructionVar202),
    Var203(instructionVar203),
    Var204(instructionVar204),
    Var205(instructionVar205),
    Var206(instructionVar206),
    Var207(instructionVar207),
    Var208(instructionVar208),
    Var209(instructionVar209),
    Var210(instructionVar210),
    Var211(instructionVar211),
    Var212(instructionVar212),
    Var213(instructionVar213),
    Var214(instructionVar214),
    Var215(instructionVar215),
    Var216(instructionVar216),
    Var217(instructionVar217),
    Var218(instructionVar218),
    Var219(instructionVar219),
    Var220(instructionVar220),
    Var221(instructionVar221),
    Var222(instructionVar222),
    Var223(instructionVar223),
    Var224(instructionVar224),
    Var225(instructionVar225),
    Var226(instructionVar226),
    Var227(instructionVar227),
    Var228(instructionVar228),
    Var229(instructionVar229),
    Var230(instructionVar230),
    Var231(instructionVar231),
    Var232(instructionVar232),
    Var233(instructionVar233),
    Var234(instructionVar234),
    Var235(instructionVar235),
    Var236(instructionVar236),
    Var237(instructionVar237),
    Var238(instructionVar238),
    Var239(instructionVar239),
    Var240(instructionVar240),
    Var241(instructionVar241),
    Var242(instructionVar242),
    Var243(instructionVar243),
    Var244(instructionVar244),
    Var245(instructionVar245),
    Var246(instructionVar246),
    Var247(instructionVar247),
    Var248(instructionVar248),
    Var249(instructionVar249),
    Var250(instructionVar250),
    Var251(instructionVar251),
    Var252(instructionVar252),
    Var253(instructionVar253),
    Var254(instructionVar254),
    Var255(instructionVar255),
    Var256(instructionVar256),
    Var257(instructionVar257),
    Var258(instructionVar258),
    Var259(instructionVar259),
    Var260(instructionVar260),
    Var261(instructionVar261),
    Var262(instructionVar262),
    Var263(instructionVar263),
    Var264(instructionVar264),
    Var265(instructionVar265),
    Var266(instructionVar266),
    Var267(instructionVar267),
    Var268(instructionVar268),
    Var269(instructionVar269),
    Var270(instructionVar270),
    Var271(instructionVar271),
    Var272(instructionVar272),
    Var273(instructionVar273),
    Var274(instructionVar274),
    Var275(instructionVar275),
    Var276(instructionVar276),
    Var277(instructionVar277),
    Var278(instructionVar278),
    Var279(instructionVar279),
    Var280(instructionVar280),
    Var281(instructionVar281),
    Var282(instructionVar282),
    Var283(instructionVar283),
    Var284(instructionVar284),
    Var285(instructionVar285),
    Var286(instructionVar286),
    Var287(instructionVar287),
    Var288(instructionVar288),
    Var289(instructionVar289),
    Var290(instructionVar290),
    Var291(instructionVar291),
}
impl instruction {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var14(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var15(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var16(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var17(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var18(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var19(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var20(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var21(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var22(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var23(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var24(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var25(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var26(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var27(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var28(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var29(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var30(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var31(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var32(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var33(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var34(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var35(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var36(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var37(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var38(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var39(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var40(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var41(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var42(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var43(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var44(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var45(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var46(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var47(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var48(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var49(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var50(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var51(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var52(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var53(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var54(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var55(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var56(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var57(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var58(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var59(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var60(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var61(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var62(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var63(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var64(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var65(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var66(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var67(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var68(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var69(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var70(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var71(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var72(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var73(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var74(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var75(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var76(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var77(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var78(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var79(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var80(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var81(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var82(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var83(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var84(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var85(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var86(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var87(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var88(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var89(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var90(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var91(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var92(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var93(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var94(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var95(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var96(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var97(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var98(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var99(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var100(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var101(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var102(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var103(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var104(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var105(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var106(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var107(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var108(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var109(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var110(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var111(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var112(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var113(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var114(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var115(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var116(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var117(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var118(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var119(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var120(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var121(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var122(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var123(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var124(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var125(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var126(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var127(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var128(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var129(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var130(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var131(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var132(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var133(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var134(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var135(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var136(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var137(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var138(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var139(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var140(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var141(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var142(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var143(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var144(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var145(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var146(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var147(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var148(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var149(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var150(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var151(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var152(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var153(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var154(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var155(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var156(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var157(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var158(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var159(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var160(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var161(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var162(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var163(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var164(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var165(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var166(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var167(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var168(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var169(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var170(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var171(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var172(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var173(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var174(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var175(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var176(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var177(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var178(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var179(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var180(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var181(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var182(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var183(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var184(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var185(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var186(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var187(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var188(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var189(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var190(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var191(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var192(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var193(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var194(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var195(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var196(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var197(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var198(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var199(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var200(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var201(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var202(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var203(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var204(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var205(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var206(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var207(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var208(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var209(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var210(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var211(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var212(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var213(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var214(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var215(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var216(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var217(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var218(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var219(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var220(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var221(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var222(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var223(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var224(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var225(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var226(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var227(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var228(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var229(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var230(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var231(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var232(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var233(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var234(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var235(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var236(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var237(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var238(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var239(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var240(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var241(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var242(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var243(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var244(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var245(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var246(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var247(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var248(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var249(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var250(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var251(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var252(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var253(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var254(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var255(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var256(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var257(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var258(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var259(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var260(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var261(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var262(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var263(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var264(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var265(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var266(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var267(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var268(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var269(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var270(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var271(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var272(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var273(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var274(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var275(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var276(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var277(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var278(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var279(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var280(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var281(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var282(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var283(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var284(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var285(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var286(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var287(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var288(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var289(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var290(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var291(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = instructionVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar8::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar9::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar10::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar11::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar12::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar13::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar14::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var14(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar15::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var15(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar16::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var16(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar17::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var17(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar18::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var18(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar19::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var19(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar20::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var20(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar21::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var21(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar22::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var22(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar23::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var23(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar24::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var24(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar25::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var25(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar26::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var26(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar27::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var27(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar28::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var28(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar29::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var29(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar30::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var30(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar31::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var31(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar32::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var32(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar33::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var33(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar34::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var34(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar35::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var35(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar36::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var36(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar37::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var37(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar38::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var38(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar39::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var39(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar40::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var40(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar41::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var41(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar42::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var42(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar43::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var43(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar44::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var44(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar45::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var45(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar46::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var46(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar47::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var47(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar48::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var48(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar49::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var49(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar50::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var50(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar51::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var51(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar52::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var52(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar53::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var53(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar54::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var54(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar55::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var55(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar56::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var56(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar57::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var57(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar58::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var58(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar59::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var59(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar60::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var60(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar61::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var61(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar62::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var62(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar63::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var63(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar64::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var64(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar65::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var65(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar66::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var66(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar67::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var67(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar68::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var68(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar69::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var69(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar70::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var70(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar71::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var71(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar72::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var72(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar73::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var73(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar74::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var74(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar75::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var75(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar76::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var76(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar77::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var77(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar78::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var78(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar79::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var79(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar80::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var80(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar81::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var81(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar82::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var82(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar83::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var83(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar84::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var84(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar85::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var85(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar86::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var86(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar87::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var87(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar88::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var88(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar89::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var89(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar90::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var90(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar91::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var91(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar92::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var92(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar93::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var93(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar94::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var94(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar95::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var95(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar96::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var96(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar97::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var97(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar98::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var98(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar99::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var99(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar100::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var100(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar101::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var101(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar102::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var102(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar103::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var103(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar104::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var104(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar105::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var105(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar106::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var106(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar107::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var107(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar108::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var108(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar109::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var109(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar110::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var110(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar111::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var111(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar112::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var112(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar113::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var113(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar114::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var114(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar115::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var115(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar116::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var116(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar117::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var117(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar118::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var118(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar119::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var119(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar120::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var120(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar121::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var121(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar122::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var122(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar123::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var123(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar124::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var124(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar125::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var125(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar126::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var126(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar127::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var127(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar128::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var128(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar129::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var129(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar130::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var130(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar131::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var131(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar132::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var132(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar133::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var133(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar134::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var134(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar135::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var135(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar136::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var136(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar137::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var137(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar138::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var138(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar139::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var139(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar140::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var140(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar141::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var141(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar142::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var142(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar143::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var143(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar144::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var144(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar145::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var145(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar146::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var146(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar147::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var147(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar148::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var148(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar149::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var149(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar150::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var150(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar151::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var151(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar152::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var152(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar153::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var153(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar154::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var154(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar155::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var155(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar156::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var156(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar157::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var157(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar158::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var158(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar159::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var159(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar160::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var160(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar161::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var161(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar162::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var162(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar163::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var163(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar164::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var164(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar165::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var165(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar166::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var166(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar167::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var167(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar168::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var168(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar169::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var169(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar170::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var170(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar171::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var171(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar172::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var172(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar173::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var173(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar174::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var174(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar175::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var175(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar176::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var176(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar177::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var177(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar178::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var178(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar179::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var179(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar180::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var180(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar181::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var181(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar182::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var182(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar183::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var183(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar184::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var184(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar185::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var185(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar186::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var186(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar187::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var187(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar188::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var188(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar189::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var189(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar190::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var190(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar191::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var191(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar192::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var192(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar193::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var193(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar194::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var194(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar195::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var195(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar196::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var196(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar197::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var197(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar198::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var198(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar199::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var199(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar200::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var200(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar201::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var201(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar202::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var202(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar203::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var203(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar204::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var204(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar205::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var205(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar206::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var206(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar207::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var207(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar208::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var208(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar209::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var209(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar210::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var210(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar211::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var211(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar212::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var212(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar213::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var213(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar214::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var214(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar215::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var215(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar216::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var216(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar217::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var217(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar218::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var218(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar219::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var219(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar220::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var220(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar221::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var221(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar222::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var222(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar223::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var223(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar224::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var224(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar225::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var225(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar226::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var226(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar227::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var227(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar228::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var228(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar229::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var229(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar230::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var230(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar231::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var231(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar232::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var232(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar233::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var233(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar234::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var234(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar235::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var235(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar236::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var236(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar237::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var237(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar238::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var238(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar239::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var239(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar240::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var240(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar241::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var241(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar242::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var242(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar243::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var243(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar244::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var244(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar245::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var245(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar246::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var246(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar247::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var247(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar248::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var248(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar249::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var249(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar250::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var250(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar251::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var251(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar252::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var252(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar253::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var253(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar254::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var254(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar255::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var255(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar256::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var256(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar257::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var257(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar258::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var258(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar259::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var259(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar260::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var260(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar261::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var261(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar262::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var262(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar263::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var263(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar264::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var264(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar265::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var265(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar266::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var266(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar267::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var267(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar268::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var268(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar269::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var269(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar270::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var270(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar271::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var271(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar272::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var272(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar273::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var273(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar274::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var274(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar275::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var275(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar276::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var276(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar277::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var277(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar278::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var278(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar279::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var279(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar280::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var280(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar281::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var281(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar282::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var282(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar283::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var283(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar284::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var284(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar285::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var285(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar286::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var286(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar287::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var287(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar288::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var288(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar289::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var289(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar290::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var290(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar291::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var291(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:424:1"]
#[derive(Clone, Debug)]
struct Ws_tVar0 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Ws_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_3_0_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 0 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:427:1"]
#[derive(Clone, Debug)]
struct Ws_tVar1 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Ws_tVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 1 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:430:1"]
#[derive(Clone, Debug)]
struct Ws_tVar2 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Ws_tVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("--]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 2 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:433:1"]
#[derive(Clone, Debug)]
struct Ws_tVar3 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Ws_tVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("++]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 3 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:436:1"]
#[derive(Clone, Debug)]
struct Ws_tVar4 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Ws_tVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("[--"),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 4 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:439:1"]
#[derive(Clone, Debug)]
struct Ws_tVar5 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Ws_tVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("[++"),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 5 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[derive(Clone, Debug)]
enum Ws_t {
    Var0(Ws_tVar0),
    Var1(Ws_tVar1),
    Var2(Ws_tVar2),
    Var3(Ws_tVar3),
    Var4(Ws_tVar4),
    Var5(Ws_tVar5),
}
impl Ws_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Ws_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Ws_tVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Ws_tVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Ws_tVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Ws_tVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Ws_tVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:444:1"]
#[derive(Clone, Debug)]
struct Wsd_tVar0 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wsd_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_3_0_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_0().disassembly() != 0 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        let TOK_3_1_Dreg = token_parser.TOK_3_1_Dreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:447:1"]
#[derive(Clone, Debug)]
struct Wsd_tVar1 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wsd_tVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 1 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:450:1"]
#[derive(Clone, Debug)]
struct Wsd_tVar2 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wsd_tVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("--]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 2 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:453:1"]
#[derive(Clone, Debug)]
struct Wsd_tVar3 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wsd_tVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("++]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 3 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:456:1"]
#[derive(Clone, Debug)]
struct Wsd_tVar4 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wsd_tVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("[--"),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 4 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:459:1"]
#[derive(Clone, Debug)]
struct Wsd_tVar5 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wsd_tVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("[++"),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 5 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[derive(Clone, Debug)]
enum Wsd_t {
    Var0(Wsd_tVar0),
    Var1(Wsd_tVar1),
    Var2(Wsd_tVar2),
    Var3(Wsd_tVar3),
    Var4(Wsd_tVar4),
    Var5(Wsd_tVar5),
}
impl Wsd_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Wsd_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wsd_tVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wsd_tVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wsd_tVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wsd_tVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wsd_tVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:464:1"]
#[derive(Clone, Debug)]
struct Wsnd_tVar0 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wsnd_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_3_0_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_0().disassembly() != 0 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        let TOK_3_1_Dreg = token_parser.TOK_3_1_Dreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:467:1"]
#[derive(Clone, Debug)]
struct Wsnd_tVar1 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wsnd_tVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 1 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:470:1"]
#[derive(Clone, Debug)]
struct Wsnd_tVar2 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wsnd_tVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("--]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 2 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:473:1"]
#[derive(Clone, Debug)]
struct Wsnd_tVar3 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wsnd_tVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("++]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 3 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:476:1"]
#[derive(Clone, Debug)]
struct Wsnd_tVar4 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wsnd_tVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("[--"),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 4 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:479:1"]
#[derive(Clone, Debug)]
struct Wsnd_tVar5 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wsnd_tVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("[++"),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 5 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[derive(Clone, Debug)]
enum Wsnd_t {
    Var0(Wsnd_tVar0),
    Var1(Wsnd_tVar1),
    Var2(Wsnd_tVar2),
    Var3(Wsnd_tVar3),
    Var4(Wsnd_tVar4),
    Var5(Wsnd_tVar5),
}
impl Wsnd_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Wsnd_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wsnd_tVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wsnd_tVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wsnd_tVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wsnd_tVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wsnd_tVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:484:1"]
#[derive(Clone, Debug)]
struct Wsb_tVar0 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wsb_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_3_0_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 0 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:487:1"]
#[derive(Clone, Debug)]
struct Wsb_tVar1 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wsb_tVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 1 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:490:1"]
#[derive(Clone, Debug)]
struct Wsb_tVar2 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wsb_tVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("--]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 2 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:493:1"]
#[derive(Clone, Debug)]
struct Wsb_tVar3 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wsb_tVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("++]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 3 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:496:1"]
#[derive(Clone, Debug)]
struct Wsb_tVar4 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wsb_tVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("[--"),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 4 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:499:1"]
#[derive(Clone, Debug)]
struct Wsb_tVar5 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wsb_tVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("[++"),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 5 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[derive(Clone, Debug)]
enum Wsb_t {
    Var0(Wsb_tVar0),
    Var1(Wsb_tVar1),
    Var2(Wsb_tVar2),
    Var3(Wsb_tVar3),
    Var4(Wsb_tVar4),
    Var5(Wsb_tVar5),
}
impl Wsb_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Wsb_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wsb_tVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wsb_tVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wsb_tVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wsb_tVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wsb_tVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:504:1"]
#[derive(Clone, Debug)]
struct Wsbyte_tVar0 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wsbyte_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_3_0_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 0 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        let TOK_3_0_Breg = token_parser.TOK_3_0_Breg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:507:1"]
#[derive(Clone, Debug)]
struct Wsbyte_tVar1 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wsbyte_tVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 1 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:510:1"]
#[derive(Clone, Debug)]
struct Wsbyte_tVar2 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wsbyte_tVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("--]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 2 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:513:1"]
#[derive(Clone, Debug)]
struct Wsbyte_tVar3 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wsbyte_tVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("++]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 3 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:516:1"]
#[derive(Clone, Debug)]
struct Wsbyte_tVar4 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wsbyte_tVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("[--"),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 4 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:519:1"]
#[derive(Clone, Debug)]
struct Wsbyte_tVar5 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wsbyte_tVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("[++"),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 5 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[derive(Clone, Debug)]
enum Wsbyte_t {
    Var0(Wsbyte_tVar0),
    Var1(Wsbyte_tVar1),
    Var2(Wsbyte_tVar2),
    Var3(Wsbyte_tVar3),
    Var4(Wsbyte_tVar4),
    Var5(Wsbyte_tVar5),
}
impl Wsbyte_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Wsbyte_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wsbyte_tVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wsbyte_tVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wsbyte_tVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wsbyte_tVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wsbyte_tVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:524:1"]
#[derive(Clone, Debug)]
struct Wsbbyte_tVar0 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wsbbyte_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_3_0_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 0 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        let TOK_3_0_Breg = token_parser.TOK_3_0_Breg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:527:1"]
#[derive(Clone, Debug)]
struct Wsbbyte_tVar1 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wsbbyte_tVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 1 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:530:1"]
#[derive(Clone, Debug)]
struct Wsbbyte_tVar2 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wsbbyte_tVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("--]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 2 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:533:1"]
#[derive(Clone, Debug)]
struct Wsbbyte_tVar3 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wsbbyte_tVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("++]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 3 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:536:1"]
#[derive(Clone, Debug)]
struct Wsbbyte_tVar4 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wsbbyte_tVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("[--"),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 4 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:539:1"]
#[derive(Clone, Debug)]
struct Wsbbyte_tVar5 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wsbbyte_tVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("[++"),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 5 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[derive(Clone, Debug)]
enum Wsbbyte_t {
    Var0(Wsbbyte_tVar0),
    Var1(Wsbbyte_tVar1),
    Var2(Wsbbyte_tVar2),
    Var3(Wsbbyte_tVar3),
    Var4(Wsbbyte_tVar4),
    Var5(Wsbbyte_tVar5),
}
impl Wsbbyte_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Wsbbyte_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wsbbyte_tVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wsbbyte_tVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wsbbyte_tVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wsbbyte_tVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wsbbyte_tVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:544:1"]
#[derive(Clone, Debug)]
struct Wd_tVar0 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl Wd_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_10_7_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 0 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:547:1"]
#[derive(Clone, Debug)]
struct Wd_tVar1 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl Wd_tVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 1 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:550:1"]
#[derive(Clone, Debug)]
struct Wd_tVar2 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl Wd_tVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("--]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 2 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:553:1"]
#[derive(Clone, Debug)]
struct Wd_tVar3 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl Wd_tVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("++]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 3 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:556:1"]
#[derive(Clone, Debug)]
struct Wd_tVar4 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl Wd_tVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("[--"),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 4 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:559:1"]
#[derive(Clone, Debug)]
struct Wd_tVar5 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl Wd_tVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("[++"),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 5 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[derive(Clone, Debug)]
enum Wd_t {
    Var0(Wd_tVar0),
    Var1(Wd_tVar1),
    Var2(Wd_tVar2),
    Var3(Wd_tVar3),
    Var4(Wd_tVar4),
    Var5(Wd_tVar5),
}
impl Wd_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Wd_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wd_tVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wd_tVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wd_tVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wd_tVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wd_tVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:564:1"]
#[derive(Clone, Debug)]
struct Wdd_tVar0 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl Wdd_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_10_7_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 0 {
            return None;
        }
        if token_parser.OP_7().disassembly() != 0 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        let TOK_10_8_Dreg = token_parser.TOK_10_8_Dreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:567:1"]
#[derive(Clone, Debug)]
struct Wdd_tVar1 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl Wdd_tVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 1 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:570:1"]
#[derive(Clone, Debug)]
struct Wdd_tVar2 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl Wdd_tVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("--]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 2 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:573:1"]
#[derive(Clone, Debug)]
struct Wdd_tVar3 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl Wdd_tVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("++]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 3 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:576:1"]
#[derive(Clone, Debug)]
struct Wdd_tVar4 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl Wdd_tVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("[--"),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 4 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:579:1"]
#[derive(Clone, Debug)]
struct Wdd_tVar5 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl Wdd_tVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("[++"),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 5 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[derive(Clone, Debug)]
enum Wdd_t {
    Var0(Wdd_tVar0),
    Var1(Wdd_tVar1),
    Var2(Wdd_tVar2),
    Var3(Wdd_tVar3),
    Var4(Wdd_tVar4),
    Var5(Wdd_tVar5),
}
impl Wdd_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Wdd_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wdd_tVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wdd_tVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wdd_tVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wdd_tVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wdd_tVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:584:1"]
#[derive(Clone, Debug)]
struct Wdbyte_tVar0 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl Wdbyte_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_10_7_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 0 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        let TOK_10_7_Breg = token_parser.TOK_10_7_Breg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:587:1"]
#[derive(Clone, Debug)]
struct Wdbyte_tVar1 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl Wdbyte_tVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 1 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:590:1"]
#[derive(Clone, Debug)]
struct Wdbyte_tVar2 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl Wdbyte_tVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("--]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 2 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:593:1"]
#[derive(Clone, Debug)]
struct Wdbyte_tVar3 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl Wdbyte_tVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("++]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 3 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:596:1"]
#[derive(Clone, Debug)]
struct Wdbyte_tVar4 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl Wdbyte_tVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("[--"),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 4 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:599:1"]
#[derive(Clone, Debug)]
struct Wdbyte_tVar5 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl Wdbyte_tVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("[++"),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 5 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[derive(Clone, Debug)]
enum Wdbyte_t {
    Var0(Wdbyte_tVar0),
    Var1(Wdbyte_tVar1),
    Var2(Wdbyte_tVar2),
    Var3(Wdbyte_tVar3),
    Var4(Wdbyte_tVar4),
    Var5(Wdbyte_tVar5),
}
impl Wdbyte_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Wdbyte_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wdbyte_tVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wdbyte_tVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wdbyte_tVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wdbyte_tVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            Wdbyte_tVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:604:1"]
#[derive(Clone, Debug)]
struct movWsVar0 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl movWsVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_3_0_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 0 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:607:1"]
#[derive(Clone, Debug)]
struct movWsVar1 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl movWsVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 1 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:610:1"]
#[derive(Clone, Debug)]
struct movWsVar2 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl movWsVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("--]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 2 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:613:1"]
#[derive(Clone, Debug)]
struct movWsVar3 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl movWsVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("++]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 3 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:616:1"]
#[derive(Clone, Debug)]
struct movWsVar4 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl movWsVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("[--"),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 4 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:619:1"]
#[derive(Clone, Debug)]
struct movWsVar5 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl movWsVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("[++"),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 5 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:622:1"]
#[derive(Clone, Debug)]
struct movWsVar6 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
    TOK_18_15_Wreg: TokenField_TOK_18_15_Wreg,
}
impl movWsVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("+"),
            self.TOK_18_15_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 6 {
            return None;
        }
        let TOK_18_15_Wreg = token_parser.TOK_18_15_Wreg();
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                TOK_18_15_Wreg,
                TOK_3_0_Wreg,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:625:1"]
#[derive(Clone, Debug)]
struct movWsVar7 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
    TOK_18_15_Wreg: TokenField_TOK_18_15_Wreg,
}
impl movWsVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("+"),
            self.TOK_18_15_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 7 {
            return None;
        }
        let TOK_18_15_Wreg = token_parser.TOK_18_15_Wreg();
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                TOK_18_15_Wreg,
                TOK_3_0_Wreg,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum movWs {
    Var0(movWsVar0),
    Var1(movWsVar1),
    Var2(movWsVar2),
    Var3(movWsVar3),
    Var4(movWsVar4),
    Var5(movWsVar5),
    Var6(movWsVar6),
    Var7(movWsVar7),
}
impl movWs {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            movWsVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            movWsVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            movWsVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            movWsVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            movWsVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            movWsVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            movWsVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            movWsVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:629:1"]
#[derive(Clone, Debug)]
struct movWsbyteVar0 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl movWsbyteVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_3_0_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 0 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        let TOK_3_0_Breg = token_parser.TOK_3_0_Breg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:632:1"]
#[derive(Clone, Debug)]
struct movWsbyteVar1 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl movWsbyteVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 1 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:635:1"]
#[derive(Clone, Debug)]
struct movWsbyteVar2 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl movWsbyteVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("--]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 2 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:638:1"]
#[derive(Clone, Debug)]
struct movWsbyteVar3 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl movWsbyteVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("++]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 3 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:641:1"]
#[derive(Clone, Debug)]
struct movWsbyteVar4 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl movWsbyteVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("[--"),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 4 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:644:1"]
#[derive(Clone, Debug)]
struct movWsbyteVar5 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl movWsbyteVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("[++"),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 5 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:647:1"]
#[derive(Clone, Debug)]
struct movWsbyteVar6 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
    TOK_18_15_Wreg: TokenField_TOK_18_15_Wreg,
}
impl movWsbyteVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("+"),
            self.TOK_18_15_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 6 {
            return None;
        }
        let TOK_18_15_Wreg = token_parser.TOK_18_15_Wreg();
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                TOK_18_15_Wreg,
                TOK_3_0_Wreg,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:650:1"]
#[derive(Clone, Debug)]
struct movWsbyteVar7 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
    TOK_18_15_Wreg: TokenField_TOK_18_15_Wreg,
}
impl movWsbyteVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("+"),
            self.TOK_18_15_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 7 {
            return None;
        }
        let TOK_18_15_Wreg = token_parser.TOK_18_15_Wreg();
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                TOK_18_15_Wreg,
                TOK_3_0_Wreg,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum movWsbyte {
    Var0(movWsbyteVar0),
    Var1(movWsbyteVar1),
    Var2(movWsbyteVar2),
    Var3(movWsbyteVar3),
    Var4(movWsbyteVar4),
    Var5(movWsbyteVar5),
    Var6(movWsbyteVar6),
    Var7(movWsbyteVar7),
}
impl movWsbyte {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            movWsbyteVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            movWsbyteVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            movWsbyteVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            movWsbyteVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            movWsbyteVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            movWsbyteVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            movWsbyteVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            movWsbyteVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:655:1"]
#[derive(Clone, Debug)]
struct movWdVar0 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl movWdVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_10_7_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 0 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:658:1"]
#[derive(Clone, Debug)]
struct movWdVar1 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl movWdVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 1 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:661:1"]
#[derive(Clone, Debug)]
struct movWdVar2 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl movWdVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("--]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 2 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:664:1"]
#[derive(Clone, Debug)]
struct movWdVar3 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl movWdVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("++]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 3 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:667:1"]
#[derive(Clone, Debug)]
struct movWdVar4 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl movWdVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("[--"),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 4 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:670:1"]
#[derive(Clone, Debug)]
struct movWdVar5 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl movWdVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("[++"),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 5 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:673:1"]
#[derive(Clone, Debug)]
struct movWdVar6 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
    TOK_18_15_Wreg: TokenField_TOK_18_15_Wreg,
}
impl movWdVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("["),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("+"),
            self.TOK_18_15_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 6 {
            return None;
        }
        let TOK_18_15_Wreg = token_parser.TOK_18_15_Wreg();
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                TOK_18_15_Wreg,
                TOK_10_7_Wreg,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:676:1"]
#[derive(Clone, Debug)]
struct movWdVar7 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
    TOK_18_15_Wreg: TokenField_TOK_18_15_Wreg,
}
impl movWdVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("["),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("+"),
            self.TOK_18_15_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 7 {
            return None;
        }
        let TOK_18_15_Wreg = token_parser.TOK_18_15_Wreg();
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                TOK_18_15_Wreg,
                TOK_10_7_Wreg,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum movWd {
    Var0(movWdVar0),
    Var1(movWdVar1),
    Var2(movWdVar2),
    Var3(movWdVar3),
    Var4(movWdVar4),
    Var5(movWdVar5),
    Var6(movWdVar6),
    Var7(movWdVar7),
}
impl movWd {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            movWdVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            movWdVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            movWdVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            movWdVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            movWdVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            movWdVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            movWdVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            movWdVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:681:1"]
#[derive(Clone, Debug)]
struct movWdbyteVar0 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl movWdbyteVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_10_7_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 0 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        let TOK_10_7_Breg = token_parser.TOK_10_7_Breg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:684:1"]
#[derive(Clone, Debug)]
struct movWdbyteVar1 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl movWdbyteVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 1 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:687:1"]
#[derive(Clone, Debug)]
struct movWdbyteVar2 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl movWdbyteVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("--]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 2 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:690:1"]
#[derive(Clone, Debug)]
struct movWdbyteVar3 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl movWdbyteVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("++]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 3 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:693:1"]
#[derive(Clone, Debug)]
struct movWdbyteVar4 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl movWdbyteVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("[--"),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 4 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:696:1"]
#[derive(Clone, Debug)]
struct movWdbyteVar5 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl movWdbyteVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("[++"),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 5 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:699:1"]
#[derive(Clone, Debug)]
struct movWdbyteVar6 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
    TOK_18_15_Wreg: TokenField_TOK_18_15_Wreg,
}
impl movWdbyteVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("["),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("+"),
            self.TOK_18_15_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 6 {
            return None;
        }
        let TOK_18_15_Wreg = token_parser.TOK_18_15_Wreg();
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                TOK_18_15_Wreg,
                TOK_10_7_Wreg,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:702:1"]
#[derive(Clone, Debug)]
struct movWdbyteVar7 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
    TOK_18_15_Wreg: TokenField_TOK_18_15_Wreg,
}
impl movWdbyteVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("["),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("+"),
            self.TOK_18_15_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 7 {
            return None;
        }
        let TOK_18_15_Wreg = token_parser.TOK_18_15_Wreg();
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                TOK_18_15_Wreg,
                TOK_10_7_Wreg,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum movWdbyte {
    Var0(movWdbyteVar0),
    Var1(movWdbyteVar1),
    Var2(movWdbyteVar2),
    Var3(movWdbyteVar3),
    Var4(movWdbyteVar4),
    Var5(movWdbyteVar5),
    Var6(movWdbyteVar6),
    Var7(movWdbyteVar7),
}
impl movWdbyte {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            movWdbyteVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            movWdbyteVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            movWdbyteVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            movWdbyteVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            movWdbyteVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            movWdbyteVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            movWdbyteVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            movWdbyteVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:709:1"]
#[derive(Clone, Debug)]
struct Wn_tVar0 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wn_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_3_0_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[derive(Clone, Debug)]
enum Wn_t {
    Var0(Wn_tVar0),
}
impl Wn_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Wn_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:712:1"]
#[derive(Clone, Debug)]
struct Wnbyte_tVar0 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wnbyte_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_3_0_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        let TOK_3_0_Breg = token_parser.TOK_3_0_Breg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[derive(Clone, Debug)]
enum Wnbyte_t {
    Var0(Wnbyte_tVar0),
}
impl Wnbyte_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Wnbyte_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:715:1"]
#[derive(Clone, Debug)]
struct Wnd_tVar0 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl Wnd_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_10_7_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[derive(Clone, Debug)]
enum Wnd_t {
    Var0(Wnd_tVar0),
}
impl Wnd_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Wnd_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:718:1"]
#[derive(Clone, Debug)]
struct Wndd_tVar0 {
    TOK_10_8_Dregn: TokenField_TOK_10_8_Dregn,
}
impl Wndd_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_10_8_Dregn.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let TOK_10_8_Dreg = token_parser.TOK_10_8_Dreg();
        let TOK_10_8_Dregn = token_parser.TOK_10_8_Dregn();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_8_Dregn }))
    }
}
#[derive(Clone, Debug)]
enum Wndd_t {
    Var0(Wndd_tVar0),
}
impl Wndd_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Wndd_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:721:1"]
#[derive(Clone, Debug)]
struct Wnda_tVar0 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl Wnda_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_10_7_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[derive(Clone, Debug)]
enum Wnda_t {
    Var0(Wnda_tVar0),
}
impl Wnda_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Wnda_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:724:1"]
#[derive(Clone, Debug)]
struct Wnbf_tVar0 {
    TOK_11_8_Wreg: TokenField_TOK_11_8_Wreg,
}
impl Wnbf_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_11_8_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let TOK_11_8_Wreg = token_parser.TOK_11_8_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_11_8_Wreg }))
    }
}
#[derive(Clone, Debug)]
enum Wnbf_t {
    Var0(Wnbf_tVar0),
}
impl Wnbf_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Wnbf_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:727:1"]
#[derive(Clone, Debug)]
struct Wdpp_tVar0 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl Wdpp_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("++]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[derive(Clone, Debug)]
enum Wdpp_t {
    Var0(Wdpp_tVar0),
}
impl Wdpp_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Wdpp_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:730:1"]
#[derive(Clone, Debug)]
struct Wndabyte_tVar0 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl Wndabyte_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_10_7_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        let TOK_10_7_Breg = token_parser.TOK_10_7_Breg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[derive(Clone, Debug)]
enum Wndabyte_t {
    Var0(Wndabyte_tVar0),
}
impl Wndabyte_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = Wndabyte_tVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:733:1"]
#[derive(Clone, Debug)]
struct Wndb_tVar0 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wndb_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_3_0_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[derive(Clone, Debug)]
enum Wndb_t {
    Var0(Wndb_tVar0),
}
impl Wndb_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Wndb_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:736:1"]
#[derive(Clone, Debug)]
struct Wndbyte_tVar0 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wndbyte_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_3_0_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        let TOK_3_0_Breg = token_parser.TOK_3_0_Breg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[derive(Clone, Debug)]
enum Wndbyte_t {
    Var0(Wndbyte_tVar0),
}
impl Wndbyte_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Wndbyte_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:739:1"]
#[derive(Clone, Debug)]
struct Wns_tVar0 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wns_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_3_0_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[derive(Clone, Debug)]
enum Wns_t {
    Var0(Wns_tVar0),
}
impl Wns_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Wns_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:742:1"]
#[derive(Clone, Debug)]
struct Wnsbyte_tVar0 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wnsbyte_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_3_0_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        let TOK_3_0_Breg = token_parser.TOK_3_0_Breg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[derive(Clone, Debug)]
enum Wnsbyte_t {
    Var0(Wnsbyte_tVar0),
}
impl Wnsbyte_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Wnsbyte_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:745:1"]
#[derive(Clone, Debug)]
struct Wb_tVar0 {
    TOK_18_15_Wreg: TokenField_TOK_18_15_Wreg,
}
impl Wb_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_18_15_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let TOK_18_15_Wreg = token_parser.TOK_18_15_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_18_15_Wreg }))
    }
}
#[derive(Clone, Debug)]
enum Wb_t {
    Var0(Wb_tVar0),
}
impl Wb_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Wb_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:748:1"]
#[derive(Clone, Debug)]
struct Wbbyte_tVar0 {
    TOK_18_15_Wreg: TokenField_TOK_18_15_Wreg,
}
impl Wbbyte_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_18_15_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let TOK_18_15_Wreg = token_parser.TOK_18_15_Wreg();
        let TOK_18_15_Breg = token_parser.TOK_18_15_Breg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_18_15_Wreg }))
    }
}
#[derive(Clone, Debug)]
enum Wbbyte_t {
    Var0(Wbbyte_tVar0),
}
impl Wbbyte_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Wbbyte_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:751:1"]
#[derive(Clone, Debug)]
struct Wbb_tVar0 {
    TOK_14_11_Wreg: TokenField_TOK_14_11_Wreg,
}
impl Wbb_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_14_11_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let TOK_14_11_Wreg = token_parser.TOK_14_11_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_14_11_Wreg }))
    }
}
#[derive(Clone, Debug)]
enum Wbb_t {
    Var0(Wbb_tVar0),
}
impl Wbb_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Wbb_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:754:1"]
#[derive(Clone, Debug)]
struct Wbds_tVar0 {
    TOK_14_12_Dregn: TokenField_TOK_14_12_Dregn,
}
impl Wbds_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_14_12_Dregn.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let TOK_14_12_Dreg = token_parser.TOK_14_12_Dreg();
        let TOK_14_12_Dregn = token_parser.TOK_14_12_Dregn();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_14_12_Dregn }))
    }
}
#[derive(Clone, Debug)]
enum Wbds_t {
    Var0(Wbds_tVar0),
}
impl Wbds_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Wbds_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:757:1"]
#[derive(Clone, Debug)]
struct Wbbbyte_tVar0 {
    TOK_14_11_Wreg: TokenField_TOK_14_11_Wreg,
}
impl Wbbbyte_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_14_11_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let TOK_14_11_Wreg = token_parser.TOK_14_11_Wreg();
        let TOK_14_11_Breg = token_parser.TOK_14_11_Breg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_14_11_Wreg }))
    }
}
#[derive(Clone, Debug)]
enum Wbbbyte_t {
    Var0(Wbbbyte_tVar0),
}
impl Wbbbyte_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Wbbbyte_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:760:1"]
#[derive(Clone, Debug)]
struct Wnb_tVar0 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wnb_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_3_0_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[derive(Clone, Debug)]
enum Wnb_t {
    Var0(Wnb_tVar0),
}
impl Wnb_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Wnb_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:763:1"]
#[derive(Clone, Debug)]
struct Wnbbyte_tVar0 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl Wnbbyte_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_3_0_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        let TOK_3_0_Breg = token_parser.TOK_3_0_Breg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[derive(Clone, Debug)]
enum Wnbbyte_t {
    Var0(Wnbbyte_tVar0),
}
impl Wnbbyte_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Wnbbyte_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:766:1"]
#[derive(Clone, Debug)]
struct Wbd_tVar0 {
    TOK_14_11_Wreg: TokenField_TOK_14_11_Wreg,
}
impl Wbd_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_14_11_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let TOK_14_11_Wreg = token_parser.TOK_14_11_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_14_11_Wreg }))
    }
}
#[derive(Clone, Debug)]
enum Wbd_t {
    Var0(Wbd_tVar0),
}
impl Wbd_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Wbd_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:769:1"]
#[derive(Clone, Debug)]
struct WREG_tVar0 {}
impl WREG_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",wreg")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_D().disassembly() != 0 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:772:1"]
#[derive(Clone, Debug)]
struct WREG_tVar1 {}
impl WREG_tVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(""), DisplayElement::Literal("")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_D().disassembly() != 1 {
            return None;
        }
        let TOK_f13 = token_parser.TOK_f13();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum WREG_t {
    Var0(WREG_tVar0),
    Var1(WREG_tVar1),
}
impl WREG_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            WREG_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            WREG_tVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:775:1"]
#[derive(Clone, Debug)]
struct WREGbyte_tVar0 {}
impl WREGbyte_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal(",wreg")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_D().disassembly() != 0 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:778:1"]
#[derive(Clone, Debug)]
struct WREGbyte_tVar1 {}
impl WREGbyte_tVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(""), DisplayElement::Literal("")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_D().disassembly() != 1 {
            return None;
        }
        let TOK_f13 = token_parser.TOK_f13();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum WREGbyte_t {
    Var0(WREGbyte_tVar0),
    Var1(WREGbyte_tVar1),
}
impl WREGbyte_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = WREGbyte_tVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = WREGbyte_tVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:781:1"]
#[derive(Clone, Debug)]
struct WREGb_tVar0 {}
impl WREGb_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("wreg")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_D().disassembly() != 0 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum WREGb_t {
    Var0(WREGb_tVar0),
}
impl WREGb_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            WREGb_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:784:1"]
#[derive(Clone, Debug)]
struct WREGbbyte_tVar0 {}
impl WREGbbyte_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("wreg")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_D().disassembly() != 0 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum WREGbbyte_t {
    Var0(WREGbbyte_tVar0),
}
impl WREGbbyte_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = WREGbbyte_tVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:787:1"]
#[derive(Clone, Debug)]
struct WREG_W0_tVar0 {}
impl WREG_W0_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("wreg")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum WREG_W0_t {
    Var0(WREG_W0_tVar0),
}
impl WREG_W0_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            WREG_W0_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:790:1"]
#[derive(Clone, Debug)]
struct WREG_W0byte_tVar0 {}
impl WREG_W0byte_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("wreg")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum WREG_W0byte_t {
    Var0(WREG_W0byte_tVar0),
}
impl WREG_W0byte_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = WREG_W0byte_tVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:793:1"]
#[derive(Clone, Debug)]
struct f13b_tVar0 {
    TOK_f13: TokenField_TOK_f13,
}
impl f13b_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_f13.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        if token_parser.TOK_D().disassembly() != 1 {
            return None;
        }
        let TOK_f13 = token_parser.TOK_f13();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_f13 }))
    }
}
#[derive(Clone, Debug)]
enum f13b_t {
    Var0(f13b_tVar0),
}
impl f13b_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            f13b_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:796:1"]
#[derive(Clone, Debug)]
struct f13bbyte_tVar0 {
    TOK_f13: TokenField_TOK_f13,
}
impl f13bbyte_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_f13.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_D().disassembly() != 1 {
            return None;
        }
        let TOK_f13 = token_parser.TOK_f13();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_f13 }))
    }
}
#[derive(Clone, Debug)]
enum f13bbyte_t {
    Var0(f13bbyte_tVar0),
}
impl f13bbyte_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = f13bbyte_tVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:799:1"]
#[derive(Clone, Debug)]
struct f12_tVar0 {
    TOK_f12: TokenField_TOK_f12,
}
impl f12_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut val: i64 = 0;
        val = (self.TOK_f12.disassembly() << (1u64 as i64));
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, val)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let mut val: i64 = 0;
        val = (token_parser.TOK_f12().disassembly() << (1u64 as i64));
        let TOK_f12 = token_parser.TOK_f12();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_f12 }))
    }
}
#[derive(Clone, Debug)]
enum f12_t {
    Var0(f12_tVar0),
}
impl f12_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            f12_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:802:1"]
#[derive(Clone, Debug)]
struct f13_tVar0 {
    TOK_f13: TokenField_TOK_f13,
}
impl f13_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_f13.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        let TOK_f13 = token_parser.TOK_f13();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_f13 }))
    }
}
#[derive(Clone, Debug)]
enum f13_t {
    Var0(f13_tVar0),
}
impl f13_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            f13_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:805:1"]
#[derive(Clone, Debug)]
struct f13byte_tVar0 {
    TOK_f13: TokenField_TOK_f13,
}
impl f13byte_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_f13.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        let TOK_f13 = token_parser.TOK_f13();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_f13 }))
    }
}
#[derive(Clone, Debug)]
enum f13byte_t {
    Var0(f13byte_tVar0),
}
impl f13byte_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            f13byte_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:808:1"]
#[derive(Clone, Debug)]
struct f15_tVar0 {
    TOK_f15: TokenField_TOK_f15,
}
impl f15_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut addr: i64 = 0;
        addr = (self.TOK_f15.disassembly() << (1u64 as i64));
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, addr)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let mut addr: i64 = 0;
        addr = (token_parser.TOK_f15().disassembly() << (1u64 as i64));
        let TOK_f15 = token_parser.TOK_f15();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_f15 }))
    }
}
#[derive(Clone, Debug)]
enum f15_t {
    Var0(f15_tVar0),
}
impl f15_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            f15_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:811:1"]
#[derive(Clone, Debug)]
struct f15b_tVar0 {
    TOK_f15b: TokenField_TOK_f15b,
}
impl f15b_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut addr: i64 = 0;
        addr = (self.TOK_f15b.disassembly() << (1u64 as i64));
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, addr)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let mut addr: i64 = 0;
        addr = (token_parser.TOK_f15b().disassembly() << (1u64 as i64));
        let TOK_f15b = token_parser.TOK_f15b();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_f15b }))
    }
}
#[derive(Clone, Debug)]
enum f15b_t {
    Var0(f15b_tVar0),
}
impl f15b_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            f15b_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:814:1"]
#[derive(Clone, Debug)]
struct k3_tVar0 {
    TOK_k3: TokenField_TOK_k3,
}
impl k3_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("#"), self.TOK_k3.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let TOK_k3 = token_parser.TOK_k3();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_k3 }))
    }
}
#[derive(Clone, Debug)]
enum k3_t {
    Var0(k3_tVar0),
}
impl k3_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            k3_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:817:1"]
#[derive(Clone, Debug)]
struct k4_tVar0 {
    TOK_k4: TokenField_TOK_k4,
}
impl k4_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("#"), self.TOK_k4.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let TOK_k4 = token_parser.TOK_k4();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_k4 }))
    }
}
#[derive(Clone, Debug)]
enum k4_t {
    Var0(k4_tVar0),
}
impl k4_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            k4_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:820:1"]
#[derive(Clone, Debug)]
struct k5Var0 {
    TOK_k5: TokenField_TOK_k5,
}
impl k5Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("#"), self.TOK_k5.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let TOK_k5 = token_parser.TOK_k5();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_k5 }))
    }
}
#[derive(Clone, Debug)]
enum k5 {
    Var0(k5Var0),
}
impl k5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            k5Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:823:1"]
#[derive(Clone, Debug)]
struct k5_tVar0 {
    TOK_k5: TokenField_TOK_k5,
}
impl k5_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("#"), self.TOK_k5.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        let TOK_k5 = token_parser.TOK_k5();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_k5 }))
    }
}
#[derive(Clone, Debug)]
enum k5_t {
    Var0(k5_tVar0),
}
impl k5_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            k5_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:826:1"]
#[derive(Clone, Debug)]
struct k5byte_tVar0 {
    TOK_k5: TokenField_TOK_k5,
}
impl k5byte_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("#"), self.TOK_k5.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        let TOK_k5 = token_parser.TOK_k5();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_k5 }))
    }
}
#[derive(Clone, Debug)]
enum k5byte_t {
    Var0(k5byte_tVar0),
}
impl k5byte_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            k5byte_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:829:1"]
#[derive(Clone, Debug)]
struct k5_B10_tVar0 {
    TOK_k5: TokenField_TOK_k5,
}
impl k5_B10_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("#"), self.TOK_k5.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_Bb().disassembly() != 0 {
            return None;
        }
        let TOK_k5 = token_parser.TOK_k5();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_k5 }))
    }
}
#[derive(Clone, Debug)]
enum k5_B10_t {
    Var0(k5_B10_tVar0),
}
impl k5_B10_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            k5_B10_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:832:1"]
#[derive(Clone, Debug)]
struct k5byte_B10_tVar0 {
    TOK_k5: TokenField_TOK_k5,
}
impl k5byte_B10_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("#"), self.TOK_k5.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_Bb().disassembly() != 1 {
            return None;
        }
        let TOK_k5 = token_parser.TOK_k5();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_k5 }))
    }
}
#[derive(Clone, Debug)]
enum k5byte_B10_t {
    Var0(k5byte_B10_tVar0),
}
impl k5byte_B10_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = k5byte_B10_tVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:836:1"]
#[derive(Clone, Debug)]
struct k10_tVar0 {
    TOK_k10: TokenField_TOK_k10,
}
impl k10_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("#"), self.TOK_k10.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_B().disassembly() != 0 {
            return None;
        }
        let TOK_k10 = token_parser.TOK_k10();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_k10 }))
    }
}
#[derive(Clone, Debug)]
enum k10_t {
    Var0(k10_tVar0),
}
impl k10_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            k10_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:839:1"]
#[derive(Clone, Debug)]
struct k10byte_tVar0 {
    TOK_k10: TokenField_TOK_k10,
}
impl k10byte_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("#"), self.TOK_k10.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_B().disassembly() != 1 {
            return None;
        }
        if token_parser.TOK_13_12_xx().disassembly() != 0 {
            return None;
        }
        let TOK_k10 = token_parser.TOK_k10();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_k10 }))
    }
}
#[derive(Clone, Debug)]
enum k10byte_t {
    Var0(k10byte_tVar0),
}
impl k10byte_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            k10byte_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:842:1"]
#[derive(Clone, Debug)]
struct k13_12_tVar0 {
    TOK_13_12_kk: TokenField_TOK_13_12_kk,
}
impl k13_12_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("#"), self.TOK_13_12_kk.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let TOK_13_12_kk = token_parser.TOK_13_12_kk();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_13_12_kk }))
    }
}
#[derive(Clone, Debug)]
enum k13_12_t {
    Var0(k13_12_tVar0),
}
impl k13_12_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            k13_12_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:845:1"]
#[derive(Clone, Debug)]
struct k14_tVar0 {
    TOK_k14: TokenField_TOK_k14,
}
impl k14_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("#"), self.TOK_k14.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let TOK_k14 = token_parser.TOK_k14();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_k14 }))
    }
}
#[derive(Clone, Debug)]
enum k14_t {
    Var0(k14_tVar0),
}
impl k14_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            k14_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:848:1"]
#[derive(Clone, Debug)]
struct k15_tVar0 {
    TOK_k15: TokenField_TOK_k15,
}
impl k15_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("#"), self.TOK_k15.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let TOK_k15 = token_parser.TOK_k15();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_k15 }))
    }
}
#[derive(Clone, Debug)]
enum k15_t {
    Var0(k15_tVar0),
}
impl k15_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            k15_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:851:1"]
#[derive(Clone, Debug)]
struct k16_tVar0 {
    TOK_k16: TokenField_TOK_k16,
}
impl k16_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("#"), self.TOK_k16.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let TOK_k16 = token_parser.TOK_k16();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_k16 }))
    }
}
#[derive(Clone, Debug)]
enum k16_t {
    Var0(k16_tVar0),
}
impl k16_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            k16_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:854:1"]
#[derive(Clone, Debug)]
struct bit4_tVar0 {
    TOK_b1: TokenField_TOK_b1,
    TOK_b3: TokenField_TOK_b3,
}
impl bit4_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut bit4: i64 = 0;
        bit4 = ((self.TOK_b1.disassembly() << (3u64 as i64))
            | self.TOK_b3.disassembly());
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("#"),
            DisplayElement::Number(true, bit4),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let mut bit4: i64 = 0;
        bit4 = ((token_parser.TOK_b1().disassembly() << (3u64 as i64))
            | token_parser.TOK_b3().disassembly());
        let TOK_b3 = token_parser.TOK_b3();
        let TOK_b1 = token_parser.TOK_b1();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_b3, TOK_b1 }))
    }
}
#[derive(Clone, Debug)]
enum bit4_t {
    Var0(bit4_tVar0),
}
impl bit4_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            bit4_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:857:1"]
#[derive(Clone, Debug)]
struct bit4byte_tVar0 {}
impl bit4byte_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(".w")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_bit4word().disassembly() != 1 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:859:1"]
#[derive(Clone, Debug)]
struct bit4byte_tVar1 {}
impl bit4byte_tVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(".b")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_bit4word().disassembly() != 0 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum bit4byte_t {
    Var0(bit4byte_tVar0),
    Var1(bit4byte_tVar1),
}
impl bit4byte_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = bit4byte_tVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = bit4byte_tVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:861:1"]
#[derive(Clone, Debug)]
struct Bbit4_tVar0 {
    TOK_b4: TokenField_TOK_b4,
}
impl Bbit4_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("#"), self.TOK_b4.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let TOK_b4 = token_parser.TOK_b4();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_b4 }))
    }
}
#[derive(Clone, Debug)]
enum Bbit4_t {
    Var0(Bbit4_tVar0),
}
impl Bbit4_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            Bbit4_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:864:1"]
#[derive(Clone, Debug)]
struct n15_tVar0 {
    TOK_n15: TokenField_TOK_n15,
}
impl n15_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_n15.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let TOK_n15 = token_parser.TOK_n15();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_n15 }))
    }
}
#[derive(Clone, Debug)]
enum n15_t {
    Var0(n15_tVar0),
}
impl n15_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            n15_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:865:1"]
#[derive(Clone, Debug)]
struct n16_tVar0 {
    TOK_n16: TokenField_TOK_n16,
}
impl n16_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut dest: i64 = 0;
        dest = (i64::try_from(inst_next).unwrap()
            + (self.TOK_n16.disassembly() << (1u64 as i64)));
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, dest)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let mut dest: i64 = 0;
        let TOK_n16 = token_parser.TOK_n16();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_n16 }))
    }
}
#[derive(Clone, Debug)]
enum n16_t {
    Var0(n16_tVar0),
}
impl n16_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            n16_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:866:1"]
#[derive(Clone, Debug)]
struct dest24_tVar0 {
    TOK_n7: TokenField_TOK_n7,
    TOK_n15: TokenField_TOK_n15,
}
impl dest24_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut dest: i64 = 0;
        dest = ((self.TOK_n7.disassembly() << (16u64 as i64))
            | (self.TOK_n15.disassembly() << (1u64 as i64)));
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, dest)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let mut dest: i64 = 0;
        dest = ((token_parser.TOK_n7().disassembly() << (16u64 as i64))
            | (token_parser.TOK_n15().disassembly() << (1u64 as i64)));
        let TOK_n15 = token_parser.TOK_n15();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let TOK_n7 = token_parser.TOK_n7();
        pattern_len += block_1_len;
        tokens_current =
            &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_n15, TOK_n7 }))
    }
}
#[derive(Clone, Debug)]
enum dest24_t {
    Var0(dest24_tVar0),
}
impl dest24_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            dest24_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:868:1"]
#[derive(Clone, Debug)]
struct WordInstNextVar0 {}
impl WordInstNextVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut winstNext: i64 = 0;
        winstNext = (i64::try_from(inst_next).unwrap() + (0u64 as i64));
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, winstNext)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let mut winstNext: i64 = 0;
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum WordInstNext {
    Var0(WordInstNextVar0),
}
impl WordInstNext {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = WordInstNextVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:869:1"]
#[derive(Clone, Debug)]
struct WordInstNext4Var0 {}
impl WordInstNext4Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut winstNext: i64 = 0;
        winstNext = (i64::try_from(inst_next).unwrap() + (0u64 as i64));
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, winstNext)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let mut winstNext: i64 = 0;
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum WordInstNext4 {
    Var0(WordInstNext4Var0),
}
impl WordInstNext4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = WordInstNext4Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:871:1"]
#[derive(Clone, Debug)]
struct WnDest_tVar0 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl WnDest_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_3_0_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[derive(Clone, Debug)]
enum WnDest_t {
    Var0(WnDest_tVar0),
}
impl WnDest_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            WnDest_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:872:1"]
#[derive(Clone, Debug)]
struct WnRDest_tVar0 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl WnRDest_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_3_0_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[derive(Clone, Debug)]
enum WnRDest_t {
    Var0(WnRDest_tVar0),
}
impl WnRDest_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            WnRDest_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:876:1"]
#[derive(Clone, Debug)]
struct WsSlit10_tVar0 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
    TOK_18_15_S: TokenField_TOK_18_15_S,
    TOK_13_11_U: TokenField_TOK_13_11_U,
    TOK_6_4_U: TokenField_TOK_6_4_U,
}
impl WsSlit10_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut val: i64 = 0;
        val = ((((self.TOK_18_15_S.disassembly() << (6u64 as i64))
            | (self.TOK_13_11_U.disassembly() << (3u64 as i64)))
            | self.TOK_6_4_U.disassembly())
            << (1u64 as i64));
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("+"),
            DisplayElement::Number(true, val),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let mut val: i64 = 0;
        val = ((((token_parser.TOK_18_15_S().disassembly() << (6u64 as i64))
            | (token_parser.TOK_13_11_U().disassembly() << (3u64 as i64)))
            | token_parser.TOK_6_4_U().disassembly())
            << (1u64 as i64));
        let TOK_18_15_S = token_parser.TOK_18_15_S();
        let TOK_13_11_U = token_parser.TOK_13_11_U();
        let TOK_6_4_U = token_parser.TOK_6_4_U();
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                TOK_18_15_S,
                TOK_13_11_U,
                TOK_6_4_U,
                TOK_3_0_Wreg,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum WsSlit10_t {
    Var0(WsSlit10_tVar0),
}
impl WsSlit10_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = WsSlit10_tVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:880:1"]
#[derive(Clone, Debug)]
struct WsSlit10byte_tVar0 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
    TOK_18_15_S: TokenField_TOK_18_15_S,
    TOK_13_11_U: TokenField_TOK_13_11_U,
    TOK_6_4_U: TokenField_TOK_6_4_U,
}
impl WsSlit10byte_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut val: i64 = 0;
        val = (((self.TOK_18_15_S.disassembly() << (6u64 as i64))
            | (self.TOK_13_11_U.disassembly() << (3u64 as i64)))
            | self.TOK_6_4_U.disassembly());
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("+"),
            DisplayElement::Number(true, val),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let mut val: i64 = 0;
        val = (((token_parser.TOK_18_15_S().disassembly() << (6u64 as i64))
            | (token_parser.TOK_13_11_U().disassembly() << (3u64 as i64)))
            | token_parser.TOK_6_4_U().disassembly());
        let TOK_18_15_S = token_parser.TOK_18_15_S();
        let TOK_13_11_U = token_parser.TOK_13_11_U();
        let TOK_6_4_U = token_parser.TOK_6_4_U();
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                TOK_18_15_S,
                TOK_13_11_U,
                TOK_6_4_U,
                TOK_3_0_Wreg,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum WsSlit10byte_t {
    Var0(WsSlit10byte_tVar0),
}
impl WsSlit10byte_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = WsSlit10byte_tVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:885:1"]
#[derive(Clone, Debug)]
struct WdSlit10_tVar0 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
    TOK_18_15_S: TokenField_TOK_18_15_S,
    TOK_13_11_U: TokenField_TOK_13_11_U,
    TOK_6_4_U: TokenField_TOK_6_4_U,
}
impl WdSlit10_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut val: i64 = 0;
        val = ((((self.TOK_18_15_S.disassembly() << (6u64 as i64))
            | (self.TOK_13_11_U.disassembly() << (3u64 as i64)))
            | self.TOK_6_4_U.disassembly())
            << (1u64 as i64));
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("["),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("+"),
            DisplayElement::Number(true, val),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let mut val: i64 = 0;
        val = ((((token_parser.TOK_18_15_S().disassembly() << (6u64 as i64))
            | (token_parser.TOK_13_11_U().disassembly() << (3u64 as i64)))
            | token_parser.TOK_6_4_U().disassembly())
            << (1u64 as i64));
        let TOK_18_15_S = token_parser.TOK_18_15_S();
        let TOK_13_11_U = token_parser.TOK_13_11_U();
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        let TOK_6_4_U = token_parser.TOK_6_4_U();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                TOK_18_15_S,
                TOK_13_11_U,
                TOK_10_7_Wreg,
                TOK_6_4_U,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum WdSlit10_t {
    Var0(WdSlit10_tVar0),
}
impl WdSlit10_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = WdSlit10_tVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:889:1"]
#[derive(Clone, Debug)]
struct WdSlit10byte_tVar0 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
    TOK_18_15_S: TokenField_TOK_18_15_S,
    TOK_13_11_U: TokenField_TOK_13_11_U,
    TOK_6_4_U: TokenField_TOK_6_4_U,
}
impl WdSlit10byte_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut val: i64 = 0;
        val = (((self.TOK_18_15_S.disassembly() << (6u64 as i64))
            | (self.TOK_13_11_U.disassembly() << (3u64 as i64)))
            | self.TOK_6_4_U.disassembly());
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("["),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("+"),
            DisplayElement::Number(true, val),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let mut val: i64 = 0;
        val = (((token_parser.TOK_18_15_S().disassembly() << (6u64 as i64))
            | (token_parser.TOK_13_11_U().disassembly() << (3u64 as i64)))
            | token_parser.TOK_6_4_U().disassembly());
        let TOK_18_15_S = token_parser.TOK_18_15_S();
        let TOK_13_11_U = token_parser.TOK_13_11_U();
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        let TOK_6_4_U = token_parser.TOK_6_4_U();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                TOK_18_15_S,
                TOK_13_11_U,
                TOK_10_7_Wreg,
                TOK_6_4_U,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum WdSlit10byte_t {
    Var0(WdSlit10byte_tVar0),
}
impl WdSlit10byte_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = WdSlit10byte_tVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:895:1"]
#[derive(Clone, Debug)]
struct n6_tVar0 {
    TOK_n6: TokenField_TOK_n6,
}
impl n6_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut dest: i64 = 0;
        dest = (i64::try_from(inst_next).unwrap()
            + ((2u64 as i64) * self.TOK_n6.disassembly()));
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, dest)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let mut dest: i64 = 0;
        let TOK_n6 = token_parser.TOK_n6();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_n6 }))
    }
}
#[derive(Clone, Debug)]
enum n6_t {
    Var0(n6_tVar0),
}
impl n6_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            n6_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:898:1"]
#[derive(Clone, Debug)]
struct k8_tVar0 {
    TOK_k8b: TokenField_TOK_k8b,
    TOK_k8a: TokenField_TOK_k8a,
}
impl k8_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut k8: i64 = 0;
        k8 = ((self.TOK_k8b.disassembly() << (5u64 as i64))
            | self.TOK_k8a.disassembly());
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("#"),
            DisplayElement::Number(true, k8),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let mut k8: i64 = 0;
        k8 = ((token_parser.TOK_k8b().disassembly() << (5u64 as i64))
            | token_parser.TOK_k8a().disassembly());
        let TOK_k8b = token_parser.TOK_k8b();
        let TOK_k8a = token_parser.TOK_k8a();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_k8b, TOK_k8a }))
    }
}
#[derive(Clone, Debug)]
enum k8_t {
    Var0(k8_tVar0),
}
impl k8_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            k8_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:901:1"]
#[derive(Clone, Debug)]
struct k8byte_tVar0 {
    TOK_k8b: TokenField_TOK_k8b,
    TOK_k8a: TokenField_TOK_k8a,
}
impl k8byte_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut k8: i64 = 0;
        k8 = ((self.TOK_k8b.disassembly() << (5u64 as i64))
            | self.TOK_k8a.disassembly());
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("#"),
            DisplayElement::Number(true, k8),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let mut k8: i64 = 0;
        k8 = ((token_parser.TOK_k8b().disassembly() << (5u64 as i64))
            | token_parser.TOK_k8a().disassembly());
        let TOK_k8b = token_parser.TOK_k8b();
        let TOK_k8a = token_parser.TOK_k8a();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_k8b, TOK_k8a }))
    }
}
#[derive(Clone, Debug)]
enum k8byte_t {
    Var0(k8byte_tVar0),
}
impl k8byte_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            k8byte_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:904:1"]
#[derive(Clone, Debug)]
struct WnWn1_tVar0 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl WnWn1_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_3_0_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        let TOK_14_11_Wreg = token_parser.TOK_14_11_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[derive(Clone, Debug)]
enum WnWn1_t {
    Var0(WnWn1_tVar0),
}
impl WnWn1_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            WnWn1_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1166:1"]
#[derive(Clone, Debug)]
struct WsMUL_tVar0 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl WsMUL_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_3_0_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 0 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1169:1"]
#[derive(Clone, Debug)]
struct WsMUL_tVar1 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl WsMUL_tVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 1 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1172:1"]
#[derive(Clone, Debug)]
struct WsMUL_tVar2 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl WsMUL_tVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("--]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 2 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1175:1"]
#[derive(Clone, Debug)]
struct WsMUL_tVar3 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl WsMUL_tVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("++]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 3 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1178:1"]
#[derive(Clone, Debug)]
struct WsMUL_tVar4 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl WsMUL_tVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("[--"),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 4 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1181:1"]
#[derive(Clone, Debug)]
struct WsMUL_tVar5 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl WsMUL_tVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("[++"),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 5 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[derive(Clone, Debug)]
enum WsMUL_t {
    Var0(WsMUL_tVar0),
    Var1(WsMUL_tVar1),
    Var2(WsMUL_tVar2),
    Var3(WsMUL_tVar3),
    Var4(WsMUL_tVar4),
    Var5(WsMUL_tVar5),
}
impl WsMUL_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            WsMUL_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            WsMUL_tVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            WsMUL_tVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            WsMUL_tVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            WsMUL_tVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            WsMUL_tVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1187:1"]
#[derive(Clone, Debug)]
struct WdMUL_tVar0 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl WdMUL_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.TOK_10_7_Wreg.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 0 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1190:1"]
#[derive(Clone, Debug)]
struct WdMUL_tVar1 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl WdMUL_tVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 1 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1193:1"]
#[derive(Clone, Debug)]
struct WdMUL_tVar2 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl WdMUL_tVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("--]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 2 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1196:1"]
#[derive(Clone, Debug)]
struct WdMUL_tVar3 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl WdMUL_tVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("++]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 3 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1199:1"]
#[derive(Clone, Debug)]
struct WdMUL_tVar4 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl WdMUL_tVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("[--"),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 4 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1202:1"]
#[derive(Clone, Debug)]
struct WdMUL_tVar5 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl WdMUL_tVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("[++"),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 5 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[derive(Clone, Debug)]
enum WdMUL_t {
    Var0(WdMUL_tVar0),
    Var1(WdMUL_tVar1),
    Var2(WdMUL_tVar2),
    Var3(WdMUL_tVar3),
    Var4(WdMUL_tVar4),
    Var5(WdMUL_tVar5),
}
impl WdMUL_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            WdMUL_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            WdMUL_tVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            WdMUL_tVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            WdMUL_tVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            WdMUL_tVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            WdMUL_tVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1207:1"]
#[derive(Clone, Debug)]
struct WsROM_tVar0 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl WsROM_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 1 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1210:1"]
#[derive(Clone, Debug)]
struct WsROM_tVar1 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl WsROM_tVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("--]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 2 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1213:1"]
#[derive(Clone, Debug)]
struct WsROM_tVar2 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl WsROM_tVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("++]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 3 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1216:1"]
#[derive(Clone, Debug)]
struct WsROM_tVar3 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl WsROM_tVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("[--"),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 4 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1219:1"]
#[derive(Clone, Debug)]
struct WsROM_tVar4 {
    TOK_3_0_Wreg: TokenField_TOK_3_0_Wreg,
}
impl WsROM_tVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("[++"),
            self.TOK_3_0_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_6_4_U().disassembly() != 5 {
            return None;
        }
        let TOK_3_0_Wreg = token_parser.TOK_3_0_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_3_0_Wreg }))
    }
}
#[derive(Clone, Debug)]
enum WsROM_t {
    Var0(WsROM_tVar0),
    Var1(WsROM_tVar1),
    Var2(WsROM_tVar2),
    Var3(WsROM_tVar3),
    Var4(WsROM_tVar4),
}
impl WsROM_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            WsROM_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            WsROM_tVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            WsROM_tVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            WsROM_tVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            WsROM_tVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1224:1"]
#[derive(Clone, Debug)]
struct WdROM_tVar0 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl WdROM_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 1 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1227:1"]
#[derive(Clone, Debug)]
struct WdROM_tVar1 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl WdROM_tVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("--]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 2 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1230:1"]
#[derive(Clone, Debug)]
struct WdROM_tVar2 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl WdROM_tVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("++]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 3 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1233:1"]
#[derive(Clone, Debug)]
struct WdROM_tVar3 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl WdROM_tVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("[--"),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 4 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:1236:1"]
#[derive(Clone, Debug)]
struct WdROM_tVar4 {
    TOK_10_7_Wreg: TokenField_TOK_10_7_Wreg,
}
impl WdROM_tVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("[++"),
            self.TOK_10_7_Wreg.display(),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TOK_13_11_U().disassembly() != 5 {
            return None;
        }
        let TOK_10_7_Wreg = token_parser.TOK_10_7_Wreg();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOK_10_7_Wreg }))
    }
}
#[derive(Clone, Debug)]
enum WdROM_t {
    Var0(WdROM_tVar0),
    Var1(WdROM_tVar1),
    Var2(WdROM_tVar2),
    Var3(WdROM_tVar3),
    Var4(WdROM_tVar4),
}
impl WdROM_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            WdROM_tVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            WdROM_tVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            WdROM_tVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            WdROM_tVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            WdROM_tVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2046:1"]
#[derive(Clone, Debug)]
struct cond1Var0 {}
impl cond1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("c")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.TOK_CCCC().disassembly() != 1 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2047:1"]
#[derive(Clone, Debug)]
struct cond1Var1 {}
impl cond1Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ge")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.TOK_CCCC().disassembly() != 13 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2050:1"]
#[derive(Clone, Debug)]
struct cond1Var2 {}
impl cond1Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("gt")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.TOK_CCCC().disassembly() != 12 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2052:1"]
#[derive(Clone, Debug)]
struct cond1Var3 {}
impl cond1Var3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("gtu")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.TOK_CCCC().disassembly() != 14 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2053:1"]
#[derive(Clone, Debug)]
struct cond1Var4 {}
impl cond1Var4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("le")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.TOK_CCCC().disassembly() != 4 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2055:1"]
#[derive(Clone, Debug)]
struct cond1Var5 {}
impl cond1Var5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("leu")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.TOK_CCCC().disassembly() != 6 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2056:1"]
#[derive(Clone, Debug)]
struct cond1Var6 {}
impl cond1Var6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("lt")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.TOK_CCCC().disassembly() != 5 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2057:1"]
#[derive(Clone, Debug)]
struct cond1Var7 {}
impl cond1Var7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("n")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.TOK_CCCC().disassembly() != 3 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2058:1"]
#[derive(Clone, Debug)]
struct cond1Var8 {}
impl cond1Var8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("nc")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.TOK_CCCC().disassembly() != 9 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2059:1"]
#[derive(Clone, Debug)]
struct cond1Var9 {}
impl cond1Var9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("nn")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.TOK_CCCC().disassembly() != 11 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2060:1"]
#[derive(Clone, Debug)]
struct cond1Var10 {}
impl cond1Var10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("nov")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.TOK_CCCC().disassembly() != 8 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2061:1"]
#[derive(Clone, Debug)]
struct cond1Var11 {}
impl cond1Var11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("nz")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.TOK_CCCC().disassembly() != 10 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2064:1"]
#[derive(Clone, Debug)]
struct cond1Var12 {}
impl cond1Var12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ov")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.TOK_CCCC().disassembly() != 0 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2067:1"]
#[derive(Clone, Debug)]
struct cond1Var13 {}
impl cond1Var13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("z")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.TOK_CCCC().disassembly() != 2 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum cond1 {
    Var0(cond1Var0),
    Var1(cond1Var1),
    Var2(cond1Var2),
    Var3(cond1Var3),
    Var4(cond1Var4),
    Var5(cond1Var5),
    Var6(cond1Var6),
    Var7(cond1Var7),
    Var8(cond1Var8),
    Var9(cond1Var9),
    Var10(cond1Var10),
    Var11(cond1Var11),
    Var12(cond1Var12),
    Var13(cond1Var13),
}
impl cond1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            cond1Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cond1Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cond1Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cond1Var3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cond1Var4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cond1Var5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cond1Var6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cond1Var7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cond1Var8::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cond1Var9::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cond1Var10::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cond1Var11::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cond1Var12::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cond1Var13::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2062:1"]
#[derive(Clone, Debug)]
struct cond2Var0 {}
impl cond2Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("oa")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.TOK_CCCC().disassembly() != 12 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2063:1"]
#[derive(Clone, Debug)]
struct cond2Var1 {}
impl cond2Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ob")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.TOK_CCCC().disassembly() != 13 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2065:1"]
#[derive(Clone, Debug)]
struct cond2Var2 {}
impl cond2Var2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sa")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.TOK_CCCC().disassembly() != 14 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:2066:1"]
#[derive(Clone, Debug)]
struct cond2Var3 {}
impl cond2Var3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sb")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        if token_parser.TOK_CCCC().disassembly() != 15 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum cond2 {
    Var0(cond2Var0),
    Var1(cond2Var1),
    Var2(cond2Var2),
    Var3(cond2Var3),
}
impl cond2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            cond2Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cond2Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cond2Var2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            cond2Var3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PIC/data/languages/PIC24.sinc:5195:1"]
#[derive(Clone, Debug)]
struct TOK_9_0_U_tVar0 {}
impl TOK_9_0_U_tVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_phase_disassembly() != 2 {
            return None;
        }
        let TOK_9_0_U = token_parser.TOK_9_0_U();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TOK_9_0_U_t {
    Var0(TOK_9_0_U_tVar0),
}
impl TOK_9_0_U_t {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = TOK_9_0_U_tVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
pub fn parse_instruction<T>(
    tokens: &[u8],
    context: &mut T,
    inst_start: u32,
    global_set: &mut impl GlobalSetTrait,
) -> Option<(u32, Vec<DisplayElement>)>
where
    T: ContextTrait + Clone,
{
    let (inst_len, instruction) =
        instruction::parse(tokens, context, inst_start)?;
    let inst_next = inst_start + inst_len;
    let mut display = vec![];
    instruction.display_extend(
        &mut display,
        context,
        inst_start,
        inst_next,
        global_set,
    );
    Some((inst_next, display))
}
