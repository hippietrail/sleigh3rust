pub type AddrType = u32;
macro_rules! impl_read_to_type {
    ($ unsigned_type : ty , $ signed_type : ty , $ len : literal , $ read_unsigned : ident , $ read_signed : ident , $ write_unsigned : ident , $ write_signed : ident) => {
        const fn $read_unsigned<const BIG_ENDIAN: bool>(
            data: [u8; $len],
            start_bit: usize,
            len_bits: usize,
        ) -> $unsigned_type {
            const TYPE_BITS: usize = <$unsigned_type>::BITS as usize;
            assert!(TYPE_BITS / 8 == $len);
            assert!(len_bits > 0);
            assert!(len_bits + start_bit <= TYPE_BITS);
            let mut data = if BIG_ENDIAN {
                <$unsigned_type>::from_be_bytes(data)
            } else {
                <$unsigned_type>::from_le_bytes(data)
            };
            let value_mask = <$unsigned_type>::MAX >> (TYPE_BITS - len_bits);
            data = data >> start_bit;
            data = data & value_mask;
            data
        }
        const fn $read_signed<const BIG_ENDIAN: bool>(
            data: [u8; $len],
            start_bit: usize,
            len_bits: usize,
        ) -> $signed_type {
            const TYPE_BITS: usize = <$signed_type>::BITS as usize;
            assert!(len_bits > 1);
            assert!(TYPE_BITS / 8 == $len);
            let data = $read_unsigned::<BIG_ENDIAN>(data, start_bit, len_bits);
            let value_mask =
                <$signed_type>::MAX as $unsigned_type >> (TYPE_BITS - len_bits);
            let sign_mask = !value_mask;
            let value_part = data & value_mask;
            let sign_part = data & sign_mask;
            if sign_part != 0 {
                sign_mask as $signed_type | value_part as $signed_type
            } else {
                data as $signed_type
            }
        }
        const fn $write_unsigned<const BIG_ENDIAN: bool>(
            value: $unsigned_type,
            mem: $unsigned_type,
            start_bit: usize,
            len_bits: usize,
        ) -> [u8; $len] {
            const TYPE_BITS: usize = <$unsigned_type>::BITS as usize;
            assert!(len_bits > 0);
            assert!(len_bits + start_bit <= TYPE_BITS);
            let value_max = <$unsigned_type>::MAX >> (TYPE_BITS - len_bits);
            let mask = value_max << start_bit;
            let mut value = value;
            value <<= start_bit;
            value = (mem & !mask) | value;
            if BIG_ENDIAN {
                value.to_be_bytes()
            } else {
                value.to_le_bytes()
            }
        }
        const fn $write_signed<const BIG_ENDIAN: bool>(
            value: $signed_type,
            mem: $signed_type,
            start_bit: usize,
            len_bits: usize,
        ) -> [u8; $len] {
            const TYPE_BITS: usize = <$unsigned_type>::BITS as usize;
            assert!(len_bits > 0);
            assert!(len_bits + start_bit <= TYPE_BITS);
            let value_max = <$signed_type>::MAX >> (TYPE_BITS - len_bits);
            let value_min = <$signed_type>::MIN >> (TYPE_BITS - len_bits);
            let mask = <$unsigned_type>::MAX >> (TYPE_BITS - len_bits);
            let value = value as $unsigned_type & mask;
            let mem = mem as $unsigned_type;
            $write_unsigned::<BIG_ENDIAN>(value, mem, start_bit, len_bits)
        }
    };
}
impl_read_to_type!(u8, i8, 1, read_u8, read_i8, write_u8, write_i8);
impl_read_to_type!(u16, i16, 2, read_u16, read_i16, write_u16, write_i16);
impl_read_to_type!(u32, i32, 4, read_u32, read_i32, write_u32, write_i32);
impl_read_to_type!(u64, i64, 8, read_u64, read_i64, write_u64, write_i64);
impl_read_to_type!(
    u128, i128, 16, read_u128, read_i128, write_u128, write_i128
);
pub trait GlobalSetTrait {
    fn set_linkreg(&mut self, address: Option<u32>, value: i64);
    fn set_vle(&mut self, address: Option<u32>, value: i64);
    fn set_lsmul(&mut self, address: Option<u32>, value: i64);
    fn set_regp(&mut self, address: Option<u32>, value: i64);
    fn set_regpset(&mut self, address: Option<u32>, value: i64);
}
pub trait MemoryRead {
    type AddressType;
    fn read(&self, addr: Self::AddressType, buf: &mut [u8]);
}
pub trait MemoryWrite {
    type AddressType;
    fn write(&mut self, addr: Self::AddressType, buf: &[u8]);
}
pub trait ContextregisterTrait:
    MemoryRead<AddressType = u32> + MemoryWrite<AddressType = u32>
{
    fn read_linkreg_raw(&self) -> u8 {
        let mut work_value = [0u8; 1u64 as usize];
        self.read(3u64 as u32, &mut work_value[0..1]);
        let value = read_u8::<true>(work_value, 0u64 as usize, 2u64 as usize);
        u8::try_from(value).unwrap()
    }
    fn write_linkreg_raw(&mut self, param: u8) {
        let mut mem = [0u8; 1];
        self.read(3u64 as u32, &mut mem[0..1]);
        let mem = u8::from_be_bytes(mem);
        let mem =
            write_u8::<true>(param as u8, mem, 0u64 as usize, 2u64 as usize);
        self.write(3u64 as u32, &mem[0..1]);
    }
    fn read_linkreg_disassembly(&self) -> i64 {
        i64::try_from(self.read_linkreg_raw()).unwrap()
    }
    fn write_linkreg_disassembly(&mut self, param: i64) {
        self.write_linkreg_raw(param as u8)
    }
    fn read_linkreg_execution(&self) -> u8 {
        self.read_linkreg_raw()
    }
    fn write_linkreg_execution(&mut self, param: u8) {
        self.write_linkreg_raw(param)
    }
    fn linkreg_display(&self) -> DisplayElement {
        meaning_number(true, self.read_linkreg_raw())
    }
    fn read_vle_raw(&self) -> u8 {
        let mut work_value = [0u8; 1u64 as usize];
        self.read(3u64 as u32, &mut work_value[0..1]);
        let value = read_u8::<true>(work_value, 2u64 as usize, 1u64 as usize);
        u8::try_from(value).unwrap()
    }
    fn write_vle_raw(&mut self, param: u8) {
        let mut mem = [0u8; 1];
        self.read(3u64 as u32, &mut mem[0..1]);
        let mem = u8::from_be_bytes(mem);
        let mem =
            write_u8::<true>(param as u8, mem, 2u64 as usize, 1u64 as usize);
        self.write(3u64 as u32, &mem[0..1]);
    }
    fn read_vle_disassembly(&self) -> i64 {
        i64::try_from(self.read_vle_raw()).unwrap()
    }
    fn write_vle_disassembly(&mut self, param: i64) {
        self.write_vle_raw(param as u8)
    }
    fn read_vle_execution(&self) -> u8 {
        self.read_vle_raw()
    }
    fn write_vle_execution(&mut self, param: u8) {
        self.write_vle_raw(param)
    }
    fn vle_display(&self) -> DisplayElement {
        meaning_number(true, self.read_vle_raw())
    }
    fn read_lsmul_raw(&self) -> u8 {
        let mut work_value = [0u8; 1u64 as usize];
        self.read(3u64 as u32, &mut work_value[0..1]);
        let value = read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
        u8::try_from(value).unwrap()
    }
    fn write_lsmul_raw(&mut self, param: u8) {
        let mut mem = [0u8; 1];
        self.read(3u64 as u32, &mut mem[0..1]);
        let mem = u8::from_be_bytes(mem);
        let mem =
            write_u8::<true>(param as u8, mem, 3u64 as usize, 5u64 as usize);
        self.write(3u64 as u32, &mem[0..1]);
    }
    fn read_lsmul_disassembly(&self) -> i64 {
        i64::try_from(self.read_lsmul_raw()).unwrap()
    }
    fn write_lsmul_disassembly(&mut self, param: i64) {
        self.write_lsmul_raw(param as u8)
    }
    fn read_lsmul_execution(&self) -> u8 {
        self.read_lsmul_raw()
    }
    fn write_lsmul_execution(&mut self, param: u8) {
        self.write_lsmul_raw(param)
    }
    fn lsmul_display(&self) -> DisplayElement {
        meaning_number(true, self.read_lsmul_raw())
    }
    fn read_regp_raw(&self) -> u8 {
        let mut work_value = [0u8; 1u64 as usize];
        self.read(2u64 as u32, &mut work_value[0..1]);
        let value = read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
        u8::try_from(value).unwrap()
    }
    fn write_regp_raw(&mut self, param: u8) {
        let mut mem = [0u8; 1];
        self.read(2u64 as u32, &mut mem[0..1]);
        let mem = u8::from_be_bytes(mem);
        let mem =
            write_u8::<true>(param as u8, mem, 0u64 as usize, 5u64 as usize);
        self.write(2u64 as u32, &mem[0..1]);
    }
    fn read_regp_disassembly(&self) -> i64 {
        todo!()
    }
    fn write_regp_disassembly(&mut self, _param: i64) {
        todo!()
    }
    fn read_regp_execution(&self) -> u32 {
        let varnode =
            meaning_0_value(u8::try_from(self.read_regp_raw()).unwrap());
        todo!("Read from the varnode {}", varnode)
    }
    fn write_regp_execution(&mut self, param: u32) {
        let varnode =
            meaning_0_value(u8::try_from(self.read_regp_raw()).unwrap());
        todo!("Write {} into the varnode {}", param, varnode)
    }
    fn regp_display(&self) -> DisplayElement {
        meaning_0_display(self.read_regp_raw())
    }
    fn read_regpset_raw(&self) -> u8 {
        let mut work_value = [0u8; 1u64 as usize];
        self.read(2u64 as u32, &mut work_value[0..1]);
        let value = read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
        u8::try_from(value).unwrap()
    }
    fn write_regpset_raw(&mut self, param: u8) {
        let mut mem = [0u8; 1];
        self.read(2u64 as u32, &mut mem[0..1]);
        let mem = u8::from_be_bytes(mem);
        let mem =
            write_u8::<true>(param as u8, mem, 0u64 as usize, 5u64 as usize);
        self.write(2u64 as u32, &mem[0..1]);
    }
    fn read_regpset_disassembly(&self) -> i64 {
        i64::try_from(self.read_regpset_raw()).unwrap()
    }
    fn write_regpset_disassembly(&mut self, param: i64) {
        self.write_regpset_raw(param as u8)
    }
    fn read_regpset_execution(&self) -> u8 {
        self.read_regpset_raw()
    }
    fn write_regpset_execution(&mut self, param: u8) {
        self.write_regpset_raw(param)
    }
    fn regpset_display(&self) -> DisplayElement {
        meaning_number(true, self.read_regpset_raw())
    }
}
pub trait ContextTrait {
    type Typeregister: ContextregisterTrait;
    fn register(&self) -> &Self::Typeregister;
    fn register_mut(&mut self) -> &mut Self::Typeregister;
}
#[derive(Debug, Clone, Copy, Default)]
pub struct ContextregisterStruct {
    pub chunk_0x0: [u8; 4u64 as usize],
}
impl ContextregisterTrait for ContextregisterStruct {}
impl MemoryRead for ContextregisterStruct {
    type AddressType = u32;
    fn read(&self, addr: Self::AddressType, buf: &mut [u8]) {
        let addr = <u64>::try_from(addr).unwrap();
        let buf_len = <u64>::try_from(buf.len()).unwrap();
        let addr_end = addr + buf_len;
        match (addr, addr_end) {
            (0u64..=3u64, 0u64..=4u64) => {
                let start = addr - 0u64;
                let end = usize::try_from(start + buf_len).unwrap();
                let start = usize::try_from(start).unwrap();
                buf.copy_from_slice(&self.chunk_0x0[start..end]);
            }
            _ => panic!("undefined mem {}:{}", addr, buf.len()),
        }
    }
}
impl MemoryWrite for ContextregisterStruct {
    type AddressType = u32;
    fn write(&mut self, addr: Self::AddressType, buf: &[u8]) {
        let addr = <u64>::try_from(addr).unwrap();
        let buf_len = <u64>::try_from(buf.len()).unwrap();
        let addr_end = addr + buf_len;
        match (addr, addr_end) {
            (0u64..=3u64, 0u64..=4u64) => {
                let start = addr - 0u64;
                let end = usize::try_from(start + buf_len).unwrap();
                let start = usize::try_from(start).unwrap();
                self.chunk_0x0[start..end].copy_from_slice(buf);
            }
            _ => panic!("undefined mem {}:{}", addr, buf.len()),
        }
    }
}
#[derive(Debug, Clone, Copy, Default)]
pub struct SpacesStruct {
    pub register: ContextregisterStruct,
}
impl ContextTrait for SpacesStruct {
    type Typeregister = ContextregisterStruct;
    fn register(&self) -> &Self::Typeregister {
        &self.register
    }
    fn register_mut(&mut self) -> &mut Self::Typeregister {
        &mut self.register
    }
}
fn meaning_number<T>(hex: bool, num: T) -> DisplayElement
where
    i64: TryFrom<T>,
    <i64 as TryFrom<T>>::Error: core::fmt::Debug,
{
    DisplayElement::Number(hex, i64::try_from(num).unwrap())
}
fn meaning_0_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_0_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_0_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::r0,
        1 => Register::r1,
        2 => Register::r2,
        3 => Register::r3,
        4 => Register::r4,
        5 => Register::r5,
        6 => Register::r6,
        7 => Register::r7,
        8 => Register::r8,
        9 => Register::r9,
        10 => Register::r10,
        11 => Register::r11,
        12 => Register::r12,
        13 => Register::r13,
        14 => Register::r14,
        15 => Register::r15,
        16 => Register::r16,
        17 => Register::r17,
        18 => Register::r18,
        19 => Register::r19,
        20 => Register::r20,
        21 => Register::r21,
        22 => Register::r22,
        23 => Register::r23,
        24 => Register::r24,
        25 => Register::r25,
        26 => Register::r26,
        27 => Register::r27,
        28 => Register::r28,
        29 => Register::r29,
        30 => Register::r30,
        31 => Register::r31,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_1_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_1_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_1_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::cr0,
        1 => Register::cr1,
        2 => Register::cr2,
        3 => Register::cr3,
        4 => Register::cr4,
        5 => Register::cr5,
        6 => Register::cr6,
        7 => Register::cr7,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_2_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_2_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_2_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::fp_fx,
        1 => Register::fp_fex,
        2 => Register::fp_vx,
        3 => Register::fp_ox,
        4 => Register::fp_ux,
        5 => Register::fp_zx,
        6 => Register::fp_xx,
        7 => Register::fp_vxsnan,
        8 => Register::fp_vxisi,
        9 => Register::fp_vxidi,
        10 => Register::fp_vxzdz,
        11 => Register::fp_vximz,
        12 => Register::fp_vxvc,
        13 => Register::fp_fr,
        14 => Register::fp_fi,
        15 => Register::fp_c,
        16 => Register::fp_cc0,
        17 => Register::fp_cc1,
        18 => Register::fp_cc2,
        19 => Register::fp_cc3,
        20 => Register::fp_reserve1,
        21 => Register::fp_vxsoft,
        22 => Register::fp_vxsqrt,
        23 => Register::fp_vxcvi,
        24 => Register::fp_ve,
        25 => Register::fp_oe,
        26 => Register::fp_ue,
        27 => Register::fp_ze,
        28 => Register::fp_xe,
        29 => Register::fp_ni,
        30 => Register::fp_rn0,
        31 => Register::fp_rn1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_3_display<T>(num: T) -> DisplayElement
where
    u16: TryFrom<T>,
    <u16 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_3_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_3_value<T>(num: T) -> Register
where
    u16: TryFrom<T>,
    <u16 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u16::try_from(num).unwrap() {
        0 => Register::dcr000,
        1 => Register::dcr020,
        2 => Register::dcr040,
        3 => Register::dcr060,
        4 => Register::dcr080,
        5 => Register::dcr0a0,
        6 => Register::dcr0c0,
        7 => Register::dcr0e0,
        8 => Register::dcr100,
        9 => Register::dcr120,
        10 => Register::dcr140,
        11 => Register::dcr160,
        12 => Register::dcr180,
        13 => Register::dcr1a0,
        14 => Register::dcr1c0,
        15 => Register::dcr1e0,
        16 => Register::dcr200,
        17 => Register::dcr220,
        18 => Register::dcr240,
        19 => Register::dcr260,
        20 => Register::dcr280,
        21 => Register::dcr2a0,
        22 => Register::dcr2c0,
        23 => Register::dcr2e0,
        24 => Register::dcr300,
        25 => Register::dcr320,
        26 => Register::dcr340,
        27 => Register::dcr360,
        28 => Register::dcr380,
        29 => Register::dcr3a0,
        30 => Register::dcr3c0,
        31 => Register::dcr3e0,
        32 => Register::dcr001,
        33 => Register::dcr021,
        34 => Register::dcr041,
        35 => Register::dcr061,
        36 => Register::dcr081,
        37 => Register::dcr0a1,
        38 => Register::dcr0c1,
        39 => Register::dcr0e1,
        40 => Register::dcr101,
        41 => Register::dcr121,
        42 => Register::dcr141,
        43 => Register::dcr161,
        44 => Register::dcr181,
        45 => Register::dcr1a1,
        46 => Register::dcr1c1,
        47 => Register::dcr1e1,
        48 => Register::dcr201,
        49 => Register::dcr221,
        50 => Register::dcr241,
        51 => Register::dcr261,
        52 => Register::dcr281,
        53 => Register::dcr2a1,
        54 => Register::dcr2c1,
        55 => Register::dcr2e1,
        56 => Register::dcr301,
        57 => Register::dcr321,
        58 => Register::dcr341,
        59 => Register::dcr361,
        60 => Register::dcr381,
        61 => Register::dcr3a1,
        62 => Register::dcr3c1,
        63 => Register::dcr3e1,
        64 => Register::dcr002,
        65 => Register::dcr022,
        66 => Register::dcr042,
        67 => Register::dcr062,
        68 => Register::dcr082,
        69 => Register::dcr0a2,
        70 => Register::dcr0c2,
        71 => Register::dcr0e2,
        72 => Register::dcr102,
        73 => Register::dcr122,
        74 => Register::dcr142,
        75 => Register::dcr162,
        76 => Register::dcr182,
        77 => Register::dcr1a2,
        78 => Register::dcr1c2,
        79 => Register::dcr1e2,
        80 => Register::dcr202,
        81 => Register::dcr222,
        82 => Register::dcr242,
        83 => Register::dcr262,
        84 => Register::dcr282,
        85 => Register::dcr2a2,
        86 => Register::dcr2c2,
        87 => Register::dcr2e2,
        88 => Register::dcr302,
        89 => Register::dcr322,
        90 => Register::dcr342,
        91 => Register::dcr362,
        92 => Register::dcr382,
        93 => Register::dcr3a2,
        94 => Register::dcr3c2,
        95 => Register::dcr3e2,
        96 => Register::dcr003,
        97 => Register::dcr023,
        98 => Register::dcr043,
        99 => Register::dcr063,
        100 => Register::dcr083,
        101 => Register::dcr0a3,
        102 => Register::dcr0c3,
        103 => Register::dcr0e3,
        104 => Register::dcr103,
        105 => Register::dcr123,
        106 => Register::dcr143,
        107 => Register::dcr163,
        108 => Register::dcr183,
        109 => Register::dcr1a3,
        110 => Register::dcr1c3,
        111 => Register::dcr1e3,
        112 => Register::dcr203,
        113 => Register::dcr223,
        114 => Register::dcr243,
        115 => Register::dcr263,
        116 => Register::dcr283,
        117 => Register::dcr2a3,
        118 => Register::dcr2c3,
        119 => Register::dcr2e3,
        120 => Register::dcr303,
        121 => Register::dcr323,
        122 => Register::dcr343,
        123 => Register::dcr363,
        124 => Register::dcr383,
        125 => Register::dcr3a3,
        126 => Register::dcr3c3,
        127 => Register::dcr3e3,
        128 => Register::dcr004,
        129 => Register::dcr024,
        130 => Register::dcr044,
        131 => Register::dcr064,
        132 => Register::dcr084,
        133 => Register::dcr0a4,
        134 => Register::dcr0c4,
        135 => Register::dcr0e4,
        136 => Register::dcr104,
        137 => Register::dcr124,
        138 => Register::dcr144,
        139 => Register::dcr164,
        140 => Register::dcr184,
        141 => Register::dcr1a4,
        142 => Register::dcr1c4,
        143 => Register::dcr1e4,
        144 => Register::dcr204,
        145 => Register::dcr224,
        146 => Register::dcr244,
        147 => Register::dcr264,
        148 => Register::dcr284,
        149 => Register::dcr2a4,
        150 => Register::dcr2c4,
        151 => Register::dcr2e4,
        152 => Register::dcr304,
        153 => Register::dcr324,
        154 => Register::dcr344,
        155 => Register::dcr364,
        156 => Register::dcr384,
        157 => Register::dcr3a4,
        158 => Register::dcr3c4,
        159 => Register::dcr3e4,
        160 => Register::dcr005,
        161 => Register::dcr025,
        162 => Register::dcr045,
        163 => Register::dcr065,
        164 => Register::dcr085,
        165 => Register::dcr0a5,
        166 => Register::dcr0c5,
        167 => Register::dcr0e5,
        168 => Register::dcr105,
        169 => Register::dcr125,
        170 => Register::dcr145,
        171 => Register::dcr165,
        172 => Register::dcr185,
        173 => Register::dcr1a5,
        174 => Register::dcr1c5,
        175 => Register::dcr1e5,
        176 => Register::dcr205,
        177 => Register::dcr225,
        178 => Register::dcr245,
        179 => Register::dcr265,
        180 => Register::dcr285,
        181 => Register::dcr2a5,
        182 => Register::dcr2c5,
        183 => Register::dcr2e5,
        184 => Register::dcr305,
        185 => Register::dcr325,
        186 => Register::dcr345,
        187 => Register::dcr365,
        188 => Register::dcr385,
        189 => Register::dcr3a5,
        190 => Register::dcr3c5,
        191 => Register::dcr3e5,
        192 => Register::dcr006,
        193 => Register::dcr026,
        194 => Register::dcr046,
        195 => Register::dcr066,
        196 => Register::dcr086,
        197 => Register::dcr0a6,
        198 => Register::dcr0c6,
        199 => Register::dcr0e6,
        200 => Register::dcr106,
        201 => Register::dcr126,
        202 => Register::dcr146,
        203 => Register::dcr166,
        204 => Register::dcr186,
        205 => Register::dcr1a6,
        206 => Register::dcr1c6,
        207 => Register::dcr1e6,
        208 => Register::dcr206,
        209 => Register::dcr226,
        210 => Register::dcr246,
        211 => Register::dcr266,
        212 => Register::dcr286,
        213 => Register::dcr2a6,
        214 => Register::dcr2c6,
        215 => Register::dcr2e6,
        216 => Register::dcr306,
        217 => Register::dcr326,
        218 => Register::dcr346,
        219 => Register::dcr366,
        220 => Register::dcr386,
        221 => Register::dcr3a6,
        222 => Register::dcr3c6,
        223 => Register::dcr3e6,
        224 => Register::dcr007,
        225 => Register::dcr027,
        226 => Register::dcr047,
        227 => Register::dcr067,
        228 => Register::dcr087,
        229 => Register::dcr0a7,
        230 => Register::dcr0c7,
        231 => Register::dcr0e7,
        232 => Register::dcr107,
        233 => Register::dcr127,
        234 => Register::dcr147,
        235 => Register::dcr167,
        236 => Register::dcr187,
        237 => Register::dcr1a7,
        238 => Register::dcr1c7,
        239 => Register::dcr1e7,
        240 => Register::dcr207,
        241 => Register::dcr227,
        242 => Register::dcr247,
        243 => Register::dcr267,
        244 => Register::dcr287,
        245 => Register::dcr2a7,
        246 => Register::dcr2c7,
        247 => Register::dcr2e7,
        248 => Register::dcr307,
        249 => Register::dcr327,
        250 => Register::dcr347,
        251 => Register::dcr367,
        252 => Register::dcr387,
        253 => Register::dcr3a7,
        254 => Register::dcr3c7,
        255 => Register::dcr3e7,
        256 => Register::dcr008,
        257 => Register::dcr028,
        258 => Register::dcr048,
        259 => Register::dcr068,
        260 => Register::dcr088,
        261 => Register::dcr0a8,
        262 => Register::dcr0c8,
        263 => Register::dcr0e8,
        264 => Register::dcr108,
        265 => Register::dcr128,
        266 => Register::dcr148,
        267 => Register::dcr168,
        268 => Register::dcr188,
        269 => Register::dcr1a8,
        270 => Register::dcr1c8,
        271 => Register::dcr1e8,
        272 => Register::dcr208,
        273 => Register::dcr228,
        274 => Register::dcr248,
        275 => Register::dcr268,
        276 => Register::dcr288,
        277 => Register::dcr2a8,
        278 => Register::dcr2c8,
        279 => Register::dcr2e8,
        280 => Register::dcr308,
        281 => Register::dcr328,
        282 => Register::dcr348,
        283 => Register::dcr368,
        284 => Register::dcr388,
        285 => Register::dcr3a8,
        286 => Register::dcr3c8,
        287 => Register::dcr3e8,
        288 => Register::dcr009,
        289 => Register::dcr029,
        290 => Register::dcr049,
        291 => Register::dcr069,
        292 => Register::dcr089,
        293 => Register::dcr0a9,
        294 => Register::dcr0c9,
        295 => Register::dcr0e9,
        296 => Register::dcr109,
        297 => Register::dcr129,
        298 => Register::dcr149,
        299 => Register::dcr169,
        300 => Register::dcr189,
        301 => Register::dcr1a9,
        302 => Register::dcr1c9,
        303 => Register::dcr1e9,
        304 => Register::dcr209,
        305 => Register::dcr229,
        306 => Register::dcr249,
        307 => Register::dcr269,
        308 => Register::dcr289,
        309 => Register::dcr2a9,
        310 => Register::dcr2c9,
        311 => Register::dcr2e9,
        312 => Register::dcr309,
        313 => Register::dcr329,
        314 => Register::dcr349,
        315 => Register::dcr369,
        316 => Register::dcr389,
        317 => Register::dcr3a9,
        318 => Register::dcr3c9,
        319 => Register::dcr3e9,
        320 => Register::dcr00a,
        321 => Register::dcr02a,
        322 => Register::dcr04a,
        323 => Register::dcr06a,
        324 => Register::dcr08a,
        325 => Register::dcr0aa,
        326 => Register::dcr0ca,
        327 => Register::dcr0ea,
        328 => Register::dcr10a,
        329 => Register::dcr12a,
        330 => Register::dcr14a,
        331 => Register::dcr16a,
        332 => Register::dcr18a,
        333 => Register::dcr1aa,
        334 => Register::dcr1ca,
        335 => Register::dcr1ea,
        336 => Register::dcr20a,
        337 => Register::dcr22a,
        338 => Register::dcr24a,
        339 => Register::dcr26a,
        340 => Register::dcr28a,
        341 => Register::dcr2aa,
        342 => Register::dcr2ca,
        343 => Register::dcr2ea,
        344 => Register::dcr30a,
        345 => Register::dcr32a,
        346 => Register::dcr34a,
        347 => Register::dcr36a,
        348 => Register::dcr38a,
        349 => Register::dcr3aa,
        350 => Register::dcr3ca,
        351 => Register::dcr3ea,
        352 => Register::dcr00b,
        353 => Register::dcr02b,
        354 => Register::dcr04b,
        355 => Register::dcr06b,
        356 => Register::dcr08b,
        357 => Register::dcr0ab,
        358 => Register::dcr0cb,
        359 => Register::dcr0eb,
        360 => Register::dcr10b,
        361 => Register::dcr12b,
        362 => Register::dcr14b,
        363 => Register::dcr16b,
        364 => Register::dcr18b,
        365 => Register::dcr1ab,
        366 => Register::dcr1cb,
        367 => Register::dcr1eb,
        368 => Register::dcr20b,
        369 => Register::dcr22b,
        370 => Register::dcr24b,
        371 => Register::dcr26b,
        372 => Register::dcr28b,
        373 => Register::dcr2ab,
        374 => Register::dcr2cb,
        375 => Register::dcr2eb,
        376 => Register::dcr30b,
        377 => Register::dcr32b,
        378 => Register::dcr34b,
        379 => Register::dcr36b,
        380 => Register::dcr38b,
        381 => Register::dcr3ab,
        382 => Register::dcr3cb,
        383 => Register::dcr3eb,
        384 => Register::dcr00c,
        385 => Register::dcr02c,
        386 => Register::dcr04c,
        387 => Register::dcr06c,
        388 => Register::dcr08c,
        389 => Register::dcr0ac,
        390 => Register::dcr0cc,
        391 => Register::dcr0ec,
        392 => Register::dcr10c,
        393 => Register::dcr12c,
        394 => Register::dcr14c,
        395 => Register::dcr16c,
        396 => Register::dcr18c,
        397 => Register::dcr1ac,
        398 => Register::dcr1cc,
        399 => Register::dcr1ec,
        400 => Register::dcr20c,
        401 => Register::dcr22c,
        402 => Register::dcr24c,
        403 => Register::dcr26c,
        404 => Register::dcr28c,
        405 => Register::dcr2ac,
        406 => Register::dcr2cc,
        407 => Register::dcr2ec,
        408 => Register::dcr30c,
        409 => Register::dcr32c,
        410 => Register::dcr34c,
        411 => Register::dcr36c,
        412 => Register::dcr38c,
        413 => Register::dcr3ac,
        414 => Register::dcr3cc,
        415 => Register::dcr3ec,
        416 => Register::dcr00d,
        417 => Register::dcr02d,
        418 => Register::dcr04d,
        419 => Register::dcr06d,
        420 => Register::dcr08d,
        421 => Register::dcr0ad,
        422 => Register::dcr0cd,
        423 => Register::dcr0ed,
        424 => Register::dcr10d,
        425 => Register::dcr12d,
        426 => Register::dcr14d,
        427 => Register::dcr16d,
        428 => Register::dcr18d,
        429 => Register::dcr1ad,
        430 => Register::dcr1cd,
        431 => Register::dcr1ed,
        432 => Register::dcr20d,
        433 => Register::dcr22d,
        434 => Register::dcr24d,
        435 => Register::dcr26d,
        436 => Register::dcr28d,
        437 => Register::dcr2ad,
        438 => Register::dcr2cd,
        439 => Register::dcr2ed,
        440 => Register::dcr30d,
        441 => Register::dcr32d,
        442 => Register::dcr34d,
        443 => Register::dcr36d,
        444 => Register::dcr38d,
        445 => Register::dcr3ad,
        446 => Register::dcr3cd,
        447 => Register::dcr3ed,
        448 => Register::dcr00e,
        449 => Register::dcr02e,
        450 => Register::dcr04e,
        451 => Register::dcr06e,
        452 => Register::dcr08e,
        453 => Register::dcr0ae,
        454 => Register::dcr0ce,
        455 => Register::dcr0ee,
        456 => Register::dcr10e,
        457 => Register::dcr12e,
        458 => Register::dcr14e,
        459 => Register::dcr16e,
        460 => Register::dcr18e,
        461 => Register::dcr1ae,
        462 => Register::dcr1ce,
        463 => Register::dcr1ee,
        464 => Register::dcr20e,
        465 => Register::dcr22e,
        466 => Register::dcr24e,
        467 => Register::dcr26e,
        468 => Register::dcr28e,
        469 => Register::dcr2ae,
        470 => Register::dcr2ce,
        471 => Register::dcr2ee,
        472 => Register::dcr30e,
        473 => Register::dcr32e,
        474 => Register::dcr34e,
        475 => Register::dcr36e,
        476 => Register::dcr38e,
        477 => Register::dcr3ae,
        478 => Register::dcr3ce,
        479 => Register::dcr3ee,
        480 => Register::dcr00f,
        481 => Register::dcr02f,
        482 => Register::dcr04f,
        483 => Register::dcr06f,
        484 => Register::dcr08f,
        485 => Register::dcr0af,
        486 => Register::dcr0cf,
        487 => Register::dcr0ef,
        488 => Register::dcr10f,
        489 => Register::dcr12f,
        490 => Register::dcr14f,
        491 => Register::dcr16f,
        492 => Register::dcr18f,
        493 => Register::dcr1af,
        494 => Register::dcr1cf,
        495 => Register::dcr1ef,
        496 => Register::dcr20f,
        497 => Register::dcr22f,
        498 => Register::dcr24f,
        499 => Register::dcr26f,
        500 => Register::dcr28f,
        501 => Register::dcr2af,
        502 => Register::dcr2cf,
        503 => Register::dcr2ef,
        504 => Register::dcr30f,
        505 => Register::dcr32f,
        506 => Register::dcr34f,
        507 => Register::dcr36f,
        508 => Register::dcr38f,
        509 => Register::dcr3af,
        510 => Register::dcr3cf,
        511 => Register::dcr3ef,
        512 => Register::dcr010,
        513 => Register::dcr030,
        514 => Register::dcr050,
        515 => Register::dcr070,
        516 => Register::dcr090,
        517 => Register::dcr0b0,
        518 => Register::dcr0d0,
        519 => Register::dcr0f0,
        520 => Register::dcr110,
        521 => Register::dcr130,
        522 => Register::dcr150,
        523 => Register::dcr170,
        524 => Register::dcr190,
        525 => Register::dcr1b0,
        526 => Register::dcr1d0,
        527 => Register::dcr1f0,
        528 => Register::dcr210,
        529 => Register::dcr230,
        530 => Register::dcr250,
        531 => Register::dcr270,
        532 => Register::dcr290,
        533 => Register::dcr2b0,
        534 => Register::dcr2d0,
        535 => Register::dcr2f0,
        536 => Register::dcr310,
        537 => Register::dcr330,
        538 => Register::dcr350,
        539 => Register::dcr370,
        540 => Register::dcr390,
        541 => Register::dcr3b0,
        542 => Register::dcr3d0,
        543 => Register::dcr3f0,
        544 => Register::dcr011,
        545 => Register::dcr031,
        546 => Register::dcr051,
        547 => Register::dcr071,
        548 => Register::dcr091,
        549 => Register::dcr0b1,
        550 => Register::dcr0d1,
        551 => Register::dcr0f1,
        552 => Register::dcr111,
        553 => Register::dcr131,
        554 => Register::dcr151,
        555 => Register::dcr171,
        556 => Register::dcr191,
        557 => Register::dcr1b1,
        558 => Register::dcr1d1,
        559 => Register::dcr1f1,
        560 => Register::dcr211,
        561 => Register::dcr231,
        562 => Register::dcr251,
        563 => Register::dcr271,
        564 => Register::dcr291,
        565 => Register::dcr2b1,
        566 => Register::dcr2d1,
        567 => Register::dcr2f1,
        568 => Register::dcr311,
        569 => Register::dcr331,
        570 => Register::dcr351,
        571 => Register::dcr371,
        572 => Register::dcr391,
        573 => Register::dcr3b1,
        574 => Register::dcr3d1,
        575 => Register::dcr3f1,
        576 => Register::dcr012,
        577 => Register::dcr032,
        578 => Register::dcr052,
        579 => Register::dcr072,
        580 => Register::dcr092,
        581 => Register::dcr0b2,
        582 => Register::dcr0d2,
        583 => Register::dcr0f2,
        584 => Register::dcr112,
        585 => Register::dcr132,
        586 => Register::dcr152,
        587 => Register::dcr172,
        588 => Register::dcr192,
        589 => Register::dcr1b2,
        590 => Register::dcr1d2,
        591 => Register::dcr1f2,
        592 => Register::dcr212,
        593 => Register::dcr232,
        594 => Register::dcr252,
        595 => Register::dcr272,
        596 => Register::dcr292,
        597 => Register::dcr2b2,
        598 => Register::dcr2d2,
        599 => Register::dcr2f2,
        600 => Register::dcr312,
        601 => Register::dcr332,
        602 => Register::dcr352,
        603 => Register::dcr372,
        604 => Register::dcr392,
        605 => Register::dcr3b2,
        606 => Register::dcr3d2,
        607 => Register::dcr3f2,
        608 => Register::dcr013,
        609 => Register::dcr033,
        610 => Register::dcr053,
        611 => Register::dcr073,
        612 => Register::dcr093,
        613 => Register::dcr0b3,
        614 => Register::dcr0d3,
        615 => Register::dcr0f3,
        616 => Register::dcr113,
        617 => Register::dcr133,
        618 => Register::dcr153,
        619 => Register::dcr173,
        620 => Register::dcr193,
        621 => Register::dcr1b3,
        622 => Register::dcr1d3,
        623 => Register::dcr1f3,
        624 => Register::dcr213,
        625 => Register::dcr233,
        626 => Register::dcr253,
        627 => Register::dcr273,
        628 => Register::dcr293,
        629 => Register::dcr2b3,
        630 => Register::dcr2d3,
        631 => Register::dcr2f3,
        632 => Register::dcr313,
        633 => Register::dcr333,
        634 => Register::dcr353,
        635 => Register::dcr373,
        636 => Register::dcr393,
        637 => Register::dcr3b3,
        638 => Register::dcr3d3,
        639 => Register::dcr3f3,
        640 => Register::dcr014,
        641 => Register::dcr034,
        642 => Register::dcr054,
        643 => Register::dcr074,
        644 => Register::dcr094,
        645 => Register::dcr0b4,
        646 => Register::dcr0d4,
        647 => Register::dcr0f4,
        648 => Register::dcr114,
        649 => Register::dcr134,
        650 => Register::dcr154,
        651 => Register::dcr174,
        652 => Register::dcr194,
        653 => Register::dcr1b4,
        654 => Register::dcr1d4,
        655 => Register::dcr1f4,
        656 => Register::dcr214,
        657 => Register::dcr234,
        658 => Register::dcr254,
        659 => Register::dcr274,
        660 => Register::dcr294,
        661 => Register::dcr2b4,
        662 => Register::dcr2d4,
        663 => Register::dcr2f4,
        664 => Register::dcr314,
        665 => Register::dcr334,
        666 => Register::dcr354,
        667 => Register::dcr374,
        668 => Register::dcr394,
        669 => Register::dcr3b4,
        670 => Register::dcr3d4,
        671 => Register::dcr3f4,
        672 => Register::dcr015,
        673 => Register::dcr035,
        674 => Register::dcr055,
        675 => Register::dcr075,
        676 => Register::dcr095,
        677 => Register::dcr0b5,
        678 => Register::dcr0d5,
        679 => Register::dcr0f5,
        680 => Register::dcr115,
        681 => Register::dcr135,
        682 => Register::dcr155,
        683 => Register::dcr175,
        684 => Register::dcr195,
        685 => Register::dcr1b5,
        686 => Register::dcr1d5,
        687 => Register::dcr1f5,
        688 => Register::dcr215,
        689 => Register::dcr235,
        690 => Register::dcr255,
        691 => Register::dcr275,
        692 => Register::dcr295,
        693 => Register::dcr2b5,
        694 => Register::dcr2d5,
        695 => Register::dcr2f5,
        696 => Register::dcr315,
        697 => Register::dcr335,
        698 => Register::dcr355,
        699 => Register::dcr375,
        700 => Register::dcr395,
        701 => Register::dcr3b5,
        702 => Register::dcr3d5,
        703 => Register::dcr3f5,
        704 => Register::dcr016,
        705 => Register::dcr036,
        706 => Register::dcr056,
        707 => Register::dcr076,
        708 => Register::dcr096,
        709 => Register::dcr0b6,
        710 => Register::dcr0d6,
        711 => Register::dcr0f6,
        712 => Register::dcr116,
        713 => Register::dcr136,
        714 => Register::dcr156,
        715 => Register::dcr176,
        716 => Register::dcr196,
        717 => Register::dcr1b6,
        718 => Register::dcr1d6,
        719 => Register::dcr1f6,
        720 => Register::dcr216,
        721 => Register::dcr236,
        722 => Register::dcr256,
        723 => Register::dcr276,
        724 => Register::dcr296,
        725 => Register::dcr2b6,
        726 => Register::dcr2d6,
        727 => Register::dcr2f6,
        728 => Register::dcr316,
        729 => Register::dcr336,
        730 => Register::dcr356,
        731 => Register::dcr376,
        732 => Register::dcr396,
        733 => Register::dcr3b6,
        734 => Register::dcr3d6,
        735 => Register::dcr3f6,
        736 => Register::dcr017,
        737 => Register::dcr037,
        738 => Register::dcr057,
        739 => Register::dcr077,
        740 => Register::dcr097,
        741 => Register::dcr0b7,
        742 => Register::dcr0d7,
        743 => Register::dcr0f7,
        744 => Register::dcr117,
        745 => Register::dcr137,
        746 => Register::dcr157,
        747 => Register::dcr177,
        748 => Register::dcr197,
        749 => Register::dcr1b7,
        750 => Register::dcr1d7,
        751 => Register::dcr1f7,
        752 => Register::dcr217,
        753 => Register::dcr237,
        754 => Register::dcr257,
        755 => Register::dcr277,
        756 => Register::dcr297,
        757 => Register::dcr2b7,
        758 => Register::dcr2d7,
        759 => Register::dcr2f7,
        760 => Register::dcr317,
        761 => Register::dcr337,
        762 => Register::dcr357,
        763 => Register::dcr377,
        764 => Register::dcr397,
        765 => Register::dcr3b7,
        766 => Register::dcr3d7,
        767 => Register::dcr3f7,
        768 => Register::dcr018,
        769 => Register::dcr038,
        770 => Register::dcr058,
        771 => Register::dcr078,
        772 => Register::dcr098,
        773 => Register::dcr0b8,
        774 => Register::dcr0d8,
        775 => Register::dcr0f8,
        776 => Register::dcr118,
        777 => Register::dcr138,
        778 => Register::dcr158,
        779 => Register::dcr178,
        780 => Register::dcr198,
        781 => Register::dcr1b8,
        782 => Register::dcr1d8,
        783 => Register::dcr1f8,
        784 => Register::dcr218,
        785 => Register::dcr238,
        786 => Register::dcr258,
        787 => Register::dcr278,
        788 => Register::dcr298,
        789 => Register::dcr2b8,
        790 => Register::dcr2d8,
        791 => Register::dcr2f8,
        792 => Register::dcr318,
        793 => Register::dcr338,
        794 => Register::dcr358,
        795 => Register::dcr378,
        796 => Register::dcr398,
        797 => Register::dcr3b8,
        798 => Register::dcr3d8,
        799 => Register::dcr3f8,
        800 => Register::dcr019,
        801 => Register::dcr039,
        802 => Register::dcr059,
        803 => Register::dcr079,
        804 => Register::dcr099,
        805 => Register::dcr0b9,
        806 => Register::dcr0d9,
        807 => Register::dcr0f9,
        808 => Register::dcr119,
        809 => Register::dcr139,
        810 => Register::dcr159,
        811 => Register::dcr179,
        812 => Register::dcr199,
        813 => Register::dcr1b9,
        814 => Register::dcr1d9,
        815 => Register::dcr1f9,
        816 => Register::dcr219,
        817 => Register::dcr239,
        818 => Register::dcr259,
        819 => Register::dcr279,
        820 => Register::dcr299,
        821 => Register::dcr2b9,
        822 => Register::dcr2d9,
        823 => Register::dcr2f9,
        824 => Register::dcr319,
        825 => Register::dcr339,
        826 => Register::dcr359,
        827 => Register::dcr379,
        828 => Register::dcr399,
        829 => Register::dcr3b9,
        830 => Register::dcr3d9,
        831 => Register::dcr3f9,
        832 => Register::dcr01a,
        833 => Register::dcr03a,
        834 => Register::dcr05a,
        835 => Register::dcr07a,
        836 => Register::dcr09a,
        837 => Register::dcr0ba,
        838 => Register::dcr0da,
        839 => Register::dcr0fa,
        840 => Register::dcr11a,
        841 => Register::dcr13a,
        842 => Register::dcr15a,
        843 => Register::dcr17a,
        844 => Register::dcr19a,
        845 => Register::dcr1ba,
        846 => Register::dcr1da,
        847 => Register::dcr1fa,
        848 => Register::dcr21a,
        849 => Register::dcr23a,
        850 => Register::dcr25a,
        851 => Register::dcr27a,
        852 => Register::dcr29a,
        853 => Register::dcr2ba,
        854 => Register::dcr2da,
        855 => Register::dcr2fa,
        856 => Register::dcr31a,
        857 => Register::dcr33a,
        858 => Register::dcr35a,
        859 => Register::dcr37a,
        860 => Register::dcr39a,
        861 => Register::dcr3ba,
        862 => Register::dcr3da,
        863 => Register::dcr3fa,
        864 => Register::dcr01b,
        865 => Register::dcr03b,
        866 => Register::dcr05b,
        867 => Register::dcr07b,
        868 => Register::dcr09b,
        869 => Register::dcr0bb,
        870 => Register::dcr0db,
        871 => Register::dcr0fb,
        872 => Register::dcr11b,
        873 => Register::dcr13b,
        874 => Register::dcr15b,
        875 => Register::dcr17b,
        876 => Register::dcr19b,
        877 => Register::dcr1bb,
        878 => Register::dcr1db,
        879 => Register::dcr1fb,
        880 => Register::dcr21b,
        881 => Register::dcr23b,
        882 => Register::dcr25b,
        883 => Register::dcr27b,
        884 => Register::dcr29b,
        885 => Register::dcr2bb,
        886 => Register::dcr2db,
        887 => Register::dcr2fb,
        888 => Register::dcr31b,
        889 => Register::dcr33b,
        890 => Register::dcr35b,
        891 => Register::dcr37b,
        892 => Register::dcr39b,
        893 => Register::dcr3bb,
        894 => Register::dcr3db,
        895 => Register::dcr3fb,
        896 => Register::dcr01c,
        897 => Register::dcr03c,
        898 => Register::dcr05c,
        899 => Register::dcr07c,
        900 => Register::dcr09c,
        901 => Register::dcr0bc,
        902 => Register::dcr0dc,
        903 => Register::dcr0fc,
        904 => Register::dcr11c,
        905 => Register::dcr13c,
        906 => Register::dcr15c,
        907 => Register::dcr17c,
        908 => Register::dcr19c,
        909 => Register::dcr1bc,
        910 => Register::dcr1dc,
        911 => Register::dcr1fc,
        912 => Register::dcr21c,
        913 => Register::dcr23c,
        914 => Register::dcr25c,
        915 => Register::dcr27c,
        916 => Register::dcr29c,
        917 => Register::dcr2bc,
        918 => Register::dcr2dc,
        919 => Register::dcr2fc,
        920 => Register::dcr31c,
        921 => Register::dcr33c,
        922 => Register::dcr35c,
        923 => Register::dcr37c,
        924 => Register::dcr39c,
        925 => Register::dcr3bc,
        926 => Register::dcr3dc,
        927 => Register::dcr3fc,
        928 => Register::dcr01d,
        929 => Register::dcr03d,
        930 => Register::dcr05d,
        931 => Register::dcr07d,
        932 => Register::dcr09d,
        933 => Register::dcr0bd,
        934 => Register::dcr0dd,
        935 => Register::dcr0fd,
        936 => Register::dcr11d,
        937 => Register::dcr13d,
        938 => Register::dcr15d,
        939 => Register::dcr17d,
        940 => Register::dcr19d,
        941 => Register::dcr1bd,
        942 => Register::dcr1dd,
        943 => Register::dcr1fd,
        944 => Register::dcr21d,
        945 => Register::dcr23d,
        946 => Register::dcr25d,
        947 => Register::dcr27d,
        948 => Register::dcr29d,
        949 => Register::dcr2bd,
        950 => Register::dcr2dd,
        951 => Register::dcr2fd,
        952 => Register::dcr31d,
        953 => Register::dcr33d,
        954 => Register::dcr35d,
        955 => Register::dcr37d,
        956 => Register::dcr39d,
        957 => Register::dcr3bd,
        958 => Register::dcr3dd,
        959 => Register::dcr3fd,
        960 => Register::dcr01e,
        961 => Register::dcr03e,
        962 => Register::dcr05e,
        963 => Register::dcr07e,
        964 => Register::dcr09e,
        965 => Register::dcr0be,
        966 => Register::dcr0de,
        967 => Register::dcr0fe,
        968 => Register::dcr11e,
        969 => Register::dcr13e,
        970 => Register::dcr15e,
        971 => Register::dcr17e,
        972 => Register::dcr19e,
        973 => Register::dcr1be,
        974 => Register::dcr1de,
        975 => Register::dcr1fe,
        976 => Register::dcr21e,
        977 => Register::dcr23e,
        978 => Register::dcr25e,
        979 => Register::dcr27e,
        980 => Register::dcr29e,
        981 => Register::dcr2be,
        982 => Register::dcr2de,
        983 => Register::dcr2fe,
        984 => Register::dcr31e,
        985 => Register::dcr33e,
        986 => Register::dcr35e,
        987 => Register::dcr37e,
        988 => Register::dcr39e,
        989 => Register::dcr3be,
        990 => Register::dcr3de,
        991 => Register::dcr3fe,
        992 => Register::dcr01f,
        993 => Register::dcr03f,
        994 => Register::dcr05f,
        995 => Register::dcr07f,
        996 => Register::dcr09f,
        997 => Register::dcr0bf,
        998 => Register::dcr0df,
        999 => Register::dcr0ff,
        1000 => Register::dcr11f,
        1001 => Register::dcr13f,
        1002 => Register::dcr15f,
        1003 => Register::dcr17f,
        1004 => Register::dcr19f,
        1005 => Register::dcr1bf,
        1006 => Register::dcr1df,
        1007 => Register::dcr1ff,
        1008 => Register::dcr21f,
        1009 => Register::dcr23f,
        1010 => Register::dcr25f,
        1011 => Register::dcr27f,
        1012 => Register::dcr29f,
        1013 => Register::dcr2bf,
        1014 => Register::dcr2df,
        1015 => Register::dcr2ff,
        1016 => Register::dcr31f,
        1017 => Register::dcr33f,
        1018 => Register::dcr35f,
        1019 => Register::dcr37f,
        1020 => Register::dcr39f,
        1021 => Register::dcr3bf,
        1022 => Register::dcr3df,
        1023 => Register::dcr3ff,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_4_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_4_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_4_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::f0,
        1 => Register::f1,
        2 => Register::f2,
        3 => Register::f3,
        4 => Register::f4,
        5 => Register::f5,
        6 => Register::f6,
        7 => Register::f7,
        8 => Register::f8,
        9 => Register::f9,
        10 => Register::f10,
        11 => Register::f11,
        12 => Register::f12,
        13 => Register::f13,
        14 => Register::f14,
        15 => Register::f15,
        16 => Register::f16,
        17 => Register::f17,
        18 => Register::f18,
        19 => Register::f19,
        20 => Register::f20,
        21 => Register::f21,
        22 => Register::f22,
        23 => Register::f23,
        24 => Register::f24,
        25 => Register::f25,
        26 => Register::f26,
        27 => Register::f27,
        28 => Register::f28,
        29 => Register::f29,
        30 => Register::f30,
        31 => Register::f31,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_5_display<T>(num: T) -> DisplayElement
where
    u16: TryFrom<T>,
    <u16 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_5_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_5_value<T>(num: T) -> Register
where
    u16: TryFrom<T>,
    <u16 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u16::try_from(num).unwrap() {
        0 => Register::spr000,
        1 => Register::spr020,
        2 => Register::spr040,
        3 => Register::spr060,
        4 => Register::spr080,
        5 => Register::spr0a0,
        6 => Register::spr0c0,
        7 => Register::spr0e0,
        8 => Register::spr100,
        9 => Register::spr120,
        10 => Register::spr140,
        11 => Register::spr160,
        12 => Register::spr180,
        13 => Register::spr1a0,
        14 => Register::spr1c0,
        15 => Register::spr1e0,
        16 => Register::spr200,
        17 => Register::spr220,
        18 => Register::spr240,
        19 => Register::spr260,
        20 => Register::spr280,
        21 => Register::spr2a0,
        22 => Register::spr2c0,
        23 => Register::spr2e0,
        24 => Register::spr300,
        25 => Register::spr320,
        26 => Register::spr340,
        27 => Register::spr360,
        28 => Register::spr380,
        29 => Register::spr3a0,
        30 => Register::spr3c0,
        31 => Register::spr3e0,
        32 => Register::XER,
        33 => Register::spr021,
        34 => Register::spr041,
        35 => Register::spr061,
        36 => Register::spr081,
        37 => Register::spr0a1,
        38 => Register::spr0c1,
        39 => Register::spr0e1,
        40 => Register::spr101,
        41 => Register::spr121,
        42 => Register::spr141,
        43 => Register::spr161,
        44 => Register::spr181,
        45 => Register::spr1a1,
        46 => Register::spr1c1,
        47 => Register::spr1e1,
        48 => Register::spr201,
        49 => Register::spr221,
        50 => Register::spr241,
        51 => Register::spr261,
        52 => Register::spr281,
        53 => Register::spr2a1,
        54 => Register::spr2c1,
        55 => Register::spr2e1,
        56 => Register::spr301,
        57 => Register::spr321,
        58 => Register::spr341,
        59 => Register::spr361,
        60 => Register::spr381,
        61 => Register::spr3a1,
        62 => Register::spr3c1,
        63 => Register::spr3e1,
        64 => Register::spr002,
        65 => Register::spr022,
        66 => Register::spr042,
        67 => Register::spr062,
        68 => Register::spr082,
        69 => Register::spr0a2,
        70 => Register::spr0c2,
        71 => Register::spr0e2,
        72 => Register::spr102,
        73 => Register::spr122,
        74 => Register::spr142,
        75 => Register::spr162,
        76 => Register::spr182,
        77 => Register::spr1a2,
        78 => Register::spr1c2,
        79 => Register::spr1e2,
        80 => Register::spr202,
        81 => Register::spr222,
        82 => Register::spr242,
        83 => Register::spr262,
        84 => Register::spr282,
        85 => Register::spr2a2,
        86 => Register::spr2c2,
        87 => Register::spr2e2,
        88 => Register::spr302,
        89 => Register::spr322,
        90 => Register::spr342,
        91 => Register::spr362,
        92 => Register::spr382,
        93 => Register::spr3a2,
        94 => Register::spr3c2,
        95 => Register::spr3e2,
        96 => Register::spr003,
        97 => Register::spr023,
        98 => Register::spr043,
        99 => Register::spr063,
        100 => Register::spr083,
        101 => Register::spr0a3,
        102 => Register::spr0c3,
        103 => Register::spr0e3,
        104 => Register::spr103,
        105 => Register::spr123,
        106 => Register::spr143,
        107 => Register::spr163,
        108 => Register::spr183,
        109 => Register::spr1a3,
        110 => Register::spr1c3,
        111 => Register::spr1e3,
        112 => Register::spr203,
        113 => Register::spr223,
        114 => Register::spr243,
        115 => Register::spr263,
        116 => Register::spr283,
        117 => Register::spr2a3,
        118 => Register::spr2c3,
        119 => Register::spr2e3,
        120 => Register::spr303,
        121 => Register::spr323,
        122 => Register::spr343,
        123 => Register::spr363,
        124 => Register::spr383,
        125 => Register::spr3a3,
        126 => Register::spr3c3,
        127 => Register::spr3e3,
        128 => Register::spr004,
        129 => Register::spr024,
        130 => Register::spr044,
        131 => Register::spr064,
        132 => Register::spr084,
        133 => Register::spr0a4,
        134 => Register::spr0c4,
        135 => Register::spr0e4,
        136 => Register::spr104,
        137 => Register::spr124,
        138 => Register::spr144,
        139 => Register::spr164,
        140 => Register::spr184,
        141 => Register::spr1a4,
        142 => Register::spr1c4,
        143 => Register::spr1e4,
        144 => Register::spr204,
        145 => Register::spr224,
        146 => Register::spr244,
        147 => Register::spr264,
        148 => Register::spr284,
        149 => Register::spr2a4,
        150 => Register::spr2c4,
        151 => Register::spr2e4,
        152 => Register::spr304,
        153 => Register::spr324,
        154 => Register::spr344,
        155 => Register::spr364,
        156 => Register::spr384,
        157 => Register::spr3a4,
        158 => Register::spr3c4,
        159 => Register::spr3e4,
        160 => Register::spr005,
        161 => Register::spr025,
        162 => Register::spr045,
        163 => Register::spr065,
        164 => Register::spr085,
        165 => Register::spr0a5,
        166 => Register::spr0c5,
        167 => Register::spr0e5,
        168 => Register::spr105,
        169 => Register::spr125,
        170 => Register::spr145,
        171 => Register::spr165,
        172 => Register::spr185,
        173 => Register::spr1a5,
        174 => Register::spr1c5,
        175 => Register::spr1e5,
        176 => Register::spr205,
        177 => Register::spr225,
        178 => Register::spr245,
        179 => Register::spr265,
        180 => Register::spr285,
        181 => Register::spr2a5,
        182 => Register::spr2c5,
        183 => Register::spr2e5,
        184 => Register::spr305,
        185 => Register::spr325,
        186 => Register::spr345,
        187 => Register::spr365,
        188 => Register::spr385,
        189 => Register::spr3a5,
        190 => Register::spr3c5,
        191 => Register::spr3e5,
        192 => Register::spr006,
        193 => Register::spr026,
        194 => Register::spr046,
        195 => Register::spr066,
        196 => Register::spr086,
        197 => Register::spr0a6,
        198 => Register::spr0c6,
        199 => Register::spr0e6,
        200 => Register::spr106,
        201 => Register::spr126,
        202 => Register::spr146,
        203 => Register::spr166,
        204 => Register::spr186,
        205 => Register::spr1a6,
        206 => Register::spr1c6,
        207 => Register::spr1e6,
        208 => Register::spr206,
        209 => Register::spr226,
        210 => Register::spr246,
        211 => Register::spr266,
        212 => Register::spr286,
        213 => Register::spr2a6,
        214 => Register::spr2c6,
        215 => Register::spr2e6,
        216 => Register::spr306,
        217 => Register::spr326,
        218 => Register::spr346,
        219 => Register::spr366,
        220 => Register::spr386,
        221 => Register::spr3a6,
        222 => Register::spr3c6,
        223 => Register::spr3e6,
        224 => Register::spr007,
        225 => Register::spr027,
        226 => Register::spr047,
        227 => Register::spr067,
        228 => Register::spr087,
        229 => Register::spr0a7,
        230 => Register::spr0c7,
        231 => Register::spr0e7,
        232 => Register::spr107,
        233 => Register::spr127,
        234 => Register::spr147,
        235 => Register::spr167,
        236 => Register::spr187,
        237 => Register::spr1a7,
        238 => Register::spr1c7,
        239 => Register::spr1e7,
        240 => Register::spr207,
        241 => Register::spr227,
        242 => Register::spr247,
        243 => Register::spr267,
        244 => Register::spr287,
        245 => Register::spr2a7,
        246 => Register::spr2c7,
        247 => Register::spr2e7,
        248 => Register::spr307,
        249 => Register::spr327,
        250 => Register::spr347,
        251 => Register::spr367,
        252 => Register::spr387,
        253 => Register::spr3a7,
        254 => Register::spr3c7,
        255 => Register::spr3e7,
        256 => Register::LR,
        257 => Register::spr028,
        258 => Register::spr048,
        259 => Register::spr068,
        260 => Register::spr088,
        261 => Register::spr0a8,
        262 => Register::spr0c8,
        263 => Register::spr0e8,
        264 => Register::spr108,
        265 => Register::spr128,
        266 => Register::spr148,
        267 => Register::spr168,
        268 => Register::spr188,
        269 => Register::spr1a8,
        270 => Register::spr1c8,
        271 => Register::spr1e8,
        272 => Register::spr208,
        273 => Register::spr228,
        274 => Register::spr248,
        275 => Register::spr268,
        276 => Register::spr288,
        277 => Register::spr2a8,
        278 => Register::spr2c8,
        279 => Register::spr2e8,
        280 => Register::spr308,
        281 => Register::spr328,
        282 => Register::spr348,
        283 => Register::spr368,
        284 => Register::spr388,
        285 => Register::spr3a8,
        286 => Register::spr3c8,
        287 => Register::spr3e8,
        288 => Register::CTR,
        289 => Register::spr029,
        290 => Register::spr049,
        291 => Register::spr069,
        292 => Register::spr089,
        293 => Register::spr0a9,
        294 => Register::spr0c9,
        295 => Register::spr0e9,
        296 => Register::spr109,
        297 => Register::spr129,
        298 => Register::spr149,
        299 => Register::spr169,
        300 => Register::spr189,
        301 => Register::spr1a9,
        302 => Register::spr1c9,
        303 => Register::spr1e9,
        304 => Register::spr209,
        305 => Register::spr229,
        306 => Register::spr249,
        307 => Register::spr269,
        308 => Register::spr289,
        309 => Register::spr2a9,
        310 => Register::spr2c9,
        311 => Register::spr2e9,
        312 => Register::spr309,
        313 => Register::spr329,
        314 => Register::spr349,
        315 => Register::spr369,
        316 => Register::spr389,
        317 => Register::spr3a9,
        318 => Register::spr3c9,
        319 => Register::spr3e9,
        320 => Register::spr00a,
        321 => Register::spr02a,
        322 => Register::spr04a,
        323 => Register::spr06a,
        324 => Register::spr08a,
        325 => Register::spr0aa,
        326 => Register::spr0ca,
        327 => Register::spr0ea,
        328 => Register::spr10a,
        329 => Register::spr12a,
        330 => Register::spr14a,
        331 => Register::spr16a,
        332 => Register::spr18a,
        333 => Register::spr1aa,
        334 => Register::spr1ca,
        335 => Register::spr1ea,
        336 => Register::spr20a,
        337 => Register::spr22a,
        338 => Register::spr24a,
        339 => Register::spr26a,
        340 => Register::spr28a,
        341 => Register::spr2aa,
        342 => Register::spr2ca,
        343 => Register::spr2ea,
        344 => Register::spr30a,
        345 => Register::spr32a,
        346 => Register::spr34a,
        347 => Register::spr36a,
        348 => Register::spr38a,
        349 => Register::spr3aa,
        350 => Register::spr3ca,
        351 => Register::spr3ea,
        352 => Register::spr00b,
        353 => Register::spr02b,
        354 => Register::spr04b,
        355 => Register::spr06b,
        356 => Register::spr08b,
        357 => Register::spr0ab,
        358 => Register::spr0cb,
        359 => Register::spr0eb,
        360 => Register::spr10b,
        361 => Register::spr12b,
        362 => Register::spr14b,
        363 => Register::spr16b,
        364 => Register::spr18b,
        365 => Register::spr1ab,
        366 => Register::spr1cb,
        367 => Register::spr1eb,
        368 => Register::spr20b,
        369 => Register::spr22b,
        370 => Register::spr24b,
        371 => Register::spr26b,
        372 => Register::spr28b,
        373 => Register::spr2ab,
        374 => Register::spr2cb,
        375 => Register::spr2eb,
        376 => Register::spr30b,
        377 => Register::spr32b,
        378 => Register::spr34b,
        379 => Register::spr36b,
        380 => Register::spr38b,
        381 => Register::spr3ab,
        382 => Register::spr3cb,
        383 => Register::spr3eb,
        384 => Register::spr00c,
        385 => Register::spr02c,
        386 => Register::spr04c,
        387 => Register::spr06c,
        388 => Register::spr08c,
        389 => Register::spr0ac,
        390 => Register::spr0cc,
        391 => Register::spr0ec,
        392 => Register::TBLr,
        393 => Register::spr12c,
        394 => Register::spr14c,
        395 => Register::spr16c,
        396 => Register::spr18c,
        397 => Register::spr1ac,
        398 => Register::spr1cc,
        399 => Register::spr1ec,
        400 => Register::spr20c,
        401 => Register::spr22c,
        402 => Register::spr24c,
        403 => Register::spr26c,
        404 => Register::spr28c,
        405 => Register::spr2ac,
        406 => Register::spr2cc,
        407 => Register::spr2ec,
        408 => Register::spr30c,
        409 => Register::spr32c,
        410 => Register::spr34c,
        411 => Register::spr36c,
        412 => Register::spr38c,
        413 => Register::spr3ac,
        414 => Register::spr3cc,
        415 => Register::spr3ec,
        416 => Register::spr00d,
        417 => Register::spr02d,
        418 => Register::spr04d,
        419 => Register::spr06d,
        420 => Register::spr08d,
        421 => Register::spr0ad,
        422 => Register::spr0cd,
        423 => Register::spr0ed,
        424 => Register::TBUr,
        425 => Register::spr12d,
        426 => Register::spr14d,
        427 => Register::spr16d,
        428 => Register::spr18d,
        429 => Register::spr1ad,
        430 => Register::spr1cd,
        431 => Register::spr1ed,
        432 => Register::spr20d,
        433 => Register::spr22d,
        434 => Register::spr24d,
        435 => Register::spr26d,
        436 => Register::spr28d,
        437 => Register::spr2ad,
        438 => Register::spr2cd,
        439 => Register::spr2ed,
        440 => Register::spr30d,
        441 => Register::spr32d,
        442 => Register::spr34d,
        443 => Register::spr36d,
        444 => Register::spr38d,
        445 => Register::spr3ad,
        446 => Register::spr3cd,
        447 => Register::spr3ed,
        448 => Register::spr00e,
        449 => Register::spr02e,
        450 => Register::spr04e,
        451 => Register::spr06e,
        452 => Register::spr08e,
        453 => Register::spr0ae,
        454 => Register::spr0ce,
        455 => Register::spr0ee,
        456 => Register::spr10e,
        457 => Register::spr12e,
        458 => Register::spr14e,
        459 => Register::spr16e,
        460 => Register::spr18e,
        461 => Register::spr1ae,
        462 => Register::spr1ce,
        463 => Register::spr1ee,
        464 => Register::spr20e,
        465 => Register::spr22e,
        466 => Register::spr24e,
        467 => Register::spr26e,
        468 => Register::spr28e,
        469 => Register::spr2ae,
        470 => Register::spr2ce,
        471 => Register::spr2ee,
        472 => Register::spr30e,
        473 => Register::spr32e,
        474 => Register::spr34e,
        475 => Register::spr36e,
        476 => Register::spr38e,
        477 => Register::spr3ae,
        478 => Register::spr3ce,
        479 => Register::spr3ee,
        480 => Register::spr00f,
        481 => Register::spr02f,
        482 => Register::spr04f,
        483 => Register::spr06f,
        484 => Register::spr08f,
        485 => Register::spr0af,
        486 => Register::spr0cf,
        487 => Register::spr0ef,
        488 => Register::spr10f,
        489 => Register::spr12f,
        490 => Register::spr14f,
        491 => Register::spr16f,
        492 => Register::spr18f,
        493 => Register::spr1af,
        494 => Register::spr1cf,
        495 => Register::spr1ef,
        496 => Register::spr20f,
        497 => Register::spr22f,
        498 => Register::spr24f,
        499 => Register::spr26f,
        500 => Register::spr28f,
        501 => Register::spr2af,
        502 => Register::spr2cf,
        503 => Register::spr2ef,
        504 => Register::spr30f,
        505 => Register::TAR,
        506 => Register::spr34f,
        507 => Register::spr36f,
        508 => Register::spr38f,
        509 => Register::spr3af,
        510 => Register::spr3cf,
        511 => Register::spr3ef,
        512 => Register::spr010,
        513 => Register::spr030,
        514 => Register::spr050,
        515 => Register::spr070,
        516 => Register::spr090,
        517 => Register::spr0b0,
        518 => Register::spr0d0,
        519 => Register::spr0f0,
        520 => Register::spr110,
        521 => Register::spr130,
        522 => Register::spr150,
        523 => Register::spr170,
        524 => Register::spr190,
        525 => Register::spr1b0,
        526 => Register::spr1d0,
        527 => Register::spr1f0,
        528 => Register::spr210,
        529 => Register::spr230,
        530 => Register::spr250,
        531 => Register::spr270,
        532 => Register::spr290,
        533 => Register::spr2b0,
        534 => Register::spr2d0,
        535 => Register::spr2f0,
        536 => Register::spr310,
        537 => Register::spr330,
        538 => Register::spr350,
        539 => Register::spr370,
        540 => Register::spr390,
        541 => Register::spr3b0,
        542 => Register::spr3d0,
        543 => Register::spr3f0,
        544 => Register::spr011,
        545 => Register::spr031,
        546 => Register::spr051,
        547 => Register::spr071,
        548 => Register::spr091,
        549 => Register::spr0b1,
        550 => Register::spr0d1,
        551 => Register::spr0f1,
        552 => Register::spr111,
        553 => Register::spr131,
        554 => Register::spr151,
        555 => Register::spr171,
        556 => Register::spr191,
        557 => Register::spr1b1,
        558 => Register::spr1d1,
        559 => Register::spr1f1,
        560 => Register::spr211,
        561 => Register::spr231,
        562 => Register::spr251,
        563 => Register::spr271,
        564 => Register::spr291,
        565 => Register::spr2b1,
        566 => Register::spr2d1,
        567 => Register::spr2f1,
        568 => Register::spr311,
        569 => Register::spr331,
        570 => Register::spr351,
        571 => Register::spr371,
        572 => Register::spr391,
        573 => Register::spr3b1,
        574 => Register::spr3d1,
        575 => Register::spr3f1,
        576 => Register::spr012,
        577 => Register::spr032,
        578 => Register::spr052,
        579 => Register::spr072,
        580 => Register::spr092,
        581 => Register::spr0b2,
        582 => Register::spr0d2,
        583 => Register::spr0f2,
        584 => Register::spr112,
        585 => Register::spr132,
        586 => Register::spr152,
        587 => Register::spr172,
        588 => Register::spr192,
        589 => Register::spr1b2,
        590 => Register::spr1d2,
        591 => Register::spr1f2,
        592 => Register::spr212,
        593 => Register::spr232,
        594 => Register::spr252,
        595 => Register::spr272,
        596 => Register::spr292,
        597 => Register::spr2b2,
        598 => Register::spr2d2,
        599 => Register::spr2f2,
        600 => Register::spr312,
        601 => Register::spr332,
        602 => Register::spr352,
        603 => Register::spr372,
        604 => Register::spr392,
        605 => Register::spr3b2,
        606 => Register::spr3d2,
        607 => Register::spr3f2,
        608 => Register::spr013,
        609 => Register::spr033,
        610 => Register::spr053,
        611 => Register::spr073,
        612 => Register::spr093,
        613 => Register::spr0b3,
        614 => Register::spr0d3,
        615 => Register::spr0f3,
        616 => Register::spr113,
        617 => Register::spr133,
        618 => Register::spr153,
        619 => Register::spr173,
        620 => Register::spr193,
        621 => Register::spr1b3,
        622 => Register::spr1d3,
        623 => Register::spr1f3,
        624 => Register::spr213,
        625 => Register::spr233,
        626 => Register::spr253,
        627 => Register::spr273,
        628 => Register::spr293,
        629 => Register::spr2b3,
        630 => Register::spr2d3,
        631 => Register::spr2f3,
        632 => Register::spr313,
        633 => Register::spr333,
        634 => Register::spr353,
        635 => Register::spr373,
        636 => Register::spr393,
        637 => Register::spr3b3,
        638 => Register::spr3d3,
        639 => Register::spr3f3,
        640 => Register::spr014,
        641 => Register::spr034,
        642 => Register::spr054,
        643 => Register::spr074,
        644 => Register::spr094,
        645 => Register::spr0b4,
        646 => Register::spr0d4,
        647 => Register::spr0f4,
        648 => Register::spr114,
        649 => Register::spr134,
        650 => Register::spr154,
        651 => Register::spr174,
        652 => Register::spr194,
        653 => Register::spr1b4,
        654 => Register::spr1d4,
        655 => Register::spr1f4,
        656 => Register::spr214,
        657 => Register::spr234,
        658 => Register::spr254,
        659 => Register::spr274,
        660 => Register::spr294,
        661 => Register::spr2b4,
        662 => Register::spr2d4,
        663 => Register::spr2f4,
        664 => Register::spr314,
        665 => Register::spr334,
        666 => Register::spr354,
        667 => Register::spr374,
        668 => Register::spr394,
        669 => Register::spr3b4,
        670 => Register::spr3d4,
        671 => Register::spr3f4,
        672 => Register::spr015,
        673 => Register::spr035,
        674 => Register::spr055,
        675 => Register::spr075,
        676 => Register::spr095,
        677 => Register::spr0b5,
        678 => Register::spr0d5,
        679 => Register::spr0f5,
        680 => Register::spr115,
        681 => Register::spr135,
        682 => Register::spr155,
        683 => Register::spr175,
        684 => Register::spr195,
        685 => Register::spr1b5,
        686 => Register::spr1d5,
        687 => Register::spr1f5,
        688 => Register::spr215,
        689 => Register::spr235,
        690 => Register::spr255,
        691 => Register::spr275,
        692 => Register::spr295,
        693 => Register::spr2b5,
        694 => Register::spr2d5,
        695 => Register::spr2f5,
        696 => Register::spr315,
        697 => Register::spr335,
        698 => Register::spr355,
        699 => Register::spr375,
        700 => Register::spr395,
        701 => Register::spr3b5,
        702 => Register::spr3d5,
        703 => Register::spr3f5,
        704 => Register::spr016,
        705 => Register::spr036,
        706 => Register::spr056,
        707 => Register::spr076,
        708 => Register::spr096,
        709 => Register::spr0b6,
        710 => Register::spr0d6,
        711 => Register::spr0f6,
        712 => Register::spr116,
        713 => Register::spr136,
        714 => Register::spr156,
        715 => Register::spr176,
        716 => Register::spr196,
        717 => Register::spr1b6,
        718 => Register::spr1d6,
        719 => Register::spr1f6,
        720 => Register::spr216,
        721 => Register::spr236,
        722 => Register::spr256,
        723 => Register::spr276,
        724 => Register::spr296,
        725 => Register::spr2b6,
        726 => Register::spr2d6,
        727 => Register::spr2f6,
        728 => Register::spr316,
        729 => Register::spr336,
        730 => Register::spr356,
        731 => Register::spr376,
        732 => Register::spr396,
        733 => Register::spr3b6,
        734 => Register::spr3d6,
        735 => Register::spr3f6,
        736 => Register::spr017,
        737 => Register::spr037,
        738 => Register::spr057,
        739 => Register::spr077,
        740 => Register::spr097,
        741 => Register::spr0b7,
        742 => Register::spr0d7,
        743 => Register::spr0f7,
        744 => Register::spr117,
        745 => Register::spr137,
        746 => Register::spr157,
        747 => Register::spr177,
        748 => Register::spr197,
        749 => Register::spr1b7,
        750 => Register::spr1d7,
        751 => Register::spr1f7,
        752 => Register::spr217,
        753 => Register::spr237,
        754 => Register::spr257,
        755 => Register::spr277,
        756 => Register::spr297,
        757 => Register::spr2b7,
        758 => Register::spr2d7,
        759 => Register::spr2f7,
        760 => Register::spr317,
        761 => Register::spr337,
        762 => Register::spr357,
        763 => Register::spr377,
        764 => Register::spr397,
        765 => Register::spr3b7,
        766 => Register::spr3d7,
        767 => Register::spr3f7,
        768 => Register::spr018,
        769 => Register::spr038,
        770 => Register::spr058,
        771 => Register::spr078,
        772 => Register::spr098,
        773 => Register::spr0b8,
        774 => Register::spr0d8,
        775 => Register::spr0f8,
        776 => Register::spr118,
        777 => Register::spr138,
        778 => Register::spr158,
        779 => Register::spr178,
        780 => Register::spr198,
        781 => Register::spr1b8,
        782 => Register::spr1d8,
        783 => Register::spr1f8,
        784 => Register::spr218,
        785 => Register::spr238,
        786 => Register::spr258,
        787 => Register::spr278,
        788 => Register::spr298,
        789 => Register::spr2b8,
        790 => Register::spr2d8,
        791 => Register::spr2f8,
        792 => Register::spr318,
        793 => Register::spr338,
        794 => Register::spr358,
        795 => Register::spr378,
        796 => Register::spr398,
        797 => Register::spr3b8,
        798 => Register::spr3d8,
        799 => Register::spr3f8,
        800 => Register::spr019,
        801 => Register::spr039,
        802 => Register::spr059,
        803 => Register::spr079,
        804 => Register::spr099,
        805 => Register::spr0b9,
        806 => Register::spr0d9,
        807 => Register::spr0f9,
        808 => Register::spr119,
        809 => Register::spr139,
        810 => Register::spr159,
        811 => Register::spr179,
        812 => Register::spr199,
        813 => Register::spr1b9,
        814 => Register::spr1d9,
        815 => Register::spr1f9,
        816 => Register::spr219,
        817 => Register::spr239,
        818 => Register::spr259,
        819 => Register::spr279,
        820 => Register::spr299,
        821 => Register::spr2b9,
        822 => Register::spr2d9,
        823 => Register::spr2f9,
        824 => Register::spr319,
        825 => Register::spr339,
        826 => Register::spr359,
        827 => Register::spr379,
        828 => Register::spr399,
        829 => Register::spr3b9,
        830 => Register::spr3d9,
        831 => Register::spr3f9,
        832 => Register::SRR0,
        833 => Register::CSRR0,
        834 => Register::spr05a,
        835 => Register::spr07a,
        836 => Register::spr09a,
        837 => Register::spr0ba,
        838 => Register::spr0da,
        839 => Register::spr0fa,
        840 => Register::spr11a,
        841 => Register::spr13a,
        842 => Register::spr15a,
        843 => Register::spr17a,
        844 => Register::spr19a,
        845 => Register::spr1ba,
        846 => Register::spr1da,
        847 => Register::spr1fa,
        848 => Register::spr21a,
        849 => Register::spr23a,
        850 => Register::spr25a,
        851 => Register::spr27a,
        852 => Register::spr29a,
        853 => Register::spr2ba,
        854 => Register::spr2da,
        855 => Register::spr2fa,
        856 => Register::spr31a,
        857 => Register::spr33a,
        858 => Register::spr35a,
        859 => Register::spr37a,
        860 => Register::spr39a,
        861 => Register::spr3ba,
        862 => Register::spr3da,
        863 => Register::spr3fa,
        864 => Register::SRR1,
        865 => Register::CSRR1,
        866 => Register::spr05b,
        867 => Register::spr07b,
        868 => Register::spr09b,
        869 => Register::spr0bb,
        870 => Register::spr0db,
        871 => Register::spr0fb,
        872 => Register::spr11b,
        873 => Register::spr13b,
        874 => Register::spr15b,
        875 => Register::spr17b,
        876 => Register::spr19b,
        877 => Register::spr1bb,
        878 => Register::spr1db,
        879 => Register::spr1fb,
        880 => Register::spr21b,
        881 => Register::spr23b,
        882 => Register::spr25b,
        883 => Register::spr27b,
        884 => Register::spr29b,
        885 => Register::spr2bb,
        886 => Register::spr2db,
        887 => Register::spr2fb,
        888 => Register::spr31b,
        889 => Register::spr33b,
        890 => Register::spr35b,
        891 => Register::spr37b,
        892 => Register::spr39b,
        893 => Register::spr3bb,
        894 => Register::spr3db,
        895 => Register::spr3fb,
        896 => Register::spr01c,
        897 => Register::spr03c,
        898 => Register::spr05c,
        899 => Register::spr07c,
        900 => Register::spr09c,
        901 => Register::spr0bc,
        902 => Register::spr0dc,
        903 => Register::spr0fc,
        904 => Register::TBLw,
        905 => Register::spr13c,
        906 => Register::spr15c,
        907 => Register::spr17c,
        908 => Register::spr19c,
        909 => Register::spr1bc,
        910 => Register::spr1dc,
        911 => Register::spr1fc,
        912 => Register::spr21c,
        913 => Register::spr23c,
        914 => Register::spr25c,
        915 => Register::spr27c,
        916 => Register::spr29c,
        917 => Register::spr2bc,
        918 => Register::spr2dc,
        919 => Register::spr2fc,
        920 => Register::spr31c,
        921 => Register::spr33c,
        922 => Register::spr35c,
        923 => Register::spr37c,
        924 => Register::spr39c,
        925 => Register::spr3bc,
        926 => Register::spr3dc,
        927 => Register::spr3fc,
        928 => Register::spr01d,
        929 => Register::spr03d,
        930 => Register::spr05d,
        931 => Register::spr07d,
        932 => Register::spr09d,
        933 => Register::spr0bd,
        934 => Register::spr0dd,
        935 => Register::spr0fd,
        936 => Register::TBUw,
        937 => Register::spr13d,
        938 => Register::spr15d,
        939 => Register::spr17d,
        940 => Register::spr19d,
        941 => Register::spr1bd,
        942 => Register::spr1dd,
        943 => Register::spr1fd,
        944 => Register::spr21d,
        945 => Register::spr23d,
        946 => Register::spr25d,
        947 => Register::spr27d,
        948 => Register::spr29d,
        949 => Register::spr2bd,
        950 => Register::spr2dd,
        951 => Register::spr2fd,
        952 => Register::spr31d,
        953 => Register::spr33d,
        954 => Register::spr35d,
        955 => Register::spr37d,
        956 => Register::spr39d,
        957 => Register::spr3bd,
        958 => Register::spr3dd,
        959 => Register::spr3fd,
        960 => Register::spr01e,
        961 => Register::spr03e,
        962 => Register::spr05e,
        963 => Register::spr07e,
        964 => Register::spr09e,
        965 => Register::spr0be,
        966 => Register::spr0de,
        967 => Register::spr0fe,
        968 => Register::spr11e,
        969 => Register::spr13e,
        970 => Register::spr15e,
        971 => Register::spr17e,
        972 => Register::spr19e,
        973 => Register::spr1be,
        974 => Register::spr1de,
        975 => Register::spr1fe,
        976 => Register::spr21e,
        977 => Register::spr23e,
        978 => Register::spr25e,
        979 => Register::spr27e,
        980 => Register::spr29e,
        981 => Register::spr2be,
        982 => Register::spr2de,
        983 => Register::spr2fe,
        984 => Register::spr31e,
        985 => Register::spr33e,
        986 => Register::spr35e,
        987 => Register::spr37e,
        988 => Register::spr39e,
        989 => Register::spr3be,
        990 => Register::spr3de,
        991 => Register::spr3fe,
        992 => Register::spr01f,
        993 => Register::spr03f,
        994 => Register::spr05f,
        995 => Register::spr07f,
        996 => Register::spr09f,
        997 => Register::spr0bf,
        998 => Register::spr0df,
        999 => Register::spr0ff,
        1000 => Register::spr11f,
        1001 => Register::spr13f,
        1002 => Register::spr15f,
        1003 => Register::spr17f,
        1004 => Register::spr19f,
        1005 => Register::spr1bf,
        1006 => Register::spr1df,
        1007 => Register::spr1ff,
        1008 => Register::spr21f,
        1009 => Register::spr23f,
        1010 => Register::spr25f,
        1011 => Register::spr27f,
        1012 => Register::spr29f,
        1013 => Register::spr2bf,
        1014 => Register::spr2df,
        1015 => Register::spr2ff,
        1016 => Register::spr31f,
        1017 => Register::spr33f,
        1018 => Register::spr35f,
        1019 => Register::spr37f,
        1020 => Register::spr39f,
        1021 => Register::spr3bf,
        1022 => Register::spr3df,
        1023 => Register::spr3ff,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_6_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_6_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_6_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::sr0,
        1 => Register::sr1,
        2 => Register::sr2,
        3 => Register::sr3,
        4 => Register::sr4,
        5 => Register::sr5,
        6 => Register::sr6,
        7 => Register::sr7,
        8 => Register::sr8,
        9 => Register::sr9,
        10 => Register::sr10,
        11 => Register::sr11,
        12 => Register::sr12,
        13 => Register::sr13,
        14 => Register::sr14,
        15 => Register::sr15,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_7_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_7_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_7_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vs0,
        1 => Register::vs1,
        2 => Register::vs2,
        3 => Register::vs3,
        4 => Register::vs4,
        5 => Register::vs5,
        6 => Register::vs6,
        7 => Register::vs7,
        8 => Register::vs8,
        9 => Register::vs9,
        10 => Register::vs10,
        11 => Register::vs11,
        12 => Register::vs12,
        13 => Register::vs13,
        14 => Register::vs14,
        15 => Register::vs15,
        16 => Register::vs16,
        17 => Register::vs17,
        18 => Register::vs18,
        19 => Register::vs19,
        20 => Register::vs20,
        21 => Register::vs21,
        22 => Register::vs22,
        23 => Register::vs23,
        24 => Register::vs24,
        25 => Register::vs25,
        26 => Register::vs26,
        27 => Register::vs27,
        28 => Register::vs28,
        29 => Register::vs29,
        30 => Register::vs30,
        31 => Register::vs31,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_8_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_8_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_8_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vs32,
        1 => Register::vs33,
        2 => Register::vs34,
        3 => Register::vs35,
        4 => Register::vs36,
        5 => Register::vs37,
        6 => Register::vs38,
        7 => Register::vs39,
        8 => Register::vs40,
        9 => Register::vs41,
        10 => Register::vs42,
        11 => Register::vs43,
        12 => Register::vs44,
        13 => Register::vs45,
        14 => Register::vs46,
        15 => Register::vs47,
        16 => Register::vs48,
        17 => Register::vs49,
        18 => Register::vs50,
        19 => Register::vs51,
        20 => Register::vs52,
        21 => Register::vs53,
        22 => Register::vs54,
        23 => Register::vs55,
        24 => Register::vs56,
        25 => Register::vs57,
        26 => Register::vs58,
        27 => Register::vs59,
        28 => Register::vs60,
        29 => Register::vs61,
        30 => Register::vs62,
        31 => Register::vs63,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_10_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_10_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_10_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_64_0,
        1 => Register::vr1_64_0,
        2 => Register::vr2_64_0,
        3 => Register::vr3_64_0,
        4 => Register::vr4_64_0,
        5 => Register::vr5_64_0,
        6 => Register::vr6_64_0,
        7 => Register::vr7_64_0,
        8 => Register::vr8_64_0,
        9 => Register::vr9_64_0,
        10 => Register::vr10_64_0,
        11 => Register::vr11_64_0,
        12 => Register::vr12_64_0,
        13 => Register::vr13_64_0,
        14 => Register::vr14_64_0,
        15 => Register::vr15_64_0,
        16 => Register::vr16_64_0,
        17 => Register::vr17_64_0,
        18 => Register::vr18_64_0,
        19 => Register::vr19_64_0,
        20 => Register::vr20_64_0,
        21 => Register::vr21_64_0,
        22 => Register::vr22_64_0,
        23 => Register::vr23_64_0,
        24 => Register::vr24_64_0,
        25 => Register::vr25_64_0,
        26 => Register::vr26_64_0,
        27 => Register::vr27_64_0,
        28 => Register::vr28_64_0,
        29 => Register::vr29_64_0,
        30 => Register::vr30_64_0,
        31 => Register::vr31_64_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_11_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_11_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_11_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_64_1,
        1 => Register::vr1_64_1,
        2 => Register::vr2_64_1,
        3 => Register::vr3_64_1,
        4 => Register::vr4_64_1,
        5 => Register::vr5_64_1,
        6 => Register::vr6_64_1,
        7 => Register::vr7_64_1,
        8 => Register::vr8_64_1,
        9 => Register::vr9_64_1,
        10 => Register::vr10_64_1,
        11 => Register::vr11_64_1,
        12 => Register::vr12_64_1,
        13 => Register::vr13_64_1,
        14 => Register::vr14_64_1,
        15 => Register::vr15_64_1,
        16 => Register::vr16_64_1,
        17 => Register::vr17_64_1,
        18 => Register::vr18_64_1,
        19 => Register::vr19_64_1,
        20 => Register::vr20_64_1,
        21 => Register::vr21_64_1,
        22 => Register::vr22_64_1,
        23 => Register::vr23_64_1,
        24 => Register::vr24_64_1,
        25 => Register::vr25_64_1,
        26 => Register::vr26_64_1,
        27 => Register::vr27_64_1,
        28 => Register::vr28_64_1,
        29 => Register::vr29_64_1,
        30 => Register::vr30_64_1,
        31 => Register::vr31_64_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_12_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_12_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_12_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_0,
        1 => Register::vr1_32_0,
        2 => Register::vr2_32_0,
        3 => Register::vr3_32_0,
        4 => Register::vr4_32_0,
        5 => Register::vr5_32_0,
        6 => Register::vr6_32_0,
        7 => Register::vr7_32_0,
        8 => Register::vr8_32_0,
        9 => Register::vr9_32_0,
        10 => Register::vr10_32_0,
        11 => Register::vr11_32_0,
        12 => Register::vr12_32_0,
        13 => Register::vr13_32_0,
        14 => Register::vr14_32_0,
        15 => Register::vr15_32_0,
        16 => Register::vr16_32_0,
        17 => Register::vr17_32_0,
        18 => Register::vr18_32_0,
        19 => Register::vr19_32_0,
        20 => Register::vr20_32_0,
        21 => Register::vr21_32_0,
        22 => Register::vr22_32_0,
        23 => Register::vr23_32_0,
        24 => Register::vr24_32_0,
        25 => Register::vr25_32_0,
        26 => Register::vr26_32_0,
        27 => Register::vr27_32_0,
        28 => Register::vr28_32_0,
        29 => Register::vr29_32_0,
        30 => Register::vr30_32_0,
        31 => Register::vr31_32_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_13_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_13_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_13_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_1,
        1 => Register::vr1_32_1,
        2 => Register::vr2_32_1,
        3 => Register::vr3_32_1,
        4 => Register::vr4_32_1,
        5 => Register::vr5_32_1,
        6 => Register::vr6_32_1,
        7 => Register::vr7_32_1,
        8 => Register::vr8_32_1,
        9 => Register::vr9_32_1,
        10 => Register::vr10_32_1,
        11 => Register::vr11_32_1,
        12 => Register::vr12_32_1,
        13 => Register::vr13_32_1,
        14 => Register::vr14_32_1,
        15 => Register::vr15_32_1,
        16 => Register::vr16_32_1,
        17 => Register::vr17_32_1,
        18 => Register::vr18_32_1,
        19 => Register::vr19_32_1,
        20 => Register::vr20_32_1,
        21 => Register::vr21_32_1,
        22 => Register::vr22_32_1,
        23 => Register::vr23_32_1,
        24 => Register::vr24_32_1,
        25 => Register::vr25_32_1,
        26 => Register::vr26_32_1,
        27 => Register::vr27_32_1,
        28 => Register::vr28_32_1,
        29 => Register::vr29_32_1,
        30 => Register::vr30_32_1,
        31 => Register::vr31_32_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_14_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_14_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_14_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_2,
        1 => Register::vr1_32_2,
        2 => Register::vr2_32_2,
        3 => Register::vr3_32_2,
        4 => Register::vr4_32_2,
        5 => Register::vr5_32_2,
        6 => Register::vr6_32_2,
        7 => Register::vr7_32_2,
        8 => Register::vr8_32_2,
        9 => Register::vr9_32_2,
        10 => Register::vr10_32_2,
        11 => Register::vr11_32_2,
        12 => Register::vr12_32_2,
        13 => Register::vr13_32_2,
        14 => Register::vr14_32_2,
        15 => Register::vr15_32_2,
        16 => Register::vr16_32_2,
        17 => Register::vr17_32_2,
        18 => Register::vr18_32_2,
        19 => Register::vr19_32_2,
        20 => Register::vr20_32_2,
        21 => Register::vr21_32_2,
        22 => Register::vr22_32_2,
        23 => Register::vr23_32_2,
        24 => Register::vr24_32_2,
        25 => Register::vr25_32_2,
        26 => Register::vr26_32_2,
        27 => Register::vr27_32_2,
        28 => Register::vr28_32_2,
        29 => Register::vr29_32_2,
        30 => Register::vr30_32_2,
        31 => Register::vr31_32_2,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_15_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_15_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_15_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_3,
        1 => Register::vr1_32_3,
        2 => Register::vr2_32_3,
        3 => Register::vr3_32_3,
        4 => Register::vr4_32_3,
        5 => Register::vr5_32_3,
        6 => Register::vr6_32_3,
        7 => Register::vr7_32_3,
        8 => Register::vr8_32_3,
        9 => Register::vr9_32_3,
        10 => Register::vr10_32_3,
        11 => Register::vr11_32_3,
        12 => Register::vr12_32_3,
        13 => Register::vr13_32_3,
        14 => Register::vr14_32_3,
        15 => Register::vr15_32_3,
        16 => Register::vr16_32_3,
        17 => Register::vr17_32_3,
        18 => Register::vr18_32_3,
        19 => Register::vr19_32_3,
        20 => Register::vr20_32_3,
        21 => Register::vr21_32_3,
        22 => Register::vr22_32_3,
        23 => Register::vr23_32_3,
        24 => Register::vr24_32_3,
        25 => Register::vr25_32_3,
        26 => Register::vr26_32_3,
        27 => Register::vr27_32_3,
        28 => Register::vr28_32_3,
        29 => Register::vr29_32_3,
        30 => Register::vr30_32_3,
        31 => Register::vr31_32_3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_16_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_16_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_16_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_0,
        1 => Register::vr1_16_0,
        2 => Register::vr2_16_0,
        3 => Register::vr3_16_0,
        4 => Register::vr4_16_0,
        5 => Register::vr5_16_0,
        6 => Register::vr6_16_0,
        7 => Register::vr7_16_0,
        8 => Register::vr8_16_0,
        9 => Register::vr9_16_0,
        10 => Register::vr10_16_0,
        11 => Register::vr11_16_0,
        12 => Register::vr12_16_0,
        13 => Register::vr13_16_0,
        14 => Register::vr14_16_0,
        15 => Register::vr15_16_0,
        16 => Register::vr16_16_0,
        17 => Register::vr17_16_0,
        18 => Register::vr18_16_0,
        19 => Register::vr19_16_0,
        20 => Register::vr20_16_0,
        21 => Register::vr21_16_0,
        22 => Register::vr22_16_0,
        23 => Register::vr23_16_0,
        24 => Register::vr24_16_0,
        25 => Register::vr25_16_0,
        26 => Register::vr26_16_0,
        27 => Register::vr27_16_0,
        28 => Register::vr28_16_0,
        29 => Register::vr29_16_0,
        30 => Register::vr30_16_0,
        31 => Register::vr31_16_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_17_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_17_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_17_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_1,
        1 => Register::vr1_16_1,
        2 => Register::vr2_16_1,
        3 => Register::vr3_16_1,
        4 => Register::vr4_16_1,
        5 => Register::vr5_16_1,
        6 => Register::vr6_16_1,
        7 => Register::vr7_16_1,
        8 => Register::vr8_16_1,
        9 => Register::vr9_16_1,
        10 => Register::vr10_16_1,
        11 => Register::vr11_16_1,
        12 => Register::vr12_16_1,
        13 => Register::vr13_16_1,
        14 => Register::vr14_16_1,
        15 => Register::vr15_16_1,
        16 => Register::vr16_16_1,
        17 => Register::vr17_16_1,
        18 => Register::vr18_16_1,
        19 => Register::vr19_16_1,
        20 => Register::vr20_16_1,
        21 => Register::vr21_16_1,
        22 => Register::vr22_16_1,
        23 => Register::vr23_16_1,
        24 => Register::vr24_16_1,
        25 => Register::vr25_16_1,
        26 => Register::vr26_16_1,
        27 => Register::vr27_16_1,
        28 => Register::vr28_16_1,
        29 => Register::vr29_16_1,
        30 => Register::vr30_16_1,
        31 => Register::vr31_16_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_18_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_18_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_18_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_2,
        1 => Register::vr1_16_2,
        2 => Register::vr2_16_2,
        3 => Register::vr3_16_2,
        4 => Register::vr4_16_2,
        5 => Register::vr5_16_2,
        6 => Register::vr6_16_2,
        7 => Register::vr7_16_2,
        8 => Register::vr8_16_2,
        9 => Register::vr9_16_2,
        10 => Register::vr10_16_2,
        11 => Register::vr11_16_2,
        12 => Register::vr12_16_2,
        13 => Register::vr13_16_2,
        14 => Register::vr14_16_2,
        15 => Register::vr15_16_2,
        16 => Register::vr16_16_2,
        17 => Register::vr17_16_2,
        18 => Register::vr18_16_2,
        19 => Register::vr19_16_2,
        20 => Register::vr20_16_2,
        21 => Register::vr21_16_2,
        22 => Register::vr22_16_2,
        23 => Register::vr23_16_2,
        24 => Register::vr24_16_2,
        25 => Register::vr25_16_2,
        26 => Register::vr26_16_2,
        27 => Register::vr27_16_2,
        28 => Register::vr28_16_2,
        29 => Register::vr29_16_2,
        30 => Register::vr30_16_2,
        31 => Register::vr31_16_2,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_19_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_19_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_19_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_3,
        1 => Register::vr1_16_3,
        2 => Register::vr2_16_3,
        3 => Register::vr3_16_3,
        4 => Register::vr4_16_3,
        5 => Register::vr5_16_3,
        6 => Register::vr6_16_3,
        7 => Register::vr7_16_3,
        8 => Register::vr8_16_3,
        9 => Register::vr9_16_3,
        10 => Register::vr10_16_3,
        11 => Register::vr11_16_3,
        12 => Register::vr12_16_3,
        13 => Register::vr13_16_3,
        14 => Register::vr14_16_3,
        15 => Register::vr15_16_3,
        16 => Register::vr16_16_3,
        17 => Register::vr17_16_3,
        18 => Register::vr18_16_3,
        19 => Register::vr19_16_3,
        20 => Register::vr20_16_3,
        21 => Register::vr21_16_3,
        22 => Register::vr22_16_3,
        23 => Register::vr23_16_3,
        24 => Register::vr24_16_3,
        25 => Register::vr25_16_3,
        26 => Register::vr26_16_3,
        27 => Register::vr27_16_3,
        28 => Register::vr28_16_3,
        29 => Register::vr29_16_3,
        30 => Register::vr30_16_3,
        31 => Register::vr31_16_3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_20_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_20_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_20_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_4,
        1 => Register::vr1_16_4,
        2 => Register::vr2_16_4,
        3 => Register::vr3_16_4,
        4 => Register::vr4_16_4,
        5 => Register::vr5_16_4,
        6 => Register::vr6_16_4,
        7 => Register::vr7_16_4,
        8 => Register::vr8_16_4,
        9 => Register::vr9_16_4,
        10 => Register::vr10_16_4,
        11 => Register::vr11_16_4,
        12 => Register::vr12_16_4,
        13 => Register::vr13_16_4,
        14 => Register::vr14_16_4,
        15 => Register::vr15_16_4,
        16 => Register::vr16_16_4,
        17 => Register::vr17_16_4,
        18 => Register::vr18_16_4,
        19 => Register::vr19_16_4,
        20 => Register::vr20_16_4,
        21 => Register::vr21_16_4,
        22 => Register::vr22_16_4,
        23 => Register::vr23_16_4,
        24 => Register::vr24_16_4,
        25 => Register::vr25_16_4,
        26 => Register::vr26_16_4,
        27 => Register::vr27_16_4,
        28 => Register::vr28_16_4,
        29 => Register::vr29_16_4,
        30 => Register::vr30_16_4,
        31 => Register::vr31_16_4,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_21_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_21_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_21_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_5,
        1 => Register::vr1_16_5,
        2 => Register::vr2_16_5,
        3 => Register::vr3_16_5,
        4 => Register::vr4_16_5,
        5 => Register::vr5_16_5,
        6 => Register::vr6_16_5,
        7 => Register::vr7_16_5,
        8 => Register::vr8_16_5,
        9 => Register::vr9_16_5,
        10 => Register::vr10_16_5,
        11 => Register::vr11_16_5,
        12 => Register::vr12_16_5,
        13 => Register::vr13_16_5,
        14 => Register::vr14_16_5,
        15 => Register::vr15_16_5,
        16 => Register::vr16_16_5,
        17 => Register::vr17_16_5,
        18 => Register::vr18_16_5,
        19 => Register::vr19_16_5,
        20 => Register::vr20_16_5,
        21 => Register::vr21_16_5,
        22 => Register::vr22_16_5,
        23 => Register::vr23_16_5,
        24 => Register::vr24_16_5,
        25 => Register::vr25_16_5,
        26 => Register::vr26_16_5,
        27 => Register::vr27_16_5,
        28 => Register::vr28_16_5,
        29 => Register::vr29_16_5,
        30 => Register::vr30_16_5,
        31 => Register::vr31_16_5,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_22_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_22_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_22_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_6,
        1 => Register::vr1_16_6,
        2 => Register::vr2_16_6,
        3 => Register::vr3_16_6,
        4 => Register::vr4_16_6,
        5 => Register::vr5_16_6,
        6 => Register::vr6_16_6,
        7 => Register::vr7_16_6,
        8 => Register::vr8_16_6,
        9 => Register::vr9_16_6,
        10 => Register::vr10_16_6,
        11 => Register::vr11_16_6,
        12 => Register::vr12_16_6,
        13 => Register::vr13_16_6,
        14 => Register::vr14_16_6,
        15 => Register::vr15_16_6,
        16 => Register::vr16_16_6,
        17 => Register::vr17_16_6,
        18 => Register::vr18_16_6,
        19 => Register::vr19_16_6,
        20 => Register::vr20_16_6,
        21 => Register::vr21_16_6,
        22 => Register::vr22_16_6,
        23 => Register::vr23_16_6,
        24 => Register::vr24_16_6,
        25 => Register::vr25_16_6,
        26 => Register::vr26_16_6,
        27 => Register::vr27_16_6,
        28 => Register::vr28_16_6,
        29 => Register::vr29_16_6,
        30 => Register::vr30_16_6,
        31 => Register::vr31_16_6,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_23_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_23_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_23_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_7,
        1 => Register::vr1_16_7,
        2 => Register::vr2_16_7,
        3 => Register::vr3_16_7,
        4 => Register::vr4_16_7,
        5 => Register::vr5_16_7,
        6 => Register::vr6_16_7,
        7 => Register::vr7_16_7,
        8 => Register::vr8_16_7,
        9 => Register::vr9_16_7,
        10 => Register::vr10_16_7,
        11 => Register::vr11_16_7,
        12 => Register::vr12_16_7,
        13 => Register::vr13_16_7,
        14 => Register::vr14_16_7,
        15 => Register::vr15_16_7,
        16 => Register::vr16_16_7,
        17 => Register::vr17_16_7,
        18 => Register::vr18_16_7,
        19 => Register::vr19_16_7,
        20 => Register::vr20_16_7,
        21 => Register::vr21_16_7,
        22 => Register::vr22_16_7,
        23 => Register::vr23_16_7,
        24 => Register::vr24_16_7,
        25 => Register::vr25_16_7,
        26 => Register::vr26_16_7,
        27 => Register::vr27_16_7,
        28 => Register::vr28_16_7,
        29 => Register::vr29_16_7,
        30 => Register::vr30_16_7,
        31 => Register::vr31_16_7,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_24_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_24_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_24_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_0,
        1 => Register::vr1_8_0,
        2 => Register::vr2_8_0,
        3 => Register::vr3_8_0,
        4 => Register::vr4_8_0,
        5 => Register::vr5_8_0,
        6 => Register::vr6_8_0,
        7 => Register::vr7_8_0,
        8 => Register::vr8_8_0,
        9 => Register::vr9_8_0,
        10 => Register::vr10_8_0,
        11 => Register::vr11_8_0,
        12 => Register::vr12_8_0,
        13 => Register::vr13_8_0,
        14 => Register::vr14_8_0,
        15 => Register::vr15_8_0,
        16 => Register::vr16_8_0,
        17 => Register::vr17_8_0,
        18 => Register::vr18_8_0,
        19 => Register::vr19_8_0,
        20 => Register::vr20_8_0,
        21 => Register::vr21_8_0,
        22 => Register::vr22_8_0,
        23 => Register::vr23_8_0,
        24 => Register::vr24_8_0,
        25 => Register::vr25_8_0,
        26 => Register::vr26_8_0,
        27 => Register::vr27_8_0,
        28 => Register::vr28_8_0,
        29 => Register::vr29_8_0,
        30 => Register::vr30_8_0,
        31 => Register::vr31_8_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_25_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_25_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_25_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_1,
        1 => Register::vr1_8_1,
        2 => Register::vr2_8_1,
        3 => Register::vr3_8_1,
        4 => Register::vr4_8_1,
        5 => Register::vr5_8_1,
        6 => Register::vr6_8_1,
        7 => Register::vr7_8_1,
        8 => Register::vr8_8_1,
        9 => Register::vr9_8_1,
        10 => Register::vr10_8_1,
        11 => Register::vr11_8_1,
        12 => Register::vr12_8_1,
        13 => Register::vr13_8_1,
        14 => Register::vr14_8_1,
        15 => Register::vr15_8_1,
        16 => Register::vr16_8_1,
        17 => Register::vr17_8_1,
        18 => Register::vr18_8_1,
        19 => Register::vr19_8_1,
        20 => Register::vr20_8_1,
        21 => Register::vr21_8_1,
        22 => Register::vr22_8_1,
        23 => Register::vr23_8_1,
        24 => Register::vr24_8_1,
        25 => Register::vr25_8_1,
        26 => Register::vr26_8_1,
        27 => Register::vr27_8_1,
        28 => Register::vr28_8_1,
        29 => Register::vr29_8_1,
        30 => Register::vr30_8_1,
        31 => Register::vr31_8_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_26_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_26_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_26_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_2,
        1 => Register::vr1_8_2,
        2 => Register::vr2_8_2,
        3 => Register::vr3_8_2,
        4 => Register::vr4_8_2,
        5 => Register::vr5_8_2,
        6 => Register::vr6_8_2,
        7 => Register::vr7_8_2,
        8 => Register::vr8_8_2,
        9 => Register::vr9_8_2,
        10 => Register::vr10_8_2,
        11 => Register::vr11_8_2,
        12 => Register::vr12_8_2,
        13 => Register::vr13_8_2,
        14 => Register::vr14_8_2,
        15 => Register::vr15_8_2,
        16 => Register::vr16_8_2,
        17 => Register::vr17_8_2,
        18 => Register::vr18_8_2,
        19 => Register::vr19_8_2,
        20 => Register::vr20_8_2,
        21 => Register::vr21_8_2,
        22 => Register::vr22_8_2,
        23 => Register::vr23_8_2,
        24 => Register::vr24_8_2,
        25 => Register::vr25_8_2,
        26 => Register::vr26_8_2,
        27 => Register::vr27_8_2,
        28 => Register::vr28_8_2,
        29 => Register::vr29_8_2,
        30 => Register::vr30_8_2,
        31 => Register::vr31_8_2,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_27_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_27_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_27_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_3,
        1 => Register::vr1_8_3,
        2 => Register::vr2_8_3,
        3 => Register::vr3_8_3,
        4 => Register::vr4_8_3,
        5 => Register::vr5_8_3,
        6 => Register::vr6_8_3,
        7 => Register::vr7_8_3,
        8 => Register::vr8_8_3,
        9 => Register::vr9_8_3,
        10 => Register::vr10_8_3,
        11 => Register::vr11_8_3,
        12 => Register::vr12_8_3,
        13 => Register::vr13_8_3,
        14 => Register::vr14_8_3,
        15 => Register::vr15_8_3,
        16 => Register::vr16_8_3,
        17 => Register::vr17_8_3,
        18 => Register::vr18_8_3,
        19 => Register::vr19_8_3,
        20 => Register::vr20_8_3,
        21 => Register::vr21_8_3,
        22 => Register::vr22_8_3,
        23 => Register::vr23_8_3,
        24 => Register::vr24_8_3,
        25 => Register::vr25_8_3,
        26 => Register::vr26_8_3,
        27 => Register::vr27_8_3,
        28 => Register::vr28_8_3,
        29 => Register::vr29_8_3,
        30 => Register::vr30_8_3,
        31 => Register::vr31_8_3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_28_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_28_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_28_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_4,
        1 => Register::vr1_8_4,
        2 => Register::vr2_8_4,
        3 => Register::vr3_8_4,
        4 => Register::vr4_8_4,
        5 => Register::vr5_8_4,
        6 => Register::vr6_8_4,
        7 => Register::vr7_8_4,
        8 => Register::vr8_8_4,
        9 => Register::vr9_8_4,
        10 => Register::vr10_8_4,
        11 => Register::vr11_8_4,
        12 => Register::vr12_8_4,
        13 => Register::vr13_8_4,
        14 => Register::vr14_8_4,
        15 => Register::vr15_8_4,
        16 => Register::vr16_8_4,
        17 => Register::vr17_8_4,
        18 => Register::vr18_8_4,
        19 => Register::vr19_8_4,
        20 => Register::vr20_8_4,
        21 => Register::vr21_8_4,
        22 => Register::vr22_8_4,
        23 => Register::vr23_8_4,
        24 => Register::vr24_8_4,
        25 => Register::vr25_8_4,
        26 => Register::vr26_8_4,
        27 => Register::vr27_8_4,
        28 => Register::vr28_8_4,
        29 => Register::vr29_8_4,
        30 => Register::vr30_8_4,
        31 => Register::vr31_8_4,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_29_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_29_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_29_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_5,
        1 => Register::vr1_8_5,
        2 => Register::vr2_8_5,
        3 => Register::vr3_8_5,
        4 => Register::vr4_8_5,
        5 => Register::vr5_8_5,
        6 => Register::vr6_8_5,
        7 => Register::vr7_8_5,
        8 => Register::vr8_8_5,
        9 => Register::vr9_8_5,
        10 => Register::vr10_8_5,
        11 => Register::vr11_8_5,
        12 => Register::vr12_8_5,
        13 => Register::vr13_8_5,
        14 => Register::vr14_8_5,
        15 => Register::vr15_8_5,
        16 => Register::vr16_8_5,
        17 => Register::vr17_8_5,
        18 => Register::vr18_8_5,
        19 => Register::vr19_8_5,
        20 => Register::vr20_8_5,
        21 => Register::vr21_8_5,
        22 => Register::vr22_8_5,
        23 => Register::vr23_8_5,
        24 => Register::vr24_8_5,
        25 => Register::vr25_8_5,
        26 => Register::vr26_8_5,
        27 => Register::vr27_8_5,
        28 => Register::vr28_8_5,
        29 => Register::vr29_8_5,
        30 => Register::vr30_8_5,
        31 => Register::vr31_8_5,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_30_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_30_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_30_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_6,
        1 => Register::vr1_8_6,
        2 => Register::vr2_8_6,
        3 => Register::vr3_8_6,
        4 => Register::vr4_8_6,
        5 => Register::vr5_8_6,
        6 => Register::vr6_8_6,
        7 => Register::vr7_8_6,
        8 => Register::vr8_8_6,
        9 => Register::vr9_8_6,
        10 => Register::vr10_8_6,
        11 => Register::vr11_8_6,
        12 => Register::vr12_8_6,
        13 => Register::vr13_8_6,
        14 => Register::vr14_8_6,
        15 => Register::vr15_8_6,
        16 => Register::vr16_8_6,
        17 => Register::vr17_8_6,
        18 => Register::vr18_8_6,
        19 => Register::vr19_8_6,
        20 => Register::vr20_8_6,
        21 => Register::vr21_8_6,
        22 => Register::vr22_8_6,
        23 => Register::vr23_8_6,
        24 => Register::vr24_8_6,
        25 => Register::vr25_8_6,
        26 => Register::vr26_8_6,
        27 => Register::vr27_8_6,
        28 => Register::vr28_8_6,
        29 => Register::vr29_8_6,
        30 => Register::vr30_8_6,
        31 => Register::vr31_8_6,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_31_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_31_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_31_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_7,
        1 => Register::vr1_8_7,
        2 => Register::vr2_8_7,
        3 => Register::vr3_8_7,
        4 => Register::vr4_8_7,
        5 => Register::vr5_8_7,
        6 => Register::vr6_8_7,
        7 => Register::vr7_8_7,
        8 => Register::vr8_8_7,
        9 => Register::vr9_8_7,
        10 => Register::vr10_8_7,
        11 => Register::vr11_8_7,
        12 => Register::vr12_8_7,
        13 => Register::vr13_8_7,
        14 => Register::vr14_8_7,
        15 => Register::vr15_8_7,
        16 => Register::vr16_8_7,
        17 => Register::vr17_8_7,
        18 => Register::vr18_8_7,
        19 => Register::vr19_8_7,
        20 => Register::vr20_8_7,
        21 => Register::vr21_8_7,
        22 => Register::vr22_8_7,
        23 => Register::vr23_8_7,
        24 => Register::vr24_8_7,
        25 => Register::vr25_8_7,
        26 => Register::vr26_8_7,
        27 => Register::vr27_8_7,
        28 => Register::vr28_8_7,
        29 => Register::vr29_8_7,
        30 => Register::vr30_8_7,
        31 => Register::vr31_8_7,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_32_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_32_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_32_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_8,
        1 => Register::vr1_8_8,
        2 => Register::vr2_8_8,
        3 => Register::vr3_8_8,
        4 => Register::vr4_8_8,
        5 => Register::vr5_8_8,
        6 => Register::vr6_8_8,
        7 => Register::vr7_8_8,
        8 => Register::vr8_8_8,
        9 => Register::vr9_8_8,
        10 => Register::vr10_8_8,
        11 => Register::vr11_8_8,
        12 => Register::vr12_8_8,
        13 => Register::vr13_8_8,
        14 => Register::vr14_8_8,
        15 => Register::vr15_8_8,
        16 => Register::vr16_8_8,
        17 => Register::vr17_8_8,
        18 => Register::vr18_8_8,
        19 => Register::vr19_8_8,
        20 => Register::vr20_8_8,
        21 => Register::vr21_8_8,
        22 => Register::vr22_8_8,
        23 => Register::vr23_8_8,
        24 => Register::vr24_8_8,
        25 => Register::vr25_8_8,
        26 => Register::vr26_8_8,
        27 => Register::vr27_8_8,
        28 => Register::vr28_8_8,
        29 => Register::vr29_8_8,
        30 => Register::vr30_8_8,
        31 => Register::vr31_8_8,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_33_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_33_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_33_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_9,
        1 => Register::vr1_8_9,
        2 => Register::vr2_8_9,
        3 => Register::vr3_8_9,
        4 => Register::vr4_8_9,
        5 => Register::vr5_8_9,
        6 => Register::vr6_8_9,
        7 => Register::vr7_8_9,
        8 => Register::vr8_8_9,
        9 => Register::vr9_8_9,
        10 => Register::vr10_8_9,
        11 => Register::vr11_8_9,
        12 => Register::vr12_8_9,
        13 => Register::vr13_8_9,
        14 => Register::vr14_8_9,
        15 => Register::vr15_8_9,
        16 => Register::vr16_8_9,
        17 => Register::vr17_8_9,
        18 => Register::vr18_8_9,
        19 => Register::vr19_8_9,
        20 => Register::vr20_8_9,
        21 => Register::vr21_8_9,
        22 => Register::vr22_8_9,
        23 => Register::vr23_8_9,
        24 => Register::vr24_8_9,
        25 => Register::vr25_8_9,
        26 => Register::vr26_8_9,
        27 => Register::vr27_8_9,
        28 => Register::vr28_8_9,
        29 => Register::vr29_8_9,
        30 => Register::vr30_8_9,
        31 => Register::vr31_8_9,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_34_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_34_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_34_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_10,
        1 => Register::vr1_8_10,
        2 => Register::vr2_8_10,
        3 => Register::vr3_8_10,
        4 => Register::vr4_8_10,
        5 => Register::vr5_8_10,
        6 => Register::vr6_8_10,
        7 => Register::vr7_8_10,
        8 => Register::vr8_8_10,
        9 => Register::vr9_8_10,
        10 => Register::vr10_8_10,
        11 => Register::vr11_8_10,
        12 => Register::vr12_8_10,
        13 => Register::vr13_8_10,
        14 => Register::vr14_8_10,
        15 => Register::vr15_8_10,
        16 => Register::vr16_8_10,
        17 => Register::vr17_8_10,
        18 => Register::vr18_8_10,
        19 => Register::vr19_8_10,
        20 => Register::vr20_8_10,
        21 => Register::vr21_8_10,
        22 => Register::vr22_8_10,
        23 => Register::vr23_8_10,
        24 => Register::vr24_8_10,
        25 => Register::vr25_8_10,
        26 => Register::vr26_8_10,
        27 => Register::vr27_8_10,
        28 => Register::vr28_8_10,
        29 => Register::vr29_8_10,
        30 => Register::vr30_8_10,
        31 => Register::vr31_8_10,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_35_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_35_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_35_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_11,
        1 => Register::vr1_8_11,
        2 => Register::vr2_8_11,
        3 => Register::vr3_8_11,
        4 => Register::vr4_8_11,
        5 => Register::vr5_8_11,
        6 => Register::vr6_8_11,
        7 => Register::vr7_8_11,
        8 => Register::vr8_8_11,
        9 => Register::vr9_8_11,
        10 => Register::vr10_8_11,
        11 => Register::vr11_8_11,
        12 => Register::vr12_8_11,
        13 => Register::vr13_8_11,
        14 => Register::vr14_8_11,
        15 => Register::vr15_8_11,
        16 => Register::vr16_8_11,
        17 => Register::vr17_8_11,
        18 => Register::vr18_8_11,
        19 => Register::vr19_8_11,
        20 => Register::vr20_8_11,
        21 => Register::vr21_8_11,
        22 => Register::vr22_8_11,
        23 => Register::vr23_8_11,
        24 => Register::vr24_8_11,
        25 => Register::vr25_8_11,
        26 => Register::vr26_8_11,
        27 => Register::vr27_8_11,
        28 => Register::vr28_8_11,
        29 => Register::vr29_8_11,
        30 => Register::vr30_8_11,
        31 => Register::vr31_8_11,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_36_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_36_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_36_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_12,
        1 => Register::vr1_8_12,
        2 => Register::vr2_8_12,
        3 => Register::vr3_8_12,
        4 => Register::vr4_8_12,
        5 => Register::vr5_8_12,
        6 => Register::vr6_8_12,
        7 => Register::vr7_8_12,
        8 => Register::vr8_8_12,
        9 => Register::vr9_8_12,
        10 => Register::vr10_8_12,
        11 => Register::vr11_8_12,
        12 => Register::vr12_8_12,
        13 => Register::vr13_8_12,
        14 => Register::vr14_8_12,
        15 => Register::vr15_8_12,
        16 => Register::vr16_8_12,
        17 => Register::vr17_8_12,
        18 => Register::vr18_8_12,
        19 => Register::vr19_8_12,
        20 => Register::vr20_8_12,
        21 => Register::vr21_8_12,
        22 => Register::vr22_8_12,
        23 => Register::vr23_8_12,
        24 => Register::vr24_8_12,
        25 => Register::vr25_8_12,
        26 => Register::vr26_8_12,
        27 => Register::vr27_8_12,
        28 => Register::vr28_8_12,
        29 => Register::vr29_8_12,
        30 => Register::vr30_8_12,
        31 => Register::vr31_8_12,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_37_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_37_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_37_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_13,
        1 => Register::vr1_8_13,
        2 => Register::vr2_8_13,
        3 => Register::vr3_8_13,
        4 => Register::vr4_8_13,
        5 => Register::vr5_8_13,
        6 => Register::vr6_8_13,
        7 => Register::vr7_8_13,
        8 => Register::vr8_8_13,
        9 => Register::vr9_8_13,
        10 => Register::vr10_8_13,
        11 => Register::vr11_8_13,
        12 => Register::vr12_8_13,
        13 => Register::vr13_8_13,
        14 => Register::vr14_8_13,
        15 => Register::vr15_8_13,
        16 => Register::vr16_8_13,
        17 => Register::vr17_8_13,
        18 => Register::vr18_8_13,
        19 => Register::vr19_8_13,
        20 => Register::vr20_8_13,
        21 => Register::vr21_8_13,
        22 => Register::vr22_8_13,
        23 => Register::vr23_8_13,
        24 => Register::vr24_8_13,
        25 => Register::vr25_8_13,
        26 => Register::vr26_8_13,
        27 => Register::vr27_8_13,
        28 => Register::vr28_8_13,
        29 => Register::vr29_8_13,
        30 => Register::vr30_8_13,
        31 => Register::vr31_8_13,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_38_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_38_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_38_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_14,
        1 => Register::vr1_8_14,
        2 => Register::vr2_8_14,
        3 => Register::vr3_8_14,
        4 => Register::vr4_8_14,
        5 => Register::vr5_8_14,
        6 => Register::vr6_8_14,
        7 => Register::vr7_8_14,
        8 => Register::vr8_8_14,
        9 => Register::vr9_8_14,
        10 => Register::vr10_8_14,
        11 => Register::vr11_8_14,
        12 => Register::vr12_8_14,
        13 => Register::vr13_8_14,
        14 => Register::vr14_8_14,
        15 => Register::vr15_8_14,
        16 => Register::vr16_8_14,
        17 => Register::vr17_8_14,
        18 => Register::vr18_8_14,
        19 => Register::vr19_8_14,
        20 => Register::vr20_8_14,
        21 => Register::vr21_8_14,
        22 => Register::vr22_8_14,
        23 => Register::vr23_8_14,
        24 => Register::vr24_8_14,
        25 => Register::vr25_8_14,
        26 => Register::vr26_8_14,
        27 => Register::vr27_8_14,
        28 => Register::vr28_8_14,
        29 => Register::vr29_8_14,
        30 => Register::vr30_8_14,
        31 => Register::vr31_8_14,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_39_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_39_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_39_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_15,
        1 => Register::vr1_8_15,
        2 => Register::vr2_8_15,
        3 => Register::vr3_8_15,
        4 => Register::vr4_8_15,
        5 => Register::vr5_8_15,
        6 => Register::vr6_8_15,
        7 => Register::vr7_8_15,
        8 => Register::vr8_8_15,
        9 => Register::vr9_8_15,
        10 => Register::vr10_8_15,
        11 => Register::vr11_8_15,
        12 => Register::vr12_8_15,
        13 => Register::vr13_8_15,
        14 => Register::vr14_8_15,
        15 => Register::vr15_8_15,
        16 => Register::vr16_8_15,
        17 => Register::vr17_8_15,
        18 => Register::vr18_8_15,
        19 => Register::vr19_8_15,
        20 => Register::vr20_8_15,
        21 => Register::vr21_8_15,
        22 => Register::vr22_8_15,
        23 => Register::vr23_8_15,
        24 => Register::vr24_8_15,
        25 => Register::vr25_8_15,
        26 => Register::vr26_8_15,
        27 => Register::vr27_8_15,
        28 => Register::vr28_8_15,
        29 => Register::vr29_8_15,
        30 => Register::vr30_8_15,
        31 => Register::vr31_8_15,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_40_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_40_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_40_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_64_0,
        1 => Register::vr1_64_0,
        2 => Register::vr2_64_0,
        3 => Register::vr3_64_0,
        4 => Register::vr4_64_0,
        5 => Register::vr5_64_0,
        6 => Register::vr6_64_0,
        7 => Register::vr7_64_0,
        8 => Register::vr8_64_0,
        9 => Register::vr9_64_0,
        10 => Register::vr10_64_0,
        11 => Register::vr11_64_0,
        12 => Register::vr12_64_0,
        13 => Register::vr13_64_0,
        14 => Register::vr14_64_0,
        15 => Register::vr15_64_0,
        16 => Register::vr16_64_0,
        17 => Register::vr17_64_0,
        18 => Register::vr18_64_0,
        19 => Register::vr19_64_0,
        20 => Register::vr20_64_0,
        21 => Register::vr21_64_0,
        22 => Register::vr22_64_0,
        23 => Register::vr23_64_0,
        24 => Register::vr24_64_0,
        25 => Register::vr25_64_0,
        26 => Register::vr26_64_0,
        27 => Register::vr27_64_0,
        28 => Register::vr28_64_0,
        29 => Register::vr29_64_0,
        30 => Register::vr30_64_0,
        31 => Register::vr31_64_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_41_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_41_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_41_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_64_1,
        1 => Register::vr1_64_1,
        2 => Register::vr2_64_1,
        3 => Register::vr3_64_1,
        4 => Register::vr4_64_1,
        5 => Register::vr5_64_1,
        6 => Register::vr6_64_1,
        7 => Register::vr7_64_1,
        8 => Register::vr8_64_1,
        9 => Register::vr9_64_1,
        10 => Register::vr10_64_1,
        11 => Register::vr11_64_1,
        12 => Register::vr12_64_1,
        13 => Register::vr13_64_1,
        14 => Register::vr14_64_1,
        15 => Register::vr15_64_1,
        16 => Register::vr16_64_1,
        17 => Register::vr17_64_1,
        18 => Register::vr18_64_1,
        19 => Register::vr19_64_1,
        20 => Register::vr20_64_1,
        21 => Register::vr21_64_1,
        22 => Register::vr22_64_1,
        23 => Register::vr23_64_1,
        24 => Register::vr24_64_1,
        25 => Register::vr25_64_1,
        26 => Register::vr26_64_1,
        27 => Register::vr27_64_1,
        28 => Register::vr28_64_1,
        29 => Register::vr29_64_1,
        30 => Register::vr30_64_1,
        31 => Register::vr31_64_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_42_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_42_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_42_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_0,
        1 => Register::vr1_32_0,
        2 => Register::vr2_32_0,
        3 => Register::vr3_32_0,
        4 => Register::vr4_32_0,
        5 => Register::vr5_32_0,
        6 => Register::vr6_32_0,
        7 => Register::vr7_32_0,
        8 => Register::vr8_32_0,
        9 => Register::vr9_32_0,
        10 => Register::vr10_32_0,
        11 => Register::vr11_32_0,
        12 => Register::vr12_32_0,
        13 => Register::vr13_32_0,
        14 => Register::vr14_32_0,
        15 => Register::vr15_32_0,
        16 => Register::vr16_32_0,
        17 => Register::vr17_32_0,
        18 => Register::vr18_32_0,
        19 => Register::vr19_32_0,
        20 => Register::vr20_32_0,
        21 => Register::vr21_32_0,
        22 => Register::vr22_32_0,
        23 => Register::vr23_32_0,
        24 => Register::vr24_32_0,
        25 => Register::vr25_32_0,
        26 => Register::vr26_32_0,
        27 => Register::vr27_32_0,
        28 => Register::vr28_32_0,
        29 => Register::vr29_32_0,
        30 => Register::vr30_32_0,
        31 => Register::vr31_32_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_43_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_43_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_43_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_1,
        1 => Register::vr1_32_1,
        2 => Register::vr2_32_1,
        3 => Register::vr3_32_1,
        4 => Register::vr4_32_1,
        5 => Register::vr5_32_1,
        6 => Register::vr6_32_1,
        7 => Register::vr7_32_1,
        8 => Register::vr8_32_1,
        9 => Register::vr9_32_1,
        10 => Register::vr10_32_1,
        11 => Register::vr11_32_1,
        12 => Register::vr12_32_1,
        13 => Register::vr13_32_1,
        14 => Register::vr14_32_1,
        15 => Register::vr15_32_1,
        16 => Register::vr16_32_1,
        17 => Register::vr17_32_1,
        18 => Register::vr18_32_1,
        19 => Register::vr19_32_1,
        20 => Register::vr20_32_1,
        21 => Register::vr21_32_1,
        22 => Register::vr22_32_1,
        23 => Register::vr23_32_1,
        24 => Register::vr24_32_1,
        25 => Register::vr25_32_1,
        26 => Register::vr26_32_1,
        27 => Register::vr27_32_1,
        28 => Register::vr28_32_1,
        29 => Register::vr29_32_1,
        30 => Register::vr30_32_1,
        31 => Register::vr31_32_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_44_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_44_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_44_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_2,
        1 => Register::vr1_32_2,
        2 => Register::vr2_32_2,
        3 => Register::vr3_32_2,
        4 => Register::vr4_32_2,
        5 => Register::vr5_32_2,
        6 => Register::vr6_32_2,
        7 => Register::vr7_32_2,
        8 => Register::vr8_32_2,
        9 => Register::vr9_32_2,
        10 => Register::vr10_32_2,
        11 => Register::vr11_32_2,
        12 => Register::vr12_32_2,
        13 => Register::vr13_32_2,
        14 => Register::vr14_32_2,
        15 => Register::vr15_32_2,
        16 => Register::vr16_32_2,
        17 => Register::vr17_32_2,
        18 => Register::vr18_32_2,
        19 => Register::vr19_32_2,
        20 => Register::vr20_32_2,
        21 => Register::vr21_32_2,
        22 => Register::vr22_32_2,
        23 => Register::vr23_32_2,
        24 => Register::vr24_32_2,
        25 => Register::vr25_32_2,
        26 => Register::vr26_32_2,
        27 => Register::vr27_32_2,
        28 => Register::vr28_32_2,
        29 => Register::vr29_32_2,
        30 => Register::vr30_32_2,
        31 => Register::vr31_32_2,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_45_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_45_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_45_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_3,
        1 => Register::vr1_32_3,
        2 => Register::vr2_32_3,
        3 => Register::vr3_32_3,
        4 => Register::vr4_32_3,
        5 => Register::vr5_32_3,
        6 => Register::vr6_32_3,
        7 => Register::vr7_32_3,
        8 => Register::vr8_32_3,
        9 => Register::vr9_32_3,
        10 => Register::vr10_32_3,
        11 => Register::vr11_32_3,
        12 => Register::vr12_32_3,
        13 => Register::vr13_32_3,
        14 => Register::vr14_32_3,
        15 => Register::vr15_32_3,
        16 => Register::vr16_32_3,
        17 => Register::vr17_32_3,
        18 => Register::vr18_32_3,
        19 => Register::vr19_32_3,
        20 => Register::vr20_32_3,
        21 => Register::vr21_32_3,
        22 => Register::vr22_32_3,
        23 => Register::vr23_32_3,
        24 => Register::vr24_32_3,
        25 => Register::vr25_32_3,
        26 => Register::vr26_32_3,
        27 => Register::vr27_32_3,
        28 => Register::vr28_32_3,
        29 => Register::vr29_32_3,
        30 => Register::vr30_32_3,
        31 => Register::vr31_32_3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_46_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_46_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_46_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_0,
        1 => Register::vr1_16_0,
        2 => Register::vr2_16_0,
        3 => Register::vr3_16_0,
        4 => Register::vr4_16_0,
        5 => Register::vr5_16_0,
        6 => Register::vr6_16_0,
        7 => Register::vr7_16_0,
        8 => Register::vr8_16_0,
        9 => Register::vr9_16_0,
        10 => Register::vr10_16_0,
        11 => Register::vr11_16_0,
        12 => Register::vr12_16_0,
        13 => Register::vr13_16_0,
        14 => Register::vr14_16_0,
        15 => Register::vr15_16_0,
        16 => Register::vr16_16_0,
        17 => Register::vr17_16_0,
        18 => Register::vr18_16_0,
        19 => Register::vr19_16_0,
        20 => Register::vr20_16_0,
        21 => Register::vr21_16_0,
        22 => Register::vr22_16_0,
        23 => Register::vr23_16_0,
        24 => Register::vr24_16_0,
        25 => Register::vr25_16_0,
        26 => Register::vr26_16_0,
        27 => Register::vr27_16_0,
        28 => Register::vr28_16_0,
        29 => Register::vr29_16_0,
        30 => Register::vr30_16_0,
        31 => Register::vr31_16_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_47_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_47_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_47_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_1,
        1 => Register::vr1_16_1,
        2 => Register::vr2_16_1,
        3 => Register::vr3_16_1,
        4 => Register::vr4_16_1,
        5 => Register::vr5_16_1,
        6 => Register::vr6_16_1,
        7 => Register::vr7_16_1,
        8 => Register::vr8_16_1,
        9 => Register::vr9_16_1,
        10 => Register::vr10_16_1,
        11 => Register::vr11_16_1,
        12 => Register::vr12_16_1,
        13 => Register::vr13_16_1,
        14 => Register::vr14_16_1,
        15 => Register::vr15_16_1,
        16 => Register::vr16_16_1,
        17 => Register::vr17_16_1,
        18 => Register::vr18_16_1,
        19 => Register::vr19_16_1,
        20 => Register::vr20_16_1,
        21 => Register::vr21_16_1,
        22 => Register::vr22_16_1,
        23 => Register::vr23_16_1,
        24 => Register::vr24_16_1,
        25 => Register::vr25_16_1,
        26 => Register::vr26_16_1,
        27 => Register::vr27_16_1,
        28 => Register::vr28_16_1,
        29 => Register::vr29_16_1,
        30 => Register::vr30_16_1,
        31 => Register::vr31_16_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_48_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_48_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_48_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_2,
        1 => Register::vr1_16_2,
        2 => Register::vr2_16_2,
        3 => Register::vr3_16_2,
        4 => Register::vr4_16_2,
        5 => Register::vr5_16_2,
        6 => Register::vr6_16_2,
        7 => Register::vr7_16_2,
        8 => Register::vr8_16_2,
        9 => Register::vr9_16_2,
        10 => Register::vr10_16_2,
        11 => Register::vr11_16_2,
        12 => Register::vr12_16_2,
        13 => Register::vr13_16_2,
        14 => Register::vr14_16_2,
        15 => Register::vr15_16_2,
        16 => Register::vr16_16_2,
        17 => Register::vr17_16_2,
        18 => Register::vr18_16_2,
        19 => Register::vr19_16_2,
        20 => Register::vr20_16_2,
        21 => Register::vr21_16_2,
        22 => Register::vr22_16_2,
        23 => Register::vr23_16_2,
        24 => Register::vr24_16_2,
        25 => Register::vr25_16_2,
        26 => Register::vr26_16_2,
        27 => Register::vr27_16_2,
        28 => Register::vr28_16_2,
        29 => Register::vr29_16_2,
        30 => Register::vr30_16_2,
        31 => Register::vr31_16_2,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_49_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_49_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_49_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_3,
        1 => Register::vr1_16_3,
        2 => Register::vr2_16_3,
        3 => Register::vr3_16_3,
        4 => Register::vr4_16_3,
        5 => Register::vr5_16_3,
        6 => Register::vr6_16_3,
        7 => Register::vr7_16_3,
        8 => Register::vr8_16_3,
        9 => Register::vr9_16_3,
        10 => Register::vr10_16_3,
        11 => Register::vr11_16_3,
        12 => Register::vr12_16_3,
        13 => Register::vr13_16_3,
        14 => Register::vr14_16_3,
        15 => Register::vr15_16_3,
        16 => Register::vr16_16_3,
        17 => Register::vr17_16_3,
        18 => Register::vr18_16_3,
        19 => Register::vr19_16_3,
        20 => Register::vr20_16_3,
        21 => Register::vr21_16_3,
        22 => Register::vr22_16_3,
        23 => Register::vr23_16_3,
        24 => Register::vr24_16_3,
        25 => Register::vr25_16_3,
        26 => Register::vr26_16_3,
        27 => Register::vr27_16_3,
        28 => Register::vr28_16_3,
        29 => Register::vr29_16_3,
        30 => Register::vr30_16_3,
        31 => Register::vr31_16_3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_50_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_50_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_50_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_4,
        1 => Register::vr1_16_4,
        2 => Register::vr2_16_4,
        3 => Register::vr3_16_4,
        4 => Register::vr4_16_4,
        5 => Register::vr5_16_4,
        6 => Register::vr6_16_4,
        7 => Register::vr7_16_4,
        8 => Register::vr8_16_4,
        9 => Register::vr9_16_4,
        10 => Register::vr10_16_4,
        11 => Register::vr11_16_4,
        12 => Register::vr12_16_4,
        13 => Register::vr13_16_4,
        14 => Register::vr14_16_4,
        15 => Register::vr15_16_4,
        16 => Register::vr16_16_4,
        17 => Register::vr17_16_4,
        18 => Register::vr18_16_4,
        19 => Register::vr19_16_4,
        20 => Register::vr20_16_4,
        21 => Register::vr21_16_4,
        22 => Register::vr22_16_4,
        23 => Register::vr23_16_4,
        24 => Register::vr24_16_4,
        25 => Register::vr25_16_4,
        26 => Register::vr26_16_4,
        27 => Register::vr27_16_4,
        28 => Register::vr28_16_4,
        29 => Register::vr29_16_4,
        30 => Register::vr30_16_4,
        31 => Register::vr31_16_4,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_51_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_51_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_51_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_5,
        1 => Register::vr1_16_5,
        2 => Register::vr2_16_5,
        3 => Register::vr3_16_5,
        4 => Register::vr4_16_5,
        5 => Register::vr5_16_5,
        6 => Register::vr6_16_5,
        7 => Register::vr7_16_5,
        8 => Register::vr8_16_5,
        9 => Register::vr9_16_5,
        10 => Register::vr10_16_5,
        11 => Register::vr11_16_5,
        12 => Register::vr12_16_5,
        13 => Register::vr13_16_5,
        14 => Register::vr14_16_5,
        15 => Register::vr15_16_5,
        16 => Register::vr16_16_5,
        17 => Register::vr17_16_5,
        18 => Register::vr18_16_5,
        19 => Register::vr19_16_5,
        20 => Register::vr20_16_5,
        21 => Register::vr21_16_5,
        22 => Register::vr22_16_5,
        23 => Register::vr23_16_5,
        24 => Register::vr24_16_5,
        25 => Register::vr25_16_5,
        26 => Register::vr26_16_5,
        27 => Register::vr27_16_5,
        28 => Register::vr28_16_5,
        29 => Register::vr29_16_5,
        30 => Register::vr30_16_5,
        31 => Register::vr31_16_5,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_52_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_52_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_52_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_6,
        1 => Register::vr1_16_6,
        2 => Register::vr2_16_6,
        3 => Register::vr3_16_6,
        4 => Register::vr4_16_6,
        5 => Register::vr5_16_6,
        6 => Register::vr6_16_6,
        7 => Register::vr7_16_6,
        8 => Register::vr8_16_6,
        9 => Register::vr9_16_6,
        10 => Register::vr10_16_6,
        11 => Register::vr11_16_6,
        12 => Register::vr12_16_6,
        13 => Register::vr13_16_6,
        14 => Register::vr14_16_6,
        15 => Register::vr15_16_6,
        16 => Register::vr16_16_6,
        17 => Register::vr17_16_6,
        18 => Register::vr18_16_6,
        19 => Register::vr19_16_6,
        20 => Register::vr20_16_6,
        21 => Register::vr21_16_6,
        22 => Register::vr22_16_6,
        23 => Register::vr23_16_6,
        24 => Register::vr24_16_6,
        25 => Register::vr25_16_6,
        26 => Register::vr26_16_6,
        27 => Register::vr27_16_6,
        28 => Register::vr28_16_6,
        29 => Register::vr29_16_6,
        30 => Register::vr30_16_6,
        31 => Register::vr31_16_6,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_53_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_53_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_53_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_7,
        1 => Register::vr1_16_7,
        2 => Register::vr2_16_7,
        3 => Register::vr3_16_7,
        4 => Register::vr4_16_7,
        5 => Register::vr5_16_7,
        6 => Register::vr6_16_7,
        7 => Register::vr7_16_7,
        8 => Register::vr8_16_7,
        9 => Register::vr9_16_7,
        10 => Register::vr10_16_7,
        11 => Register::vr11_16_7,
        12 => Register::vr12_16_7,
        13 => Register::vr13_16_7,
        14 => Register::vr14_16_7,
        15 => Register::vr15_16_7,
        16 => Register::vr16_16_7,
        17 => Register::vr17_16_7,
        18 => Register::vr18_16_7,
        19 => Register::vr19_16_7,
        20 => Register::vr20_16_7,
        21 => Register::vr21_16_7,
        22 => Register::vr22_16_7,
        23 => Register::vr23_16_7,
        24 => Register::vr24_16_7,
        25 => Register::vr25_16_7,
        26 => Register::vr26_16_7,
        27 => Register::vr27_16_7,
        28 => Register::vr28_16_7,
        29 => Register::vr29_16_7,
        30 => Register::vr30_16_7,
        31 => Register::vr31_16_7,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_54_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_54_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_54_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_0,
        1 => Register::vr1_8_0,
        2 => Register::vr2_8_0,
        3 => Register::vr3_8_0,
        4 => Register::vr4_8_0,
        5 => Register::vr5_8_0,
        6 => Register::vr6_8_0,
        7 => Register::vr7_8_0,
        8 => Register::vr8_8_0,
        9 => Register::vr9_8_0,
        10 => Register::vr10_8_0,
        11 => Register::vr11_8_0,
        12 => Register::vr12_8_0,
        13 => Register::vr13_8_0,
        14 => Register::vr14_8_0,
        15 => Register::vr15_8_0,
        16 => Register::vr16_8_0,
        17 => Register::vr17_8_0,
        18 => Register::vr18_8_0,
        19 => Register::vr19_8_0,
        20 => Register::vr20_8_0,
        21 => Register::vr21_8_0,
        22 => Register::vr22_8_0,
        23 => Register::vr23_8_0,
        24 => Register::vr24_8_0,
        25 => Register::vr25_8_0,
        26 => Register::vr26_8_0,
        27 => Register::vr27_8_0,
        28 => Register::vr28_8_0,
        29 => Register::vr29_8_0,
        30 => Register::vr30_8_0,
        31 => Register::vr31_8_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_55_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_55_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_55_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_1,
        1 => Register::vr1_8_1,
        2 => Register::vr2_8_1,
        3 => Register::vr3_8_1,
        4 => Register::vr4_8_1,
        5 => Register::vr5_8_1,
        6 => Register::vr6_8_1,
        7 => Register::vr7_8_1,
        8 => Register::vr8_8_1,
        9 => Register::vr9_8_1,
        10 => Register::vr10_8_1,
        11 => Register::vr11_8_1,
        12 => Register::vr12_8_1,
        13 => Register::vr13_8_1,
        14 => Register::vr14_8_1,
        15 => Register::vr15_8_1,
        16 => Register::vr16_8_1,
        17 => Register::vr17_8_1,
        18 => Register::vr18_8_1,
        19 => Register::vr19_8_1,
        20 => Register::vr20_8_1,
        21 => Register::vr21_8_1,
        22 => Register::vr22_8_1,
        23 => Register::vr23_8_1,
        24 => Register::vr24_8_1,
        25 => Register::vr25_8_1,
        26 => Register::vr26_8_1,
        27 => Register::vr27_8_1,
        28 => Register::vr28_8_1,
        29 => Register::vr29_8_1,
        30 => Register::vr30_8_1,
        31 => Register::vr31_8_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_56_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_56_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_56_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_2,
        1 => Register::vr1_8_2,
        2 => Register::vr2_8_2,
        3 => Register::vr3_8_2,
        4 => Register::vr4_8_2,
        5 => Register::vr5_8_2,
        6 => Register::vr6_8_2,
        7 => Register::vr7_8_2,
        8 => Register::vr8_8_2,
        9 => Register::vr9_8_2,
        10 => Register::vr10_8_2,
        11 => Register::vr11_8_2,
        12 => Register::vr12_8_2,
        13 => Register::vr13_8_2,
        14 => Register::vr14_8_2,
        15 => Register::vr15_8_2,
        16 => Register::vr16_8_2,
        17 => Register::vr17_8_2,
        18 => Register::vr18_8_2,
        19 => Register::vr19_8_2,
        20 => Register::vr20_8_2,
        21 => Register::vr21_8_2,
        22 => Register::vr22_8_2,
        23 => Register::vr23_8_2,
        24 => Register::vr24_8_2,
        25 => Register::vr25_8_2,
        26 => Register::vr26_8_2,
        27 => Register::vr27_8_2,
        28 => Register::vr28_8_2,
        29 => Register::vr29_8_2,
        30 => Register::vr30_8_2,
        31 => Register::vr31_8_2,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_57_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_57_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_57_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_3,
        1 => Register::vr1_8_3,
        2 => Register::vr2_8_3,
        3 => Register::vr3_8_3,
        4 => Register::vr4_8_3,
        5 => Register::vr5_8_3,
        6 => Register::vr6_8_3,
        7 => Register::vr7_8_3,
        8 => Register::vr8_8_3,
        9 => Register::vr9_8_3,
        10 => Register::vr10_8_3,
        11 => Register::vr11_8_3,
        12 => Register::vr12_8_3,
        13 => Register::vr13_8_3,
        14 => Register::vr14_8_3,
        15 => Register::vr15_8_3,
        16 => Register::vr16_8_3,
        17 => Register::vr17_8_3,
        18 => Register::vr18_8_3,
        19 => Register::vr19_8_3,
        20 => Register::vr20_8_3,
        21 => Register::vr21_8_3,
        22 => Register::vr22_8_3,
        23 => Register::vr23_8_3,
        24 => Register::vr24_8_3,
        25 => Register::vr25_8_3,
        26 => Register::vr26_8_3,
        27 => Register::vr27_8_3,
        28 => Register::vr28_8_3,
        29 => Register::vr29_8_3,
        30 => Register::vr30_8_3,
        31 => Register::vr31_8_3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_58_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_58_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_58_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_4,
        1 => Register::vr1_8_4,
        2 => Register::vr2_8_4,
        3 => Register::vr3_8_4,
        4 => Register::vr4_8_4,
        5 => Register::vr5_8_4,
        6 => Register::vr6_8_4,
        7 => Register::vr7_8_4,
        8 => Register::vr8_8_4,
        9 => Register::vr9_8_4,
        10 => Register::vr10_8_4,
        11 => Register::vr11_8_4,
        12 => Register::vr12_8_4,
        13 => Register::vr13_8_4,
        14 => Register::vr14_8_4,
        15 => Register::vr15_8_4,
        16 => Register::vr16_8_4,
        17 => Register::vr17_8_4,
        18 => Register::vr18_8_4,
        19 => Register::vr19_8_4,
        20 => Register::vr20_8_4,
        21 => Register::vr21_8_4,
        22 => Register::vr22_8_4,
        23 => Register::vr23_8_4,
        24 => Register::vr24_8_4,
        25 => Register::vr25_8_4,
        26 => Register::vr26_8_4,
        27 => Register::vr27_8_4,
        28 => Register::vr28_8_4,
        29 => Register::vr29_8_4,
        30 => Register::vr30_8_4,
        31 => Register::vr31_8_4,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_59_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_59_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_59_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_5,
        1 => Register::vr1_8_5,
        2 => Register::vr2_8_5,
        3 => Register::vr3_8_5,
        4 => Register::vr4_8_5,
        5 => Register::vr5_8_5,
        6 => Register::vr6_8_5,
        7 => Register::vr7_8_5,
        8 => Register::vr8_8_5,
        9 => Register::vr9_8_5,
        10 => Register::vr10_8_5,
        11 => Register::vr11_8_5,
        12 => Register::vr12_8_5,
        13 => Register::vr13_8_5,
        14 => Register::vr14_8_5,
        15 => Register::vr15_8_5,
        16 => Register::vr16_8_5,
        17 => Register::vr17_8_5,
        18 => Register::vr18_8_5,
        19 => Register::vr19_8_5,
        20 => Register::vr20_8_5,
        21 => Register::vr21_8_5,
        22 => Register::vr22_8_5,
        23 => Register::vr23_8_5,
        24 => Register::vr24_8_5,
        25 => Register::vr25_8_5,
        26 => Register::vr26_8_5,
        27 => Register::vr27_8_5,
        28 => Register::vr28_8_5,
        29 => Register::vr29_8_5,
        30 => Register::vr30_8_5,
        31 => Register::vr31_8_5,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_60_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_60_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_60_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_6,
        1 => Register::vr1_8_6,
        2 => Register::vr2_8_6,
        3 => Register::vr3_8_6,
        4 => Register::vr4_8_6,
        5 => Register::vr5_8_6,
        6 => Register::vr6_8_6,
        7 => Register::vr7_8_6,
        8 => Register::vr8_8_6,
        9 => Register::vr9_8_6,
        10 => Register::vr10_8_6,
        11 => Register::vr11_8_6,
        12 => Register::vr12_8_6,
        13 => Register::vr13_8_6,
        14 => Register::vr14_8_6,
        15 => Register::vr15_8_6,
        16 => Register::vr16_8_6,
        17 => Register::vr17_8_6,
        18 => Register::vr18_8_6,
        19 => Register::vr19_8_6,
        20 => Register::vr20_8_6,
        21 => Register::vr21_8_6,
        22 => Register::vr22_8_6,
        23 => Register::vr23_8_6,
        24 => Register::vr24_8_6,
        25 => Register::vr25_8_6,
        26 => Register::vr26_8_6,
        27 => Register::vr27_8_6,
        28 => Register::vr28_8_6,
        29 => Register::vr29_8_6,
        30 => Register::vr30_8_6,
        31 => Register::vr31_8_6,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_61_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_61_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_61_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_7,
        1 => Register::vr1_8_7,
        2 => Register::vr2_8_7,
        3 => Register::vr3_8_7,
        4 => Register::vr4_8_7,
        5 => Register::vr5_8_7,
        6 => Register::vr6_8_7,
        7 => Register::vr7_8_7,
        8 => Register::vr8_8_7,
        9 => Register::vr9_8_7,
        10 => Register::vr10_8_7,
        11 => Register::vr11_8_7,
        12 => Register::vr12_8_7,
        13 => Register::vr13_8_7,
        14 => Register::vr14_8_7,
        15 => Register::vr15_8_7,
        16 => Register::vr16_8_7,
        17 => Register::vr17_8_7,
        18 => Register::vr18_8_7,
        19 => Register::vr19_8_7,
        20 => Register::vr20_8_7,
        21 => Register::vr21_8_7,
        22 => Register::vr22_8_7,
        23 => Register::vr23_8_7,
        24 => Register::vr24_8_7,
        25 => Register::vr25_8_7,
        26 => Register::vr26_8_7,
        27 => Register::vr27_8_7,
        28 => Register::vr28_8_7,
        29 => Register::vr29_8_7,
        30 => Register::vr30_8_7,
        31 => Register::vr31_8_7,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_62_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_62_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_62_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_8,
        1 => Register::vr1_8_8,
        2 => Register::vr2_8_8,
        3 => Register::vr3_8_8,
        4 => Register::vr4_8_8,
        5 => Register::vr5_8_8,
        6 => Register::vr6_8_8,
        7 => Register::vr7_8_8,
        8 => Register::vr8_8_8,
        9 => Register::vr9_8_8,
        10 => Register::vr10_8_8,
        11 => Register::vr11_8_8,
        12 => Register::vr12_8_8,
        13 => Register::vr13_8_8,
        14 => Register::vr14_8_8,
        15 => Register::vr15_8_8,
        16 => Register::vr16_8_8,
        17 => Register::vr17_8_8,
        18 => Register::vr18_8_8,
        19 => Register::vr19_8_8,
        20 => Register::vr20_8_8,
        21 => Register::vr21_8_8,
        22 => Register::vr22_8_8,
        23 => Register::vr23_8_8,
        24 => Register::vr24_8_8,
        25 => Register::vr25_8_8,
        26 => Register::vr26_8_8,
        27 => Register::vr27_8_8,
        28 => Register::vr28_8_8,
        29 => Register::vr29_8_8,
        30 => Register::vr30_8_8,
        31 => Register::vr31_8_8,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_63_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_63_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_63_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_9,
        1 => Register::vr1_8_9,
        2 => Register::vr2_8_9,
        3 => Register::vr3_8_9,
        4 => Register::vr4_8_9,
        5 => Register::vr5_8_9,
        6 => Register::vr6_8_9,
        7 => Register::vr7_8_9,
        8 => Register::vr8_8_9,
        9 => Register::vr9_8_9,
        10 => Register::vr10_8_9,
        11 => Register::vr11_8_9,
        12 => Register::vr12_8_9,
        13 => Register::vr13_8_9,
        14 => Register::vr14_8_9,
        15 => Register::vr15_8_9,
        16 => Register::vr16_8_9,
        17 => Register::vr17_8_9,
        18 => Register::vr18_8_9,
        19 => Register::vr19_8_9,
        20 => Register::vr20_8_9,
        21 => Register::vr21_8_9,
        22 => Register::vr22_8_9,
        23 => Register::vr23_8_9,
        24 => Register::vr24_8_9,
        25 => Register::vr25_8_9,
        26 => Register::vr26_8_9,
        27 => Register::vr27_8_9,
        28 => Register::vr28_8_9,
        29 => Register::vr29_8_9,
        30 => Register::vr30_8_9,
        31 => Register::vr31_8_9,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_64_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_64_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_64_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_10,
        1 => Register::vr1_8_10,
        2 => Register::vr2_8_10,
        3 => Register::vr3_8_10,
        4 => Register::vr4_8_10,
        5 => Register::vr5_8_10,
        6 => Register::vr6_8_10,
        7 => Register::vr7_8_10,
        8 => Register::vr8_8_10,
        9 => Register::vr9_8_10,
        10 => Register::vr10_8_10,
        11 => Register::vr11_8_10,
        12 => Register::vr12_8_10,
        13 => Register::vr13_8_10,
        14 => Register::vr14_8_10,
        15 => Register::vr15_8_10,
        16 => Register::vr16_8_10,
        17 => Register::vr17_8_10,
        18 => Register::vr18_8_10,
        19 => Register::vr19_8_10,
        20 => Register::vr20_8_10,
        21 => Register::vr21_8_10,
        22 => Register::vr22_8_10,
        23 => Register::vr23_8_10,
        24 => Register::vr24_8_10,
        25 => Register::vr25_8_10,
        26 => Register::vr26_8_10,
        27 => Register::vr27_8_10,
        28 => Register::vr28_8_10,
        29 => Register::vr29_8_10,
        30 => Register::vr30_8_10,
        31 => Register::vr31_8_10,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_65_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_65_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_65_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_11,
        1 => Register::vr1_8_11,
        2 => Register::vr2_8_11,
        3 => Register::vr3_8_11,
        4 => Register::vr4_8_11,
        5 => Register::vr5_8_11,
        6 => Register::vr6_8_11,
        7 => Register::vr7_8_11,
        8 => Register::vr8_8_11,
        9 => Register::vr9_8_11,
        10 => Register::vr10_8_11,
        11 => Register::vr11_8_11,
        12 => Register::vr12_8_11,
        13 => Register::vr13_8_11,
        14 => Register::vr14_8_11,
        15 => Register::vr15_8_11,
        16 => Register::vr16_8_11,
        17 => Register::vr17_8_11,
        18 => Register::vr18_8_11,
        19 => Register::vr19_8_11,
        20 => Register::vr20_8_11,
        21 => Register::vr21_8_11,
        22 => Register::vr22_8_11,
        23 => Register::vr23_8_11,
        24 => Register::vr24_8_11,
        25 => Register::vr25_8_11,
        26 => Register::vr26_8_11,
        27 => Register::vr27_8_11,
        28 => Register::vr28_8_11,
        29 => Register::vr29_8_11,
        30 => Register::vr30_8_11,
        31 => Register::vr31_8_11,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_66_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_66_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_66_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_12,
        1 => Register::vr1_8_12,
        2 => Register::vr2_8_12,
        3 => Register::vr3_8_12,
        4 => Register::vr4_8_12,
        5 => Register::vr5_8_12,
        6 => Register::vr6_8_12,
        7 => Register::vr7_8_12,
        8 => Register::vr8_8_12,
        9 => Register::vr9_8_12,
        10 => Register::vr10_8_12,
        11 => Register::vr11_8_12,
        12 => Register::vr12_8_12,
        13 => Register::vr13_8_12,
        14 => Register::vr14_8_12,
        15 => Register::vr15_8_12,
        16 => Register::vr16_8_12,
        17 => Register::vr17_8_12,
        18 => Register::vr18_8_12,
        19 => Register::vr19_8_12,
        20 => Register::vr20_8_12,
        21 => Register::vr21_8_12,
        22 => Register::vr22_8_12,
        23 => Register::vr23_8_12,
        24 => Register::vr24_8_12,
        25 => Register::vr25_8_12,
        26 => Register::vr26_8_12,
        27 => Register::vr27_8_12,
        28 => Register::vr28_8_12,
        29 => Register::vr29_8_12,
        30 => Register::vr30_8_12,
        31 => Register::vr31_8_12,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_67_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_67_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_67_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_13,
        1 => Register::vr1_8_13,
        2 => Register::vr2_8_13,
        3 => Register::vr3_8_13,
        4 => Register::vr4_8_13,
        5 => Register::vr5_8_13,
        6 => Register::vr6_8_13,
        7 => Register::vr7_8_13,
        8 => Register::vr8_8_13,
        9 => Register::vr9_8_13,
        10 => Register::vr10_8_13,
        11 => Register::vr11_8_13,
        12 => Register::vr12_8_13,
        13 => Register::vr13_8_13,
        14 => Register::vr14_8_13,
        15 => Register::vr15_8_13,
        16 => Register::vr16_8_13,
        17 => Register::vr17_8_13,
        18 => Register::vr18_8_13,
        19 => Register::vr19_8_13,
        20 => Register::vr20_8_13,
        21 => Register::vr21_8_13,
        22 => Register::vr22_8_13,
        23 => Register::vr23_8_13,
        24 => Register::vr24_8_13,
        25 => Register::vr25_8_13,
        26 => Register::vr26_8_13,
        27 => Register::vr27_8_13,
        28 => Register::vr28_8_13,
        29 => Register::vr29_8_13,
        30 => Register::vr30_8_13,
        31 => Register::vr31_8_13,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_68_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_68_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_68_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_14,
        1 => Register::vr1_8_14,
        2 => Register::vr2_8_14,
        3 => Register::vr3_8_14,
        4 => Register::vr4_8_14,
        5 => Register::vr5_8_14,
        6 => Register::vr6_8_14,
        7 => Register::vr7_8_14,
        8 => Register::vr8_8_14,
        9 => Register::vr9_8_14,
        10 => Register::vr10_8_14,
        11 => Register::vr11_8_14,
        12 => Register::vr12_8_14,
        13 => Register::vr13_8_14,
        14 => Register::vr14_8_14,
        15 => Register::vr15_8_14,
        16 => Register::vr16_8_14,
        17 => Register::vr17_8_14,
        18 => Register::vr18_8_14,
        19 => Register::vr19_8_14,
        20 => Register::vr20_8_14,
        21 => Register::vr21_8_14,
        22 => Register::vr22_8_14,
        23 => Register::vr23_8_14,
        24 => Register::vr24_8_14,
        25 => Register::vr25_8_14,
        26 => Register::vr26_8_14,
        27 => Register::vr27_8_14,
        28 => Register::vr28_8_14,
        29 => Register::vr29_8_14,
        30 => Register::vr30_8_14,
        31 => Register::vr31_8_14,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_69_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_69_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_69_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_15,
        1 => Register::vr1_8_15,
        2 => Register::vr2_8_15,
        3 => Register::vr3_8_15,
        4 => Register::vr4_8_15,
        5 => Register::vr5_8_15,
        6 => Register::vr6_8_15,
        7 => Register::vr7_8_15,
        8 => Register::vr8_8_15,
        9 => Register::vr9_8_15,
        10 => Register::vr10_8_15,
        11 => Register::vr11_8_15,
        12 => Register::vr12_8_15,
        13 => Register::vr13_8_15,
        14 => Register::vr14_8_15,
        15 => Register::vr15_8_15,
        16 => Register::vr16_8_15,
        17 => Register::vr17_8_15,
        18 => Register::vr18_8_15,
        19 => Register::vr19_8_15,
        20 => Register::vr20_8_15,
        21 => Register::vr21_8_15,
        22 => Register::vr22_8_15,
        23 => Register::vr23_8_15,
        24 => Register::vr24_8_15,
        25 => Register::vr25_8_15,
        26 => Register::vr26_8_15,
        27 => Register::vr27_8_15,
        28 => Register::vr28_8_15,
        29 => Register::vr29_8_15,
        30 => Register::vr30_8_15,
        31 => Register::vr31_8_15,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_70_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_70_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_70_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_64_0,
        1 => Register::vr1_64_0,
        2 => Register::vr2_64_0,
        3 => Register::vr3_64_0,
        4 => Register::vr4_64_0,
        5 => Register::vr5_64_0,
        6 => Register::vr6_64_0,
        7 => Register::vr7_64_0,
        8 => Register::vr8_64_0,
        9 => Register::vr9_64_0,
        10 => Register::vr10_64_0,
        11 => Register::vr11_64_0,
        12 => Register::vr12_64_0,
        13 => Register::vr13_64_0,
        14 => Register::vr14_64_0,
        15 => Register::vr15_64_0,
        16 => Register::vr16_64_0,
        17 => Register::vr17_64_0,
        18 => Register::vr18_64_0,
        19 => Register::vr19_64_0,
        20 => Register::vr20_64_0,
        21 => Register::vr21_64_0,
        22 => Register::vr22_64_0,
        23 => Register::vr23_64_0,
        24 => Register::vr24_64_0,
        25 => Register::vr25_64_0,
        26 => Register::vr26_64_0,
        27 => Register::vr27_64_0,
        28 => Register::vr28_64_0,
        29 => Register::vr29_64_0,
        30 => Register::vr30_64_0,
        31 => Register::vr31_64_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_71_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_71_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_71_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_64_1,
        1 => Register::vr1_64_1,
        2 => Register::vr2_64_1,
        3 => Register::vr3_64_1,
        4 => Register::vr4_64_1,
        5 => Register::vr5_64_1,
        6 => Register::vr6_64_1,
        7 => Register::vr7_64_1,
        8 => Register::vr8_64_1,
        9 => Register::vr9_64_1,
        10 => Register::vr10_64_1,
        11 => Register::vr11_64_1,
        12 => Register::vr12_64_1,
        13 => Register::vr13_64_1,
        14 => Register::vr14_64_1,
        15 => Register::vr15_64_1,
        16 => Register::vr16_64_1,
        17 => Register::vr17_64_1,
        18 => Register::vr18_64_1,
        19 => Register::vr19_64_1,
        20 => Register::vr20_64_1,
        21 => Register::vr21_64_1,
        22 => Register::vr22_64_1,
        23 => Register::vr23_64_1,
        24 => Register::vr24_64_1,
        25 => Register::vr25_64_1,
        26 => Register::vr26_64_1,
        27 => Register::vr27_64_1,
        28 => Register::vr28_64_1,
        29 => Register::vr29_64_1,
        30 => Register::vr30_64_1,
        31 => Register::vr31_64_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_72_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_72_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_72_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_0,
        1 => Register::vr1_32_0,
        2 => Register::vr2_32_0,
        3 => Register::vr3_32_0,
        4 => Register::vr4_32_0,
        5 => Register::vr5_32_0,
        6 => Register::vr6_32_0,
        7 => Register::vr7_32_0,
        8 => Register::vr8_32_0,
        9 => Register::vr9_32_0,
        10 => Register::vr10_32_0,
        11 => Register::vr11_32_0,
        12 => Register::vr12_32_0,
        13 => Register::vr13_32_0,
        14 => Register::vr14_32_0,
        15 => Register::vr15_32_0,
        16 => Register::vr16_32_0,
        17 => Register::vr17_32_0,
        18 => Register::vr18_32_0,
        19 => Register::vr19_32_0,
        20 => Register::vr20_32_0,
        21 => Register::vr21_32_0,
        22 => Register::vr22_32_0,
        23 => Register::vr23_32_0,
        24 => Register::vr24_32_0,
        25 => Register::vr25_32_0,
        26 => Register::vr26_32_0,
        27 => Register::vr27_32_0,
        28 => Register::vr28_32_0,
        29 => Register::vr29_32_0,
        30 => Register::vr30_32_0,
        31 => Register::vr31_32_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_73_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_73_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_73_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_1,
        1 => Register::vr1_32_1,
        2 => Register::vr2_32_1,
        3 => Register::vr3_32_1,
        4 => Register::vr4_32_1,
        5 => Register::vr5_32_1,
        6 => Register::vr6_32_1,
        7 => Register::vr7_32_1,
        8 => Register::vr8_32_1,
        9 => Register::vr9_32_1,
        10 => Register::vr10_32_1,
        11 => Register::vr11_32_1,
        12 => Register::vr12_32_1,
        13 => Register::vr13_32_1,
        14 => Register::vr14_32_1,
        15 => Register::vr15_32_1,
        16 => Register::vr16_32_1,
        17 => Register::vr17_32_1,
        18 => Register::vr18_32_1,
        19 => Register::vr19_32_1,
        20 => Register::vr20_32_1,
        21 => Register::vr21_32_1,
        22 => Register::vr22_32_1,
        23 => Register::vr23_32_1,
        24 => Register::vr24_32_1,
        25 => Register::vr25_32_1,
        26 => Register::vr26_32_1,
        27 => Register::vr27_32_1,
        28 => Register::vr28_32_1,
        29 => Register::vr29_32_1,
        30 => Register::vr30_32_1,
        31 => Register::vr31_32_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_74_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_74_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_74_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_2,
        1 => Register::vr1_32_2,
        2 => Register::vr2_32_2,
        3 => Register::vr3_32_2,
        4 => Register::vr4_32_2,
        5 => Register::vr5_32_2,
        6 => Register::vr6_32_2,
        7 => Register::vr7_32_2,
        8 => Register::vr8_32_2,
        9 => Register::vr9_32_2,
        10 => Register::vr10_32_2,
        11 => Register::vr11_32_2,
        12 => Register::vr12_32_2,
        13 => Register::vr13_32_2,
        14 => Register::vr14_32_2,
        15 => Register::vr15_32_2,
        16 => Register::vr16_32_2,
        17 => Register::vr17_32_2,
        18 => Register::vr18_32_2,
        19 => Register::vr19_32_2,
        20 => Register::vr20_32_2,
        21 => Register::vr21_32_2,
        22 => Register::vr22_32_2,
        23 => Register::vr23_32_2,
        24 => Register::vr24_32_2,
        25 => Register::vr25_32_2,
        26 => Register::vr26_32_2,
        27 => Register::vr27_32_2,
        28 => Register::vr28_32_2,
        29 => Register::vr29_32_2,
        30 => Register::vr30_32_2,
        31 => Register::vr31_32_2,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_75_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_75_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_75_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_3,
        1 => Register::vr1_32_3,
        2 => Register::vr2_32_3,
        3 => Register::vr3_32_3,
        4 => Register::vr4_32_3,
        5 => Register::vr5_32_3,
        6 => Register::vr6_32_3,
        7 => Register::vr7_32_3,
        8 => Register::vr8_32_3,
        9 => Register::vr9_32_3,
        10 => Register::vr10_32_3,
        11 => Register::vr11_32_3,
        12 => Register::vr12_32_3,
        13 => Register::vr13_32_3,
        14 => Register::vr14_32_3,
        15 => Register::vr15_32_3,
        16 => Register::vr16_32_3,
        17 => Register::vr17_32_3,
        18 => Register::vr18_32_3,
        19 => Register::vr19_32_3,
        20 => Register::vr20_32_3,
        21 => Register::vr21_32_3,
        22 => Register::vr22_32_3,
        23 => Register::vr23_32_3,
        24 => Register::vr24_32_3,
        25 => Register::vr25_32_3,
        26 => Register::vr26_32_3,
        27 => Register::vr27_32_3,
        28 => Register::vr28_32_3,
        29 => Register::vr29_32_3,
        30 => Register::vr30_32_3,
        31 => Register::vr31_32_3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_76_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_76_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_76_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_0,
        1 => Register::vr1_16_0,
        2 => Register::vr2_16_0,
        3 => Register::vr3_16_0,
        4 => Register::vr4_16_0,
        5 => Register::vr5_16_0,
        6 => Register::vr6_16_0,
        7 => Register::vr7_16_0,
        8 => Register::vr8_16_0,
        9 => Register::vr9_16_0,
        10 => Register::vr10_16_0,
        11 => Register::vr11_16_0,
        12 => Register::vr12_16_0,
        13 => Register::vr13_16_0,
        14 => Register::vr14_16_0,
        15 => Register::vr15_16_0,
        16 => Register::vr16_16_0,
        17 => Register::vr17_16_0,
        18 => Register::vr18_16_0,
        19 => Register::vr19_16_0,
        20 => Register::vr20_16_0,
        21 => Register::vr21_16_0,
        22 => Register::vr22_16_0,
        23 => Register::vr23_16_0,
        24 => Register::vr24_16_0,
        25 => Register::vr25_16_0,
        26 => Register::vr26_16_0,
        27 => Register::vr27_16_0,
        28 => Register::vr28_16_0,
        29 => Register::vr29_16_0,
        30 => Register::vr30_16_0,
        31 => Register::vr31_16_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_77_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_77_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_77_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_1,
        1 => Register::vr1_16_1,
        2 => Register::vr2_16_1,
        3 => Register::vr3_16_1,
        4 => Register::vr4_16_1,
        5 => Register::vr5_16_1,
        6 => Register::vr6_16_1,
        7 => Register::vr7_16_1,
        8 => Register::vr8_16_1,
        9 => Register::vr9_16_1,
        10 => Register::vr10_16_1,
        11 => Register::vr11_16_1,
        12 => Register::vr12_16_1,
        13 => Register::vr13_16_1,
        14 => Register::vr14_16_1,
        15 => Register::vr15_16_1,
        16 => Register::vr16_16_1,
        17 => Register::vr17_16_1,
        18 => Register::vr18_16_1,
        19 => Register::vr19_16_1,
        20 => Register::vr20_16_1,
        21 => Register::vr21_16_1,
        22 => Register::vr22_16_1,
        23 => Register::vr23_16_1,
        24 => Register::vr24_16_1,
        25 => Register::vr25_16_1,
        26 => Register::vr26_16_1,
        27 => Register::vr27_16_1,
        28 => Register::vr28_16_1,
        29 => Register::vr29_16_1,
        30 => Register::vr30_16_1,
        31 => Register::vr31_16_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_78_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_78_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_78_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_2,
        1 => Register::vr1_16_2,
        2 => Register::vr2_16_2,
        3 => Register::vr3_16_2,
        4 => Register::vr4_16_2,
        5 => Register::vr5_16_2,
        6 => Register::vr6_16_2,
        7 => Register::vr7_16_2,
        8 => Register::vr8_16_2,
        9 => Register::vr9_16_2,
        10 => Register::vr10_16_2,
        11 => Register::vr11_16_2,
        12 => Register::vr12_16_2,
        13 => Register::vr13_16_2,
        14 => Register::vr14_16_2,
        15 => Register::vr15_16_2,
        16 => Register::vr16_16_2,
        17 => Register::vr17_16_2,
        18 => Register::vr18_16_2,
        19 => Register::vr19_16_2,
        20 => Register::vr20_16_2,
        21 => Register::vr21_16_2,
        22 => Register::vr22_16_2,
        23 => Register::vr23_16_2,
        24 => Register::vr24_16_2,
        25 => Register::vr25_16_2,
        26 => Register::vr26_16_2,
        27 => Register::vr27_16_2,
        28 => Register::vr28_16_2,
        29 => Register::vr29_16_2,
        30 => Register::vr30_16_2,
        31 => Register::vr31_16_2,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_79_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_79_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_79_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_3,
        1 => Register::vr1_16_3,
        2 => Register::vr2_16_3,
        3 => Register::vr3_16_3,
        4 => Register::vr4_16_3,
        5 => Register::vr5_16_3,
        6 => Register::vr6_16_3,
        7 => Register::vr7_16_3,
        8 => Register::vr8_16_3,
        9 => Register::vr9_16_3,
        10 => Register::vr10_16_3,
        11 => Register::vr11_16_3,
        12 => Register::vr12_16_3,
        13 => Register::vr13_16_3,
        14 => Register::vr14_16_3,
        15 => Register::vr15_16_3,
        16 => Register::vr16_16_3,
        17 => Register::vr17_16_3,
        18 => Register::vr18_16_3,
        19 => Register::vr19_16_3,
        20 => Register::vr20_16_3,
        21 => Register::vr21_16_3,
        22 => Register::vr22_16_3,
        23 => Register::vr23_16_3,
        24 => Register::vr24_16_3,
        25 => Register::vr25_16_3,
        26 => Register::vr26_16_3,
        27 => Register::vr27_16_3,
        28 => Register::vr28_16_3,
        29 => Register::vr29_16_3,
        30 => Register::vr30_16_3,
        31 => Register::vr31_16_3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_80_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_80_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_80_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_4,
        1 => Register::vr1_16_4,
        2 => Register::vr2_16_4,
        3 => Register::vr3_16_4,
        4 => Register::vr4_16_4,
        5 => Register::vr5_16_4,
        6 => Register::vr6_16_4,
        7 => Register::vr7_16_4,
        8 => Register::vr8_16_4,
        9 => Register::vr9_16_4,
        10 => Register::vr10_16_4,
        11 => Register::vr11_16_4,
        12 => Register::vr12_16_4,
        13 => Register::vr13_16_4,
        14 => Register::vr14_16_4,
        15 => Register::vr15_16_4,
        16 => Register::vr16_16_4,
        17 => Register::vr17_16_4,
        18 => Register::vr18_16_4,
        19 => Register::vr19_16_4,
        20 => Register::vr20_16_4,
        21 => Register::vr21_16_4,
        22 => Register::vr22_16_4,
        23 => Register::vr23_16_4,
        24 => Register::vr24_16_4,
        25 => Register::vr25_16_4,
        26 => Register::vr26_16_4,
        27 => Register::vr27_16_4,
        28 => Register::vr28_16_4,
        29 => Register::vr29_16_4,
        30 => Register::vr30_16_4,
        31 => Register::vr31_16_4,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_81_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_81_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_81_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_5,
        1 => Register::vr1_16_5,
        2 => Register::vr2_16_5,
        3 => Register::vr3_16_5,
        4 => Register::vr4_16_5,
        5 => Register::vr5_16_5,
        6 => Register::vr6_16_5,
        7 => Register::vr7_16_5,
        8 => Register::vr8_16_5,
        9 => Register::vr9_16_5,
        10 => Register::vr10_16_5,
        11 => Register::vr11_16_5,
        12 => Register::vr12_16_5,
        13 => Register::vr13_16_5,
        14 => Register::vr14_16_5,
        15 => Register::vr15_16_5,
        16 => Register::vr16_16_5,
        17 => Register::vr17_16_5,
        18 => Register::vr18_16_5,
        19 => Register::vr19_16_5,
        20 => Register::vr20_16_5,
        21 => Register::vr21_16_5,
        22 => Register::vr22_16_5,
        23 => Register::vr23_16_5,
        24 => Register::vr24_16_5,
        25 => Register::vr25_16_5,
        26 => Register::vr26_16_5,
        27 => Register::vr27_16_5,
        28 => Register::vr28_16_5,
        29 => Register::vr29_16_5,
        30 => Register::vr30_16_5,
        31 => Register::vr31_16_5,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_82_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_82_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_82_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_6,
        1 => Register::vr1_16_6,
        2 => Register::vr2_16_6,
        3 => Register::vr3_16_6,
        4 => Register::vr4_16_6,
        5 => Register::vr5_16_6,
        6 => Register::vr6_16_6,
        7 => Register::vr7_16_6,
        8 => Register::vr8_16_6,
        9 => Register::vr9_16_6,
        10 => Register::vr10_16_6,
        11 => Register::vr11_16_6,
        12 => Register::vr12_16_6,
        13 => Register::vr13_16_6,
        14 => Register::vr14_16_6,
        15 => Register::vr15_16_6,
        16 => Register::vr16_16_6,
        17 => Register::vr17_16_6,
        18 => Register::vr18_16_6,
        19 => Register::vr19_16_6,
        20 => Register::vr20_16_6,
        21 => Register::vr21_16_6,
        22 => Register::vr22_16_6,
        23 => Register::vr23_16_6,
        24 => Register::vr24_16_6,
        25 => Register::vr25_16_6,
        26 => Register::vr26_16_6,
        27 => Register::vr27_16_6,
        28 => Register::vr28_16_6,
        29 => Register::vr29_16_6,
        30 => Register::vr30_16_6,
        31 => Register::vr31_16_6,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_83_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_83_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_83_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_7,
        1 => Register::vr1_16_7,
        2 => Register::vr2_16_7,
        3 => Register::vr3_16_7,
        4 => Register::vr4_16_7,
        5 => Register::vr5_16_7,
        6 => Register::vr6_16_7,
        7 => Register::vr7_16_7,
        8 => Register::vr8_16_7,
        9 => Register::vr9_16_7,
        10 => Register::vr10_16_7,
        11 => Register::vr11_16_7,
        12 => Register::vr12_16_7,
        13 => Register::vr13_16_7,
        14 => Register::vr14_16_7,
        15 => Register::vr15_16_7,
        16 => Register::vr16_16_7,
        17 => Register::vr17_16_7,
        18 => Register::vr18_16_7,
        19 => Register::vr19_16_7,
        20 => Register::vr20_16_7,
        21 => Register::vr21_16_7,
        22 => Register::vr22_16_7,
        23 => Register::vr23_16_7,
        24 => Register::vr24_16_7,
        25 => Register::vr25_16_7,
        26 => Register::vr26_16_7,
        27 => Register::vr27_16_7,
        28 => Register::vr28_16_7,
        29 => Register::vr29_16_7,
        30 => Register::vr30_16_7,
        31 => Register::vr31_16_7,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_84_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_84_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_84_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_0,
        1 => Register::vr1_8_0,
        2 => Register::vr2_8_0,
        3 => Register::vr3_8_0,
        4 => Register::vr4_8_0,
        5 => Register::vr5_8_0,
        6 => Register::vr6_8_0,
        7 => Register::vr7_8_0,
        8 => Register::vr8_8_0,
        9 => Register::vr9_8_0,
        10 => Register::vr10_8_0,
        11 => Register::vr11_8_0,
        12 => Register::vr12_8_0,
        13 => Register::vr13_8_0,
        14 => Register::vr14_8_0,
        15 => Register::vr15_8_0,
        16 => Register::vr16_8_0,
        17 => Register::vr17_8_0,
        18 => Register::vr18_8_0,
        19 => Register::vr19_8_0,
        20 => Register::vr20_8_0,
        21 => Register::vr21_8_0,
        22 => Register::vr22_8_0,
        23 => Register::vr23_8_0,
        24 => Register::vr24_8_0,
        25 => Register::vr25_8_0,
        26 => Register::vr26_8_0,
        27 => Register::vr27_8_0,
        28 => Register::vr28_8_0,
        29 => Register::vr29_8_0,
        30 => Register::vr30_8_0,
        31 => Register::vr31_8_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_85_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_85_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_85_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_1,
        1 => Register::vr1_8_1,
        2 => Register::vr2_8_1,
        3 => Register::vr3_8_1,
        4 => Register::vr4_8_1,
        5 => Register::vr5_8_1,
        6 => Register::vr6_8_1,
        7 => Register::vr7_8_1,
        8 => Register::vr8_8_1,
        9 => Register::vr9_8_1,
        10 => Register::vr10_8_1,
        11 => Register::vr11_8_1,
        12 => Register::vr12_8_1,
        13 => Register::vr13_8_1,
        14 => Register::vr14_8_1,
        15 => Register::vr15_8_1,
        16 => Register::vr16_8_1,
        17 => Register::vr17_8_1,
        18 => Register::vr18_8_1,
        19 => Register::vr19_8_1,
        20 => Register::vr20_8_1,
        21 => Register::vr21_8_1,
        22 => Register::vr22_8_1,
        23 => Register::vr23_8_1,
        24 => Register::vr24_8_1,
        25 => Register::vr25_8_1,
        26 => Register::vr26_8_1,
        27 => Register::vr27_8_1,
        28 => Register::vr28_8_1,
        29 => Register::vr29_8_1,
        30 => Register::vr30_8_1,
        31 => Register::vr31_8_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_86_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_86_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_86_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_2,
        1 => Register::vr1_8_2,
        2 => Register::vr2_8_2,
        3 => Register::vr3_8_2,
        4 => Register::vr4_8_2,
        5 => Register::vr5_8_2,
        6 => Register::vr6_8_2,
        7 => Register::vr7_8_2,
        8 => Register::vr8_8_2,
        9 => Register::vr9_8_2,
        10 => Register::vr10_8_2,
        11 => Register::vr11_8_2,
        12 => Register::vr12_8_2,
        13 => Register::vr13_8_2,
        14 => Register::vr14_8_2,
        15 => Register::vr15_8_2,
        16 => Register::vr16_8_2,
        17 => Register::vr17_8_2,
        18 => Register::vr18_8_2,
        19 => Register::vr19_8_2,
        20 => Register::vr20_8_2,
        21 => Register::vr21_8_2,
        22 => Register::vr22_8_2,
        23 => Register::vr23_8_2,
        24 => Register::vr24_8_2,
        25 => Register::vr25_8_2,
        26 => Register::vr26_8_2,
        27 => Register::vr27_8_2,
        28 => Register::vr28_8_2,
        29 => Register::vr29_8_2,
        30 => Register::vr30_8_2,
        31 => Register::vr31_8_2,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_87_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_87_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_87_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_3,
        1 => Register::vr1_8_3,
        2 => Register::vr2_8_3,
        3 => Register::vr3_8_3,
        4 => Register::vr4_8_3,
        5 => Register::vr5_8_3,
        6 => Register::vr6_8_3,
        7 => Register::vr7_8_3,
        8 => Register::vr8_8_3,
        9 => Register::vr9_8_3,
        10 => Register::vr10_8_3,
        11 => Register::vr11_8_3,
        12 => Register::vr12_8_3,
        13 => Register::vr13_8_3,
        14 => Register::vr14_8_3,
        15 => Register::vr15_8_3,
        16 => Register::vr16_8_3,
        17 => Register::vr17_8_3,
        18 => Register::vr18_8_3,
        19 => Register::vr19_8_3,
        20 => Register::vr20_8_3,
        21 => Register::vr21_8_3,
        22 => Register::vr22_8_3,
        23 => Register::vr23_8_3,
        24 => Register::vr24_8_3,
        25 => Register::vr25_8_3,
        26 => Register::vr26_8_3,
        27 => Register::vr27_8_3,
        28 => Register::vr28_8_3,
        29 => Register::vr29_8_3,
        30 => Register::vr30_8_3,
        31 => Register::vr31_8_3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_88_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_88_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_88_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_4,
        1 => Register::vr1_8_4,
        2 => Register::vr2_8_4,
        3 => Register::vr3_8_4,
        4 => Register::vr4_8_4,
        5 => Register::vr5_8_4,
        6 => Register::vr6_8_4,
        7 => Register::vr7_8_4,
        8 => Register::vr8_8_4,
        9 => Register::vr9_8_4,
        10 => Register::vr10_8_4,
        11 => Register::vr11_8_4,
        12 => Register::vr12_8_4,
        13 => Register::vr13_8_4,
        14 => Register::vr14_8_4,
        15 => Register::vr15_8_4,
        16 => Register::vr16_8_4,
        17 => Register::vr17_8_4,
        18 => Register::vr18_8_4,
        19 => Register::vr19_8_4,
        20 => Register::vr20_8_4,
        21 => Register::vr21_8_4,
        22 => Register::vr22_8_4,
        23 => Register::vr23_8_4,
        24 => Register::vr24_8_4,
        25 => Register::vr25_8_4,
        26 => Register::vr26_8_4,
        27 => Register::vr27_8_4,
        28 => Register::vr28_8_4,
        29 => Register::vr29_8_4,
        30 => Register::vr30_8_4,
        31 => Register::vr31_8_4,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_89_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_89_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_89_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_5,
        1 => Register::vr1_8_5,
        2 => Register::vr2_8_5,
        3 => Register::vr3_8_5,
        4 => Register::vr4_8_5,
        5 => Register::vr5_8_5,
        6 => Register::vr6_8_5,
        7 => Register::vr7_8_5,
        8 => Register::vr8_8_5,
        9 => Register::vr9_8_5,
        10 => Register::vr10_8_5,
        11 => Register::vr11_8_5,
        12 => Register::vr12_8_5,
        13 => Register::vr13_8_5,
        14 => Register::vr14_8_5,
        15 => Register::vr15_8_5,
        16 => Register::vr16_8_5,
        17 => Register::vr17_8_5,
        18 => Register::vr18_8_5,
        19 => Register::vr19_8_5,
        20 => Register::vr20_8_5,
        21 => Register::vr21_8_5,
        22 => Register::vr22_8_5,
        23 => Register::vr23_8_5,
        24 => Register::vr24_8_5,
        25 => Register::vr25_8_5,
        26 => Register::vr26_8_5,
        27 => Register::vr27_8_5,
        28 => Register::vr28_8_5,
        29 => Register::vr29_8_5,
        30 => Register::vr30_8_5,
        31 => Register::vr31_8_5,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_90_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_90_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_90_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_6,
        1 => Register::vr1_8_6,
        2 => Register::vr2_8_6,
        3 => Register::vr3_8_6,
        4 => Register::vr4_8_6,
        5 => Register::vr5_8_6,
        6 => Register::vr6_8_6,
        7 => Register::vr7_8_6,
        8 => Register::vr8_8_6,
        9 => Register::vr9_8_6,
        10 => Register::vr10_8_6,
        11 => Register::vr11_8_6,
        12 => Register::vr12_8_6,
        13 => Register::vr13_8_6,
        14 => Register::vr14_8_6,
        15 => Register::vr15_8_6,
        16 => Register::vr16_8_6,
        17 => Register::vr17_8_6,
        18 => Register::vr18_8_6,
        19 => Register::vr19_8_6,
        20 => Register::vr20_8_6,
        21 => Register::vr21_8_6,
        22 => Register::vr22_8_6,
        23 => Register::vr23_8_6,
        24 => Register::vr24_8_6,
        25 => Register::vr25_8_6,
        26 => Register::vr26_8_6,
        27 => Register::vr27_8_6,
        28 => Register::vr28_8_6,
        29 => Register::vr29_8_6,
        30 => Register::vr30_8_6,
        31 => Register::vr31_8_6,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_91_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_91_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_91_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_7,
        1 => Register::vr1_8_7,
        2 => Register::vr2_8_7,
        3 => Register::vr3_8_7,
        4 => Register::vr4_8_7,
        5 => Register::vr5_8_7,
        6 => Register::vr6_8_7,
        7 => Register::vr7_8_7,
        8 => Register::vr8_8_7,
        9 => Register::vr9_8_7,
        10 => Register::vr10_8_7,
        11 => Register::vr11_8_7,
        12 => Register::vr12_8_7,
        13 => Register::vr13_8_7,
        14 => Register::vr14_8_7,
        15 => Register::vr15_8_7,
        16 => Register::vr16_8_7,
        17 => Register::vr17_8_7,
        18 => Register::vr18_8_7,
        19 => Register::vr19_8_7,
        20 => Register::vr20_8_7,
        21 => Register::vr21_8_7,
        22 => Register::vr22_8_7,
        23 => Register::vr23_8_7,
        24 => Register::vr24_8_7,
        25 => Register::vr25_8_7,
        26 => Register::vr26_8_7,
        27 => Register::vr27_8_7,
        28 => Register::vr28_8_7,
        29 => Register::vr29_8_7,
        30 => Register::vr30_8_7,
        31 => Register::vr31_8_7,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_92_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_92_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_92_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_8,
        1 => Register::vr1_8_8,
        2 => Register::vr2_8_8,
        3 => Register::vr3_8_8,
        4 => Register::vr4_8_8,
        5 => Register::vr5_8_8,
        6 => Register::vr6_8_8,
        7 => Register::vr7_8_8,
        8 => Register::vr8_8_8,
        9 => Register::vr9_8_8,
        10 => Register::vr10_8_8,
        11 => Register::vr11_8_8,
        12 => Register::vr12_8_8,
        13 => Register::vr13_8_8,
        14 => Register::vr14_8_8,
        15 => Register::vr15_8_8,
        16 => Register::vr16_8_8,
        17 => Register::vr17_8_8,
        18 => Register::vr18_8_8,
        19 => Register::vr19_8_8,
        20 => Register::vr20_8_8,
        21 => Register::vr21_8_8,
        22 => Register::vr22_8_8,
        23 => Register::vr23_8_8,
        24 => Register::vr24_8_8,
        25 => Register::vr25_8_8,
        26 => Register::vr26_8_8,
        27 => Register::vr27_8_8,
        28 => Register::vr28_8_8,
        29 => Register::vr29_8_8,
        30 => Register::vr30_8_8,
        31 => Register::vr31_8_8,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_93_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_93_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_93_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_9,
        1 => Register::vr1_8_9,
        2 => Register::vr2_8_9,
        3 => Register::vr3_8_9,
        4 => Register::vr4_8_9,
        5 => Register::vr5_8_9,
        6 => Register::vr6_8_9,
        7 => Register::vr7_8_9,
        8 => Register::vr8_8_9,
        9 => Register::vr9_8_9,
        10 => Register::vr10_8_9,
        11 => Register::vr11_8_9,
        12 => Register::vr12_8_9,
        13 => Register::vr13_8_9,
        14 => Register::vr14_8_9,
        15 => Register::vr15_8_9,
        16 => Register::vr16_8_9,
        17 => Register::vr17_8_9,
        18 => Register::vr18_8_9,
        19 => Register::vr19_8_9,
        20 => Register::vr20_8_9,
        21 => Register::vr21_8_9,
        22 => Register::vr22_8_9,
        23 => Register::vr23_8_9,
        24 => Register::vr24_8_9,
        25 => Register::vr25_8_9,
        26 => Register::vr26_8_9,
        27 => Register::vr27_8_9,
        28 => Register::vr28_8_9,
        29 => Register::vr29_8_9,
        30 => Register::vr30_8_9,
        31 => Register::vr31_8_9,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_94_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_94_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_94_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_10,
        1 => Register::vr1_8_10,
        2 => Register::vr2_8_10,
        3 => Register::vr3_8_10,
        4 => Register::vr4_8_10,
        5 => Register::vr5_8_10,
        6 => Register::vr6_8_10,
        7 => Register::vr7_8_10,
        8 => Register::vr8_8_10,
        9 => Register::vr9_8_10,
        10 => Register::vr10_8_10,
        11 => Register::vr11_8_10,
        12 => Register::vr12_8_10,
        13 => Register::vr13_8_10,
        14 => Register::vr14_8_10,
        15 => Register::vr15_8_10,
        16 => Register::vr16_8_10,
        17 => Register::vr17_8_10,
        18 => Register::vr18_8_10,
        19 => Register::vr19_8_10,
        20 => Register::vr20_8_10,
        21 => Register::vr21_8_10,
        22 => Register::vr22_8_10,
        23 => Register::vr23_8_10,
        24 => Register::vr24_8_10,
        25 => Register::vr25_8_10,
        26 => Register::vr26_8_10,
        27 => Register::vr27_8_10,
        28 => Register::vr28_8_10,
        29 => Register::vr29_8_10,
        30 => Register::vr30_8_10,
        31 => Register::vr31_8_10,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_95_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_95_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_95_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_11,
        1 => Register::vr1_8_11,
        2 => Register::vr2_8_11,
        3 => Register::vr3_8_11,
        4 => Register::vr4_8_11,
        5 => Register::vr5_8_11,
        6 => Register::vr6_8_11,
        7 => Register::vr7_8_11,
        8 => Register::vr8_8_11,
        9 => Register::vr9_8_11,
        10 => Register::vr10_8_11,
        11 => Register::vr11_8_11,
        12 => Register::vr12_8_11,
        13 => Register::vr13_8_11,
        14 => Register::vr14_8_11,
        15 => Register::vr15_8_11,
        16 => Register::vr16_8_11,
        17 => Register::vr17_8_11,
        18 => Register::vr18_8_11,
        19 => Register::vr19_8_11,
        20 => Register::vr20_8_11,
        21 => Register::vr21_8_11,
        22 => Register::vr22_8_11,
        23 => Register::vr23_8_11,
        24 => Register::vr24_8_11,
        25 => Register::vr25_8_11,
        26 => Register::vr26_8_11,
        27 => Register::vr27_8_11,
        28 => Register::vr28_8_11,
        29 => Register::vr29_8_11,
        30 => Register::vr30_8_11,
        31 => Register::vr31_8_11,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_96_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_96_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_96_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_12,
        1 => Register::vr1_8_12,
        2 => Register::vr2_8_12,
        3 => Register::vr3_8_12,
        4 => Register::vr4_8_12,
        5 => Register::vr5_8_12,
        6 => Register::vr6_8_12,
        7 => Register::vr7_8_12,
        8 => Register::vr8_8_12,
        9 => Register::vr9_8_12,
        10 => Register::vr10_8_12,
        11 => Register::vr11_8_12,
        12 => Register::vr12_8_12,
        13 => Register::vr13_8_12,
        14 => Register::vr14_8_12,
        15 => Register::vr15_8_12,
        16 => Register::vr16_8_12,
        17 => Register::vr17_8_12,
        18 => Register::vr18_8_12,
        19 => Register::vr19_8_12,
        20 => Register::vr20_8_12,
        21 => Register::vr21_8_12,
        22 => Register::vr22_8_12,
        23 => Register::vr23_8_12,
        24 => Register::vr24_8_12,
        25 => Register::vr25_8_12,
        26 => Register::vr26_8_12,
        27 => Register::vr27_8_12,
        28 => Register::vr28_8_12,
        29 => Register::vr29_8_12,
        30 => Register::vr30_8_12,
        31 => Register::vr31_8_12,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_97_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_97_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_97_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_13,
        1 => Register::vr1_8_13,
        2 => Register::vr2_8_13,
        3 => Register::vr3_8_13,
        4 => Register::vr4_8_13,
        5 => Register::vr5_8_13,
        6 => Register::vr6_8_13,
        7 => Register::vr7_8_13,
        8 => Register::vr8_8_13,
        9 => Register::vr9_8_13,
        10 => Register::vr10_8_13,
        11 => Register::vr11_8_13,
        12 => Register::vr12_8_13,
        13 => Register::vr13_8_13,
        14 => Register::vr14_8_13,
        15 => Register::vr15_8_13,
        16 => Register::vr16_8_13,
        17 => Register::vr17_8_13,
        18 => Register::vr18_8_13,
        19 => Register::vr19_8_13,
        20 => Register::vr20_8_13,
        21 => Register::vr21_8_13,
        22 => Register::vr22_8_13,
        23 => Register::vr23_8_13,
        24 => Register::vr24_8_13,
        25 => Register::vr25_8_13,
        26 => Register::vr26_8_13,
        27 => Register::vr27_8_13,
        28 => Register::vr28_8_13,
        29 => Register::vr29_8_13,
        30 => Register::vr30_8_13,
        31 => Register::vr31_8_13,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_98_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_98_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_98_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_14,
        1 => Register::vr1_8_14,
        2 => Register::vr2_8_14,
        3 => Register::vr3_8_14,
        4 => Register::vr4_8_14,
        5 => Register::vr5_8_14,
        6 => Register::vr6_8_14,
        7 => Register::vr7_8_14,
        8 => Register::vr8_8_14,
        9 => Register::vr9_8_14,
        10 => Register::vr10_8_14,
        11 => Register::vr11_8_14,
        12 => Register::vr12_8_14,
        13 => Register::vr13_8_14,
        14 => Register::vr14_8_14,
        15 => Register::vr15_8_14,
        16 => Register::vr16_8_14,
        17 => Register::vr17_8_14,
        18 => Register::vr18_8_14,
        19 => Register::vr19_8_14,
        20 => Register::vr20_8_14,
        21 => Register::vr21_8_14,
        22 => Register::vr22_8_14,
        23 => Register::vr23_8_14,
        24 => Register::vr24_8_14,
        25 => Register::vr25_8_14,
        26 => Register::vr26_8_14,
        27 => Register::vr27_8_14,
        28 => Register::vr28_8_14,
        29 => Register::vr29_8_14,
        30 => Register::vr30_8_14,
        31 => Register::vr31_8_14,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_99_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_99_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_99_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_15,
        1 => Register::vr1_8_15,
        2 => Register::vr2_8_15,
        3 => Register::vr3_8_15,
        4 => Register::vr4_8_15,
        5 => Register::vr5_8_15,
        6 => Register::vr6_8_15,
        7 => Register::vr7_8_15,
        8 => Register::vr8_8_15,
        9 => Register::vr9_8_15,
        10 => Register::vr10_8_15,
        11 => Register::vr11_8_15,
        12 => Register::vr12_8_15,
        13 => Register::vr13_8_15,
        14 => Register::vr14_8_15,
        15 => Register::vr15_8_15,
        16 => Register::vr16_8_15,
        17 => Register::vr17_8_15,
        18 => Register::vr18_8_15,
        19 => Register::vr19_8_15,
        20 => Register::vr20_8_15,
        21 => Register::vr21_8_15,
        22 => Register::vr22_8_15,
        23 => Register::vr23_8_15,
        24 => Register::vr24_8_15,
        25 => Register::vr25_8_15,
        26 => Register::vr26_8_15,
        27 => Register::vr27_8_15,
        28 => Register::vr28_8_15,
        29 => Register::vr29_8_15,
        30 => Register::vr30_8_15,
        31 => Register::vr31_8_15,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_100_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_100_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_100_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_64_0,
        1 => Register::vr1_64_0,
        2 => Register::vr2_64_0,
        3 => Register::vr3_64_0,
        4 => Register::vr4_64_0,
        5 => Register::vr5_64_0,
        6 => Register::vr6_64_0,
        7 => Register::vr7_64_0,
        8 => Register::vr8_64_0,
        9 => Register::vr9_64_0,
        10 => Register::vr10_64_0,
        11 => Register::vr11_64_0,
        12 => Register::vr12_64_0,
        13 => Register::vr13_64_0,
        14 => Register::vr14_64_0,
        15 => Register::vr15_64_0,
        16 => Register::vr16_64_0,
        17 => Register::vr17_64_0,
        18 => Register::vr18_64_0,
        19 => Register::vr19_64_0,
        20 => Register::vr20_64_0,
        21 => Register::vr21_64_0,
        22 => Register::vr22_64_0,
        23 => Register::vr23_64_0,
        24 => Register::vr24_64_0,
        25 => Register::vr25_64_0,
        26 => Register::vr26_64_0,
        27 => Register::vr27_64_0,
        28 => Register::vr28_64_0,
        29 => Register::vr29_64_0,
        30 => Register::vr30_64_0,
        31 => Register::vr31_64_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_101_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_101_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_101_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_64_1,
        1 => Register::vr1_64_1,
        2 => Register::vr2_64_1,
        3 => Register::vr3_64_1,
        4 => Register::vr4_64_1,
        5 => Register::vr5_64_1,
        6 => Register::vr6_64_1,
        7 => Register::vr7_64_1,
        8 => Register::vr8_64_1,
        9 => Register::vr9_64_1,
        10 => Register::vr10_64_1,
        11 => Register::vr11_64_1,
        12 => Register::vr12_64_1,
        13 => Register::vr13_64_1,
        14 => Register::vr14_64_1,
        15 => Register::vr15_64_1,
        16 => Register::vr16_64_1,
        17 => Register::vr17_64_1,
        18 => Register::vr18_64_1,
        19 => Register::vr19_64_1,
        20 => Register::vr20_64_1,
        21 => Register::vr21_64_1,
        22 => Register::vr22_64_1,
        23 => Register::vr23_64_1,
        24 => Register::vr24_64_1,
        25 => Register::vr25_64_1,
        26 => Register::vr26_64_1,
        27 => Register::vr27_64_1,
        28 => Register::vr28_64_1,
        29 => Register::vr29_64_1,
        30 => Register::vr30_64_1,
        31 => Register::vr31_64_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_102_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_102_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_102_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_0,
        1 => Register::vr1_32_0,
        2 => Register::vr2_32_0,
        3 => Register::vr3_32_0,
        4 => Register::vr4_32_0,
        5 => Register::vr5_32_0,
        6 => Register::vr6_32_0,
        7 => Register::vr7_32_0,
        8 => Register::vr8_32_0,
        9 => Register::vr9_32_0,
        10 => Register::vr10_32_0,
        11 => Register::vr11_32_0,
        12 => Register::vr12_32_0,
        13 => Register::vr13_32_0,
        14 => Register::vr14_32_0,
        15 => Register::vr15_32_0,
        16 => Register::vr16_32_0,
        17 => Register::vr17_32_0,
        18 => Register::vr18_32_0,
        19 => Register::vr19_32_0,
        20 => Register::vr20_32_0,
        21 => Register::vr21_32_0,
        22 => Register::vr22_32_0,
        23 => Register::vr23_32_0,
        24 => Register::vr24_32_0,
        25 => Register::vr25_32_0,
        26 => Register::vr26_32_0,
        27 => Register::vr27_32_0,
        28 => Register::vr28_32_0,
        29 => Register::vr29_32_0,
        30 => Register::vr30_32_0,
        31 => Register::vr31_32_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_103_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_103_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_103_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_1,
        1 => Register::vr1_32_1,
        2 => Register::vr2_32_1,
        3 => Register::vr3_32_1,
        4 => Register::vr4_32_1,
        5 => Register::vr5_32_1,
        6 => Register::vr6_32_1,
        7 => Register::vr7_32_1,
        8 => Register::vr8_32_1,
        9 => Register::vr9_32_1,
        10 => Register::vr10_32_1,
        11 => Register::vr11_32_1,
        12 => Register::vr12_32_1,
        13 => Register::vr13_32_1,
        14 => Register::vr14_32_1,
        15 => Register::vr15_32_1,
        16 => Register::vr16_32_1,
        17 => Register::vr17_32_1,
        18 => Register::vr18_32_1,
        19 => Register::vr19_32_1,
        20 => Register::vr20_32_1,
        21 => Register::vr21_32_1,
        22 => Register::vr22_32_1,
        23 => Register::vr23_32_1,
        24 => Register::vr24_32_1,
        25 => Register::vr25_32_1,
        26 => Register::vr26_32_1,
        27 => Register::vr27_32_1,
        28 => Register::vr28_32_1,
        29 => Register::vr29_32_1,
        30 => Register::vr30_32_1,
        31 => Register::vr31_32_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_104_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_104_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_104_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_2,
        1 => Register::vr1_32_2,
        2 => Register::vr2_32_2,
        3 => Register::vr3_32_2,
        4 => Register::vr4_32_2,
        5 => Register::vr5_32_2,
        6 => Register::vr6_32_2,
        7 => Register::vr7_32_2,
        8 => Register::vr8_32_2,
        9 => Register::vr9_32_2,
        10 => Register::vr10_32_2,
        11 => Register::vr11_32_2,
        12 => Register::vr12_32_2,
        13 => Register::vr13_32_2,
        14 => Register::vr14_32_2,
        15 => Register::vr15_32_2,
        16 => Register::vr16_32_2,
        17 => Register::vr17_32_2,
        18 => Register::vr18_32_2,
        19 => Register::vr19_32_2,
        20 => Register::vr20_32_2,
        21 => Register::vr21_32_2,
        22 => Register::vr22_32_2,
        23 => Register::vr23_32_2,
        24 => Register::vr24_32_2,
        25 => Register::vr25_32_2,
        26 => Register::vr26_32_2,
        27 => Register::vr27_32_2,
        28 => Register::vr28_32_2,
        29 => Register::vr29_32_2,
        30 => Register::vr30_32_2,
        31 => Register::vr31_32_2,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_105_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_105_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_105_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_3,
        1 => Register::vr1_32_3,
        2 => Register::vr2_32_3,
        3 => Register::vr3_32_3,
        4 => Register::vr4_32_3,
        5 => Register::vr5_32_3,
        6 => Register::vr6_32_3,
        7 => Register::vr7_32_3,
        8 => Register::vr8_32_3,
        9 => Register::vr9_32_3,
        10 => Register::vr10_32_3,
        11 => Register::vr11_32_3,
        12 => Register::vr12_32_3,
        13 => Register::vr13_32_3,
        14 => Register::vr14_32_3,
        15 => Register::vr15_32_3,
        16 => Register::vr16_32_3,
        17 => Register::vr17_32_3,
        18 => Register::vr18_32_3,
        19 => Register::vr19_32_3,
        20 => Register::vr20_32_3,
        21 => Register::vr21_32_3,
        22 => Register::vr22_32_3,
        23 => Register::vr23_32_3,
        24 => Register::vr24_32_3,
        25 => Register::vr25_32_3,
        26 => Register::vr26_32_3,
        27 => Register::vr27_32_3,
        28 => Register::vr28_32_3,
        29 => Register::vr29_32_3,
        30 => Register::vr30_32_3,
        31 => Register::vr31_32_3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_106_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_106_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_106_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_0,
        1 => Register::vr1_16_0,
        2 => Register::vr2_16_0,
        3 => Register::vr3_16_0,
        4 => Register::vr4_16_0,
        5 => Register::vr5_16_0,
        6 => Register::vr6_16_0,
        7 => Register::vr7_16_0,
        8 => Register::vr8_16_0,
        9 => Register::vr9_16_0,
        10 => Register::vr10_16_0,
        11 => Register::vr11_16_0,
        12 => Register::vr12_16_0,
        13 => Register::vr13_16_0,
        14 => Register::vr14_16_0,
        15 => Register::vr15_16_0,
        16 => Register::vr16_16_0,
        17 => Register::vr17_16_0,
        18 => Register::vr18_16_0,
        19 => Register::vr19_16_0,
        20 => Register::vr20_16_0,
        21 => Register::vr21_16_0,
        22 => Register::vr22_16_0,
        23 => Register::vr23_16_0,
        24 => Register::vr24_16_0,
        25 => Register::vr25_16_0,
        26 => Register::vr26_16_0,
        27 => Register::vr27_16_0,
        28 => Register::vr28_16_0,
        29 => Register::vr29_16_0,
        30 => Register::vr30_16_0,
        31 => Register::vr31_16_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_107_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_107_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_107_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_1,
        1 => Register::vr1_16_1,
        2 => Register::vr2_16_1,
        3 => Register::vr3_16_1,
        4 => Register::vr4_16_1,
        5 => Register::vr5_16_1,
        6 => Register::vr6_16_1,
        7 => Register::vr7_16_1,
        8 => Register::vr8_16_1,
        9 => Register::vr9_16_1,
        10 => Register::vr10_16_1,
        11 => Register::vr11_16_1,
        12 => Register::vr12_16_1,
        13 => Register::vr13_16_1,
        14 => Register::vr14_16_1,
        15 => Register::vr15_16_1,
        16 => Register::vr16_16_1,
        17 => Register::vr17_16_1,
        18 => Register::vr18_16_1,
        19 => Register::vr19_16_1,
        20 => Register::vr20_16_1,
        21 => Register::vr21_16_1,
        22 => Register::vr22_16_1,
        23 => Register::vr23_16_1,
        24 => Register::vr24_16_1,
        25 => Register::vr25_16_1,
        26 => Register::vr26_16_1,
        27 => Register::vr27_16_1,
        28 => Register::vr28_16_1,
        29 => Register::vr29_16_1,
        30 => Register::vr30_16_1,
        31 => Register::vr31_16_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_108_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_108_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_108_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_2,
        1 => Register::vr1_16_2,
        2 => Register::vr2_16_2,
        3 => Register::vr3_16_2,
        4 => Register::vr4_16_2,
        5 => Register::vr5_16_2,
        6 => Register::vr6_16_2,
        7 => Register::vr7_16_2,
        8 => Register::vr8_16_2,
        9 => Register::vr9_16_2,
        10 => Register::vr10_16_2,
        11 => Register::vr11_16_2,
        12 => Register::vr12_16_2,
        13 => Register::vr13_16_2,
        14 => Register::vr14_16_2,
        15 => Register::vr15_16_2,
        16 => Register::vr16_16_2,
        17 => Register::vr17_16_2,
        18 => Register::vr18_16_2,
        19 => Register::vr19_16_2,
        20 => Register::vr20_16_2,
        21 => Register::vr21_16_2,
        22 => Register::vr22_16_2,
        23 => Register::vr23_16_2,
        24 => Register::vr24_16_2,
        25 => Register::vr25_16_2,
        26 => Register::vr26_16_2,
        27 => Register::vr27_16_2,
        28 => Register::vr28_16_2,
        29 => Register::vr29_16_2,
        30 => Register::vr30_16_2,
        31 => Register::vr31_16_2,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_109_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_109_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_109_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_3,
        1 => Register::vr1_16_3,
        2 => Register::vr2_16_3,
        3 => Register::vr3_16_3,
        4 => Register::vr4_16_3,
        5 => Register::vr5_16_3,
        6 => Register::vr6_16_3,
        7 => Register::vr7_16_3,
        8 => Register::vr8_16_3,
        9 => Register::vr9_16_3,
        10 => Register::vr10_16_3,
        11 => Register::vr11_16_3,
        12 => Register::vr12_16_3,
        13 => Register::vr13_16_3,
        14 => Register::vr14_16_3,
        15 => Register::vr15_16_3,
        16 => Register::vr16_16_3,
        17 => Register::vr17_16_3,
        18 => Register::vr18_16_3,
        19 => Register::vr19_16_3,
        20 => Register::vr20_16_3,
        21 => Register::vr21_16_3,
        22 => Register::vr22_16_3,
        23 => Register::vr23_16_3,
        24 => Register::vr24_16_3,
        25 => Register::vr25_16_3,
        26 => Register::vr26_16_3,
        27 => Register::vr27_16_3,
        28 => Register::vr28_16_3,
        29 => Register::vr29_16_3,
        30 => Register::vr30_16_3,
        31 => Register::vr31_16_3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_110_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_110_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_110_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_4,
        1 => Register::vr1_16_4,
        2 => Register::vr2_16_4,
        3 => Register::vr3_16_4,
        4 => Register::vr4_16_4,
        5 => Register::vr5_16_4,
        6 => Register::vr6_16_4,
        7 => Register::vr7_16_4,
        8 => Register::vr8_16_4,
        9 => Register::vr9_16_4,
        10 => Register::vr10_16_4,
        11 => Register::vr11_16_4,
        12 => Register::vr12_16_4,
        13 => Register::vr13_16_4,
        14 => Register::vr14_16_4,
        15 => Register::vr15_16_4,
        16 => Register::vr16_16_4,
        17 => Register::vr17_16_4,
        18 => Register::vr18_16_4,
        19 => Register::vr19_16_4,
        20 => Register::vr20_16_4,
        21 => Register::vr21_16_4,
        22 => Register::vr22_16_4,
        23 => Register::vr23_16_4,
        24 => Register::vr24_16_4,
        25 => Register::vr25_16_4,
        26 => Register::vr26_16_4,
        27 => Register::vr27_16_4,
        28 => Register::vr28_16_4,
        29 => Register::vr29_16_4,
        30 => Register::vr30_16_4,
        31 => Register::vr31_16_4,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_111_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_111_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_111_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_5,
        1 => Register::vr1_16_5,
        2 => Register::vr2_16_5,
        3 => Register::vr3_16_5,
        4 => Register::vr4_16_5,
        5 => Register::vr5_16_5,
        6 => Register::vr6_16_5,
        7 => Register::vr7_16_5,
        8 => Register::vr8_16_5,
        9 => Register::vr9_16_5,
        10 => Register::vr10_16_5,
        11 => Register::vr11_16_5,
        12 => Register::vr12_16_5,
        13 => Register::vr13_16_5,
        14 => Register::vr14_16_5,
        15 => Register::vr15_16_5,
        16 => Register::vr16_16_5,
        17 => Register::vr17_16_5,
        18 => Register::vr18_16_5,
        19 => Register::vr19_16_5,
        20 => Register::vr20_16_5,
        21 => Register::vr21_16_5,
        22 => Register::vr22_16_5,
        23 => Register::vr23_16_5,
        24 => Register::vr24_16_5,
        25 => Register::vr25_16_5,
        26 => Register::vr26_16_5,
        27 => Register::vr27_16_5,
        28 => Register::vr28_16_5,
        29 => Register::vr29_16_5,
        30 => Register::vr30_16_5,
        31 => Register::vr31_16_5,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_112_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_112_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_112_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_6,
        1 => Register::vr1_16_6,
        2 => Register::vr2_16_6,
        3 => Register::vr3_16_6,
        4 => Register::vr4_16_6,
        5 => Register::vr5_16_6,
        6 => Register::vr6_16_6,
        7 => Register::vr7_16_6,
        8 => Register::vr8_16_6,
        9 => Register::vr9_16_6,
        10 => Register::vr10_16_6,
        11 => Register::vr11_16_6,
        12 => Register::vr12_16_6,
        13 => Register::vr13_16_6,
        14 => Register::vr14_16_6,
        15 => Register::vr15_16_6,
        16 => Register::vr16_16_6,
        17 => Register::vr17_16_6,
        18 => Register::vr18_16_6,
        19 => Register::vr19_16_6,
        20 => Register::vr20_16_6,
        21 => Register::vr21_16_6,
        22 => Register::vr22_16_6,
        23 => Register::vr23_16_6,
        24 => Register::vr24_16_6,
        25 => Register::vr25_16_6,
        26 => Register::vr26_16_6,
        27 => Register::vr27_16_6,
        28 => Register::vr28_16_6,
        29 => Register::vr29_16_6,
        30 => Register::vr30_16_6,
        31 => Register::vr31_16_6,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_113_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_113_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_113_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_7,
        1 => Register::vr1_16_7,
        2 => Register::vr2_16_7,
        3 => Register::vr3_16_7,
        4 => Register::vr4_16_7,
        5 => Register::vr5_16_7,
        6 => Register::vr6_16_7,
        7 => Register::vr7_16_7,
        8 => Register::vr8_16_7,
        9 => Register::vr9_16_7,
        10 => Register::vr10_16_7,
        11 => Register::vr11_16_7,
        12 => Register::vr12_16_7,
        13 => Register::vr13_16_7,
        14 => Register::vr14_16_7,
        15 => Register::vr15_16_7,
        16 => Register::vr16_16_7,
        17 => Register::vr17_16_7,
        18 => Register::vr18_16_7,
        19 => Register::vr19_16_7,
        20 => Register::vr20_16_7,
        21 => Register::vr21_16_7,
        22 => Register::vr22_16_7,
        23 => Register::vr23_16_7,
        24 => Register::vr24_16_7,
        25 => Register::vr25_16_7,
        26 => Register::vr26_16_7,
        27 => Register::vr27_16_7,
        28 => Register::vr28_16_7,
        29 => Register::vr29_16_7,
        30 => Register::vr30_16_7,
        31 => Register::vr31_16_7,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_114_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_114_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_114_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_0,
        1 => Register::vr1_8_0,
        2 => Register::vr2_8_0,
        3 => Register::vr3_8_0,
        4 => Register::vr4_8_0,
        5 => Register::vr5_8_0,
        6 => Register::vr6_8_0,
        7 => Register::vr7_8_0,
        8 => Register::vr8_8_0,
        9 => Register::vr9_8_0,
        10 => Register::vr10_8_0,
        11 => Register::vr11_8_0,
        12 => Register::vr12_8_0,
        13 => Register::vr13_8_0,
        14 => Register::vr14_8_0,
        15 => Register::vr15_8_0,
        16 => Register::vr16_8_0,
        17 => Register::vr17_8_0,
        18 => Register::vr18_8_0,
        19 => Register::vr19_8_0,
        20 => Register::vr20_8_0,
        21 => Register::vr21_8_0,
        22 => Register::vr22_8_0,
        23 => Register::vr23_8_0,
        24 => Register::vr24_8_0,
        25 => Register::vr25_8_0,
        26 => Register::vr26_8_0,
        27 => Register::vr27_8_0,
        28 => Register::vr28_8_0,
        29 => Register::vr29_8_0,
        30 => Register::vr30_8_0,
        31 => Register::vr31_8_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_115_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_115_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_115_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_1,
        1 => Register::vr1_8_1,
        2 => Register::vr2_8_1,
        3 => Register::vr3_8_1,
        4 => Register::vr4_8_1,
        5 => Register::vr5_8_1,
        6 => Register::vr6_8_1,
        7 => Register::vr7_8_1,
        8 => Register::vr8_8_1,
        9 => Register::vr9_8_1,
        10 => Register::vr10_8_1,
        11 => Register::vr11_8_1,
        12 => Register::vr12_8_1,
        13 => Register::vr13_8_1,
        14 => Register::vr14_8_1,
        15 => Register::vr15_8_1,
        16 => Register::vr16_8_1,
        17 => Register::vr17_8_1,
        18 => Register::vr18_8_1,
        19 => Register::vr19_8_1,
        20 => Register::vr20_8_1,
        21 => Register::vr21_8_1,
        22 => Register::vr22_8_1,
        23 => Register::vr23_8_1,
        24 => Register::vr24_8_1,
        25 => Register::vr25_8_1,
        26 => Register::vr26_8_1,
        27 => Register::vr27_8_1,
        28 => Register::vr28_8_1,
        29 => Register::vr29_8_1,
        30 => Register::vr30_8_1,
        31 => Register::vr31_8_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_116_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_116_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_116_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_2,
        1 => Register::vr1_8_2,
        2 => Register::vr2_8_2,
        3 => Register::vr3_8_2,
        4 => Register::vr4_8_2,
        5 => Register::vr5_8_2,
        6 => Register::vr6_8_2,
        7 => Register::vr7_8_2,
        8 => Register::vr8_8_2,
        9 => Register::vr9_8_2,
        10 => Register::vr10_8_2,
        11 => Register::vr11_8_2,
        12 => Register::vr12_8_2,
        13 => Register::vr13_8_2,
        14 => Register::vr14_8_2,
        15 => Register::vr15_8_2,
        16 => Register::vr16_8_2,
        17 => Register::vr17_8_2,
        18 => Register::vr18_8_2,
        19 => Register::vr19_8_2,
        20 => Register::vr20_8_2,
        21 => Register::vr21_8_2,
        22 => Register::vr22_8_2,
        23 => Register::vr23_8_2,
        24 => Register::vr24_8_2,
        25 => Register::vr25_8_2,
        26 => Register::vr26_8_2,
        27 => Register::vr27_8_2,
        28 => Register::vr28_8_2,
        29 => Register::vr29_8_2,
        30 => Register::vr30_8_2,
        31 => Register::vr31_8_2,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_117_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_117_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_117_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_3,
        1 => Register::vr1_8_3,
        2 => Register::vr2_8_3,
        3 => Register::vr3_8_3,
        4 => Register::vr4_8_3,
        5 => Register::vr5_8_3,
        6 => Register::vr6_8_3,
        7 => Register::vr7_8_3,
        8 => Register::vr8_8_3,
        9 => Register::vr9_8_3,
        10 => Register::vr10_8_3,
        11 => Register::vr11_8_3,
        12 => Register::vr12_8_3,
        13 => Register::vr13_8_3,
        14 => Register::vr14_8_3,
        15 => Register::vr15_8_3,
        16 => Register::vr16_8_3,
        17 => Register::vr17_8_3,
        18 => Register::vr18_8_3,
        19 => Register::vr19_8_3,
        20 => Register::vr20_8_3,
        21 => Register::vr21_8_3,
        22 => Register::vr22_8_3,
        23 => Register::vr23_8_3,
        24 => Register::vr24_8_3,
        25 => Register::vr25_8_3,
        26 => Register::vr26_8_3,
        27 => Register::vr27_8_3,
        28 => Register::vr28_8_3,
        29 => Register::vr29_8_3,
        30 => Register::vr30_8_3,
        31 => Register::vr31_8_3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_118_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_118_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_118_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_4,
        1 => Register::vr1_8_4,
        2 => Register::vr2_8_4,
        3 => Register::vr3_8_4,
        4 => Register::vr4_8_4,
        5 => Register::vr5_8_4,
        6 => Register::vr6_8_4,
        7 => Register::vr7_8_4,
        8 => Register::vr8_8_4,
        9 => Register::vr9_8_4,
        10 => Register::vr10_8_4,
        11 => Register::vr11_8_4,
        12 => Register::vr12_8_4,
        13 => Register::vr13_8_4,
        14 => Register::vr14_8_4,
        15 => Register::vr15_8_4,
        16 => Register::vr16_8_4,
        17 => Register::vr17_8_4,
        18 => Register::vr18_8_4,
        19 => Register::vr19_8_4,
        20 => Register::vr20_8_4,
        21 => Register::vr21_8_4,
        22 => Register::vr22_8_4,
        23 => Register::vr23_8_4,
        24 => Register::vr24_8_4,
        25 => Register::vr25_8_4,
        26 => Register::vr26_8_4,
        27 => Register::vr27_8_4,
        28 => Register::vr28_8_4,
        29 => Register::vr29_8_4,
        30 => Register::vr30_8_4,
        31 => Register::vr31_8_4,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_119_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_119_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_119_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_5,
        1 => Register::vr1_8_5,
        2 => Register::vr2_8_5,
        3 => Register::vr3_8_5,
        4 => Register::vr4_8_5,
        5 => Register::vr5_8_5,
        6 => Register::vr6_8_5,
        7 => Register::vr7_8_5,
        8 => Register::vr8_8_5,
        9 => Register::vr9_8_5,
        10 => Register::vr10_8_5,
        11 => Register::vr11_8_5,
        12 => Register::vr12_8_5,
        13 => Register::vr13_8_5,
        14 => Register::vr14_8_5,
        15 => Register::vr15_8_5,
        16 => Register::vr16_8_5,
        17 => Register::vr17_8_5,
        18 => Register::vr18_8_5,
        19 => Register::vr19_8_5,
        20 => Register::vr20_8_5,
        21 => Register::vr21_8_5,
        22 => Register::vr22_8_5,
        23 => Register::vr23_8_5,
        24 => Register::vr24_8_5,
        25 => Register::vr25_8_5,
        26 => Register::vr26_8_5,
        27 => Register::vr27_8_5,
        28 => Register::vr28_8_5,
        29 => Register::vr29_8_5,
        30 => Register::vr30_8_5,
        31 => Register::vr31_8_5,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_120_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_120_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_120_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_6,
        1 => Register::vr1_8_6,
        2 => Register::vr2_8_6,
        3 => Register::vr3_8_6,
        4 => Register::vr4_8_6,
        5 => Register::vr5_8_6,
        6 => Register::vr6_8_6,
        7 => Register::vr7_8_6,
        8 => Register::vr8_8_6,
        9 => Register::vr9_8_6,
        10 => Register::vr10_8_6,
        11 => Register::vr11_8_6,
        12 => Register::vr12_8_6,
        13 => Register::vr13_8_6,
        14 => Register::vr14_8_6,
        15 => Register::vr15_8_6,
        16 => Register::vr16_8_6,
        17 => Register::vr17_8_6,
        18 => Register::vr18_8_6,
        19 => Register::vr19_8_6,
        20 => Register::vr20_8_6,
        21 => Register::vr21_8_6,
        22 => Register::vr22_8_6,
        23 => Register::vr23_8_6,
        24 => Register::vr24_8_6,
        25 => Register::vr25_8_6,
        26 => Register::vr26_8_6,
        27 => Register::vr27_8_6,
        28 => Register::vr28_8_6,
        29 => Register::vr29_8_6,
        30 => Register::vr30_8_6,
        31 => Register::vr31_8_6,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_121_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_121_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_121_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_7,
        1 => Register::vr1_8_7,
        2 => Register::vr2_8_7,
        3 => Register::vr3_8_7,
        4 => Register::vr4_8_7,
        5 => Register::vr5_8_7,
        6 => Register::vr6_8_7,
        7 => Register::vr7_8_7,
        8 => Register::vr8_8_7,
        9 => Register::vr9_8_7,
        10 => Register::vr10_8_7,
        11 => Register::vr11_8_7,
        12 => Register::vr12_8_7,
        13 => Register::vr13_8_7,
        14 => Register::vr14_8_7,
        15 => Register::vr15_8_7,
        16 => Register::vr16_8_7,
        17 => Register::vr17_8_7,
        18 => Register::vr18_8_7,
        19 => Register::vr19_8_7,
        20 => Register::vr20_8_7,
        21 => Register::vr21_8_7,
        22 => Register::vr22_8_7,
        23 => Register::vr23_8_7,
        24 => Register::vr24_8_7,
        25 => Register::vr25_8_7,
        26 => Register::vr26_8_7,
        27 => Register::vr27_8_7,
        28 => Register::vr28_8_7,
        29 => Register::vr29_8_7,
        30 => Register::vr30_8_7,
        31 => Register::vr31_8_7,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_122_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_122_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_122_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_8,
        1 => Register::vr1_8_8,
        2 => Register::vr2_8_8,
        3 => Register::vr3_8_8,
        4 => Register::vr4_8_8,
        5 => Register::vr5_8_8,
        6 => Register::vr6_8_8,
        7 => Register::vr7_8_8,
        8 => Register::vr8_8_8,
        9 => Register::vr9_8_8,
        10 => Register::vr10_8_8,
        11 => Register::vr11_8_8,
        12 => Register::vr12_8_8,
        13 => Register::vr13_8_8,
        14 => Register::vr14_8_8,
        15 => Register::vr15_8_8,
        16 => Register::vr16_8_8,
        17 => Register::vr17_8_8,
        18 => Register::vr18_8_8,
        19 => Register::vr19_8_8,
        20 => Register::vr20_8_8,
        21 => Register::vr21_8_8,
        22 => Register::vr22_8_8,
        23 => Register::vr23_8_8,
        24 => Register::vr24_8_8,
        25 => Register::vr25_8_8,
        26 => Register::vr26_8_8,
        27 => Register::vr27_8_8,
        28 => Register::vr28_8_8,
        29 => Register::vr29_8_8,
        30 => Register::vr30_8_8,
        31 => Register::vr31_8_8,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_123_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_123_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_123_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_9,
        1 => Register::vr1_8_9,
        2 => Register::vr2_8_9,
        3 => Register::vr3_8_9,
        4 => Register::vr4_8_9,
        5 => Register::vr5_8_9,
        6 => Register::vr6_8_9,
        7 => Register::vr7_8_9,
        8 => Register::vr8_8_9,
        9 => Register::vr9_8_9,
        10 => Register::vr10_8_9,
        11 => Register::vr11_8_9,
        12 => Register::vr12_8_9,
        13 => Register::vr13_8_9,
        14 => Register::vr14_8_9,
        15 => Register::vr15_8_9,
        16 => Register::vr16_8_9,
        17 => Register::vr17_8_9,
        18 => Register::vr18_8_9,
        19 => Register::vr19_8_9,
        20 => Register::vr20_8_9,
        21 => Register::vr21_8_9,
        22 => Register::vr22_8_9,
        23 => Register::vr23_8_9,
        24 => Register::vr24_8_9,
        25 => Register::vr25_8_9,
        26 => Register::vr26_8_9,
        27 => Register::vr27_8_9,
        28 => Register::vr28_8_9,
        29 => Register::vr29_8_9,
        30 => Register::vr30_8_9,
        31 => Register::vr31_8_9,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_124_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_124_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_124_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_10,
        1 => Register::vr1_8_10,
        2 => Register::vr2_8_10,
        3 => Register::vr3_8_10,
        4 => Register::vr4_8_10,
        5 => Register::vr5_8_10,
        6 => Register::vr6_8_10,
        7 => Register::vr7_8_10,
        8 => Register::vr8_8_10,
        9 => Register::vr9_8_10,
        10 => Register::vr10_8_10,
        11 => Register::vr11_8_10,
        12 => Register::vr12_8_10,
        13 => Register::vr13_8_10,
        14 => Register::vr14_8_10,
        15 => Register::vr15_8_10,
        16 => Register::vr16_8_10,
        17 => Register::vr17_8_10,
        18 => Register::vr18_8_10,
        19 => Register::vr19_8_10,
        20 => Register::vr20_8_10,
        21 => Register::vr21_8_10,
        22 => Register::vr22_8_10,
        23 => Register::vr23_8_10,
        24 => Register::vr24_8_10,
        25 => Register::vr25_8_10,
        26 => Register::vr26_8_10,
        27 => Register::vr27_8_10,
        28 => Register::vr28_8_10,
        29 => Register::vr29_8_10,
        30 => Register::vr30_8_10,
        31 => Register::vr31_8_10,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_125_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_125_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_125_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_11,
        1 => Register::vr1_8_11,
        2 => Register::vr2_8_11,
        3 => Register::vr3_8_11,
        4 => Register::vr4_8_11,
        5 => Register::vr5_8_11,
        6 => Register::vr6_8_11,
        7 => Register::vr7_8_11,
        8 => Register::vr8_8_11,
        9 => Register::vr9_8_11,
        10 => Register::vr10_8_11,
        11 => Register::vr11_8_11,
        12 => Register::vr12_8_11,
        13 => Register::vr13_8_11,
        14 => Register::vr14_8_11,
        15 => Register::vr15_8_11,
        16 => Register::vr16_8_11,
        17 => Register::vr17_8_11,
        18 => Register::vr18_8_11,
        19 => Register::vr19_8_11,
        20 => Register::vr20_8_11,
        21 => Register::vr21_8_11,
        22 => Register::vr22_8_11,
        23 => Register::vr23_8_11,
        24 => Register::vr24_8_11,
        25 => Register::vr25_8_11,
        26 => Register::vr26_8_11,
        27 => Register::vr27_8_11,
        28 => Register::vr28_8_11,
        29 => Register::vr29_8_11,
        30 => Register::vr30_8_11,
        31 => Register::vr31_8_11,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_126_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_126_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_126_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_12,
        1 => Register::vr1_8_12,
        2 => Register::vr2_8_12,
        3 => Register::vr3_8_12,
        4 => Register::vr4_8_12,
        5 => Register::vr5_8_12,
        6 => Register::vr6_8_12,
        7 => Register::vr7_8_12,
        8 => Register::vr8_8_12,
        9 => Register::vr9_8_12,
        10 => Register::vr10_8_12,
        11 => Register::vr11_8_12,
        12 => Register::vr12_8_12,
        13 => Register::vr13_8_12,
        14 => Register::vr14_8_12,
        15 => Register::vr15_8_12,
        16 => Register::vr16_8_12,
        17 => Register::vr17_8_12,
        18 => Register::vr18_8_12,
        19 => Register::vr19_8_12,
        20 => Register::vr20_8_12,
        21 => Register::vr21_8_12,
        22 => Register::vr22_8_12,
        23 => Register::vr23_8_12,
        24 => Register::vr24_8_12,
        25 => Register::vr25_8_12,
        26 => Register::vr26_8_12,
        27 => Register::vr27_8_12,
        28 => Register::vr28_8_12,
        29 => Register::vr29_8_12,
        30 => Register::vr30_8_12,
        31 => Register::vr31_8_12,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_127_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_127_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_127_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_13,
        1 => Register::vr1_8_13,
        2 => Register::vr2_8_13,
        3 => Register::vr3_8_13,
        4 => Register::vr4_8_13,
        5 => Register::vr5_8_13,
        6 => Register::vr6_8_13,
        7 => Register::vr7_8_13,
        8 => Register::vr8_8_13,
        9 => Register::vr9_8_13,
        10 => Register::vr10_8_13,
        11 => Register::vr11_8_13,
        12 => Register::vr12_8_13,
        13 => Register::vr13_8_13,
        14 => Register::vr14_8_13,
        15 => Register::vr15_8_13,
        16 => Register::vr16_8_13,
        17 => Register::vr17_8_13,
        18 => Register::vr18_8_13,
        19 => Register::vr19_8_13,
        20 => Register::vr20_8_13,
        21 => Register::vr21_8_13,
        22 => Register::vr22_8_13,
        23 => Register::vr23_8_13,
        24 => Register::vr24_8_13,
        25 => Register::vr25_8_13,
        26 => Register::vr26_8_13,
        27 => Register::vr27_8_13,
        28 => Register::vr28_8_13,
        29 => Register::vr29_8_13,
        30 => Register::vr30_8_13,
        31 => Register::vr31_8_13,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_128_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_128_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_128_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_14,
        1 => Register::vr1_8_14,
        2 => Register::vr2_8_14,
        3 => Register::vr3_8_14,
        4 => Register::vr4_8_14,
        5 => Register::vr5_8_14,
        6 => Register::vr6_8_14,
        7 => Register::vr7_8_14,
        8 => Register::vr8_8_14,
        9 => Register::vr9_8_14,
        10 => Register::vr10_8_14,
        11 => Register::vr11_8_14,
        12 => Register::vr12_8_14,
        13 => Register::vr13_8_14,
        14 => Register::vr14_8_14,
        15 => Register::vr15_8_14,
        16 => Register::vr16_8_14,
        17 => Register::vr17_8_14,
        18 => Register::vr18_8_14,
        19 => Register::vr19_8_14,
        20 => Register::vr20_8_14,
        21 => Register::vr21_8_14,
        22 => Register::vr22_8_14,
        23 => Register::vr23_8_14,
        24 => Register::vr24_8_14,
        25 => Register::vr25_8_14,
        26 => Register::vr26_8_14,
        27 => Register::vr27_8_14,
        28 => Register::vr28_8_14,
        29 => Register::vr29_8_14,
        30 => Register::vr30_8_14,
        31 => Register::vr31_8_14,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_129_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_129_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_129_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_15,
        1 => Register::vr1_8_15,
        2 => Register::vr2_8_15,
        3 => Register::vr3_8_15,
        4 => Register::vr4_8_15,
        5 => Register::vr5_8_15,
        6 => Register::vr6_8_15,
        7 => Register::vr7_8_15,
        8 => Register::vr8_8_15,
        9 => Register::vr9_8_15,
        10 => Register::vr10_8_15,
        11 => Register::vr11_8_15,
        12 => Register::vr12_8_15,
        13 => Register::vr13_8_15,
        14 => Register::vr14_8_15,
        15 => Register::vr15_8_15,
        16 => Register::vr16_8_15,
        17 => Register::vr17_8_15,
        18 => Register::vr18_8_15,
        19 => Register::vr19_8_15,
        20 => Register::vr20_8_15,
        21 => Register::vr21_8_15,
        22 => Register::vr22_8_15,
        23 => Register::vr23_8_15,
        24 => Register::vr24_8_15,
        25 => Register::vr25_8_15,
        26 => Register::vr26_8_15,
        27 => Register::vr27_8_15,
        28 => Register::vr28_8_15,
        29 => Register::vr29_8_15,
        30 => Register::vr30_8_15,
        31 => Register::vr31_8_15,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_130_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_130_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_130_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_64_0,
        1 => Register::vr1_64_0,
        2 => Register::vr2_64_0,
        3 => Register::vr3_64_0,
        4 => Register::vr4_64_0,
        5 => Register::vr5_64_0,
        6 => Register::vr6_64_0,
        7 => Register::vr7_64_0,
        8 => Register::vr8_64_0,
        9 => Register::vr9_64_0,
        10 => Register::vr10_64_0,
        11 => Register::vr11_64_0,
        12 => Register::vr12_64_0,
        13 => Register::vr13_64_0,
        14 => Register::vr14_64_0,
        15 => Register::vr15_64_0,
        16 => Register::vr16_64_0,
        17 => Register::vr17_64_0,
        18 => Register::vr18_64_0,
        19 => Register::vr19_64_0,
        20 => Register::vr20_64_0,
        21 => Register::vr21_64_0,
        22 => Register::vr22_64_0,
        23 => Register::vr23_64_0,
        24 => Register::vr24_64_0,
        25 => Register::vr25_64_0,
        26 => Register::vr26_64_0,
        27 => Register::vr27_64_0,
        28 => Register::vr28_64_0,
        29 => Register::vr29_64_0,
        30 => Register::vr30_64_0,
        31 => Register::vr31_64_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_131_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_131_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_131_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_64_1,
        1 => Register::vr1_64_1,
        2 => Register::vr2_64_1,
        3 => Register::vr3_64_1,
        4 => Register::vr4_64_1,
        5 => Register::vr5_64_1,
        6 => Register::vr6_64_1,
        7 => Register::vr7_64_1,
        8 => Register::vr8_64_1,
        9 => Register::vr9_64_1,
        10 => Register::vr10_64_1,
        11 => Register::vr11_64_1,
        12 => Register::vr12_64_1,
        13 => Register::vr13_64_1,
        14 => Register::vr14_64_1,
        15 => Register::vr15_64_1,
        16 => Register::vr16_64_1,
        17 => Register::vr17_64_1,
        18 => Register::vr18_64_1,
        19 => Register::vr19_64_1,
        20 => Register::vr20_64_1,
        21 => Register::vr21_64_1,
        22 => Register::vr22_64_1,
        23 => Register::vr23_64_1,
        24 => Register::vr24_64_1,
        25 => Register::vr25_64_1,
        26 => Register::vr26_64_1,
        27 => Register::vr27_64_1,
        28 => Register::vr28_64_1,
        29 => Register::vr29_64_1,
        30 => Register::vr30_64_1,
        31 => Register::vr31_64_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_132_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_132_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_132_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_0,
        1 => Register::vr1_32_0,
        2 => Register::vr2_32_0,
        3 => Register::vr3_32_0,
        4 => Register::vr4_32_0,
        5 => Register::vr5_32_0,
        6 => Register::vr6_32_0,
        7 => Register::vr7_32_0,
        8 => Register::vr8_32_0,
        9 => Register::vr9_32_0,
        10 => Register::vr10_32_0,
        11 => Register::vr11_32_0,
        12 => Register::vr12_32_0,
        13 => Register::vr13_32_0,
        14 => Register::vr14_32_0,
        15 => Register::vr15_32_0,
        16 => Register::vr16_32_0,
        17 => Register::vr17_32_0,
        18 => Register::vr18_32_0,
        19 => Register::vr19_32_0,
        20 => Register::vr20_32_0,
        21 => Register::vr21_32_0,
        22 => Register::vr22_32_0,
        23 => Register::vr23_32_0,
        24 => Register::vr24_32_0,
        25 => Register::vr25_32_0,
        26 => Register::vr26_32_0,
        27 => Register::vr27_32_0,
        28 => Register::vr28_32_0,
        29 => Register::vr29_32_0,
        30 => Register::vr30_32_0,
        31 => Register::vr31_32_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_133_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_133_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_133_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_1,
        1 => Register::vr1_32_1,
        2 => Register::vr2_32_1,
        3 => Register::vr3_32_1,
        4 => Register::vr4_32_1,
        5 => Register::vr5_32_1,
        6 => Register::vr6_32_1,
        7 => Register::vr7_32_1,
        8 => Register::vr8_32_1,
        9 => Register::vr9_32_1,
        10 => Register::vr10_32_1,
        11 => Register::vr11_32_1,
        12 => Register::vr12_32_1,
        13 => Register::vr13_32_1,
        14 => Register::vr14_32_1,
        15 => Register::vr15_32_1,
        16 => Register::vr16_32_1,
        17 => Register::vr17_32_1,
        18 => Register::vr18_32_1,
        19 => Register::vr19_32_1,
        20 => Register::vr20_32_1,
        21 => Register::vr21_32_1,
        22 => Register::vr22_32_1,
        23 => Register::vr23_32_1,
        24 => Register::vr24_32_1,
        25 => Register::vr25_32_1,
        26 => Register::vr26_32_1,
        27 => Register::vr27_32_1,
        28 => Register::vr28_32_1,
        29 => Register::vr29_32_1,
        30 => Register::vr30_32_1,
        31 => Register::vr31_32_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_134_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_134_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_134_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_2,
        1 => Register::vr1_32_2,
        2 => Register::vr2_32_2,
        3 => Register::vr3_32_2,
        4 => Register::vr4_32_2,
        5 => Register::vr5_32_2,
        6 => Register::vr6_32_2,
        7 => Register::vr7_32_2,
        8 => Register::vr8_32_2,
        9 => Register::vr9_32_2,
        10 => Register::vr10_32_2,
        11 => Register::vr11_32_2,
        12 => Register::vr12_32_2,
        13 => Register::vr13_32_2,
        14 => Register::vr14_32_2,
        15 => Register::vr15_32_2,
        16 => Register::vr16_32_2,
        17 => Register::vr17_32_2,
        18 => Register::vr18_32_2,
        19 => Register::vr19_32_2,
        20 => Register::vr20_32_2,
        21 => Register::vr21_32_2,
        22 => Register::vr22_32_2,
        23 => Register::vr23_32_2,
        24 => Register::vr24_32_2,
        25 => Register::vr25_32_2,
        26 => Register::vr26_32_2,
        27 => Register::vr27_32_2,
        28 => Register::vr28_32_2,
        29 => Register::vr29_32_2,
        30 => Register::vr30_32_2,
        31 => Register::vr31_32_2,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_135_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_135_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_135_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_3,
        1 => Register::vr1_32_3,
        2 => Register::vr2_32_3,
        3 => Register::vr3_32_3,
        4 => Register::vr4_32_3,
        5 => Register::vr5_32_3,
        6 => Register::vr6_32_3,
        7 => Register::vr7_32_3,
        8 => Register::vr8_32_3,
        9 => Register::vr9_32_3,
        10 => Register::vr10_32_3,
        11 => Register::vr11_32_3,
        12 => Register::vr12_32_3,
        13 => Register::vr13_32_3,
        14 => Register::vr14_32_3,
        15 => Register::vr15_32_3,
        16 => Register::vr16_32_3,
        17 => Register::vr17_32_3,
        18 => Register::vr18_32_3,
        19 => Register::vr19_32_3,
        20 => Register::vr20_32_3,
        21 => Register::vr21_32_3,
        22 => Register::vr22_32_3,
        23 => Register::vr23_32_3,
        24 => Register::vr24_32_3,
        25 => Register::vr25_32_3,
        26 => Register::vr26_32_3,
        27 => Register::vr27_32_3,
        28 => Register::vr28_32_3,
        29 => Register::vr29_32_3,
        30 => Register::vr30_32_3,
        31 => Register::vr31_32_3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_136_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_136_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_136_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_0,
        1 => Register::vr1_16_0,
        2 => Register::vr2_16_0,
        3 => Register::vr3_16_0,
        4 => Register::vr4_16_0,
        5 => Register::vr5_16_0,
        6 => Register::vr6_16_0,
        7 => Register::vr7_16_0,
        8 => Register::vr8_16_0,
        9 => Register::vr9_16_0,
        10 => Register::vr10_16_0,
        11 => Register::vr11_16_0,
        12 => Register::vr12_16_0,
        13 => Register::vr13_16_0,
        14 => Register::vr14_16_0,
        15 => Register::vr15_16_0,
        16 => Register::vr16_16_0,
        17 => Register::vr17_16_0,
        18 => Register::vr18_16_0,
        19 => Register::vr19_16_0,
        20 => Register::vr20_16_0,
        21 => Register::vr21_16_0,
        22 => Register::vr22_16_0,
        23 => Register::vr23_16_0,
        24 => Register::vr24_16_0,
        25 => Register::vr25_16_0,
        26 => Register::vr26_16_0,
        27 => Register::vr27_16_0,
        28 => Register::vr28_16_0,
        29 => Register::vr29_16_0,
        30 => Register::vr30_16_0,
        31 => Register::vr31_16_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_137_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_137_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_137_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_1,
        1 => Register::vr1_16_1,
        2 => Register::vr2_16_1,
        3 => Register::vr3_16_1,
        4 => Register::vr4_16_1,
        5 => Register::vr5_16_1,
        6 => Register::vr6_16_1,
        7 => Register::vr7_16_1,
        8 => Register::vr8_16_1,
        9 => Register::vr9_16_1,
        10 => Register::vr10_16_1,
        11 => Register::vr11_16_1,
        12 => Register::vr12_16_1,
        13 => Register::vr13_16_1,
        14 => Register::vr14_16_1,
        15 => Register::vr15_16_1,
        16 => Register::vr16_16_1,
        17 => Register::vr17_16_1,
        18 => Register::vr18_16_1,
        19 => Register::vr19_16_1,
        20 => Register::vr20_16_1,
        21 => Register::vr21_16_1,
        22 => Register::vr22_16_1,
        23 => Register::vr23_16_1,
        24 => Register::vr24_16_1,
        25 => Register::vr25_16_1,
        26 => Register::vr26_16_1,
        27 => Register::vr27_16_1,
        28 => Register::vr28_16_1,
        29 => Register::vr29_16_1,
        30 => Register::vr30_16_1,
        31 => Register::vr31_16_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_138_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_138_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_138_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_2,
        1 => Register::vr1_16_2,
        2 => Register::vr2_16_2,
        3 => Register::vr3_16_2,
        4 => Register::vr4_16_2,
        5 => Register::vr5_16_2,
        6 => Register::vr6_16_2,
        7 => Register::vr7_16_2,
        8 => Register::vr8_16_2,
        9 => Register::vr9_16_2,
        10 => Register::vr10_16_2,
        11 => Register::vr11_16_2,
        12 => Register::vr12_16_2,
        13 => Register::vr13_16_2,
        14 => Register::vr14_16_2,
        15 => Register::vr15_16_2,
        16 => Register::vr16_16_2,
        17 => Register::vr17_16_2,
        18 => Register::vr18_16_2,
        19 => Register::vr19_16_2,
        20 => Register::vr20_16_2,
        21 => Register::vr21_16_2,
        22 => Register::vr22_16_2,
        23 => Register::vr23_16_2,
        24 => Register::vr24_16_2,
        25 => Register::vr25_16_2,
        26 => Register::vr26_16_2,
        27 => Register::vr27_16_2,
        28 => Register::vr28_16_2,
        29 => Register::vr29_16_2,
        30 => Register::vr30_16_2,
        31 => Register::vr31_16_2,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_139_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_139_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_139_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_3,
        1 => Register::vr1_16_3,
        2 => Register::vr2_16_3,
        3 => Register::vr3_16_3,
        4 => Register::vr4_16_3,
        5 => Register::vr5_16_3,
        6 => Register::vr6_16_3,
        7 => Register::vr7_16_3,
        8 => Register::vr8_16_3,
        9 => Register::vr9_16_3,
        10 => Register::vr10_16_3,
        11 => Register::vr11_16_3,
        12 => Register::vr12_16_3,
        13 => Register::vr13_16_3,
        14 => Register::vr14_16_3,
        15 => Register::vr15_16_3,
        16 => Register::vr16_16_3,
        17 => Register::vr17_16_3,
        18 => Register::vr18_16_3,
        19 => Register::vr19_16_3,
        20 => Register::vr20_16_3,
        21 => Register::vr21_16_3,
        22 => Register::vr22_16_3,
        23 => Register::vr23_16_3,
        24 => Register::vr24_16_3,
        25 => Register::vr25_16_3,
        26 => Register::vr26_16_3,
        27 => Register::vr27_16_3,
        28 => Register::vr28_16_3,
        29 => Register::vr29_16_3,
        30 => Register::vr30_16_3,
        31 => Register::vr31_16_3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_140_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_140_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_140_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_4,
        1 => Register::vr1_16_4,
        2 => Register::vr2_16_4,
        3 => Register::vr3_16_4,
        4 => Register::vr4_16_4,
        5 => Register::vr5_16_4,
        6 => Register::vr6_16_4,
        7 => Register::vr7_16_4,
        8 => Register::vr8_16_4,
        9 => Register::vr9_16_4,
        10 => Register::vr10_16_4,
        11 => Register::vr11_16_4,
        12 => Register::vr12_16_4,
        13 => Register::vr13_16_4,
        14 => Register::vr14_16_4,
        15 => Register::vr15_16_4,
        16 => Register::vr16_16_4,
        17 => Register::vr17_16_4,
        18 => Register::vr18_16_4,
        19 => Register::vr19_16_4,
        20 => Register::vr20_16_4,
        21 => Register::vr21_16_4,
        22 => Register::vr22_16_4,
        23 => Register::vr23_16_4,
        24 => Register::vr24_16_4,
        25 => Register::vr25_16_4,
        26 => Register::vr26_16_4,
        27 => Register::vr27_16_4,
        28 => Register::vr28_16_4,
        29 => Register::vr29_16_4,
        30 => Register::vr30_16_4,
        31 => Register::vr31_16_4,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_141_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_141_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_141_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_5,
        1 => Register::vr1_16_5,
        2 => Register::vr2_16_5,
        3 => Register::vr3_16_5,
        4 => Register::vr4_16_5,
        5 => Register::vr5_16_5,
        6 => Register::vr6_16_5,
        7 => Register::vr7_16_5,
        8 => Register::vr8_16_5,
        9 => Register::vr9_16_5,
        10 => Register::vr10_16_5,
        11 => Register::vr11_16_5,
        12 => Register::vr12_16_5,
        13 => Register::vr13_16_5,
        14 => Register::vr14_16_5,
        15 => Register::vr15_16_5,
        16 => Register::vr16_16_5,
        17 => Register::vr17_16_5,
        18 => Register::vr18_16_5,
        19 => Register::vr19_16_5,
        20 => Register::vr20_16_5,
        21 => Register::vr21_16_5,
        22 => Register::vr22_16_5,
        23 => Register::vr23_16_5,
        24 => Register::vr24_16_5,
        25 => Register::vr25_16_5,
        26 => Register::vr26_16_5,
        27 => Register::vr27_16_5,
        28 => Register::vr28_16_5,
        29 => Register::vr29_16_5,
        30 => Register::vr30_16_5,
        31 => Register::vr31_16_5,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_142_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_142_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_142_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_6,
        1 => Register::vr1_16_6,
        2 => Register::vr2_16_6,
        3 => Register::vr3_16_6,
        4 => Register::vr4_16_6,
        5 => Register::vr5_16_6,
        6 => Register::vr6_16_6,
        7 => Register::vr7_16_6,
        8 => Register::vr8_16_6,
        9 => Register::vr9_16_6,
        10 => Register::vr10_16_6,
        11 => Register::vr11_16_6,
        12 => Register::vr12_16_6,
        13 => Register::vr13_16_6,
        14 => Register::vr14_16_6,
        15 => Register::vr15_16_6,
        16 => Register::vr16_16_6,
        17 => Register::vr17_16_6,
        18 => Register::vr18_16_6,
        19 => Register::vr19_16_6,
        20 => Register::vr20_16_6,
        21 => Register::vr21_16_6,
        22 => Register::vr22_16_6,
        23 => Register::vr23_16_6,
        24 => Register::vr24_16_6,
        25 => Register::vr25_16_6,
        26 => Register::vr26_16_6,
        27 => Register::vr27_16_6,
        28 => Register::vr28_16_6,
        29 => Register::vr29_16_6,
        30 => Register::vr30_16_6,
        31 => Register::vr31_16_6,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_143_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_143_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_143_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_7,
        1 => Register::vr1_16_7,
        2 => Register::vr2_16_7,
        3 => Register::vr3_16_7,
        4 => Register::vr4_16_7,
        5 => Register::vr5_16_7,
        6 => Register::vr6_16_7,
        7 => Register::vr7_16_7,
        8 => Register::vr8_16_7,
        9 => Register::vr9_16_7,
        10 => Register::vr10_16_7,
        11 => Register::vr11_16_7,
        12 => Register::vr12_16_7,
        13 => Register::vr13_16_7,
        14 => Register::vr14_16_7,
        15 => Register::vr15_16_7,
        16 => Register::vr16_16_7,
        17 => Register::vr17_16_7,
        18 => Register::vr18_16_7,
        19 => Register::vr19_16_7,
        20 => Register::vr20_16_7,
        21 => Register::vr21_16_7,
        22 => Register::vr22_16_7,
        23 => Register::vr23_16_7,
        24 => Register::vr24_16_7,
        25 => Register::vr25_16_7,
        26 => Register::vr26_16_7,
        27 => Register::vr27_16_7,
        28 => Register::vr28_16_7,
        29 => Register::vr29_16_7,
        30 => Register::vr30_16_7,
        31 => Register::vr31_16_7,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_144_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_144_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_144_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_0,
        1 => Register::vr1_8_0,
        2 => Register::vr2_8_0,
        3 => Register::vr3_8_0,
        4 => Register::vr4_8_0,
        5 => Register::vr5_8_0,
        6 => Register::vr6_8_0,
        7 => Register::vr7_8_0,
        8 => Register::vr8_8_0,
        9 => Register::vr9_8_0,
        10 => Register::vr10_8_0,
        11 => Register::vr11_8_0,
        12 => Register::vr12_8_0,
        13 => Register::vr13_8_0,
        14 => Register::vr14_8_0,
        15 => Register::vr15_8_0,
        16 => Register::vr16_8_0,
        17 => Register::vr17_8_0,
        18 => Register::vr18_8_0,
        19 => Register::vr19_8_0,
        20 => Register::vr20_8_0,
        21 => Register::vr21_8_0,
        22 => Register::vr22_8_0,
        23 => Register::vr23_8_0,
        24 => Register::vr24_8_0,
        25 => Register::vr25_8_0,
        26 => Register::vr26_8_0,
        27 => Register::vr27_8_0,
        28 => Register::vr28_8_0,
        29 => Register::vr29_8_0,
        30 => Register::vr30_8_0,
        31 => Register::vr31_8_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_145_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_145_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_145_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_1,
        1 => Register::vr1_8_1,
        2 => Register::vr2_8_1,
        3 => Register::vr3_8_1,
        4 => Register::vr4_8_1,
        5 => Register::vr5_8_1,
        6 => Register::vr6_8_1,
        7 => Register::vr7_8_1,
        8 => Register::vr8_8_1,
        9 => Register::vr9_8_1,
        10 => Register::vr10_8_1,
        11 => Register::vr11_8_1,
        12 => Register::vr12_8_1,
        13 => Register::vr13_8_1,
        14 => Register::vr14_8_1,
        15 => Register::vr15_8_1,
        16 => Register::vr16_8_1,
        17 => Register::vr17_8_1,
        18 => Register::vr18_8_1,
        19 => Register::vr19_8_1,
        20 => Register::vr20_8_1,
        21 => Register::vr21_8_1,
        22 => Register::vr22_8_1,
        23 => Register::vr23_8_1,
        24 => Register::vr24_8_1,
        25 => Register::vr25_8_1,
        26 => Register::vr26_8_1,
        27 => Register::vr27_8_1,
        28 => Register::vr28_8_1,
        29 => Register::vr29_8_1,
        30 => Register::vr30_8_1,
        31 => Register::vr31_8_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_146_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_146_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_146_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_2,
        1 => Register::vr1_8_2,
        2 => Register::vr2_8_2,
        3 => Register::vr3_8_2,
        4 => Register::vr4_8_2,
        5 => Register::vr5_8_2,
        6 => Register::vr6_8_2,
        7 => Register::vr7_8_2,
        8 => Register::vr8_8_2,
        9 => Register::vr9_8_2,
        10 => Register::vr10_8_2,
        11 => Register::vr11_8_2,
        12 => Register::vr12_8_2,
        13 => Register::vr13_8_2,
        14 => Register::vr14_8_2,
        15 => Register::vr15_8_2,
        16 => Register::vr16_8_2,
        17 => Register::vr17_8_2,
        18 => Register::vr18_8_2,
        19 => Register::vr19_8_2,
        20 => Register::vr20_8_2,
        21 => Register::vr21_8_2,
        22 => Register::vr22_8_2,
        23 => Register::vr23_8_2,
        24 => Register::vr24_8_2,
        25 => Register::vr25_8_2,
        26 => Register::vr26_8_2,
        27 => Register::vr27_8_2,
        28 => Register::vr28_8_2,
        29 => Register::vr29_8_2,
        30 => Register::vr30_8_2,
        31 => Register::vr31_8_2,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_147_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_147_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_147_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_3,
        1 => Register::vr1_8_3,
        2 => Register::vr2_8_3,
        3 => Register::vr3_8_3,
        4 => Register::vr4_8_3,
        5 => Register::vr5_8_3,
        6 => Register::vr6_8_3,
        7 => Register::vr7_8_3,
        8 => Register::vr8_8_3,
        9 => Register::vr9_8_3,
        10 => Register::vr10_8_3,
        11 => Register::vr11_8_3,
        12 => Register::vr12_8_3,
        13 => Register::vr13_8_3,
        14 => Register::vr14_8_3,
        15 => Register::vr15_8_3,
        16 => Register::vr16_8_3,
        17 => Register::vr17_8_3,
        18 => Register::vr18_8_3,
        19 => Register::vr19_8_3,
        20 => Register::vr20_8_3,
        21 => Register::vr21_8_3,
        22 => Register::vr22_8_3,
        23 => Register::vr23_8_3,
        24 => Register::vr24_8_3,
        25 => Register::vr25_8_3,
        26 => Register::vr26_8_3,
        27 => Register::vr27_8_3,
        28 => Register::vr28_8_3,
        29 => Register::vr29_8_3,
        30 => Register::vr30_8_3,
        31 => Register::vr31_8_3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_148_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_148_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_148_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_4,
        1 => Register::vr1_8_4,
        2 => Register::vr2_8_4,
        3 => Register::vr3_8_4,
        4 => Register::vr4_8_4,
        5 => Register::vr5_8_4,
        6 => Register::vr6_8_4,
        7 => Register::vr7_8_4,
        8 => Register::vr8_8_4,
        9 => Register::vr9_8_4,
        10 => Register::vr10_8_4,
        11 => Register::vr11_8_4,
        12 => Register::vr12_8_4,
        13 => Register::vr13_8_4,
        14 => Register::vr14_8_4,
        15 => Register::vr15_8_4,
        16 => Register::vr16_8_4,
        17 => Register::vr17_8_4,
        18 => Register::vr18_8_4,
        19 => Register::vr19_8_4,
        20 => Register::vr20_8_4,
        21 => Register::vr21_8_4,
        22 => Register::vr22_8_4,
        23 => Register::vr23_8_4,
        24 => Register::vr24_8_4,
        25 => Register::vr25_8_4,
        26 => Register::vr26_8_4,
        27 => Register::vr27_8_4,
        28 => Register::vr28_8_4,
        29 => Register::vr29_8_4,
        30 => Register::vr30_8_4,
        31 => Register::vr31_8_4,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_149_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_149_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_149_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_5,
        1 => Register::vr1_8_5,
        2 => Register::vr2_8_5,
        3 => Register::vr3_8_5,
        4 => Register::vr4_8_5,
        5 => Register::vr5_8_5,
        6 => Register::vr6_8_5,
        7 => Register::vr7_8_5,
        8 => Register::vr8_8_5,
        9 => Register::vr9_8_5,
        10 => Register::vr10_8_5,
        11 => Register::vr11_8_5,
        12 => Register::vr12_8_5,
        13 => Register::vr13_8_5,
        14 => Register::vr14_8_5,
        15 => Register::vr15_8_5,
        16 => Register::vr16_8_5,
        17 => Register::vr17_8_5,
        18 => Register::vr18_8_5,
        19 => Register::vr19_8_5,
        20 => Register::vr20_8_5,
        21 => Register::vr21_8_5,
        22 => Register::vr22_8_5,
        23 => Register::vr23_8_5,
        24 => Register::vr24_8_5,
        25 => Register::vr25_8_5,
        26 => Register::vr26_8_5,
        27 => Register::vr27_8_5,
        28 => Register::vr28_8_5,
        29 => Register::vr29_8_5,
        30 => Register::vr30_8_5,
        31 => Register::vr31_8_5,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_150_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_150_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_150_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_6,
        1 => Register::vr1_8_6,
        2 => Register::vr2_8_6,
        3 => Register::vr3_8_6,
        4 => Register::vr4_8_6,
        5 => Register::vr5_8_6,
        6 => Register::vr6_8_6,
        7 => Register::vr7_8_6,
        8 => Register::vr8_8_6,
        9 => Register::vr9_8_6,
        10 => Register::vr10_8_6,
        11 => Register::vr11_8_6,
        12 => Register::vr12_8_6,
        13 => Register::vr13_8_6,
        14 => Register::vr14_8_6,
        15 => Register::vr15_8_6,
        16 => Register::vr16_8_6,
        17 => Register::vr17_8_6,
        18 => Register::vr18_8_6,
        19 => Register::vr19_8_6,
        20 => Register::vr20_8_6,
        21 => Register::vr21_8_6,
        22 => Register::vr22_8_6,
        23 => Register::vr23_8_6,
        24 => Register::vr24_8_6,
        25 => Register::vr25_8_6,
        26 => Register::vr26_8_6,
        27 => Register::vr27_8_6,
        28 => Register::vr28_8_6,
        29 => Register::vr29_8_6,
        30 => Register::vr30_8_6,
        31 => Register::vr31_8_6,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_151_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_151_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_151_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_7,
        1 => Register::vr1_8_7,
        2 => Register::vr2_8_7,
        3 => Register::vr3_8_7,
        4 => Register::vr4_8_7,
        5 => Register::vr5_8_7,
        6 => Register::vr6_8_7,
        7 => Register::vr7_8_7,
        8 => Register::vr8_8_7,
        9 => Register::vr9_8_7,
        10 => Register::vr10_8_7,
        11 => Register::vr11_8_7,
        12 => Register::vr12_8_7,
        13 => Register::vr13_8_7,
        14 => Register::vr14_8_7,
        15 => Register::vr15_8_7,
        16 => Register::vr16_8_7,
        17 => Register::vr17_8_7,
        18 => Register::vr18_8_7,
        19 => Register::vr19_8_7,
        20 => Register::vr20_8_7,
        21 => Register::vr21_8_7,
        22 => Register::vr22_8_7,
        23 => Register::vr23_8_7,
        24 => Register::vr24_8_7,
        25 => Register::vr25_8_7,
        26 => Register::vr26_8_7,
        27 => Register::vr27_8_7,
        28 => Register::vr28_8_7,
        29 => Register::vr29_8_7,
        30 => Register::vr30_8_7,
        31 => Register::vr31_8_7,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_152_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_152_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_152_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_8,
        1 => Register::vr1_8_8,
        2 => Register::vr2_8_8,
        3 => Register::vr3_8_8,
        4 => Register::vr4_8_8,
        5 => Register::vr5_8_8,
        6 => Register::vr6_8_8,
        7 => Register::vr7_8_8,
        8 => Register::vr8_8_8,
        9 => Register::vr9_8_8,
        10 => Register::vr10_8_8,
        11 => Register::vr11_8_8,
        12 => Register::vr12_8_8,
        13 => Register::vr13_8_8,
        14 => Register::vr14_8_8,
        15 => Register::vr15_8_8,
        16 => Register::vr16_8_8,
        17 => Register::vr17_8_8,
        18 => Register::vr18_8_8,
        19 => Register::vr19_8_8,
        20 => Register::vr20_8_8,
        21 => Register::vr21_8_8,
        22 => Register::vr22_8_8,
        23 => Register::vr23_8_8,
        24 => Register::vr24_8_8,
        25 => Register::vr25_8_8,
        26 => Register::vr26_8_8,
        27 => Register::vr27_8_8,
        28 => Register::vr28_8_8,
        29 => Register::vr29_8_8,
        30 => Register::vr30_8_8,
        31 => Register::vr31_8_8,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_153_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_153_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_153_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_9,
        1 => Register::vr1_8_9,
        2 => Register::vr2_8_9,
        3 => Register::vr3_8_9,
        4 => Register::vr4_8_9,
        5 => Register::vr5_8_9,
        6 => Register::vr6_8_9,
        7 => Register::vr7_8_9,
        8 => Register::vr8_8_9,
        9 => Register::vr9_8_9,
        10 => Register::vr10_8_9,
        11 => Register::vr11_8_9,
        12 => Register::vr12_8_9,
        13 => Register::vr13_8_9,
        14 => Register::vr14_8_9,
        15 => Register::vr15_8_9,
        16 => Register::vr16_8_9,
        17 => Register::vr17_8_9,
        18 => Register::vr18_8_9,
        19 => Register::vr19_8_9,
        20 => Register::vr20_8_9,
        21 => Register::vr21_8_9,
        22 => Register::vr22_8_9,
        23 => Register::vr23_8_9,
        24 => Register::vr24_8_9,
        25 => Register::vr25_8_9,
        26 => Register::vr26_8_9,
        27 => Register::vr27_8_9,
        28 => Register::vr28_8_9,
        29 => Register::vr29_8_9,
        30 => Register::vr30_8_9,
        31 => Register::vr31_8_9,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_154_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_154_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_154_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_10,
        1 => Register::vr1_8_10,
        2 => Register::vr2_8_10,
        3 => Register::vr3_8_10,
        4 => Register::vr4_8_10,
        5 => Register::vr5_8_10,
        6 => Register::vr6_8_10,
        7 => Register::vr7_8_10,
        8 => Register::vr8_8_10,
        9 => Register::vr9_8_10,
        10 => Register::vr10_8_10,
        11 => Register::vr11_8_10,
        12 => Register::vr12_8_10,
        13 => Register::vr13_8_10,
        14 => Register::vr14_8_10,
        15 => Register::vr15_8_10,
        16 => Register::vr16_8_10,
        17 => Register::vr17_8_10,
        18 => Register::vr18_8_10,
        19 => Register::vr19_8_10,
        20 => Register::vr20_8_10,
        21 => Register::vr21_8_10,
        22 => Register::vr22_8_10,
        23 => Register::vr23_8_10,
        24 => Register::vr24_8_10,
        25 => Register::vr25_8_10,
        26 => Register::vr26_8_10,
        27 => Register::vr27_8_10,
        28 => Register::vr28_8_10,
        29 => Register::vr29_8_10,
        30 => Register::vr30_8_10,
        31 => Register::vr31_8_10,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_155_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_155_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_155_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_11,
        1 => Register::vr1_8_11,
        2 => Register::vr2_8_11,
        3 => Register::vr3_8_11,
        4 => Register::vr4_8_11,
        5 => Register::vr5_8_11,
        6 => Register::vr6_8_11,
        7 => Register::vr7_8_11,
        8 => Register::vr8_8_11,
        9 => Register::vr9_8_11,
        10 => Register::vr10_8_11,
        11 => Register::vr11_8_11,
        12 => Register::vr12_8_11,
        13 => Register::vr13_8_11,
        14 => Register::vr14_8_11,
        15 => Register::vr15_8_11,
        16 => Register::vr16_8_11,
        17 => Register::vr17_8_11,
        18 => Register::vr18_8_11,
        19 => Register::vr19_8_11,
        20 => Register::vr20_8_11,
        21 => Register::vr21_8_11,
        22 => Register::vr22_8_11,
        23 => Register::vr23_8_11,
        24 => Register::vr24_8_11,
        25 => Register::vr25_8_11,
        26 => Register::vr26_8_11,
        27 => Register::vr27_8_11,
        28 => Register::vr28_8_11,
        29 => Register::vr29_8_11,
        30 => Register::vr30_8_11,
        31 => Register::vr31_8_11,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_156_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_156_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_156_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_12,
        1 => Register::vr1_8_12,
        2 => Register::vr2_8_12,
        3 => Register::vr3_8_12,
        4 => Register::vr4_8_12,
        5 => Register::vr5_8_12,
        6 => Register::vr6_8_12,
        7 => Register::vr7_8_12,
        8 => Register::vr8_8_12,
        9 => Register::vr9_8_12,
        10 => Register::vr10_8_12,
        11 => Register::vr11_8_12,
        12 => Register::vr12_8_12,
        13 => Register::vr13_8_12,
        14 => Register::vr14_8_12,
        15 => Register::vr15_8_12,
        16 => Register::vr16_8_12,
        17 => Register::vr17_8_12,
        18 => Register::vr18_8_12,
        19 => Register::vr19_8_12,
        20 => Register::vr20_8_12,
        21 => Register::vr21_8_12,
        22 => Register::vr22_8_12,
        23 => Register::vr23_8_12,
        24 => Register::vr24_8_12,
        25 => Register::vr25_8_12,
        26 => Register::vr26_8_12,
        27 => Register::vr27_8_12,
        28 => Register::vr28_8_12,
        29 => Register::vr29_8_12,
        30 => Register::vr30_8_12,
        31 => Register::vr31_8_12,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_157_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_157_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_157_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_13,
        1 => Register::vr1_8_13,
        2 => Register::vr2_8_13,
        3 => Register::vr3_8_13,
        4 => Register::vr4_8_13,
        5 => Register::vr5_8_13,
        6 => Register::vr6_8_13,
        7 => Register::vr7_8_13,
        8 => Register::vr8_8_13,
        9 => Register::vr9_8_13,
        10 => Register::vr10_8_13,
        11 => Register::vr11_8_13,
        12 => Register::vr12_8_13,
        13 => Register::vr13_8_13,
        14 => Register::vr14_8_13,
        15 => Register::vr15_8_13,
        16 => Register::vr16_8_13,
        17 => Register::vr17_8_13,
        18 => Register::vr18_8_13,
        19 => Register::vr19_8_13,
        20 => Register::vr20_8_13,
        21 => Register::vr21_8_13,
        22 => Register::vr22_8_13,
        23 => Register::vr23_8_13,
        24 => Register::vr24_8_13,
        25 => Register::vr25_8_13,
        26 => Register::vr26_8_13,
        27 => Register::vr27_8_13,
        28 => Register::vr28_8_13,
        29 => Register::vr29_8_13,
        30 => Register::vr30_8_13,
        31 => Register::vr31_8_13,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_158_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_158_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_158_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_14,
        1 => Register::vr1_8_14,
        2 => Register::vr2_8_14,
        3 => Register::vr3_8_14,
        4 => Register::vr4_8_14,
        5 => Register::vr5_8_14,
        6 => Register::vr6_8_14,
        7 => Register::vr7_8_14,
        8 => Register::vr8_8_14,
        9 => Register::vr9_8_14,
        10 => Register::vr10_8_14,
        11 => Register::vr11_8_14,
        12 => Register::vr12_8_14,
        13 => Register::vr13_8_14,
        14 => Register::vr14_8_14,
        15 => Register::vr15_8_14,
        16 => Register::vr16_8_14,
        17 => Register::vr17_8_14,
        18 => Register::vr18_8_14,
        19 => Register::vr19_8_14,
        20 => Register::vr20_8_14,
        21 => Register::vr21_8_14,
        22 => Register::vr22_8_14,
        23 => Register::vr23_8_14,
        24 => Register::vr24_8_14,
        25 => Register::vr25_8_14,
        26 => Register::vr26_8_14,
        27 => Register::vr27_8_14,
        28 => Register::vr28_8_14,
        29 => Register::vr29_8_14,
        30 => Register::vr30_8_14,
        31 => Register::vr31_8_14,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_159_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_159_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_159_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_15,
        1 => Register::vr1_8_15,
        2 => Register::vr2_8_15,
        3 => Register::vr3_8_15,
        4 => Register::vr4_8_15,
        5 => Register::vr5_8_15,
        6 => Register::vr6_8_15,
        7 => Register::vr7_8_15,
        8 => Register::vr8_8_15,
        9 => Register::vr9_8_15,
        10 => Register::vr10_8_15,
        11 => Register::vr11_8_15,
        12 => Register::vr12_8_15,
        13 => Register::vr13_8_15,
        14 => Register::vr14_8_15,
        15 => Register::vr15_8_15,
        16 => Register::vr16_8_15,
        17 => Register::vr17_8_15,
        18 => Register::vr18_8_15,
        19 => Register::vr19_8_15,
        20 => Register::vr20_8_15,
        21 => Register::vr21_8_15,
        22 => Register::vr22_8_15,
        23 => Register::vr23_8_15,
        24 => Register::vr24_8_15,
        25 => Register::vr25_8_15,
        26 => Register::vr26_8_15,
        27 => Register::vr27_8_15,
        28 => Register::vr28_8_15,
        29 => Register::vr29_8_15,
        30 => Register::vr30_8_15,
        31 => Register::vr31_8_15,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_160_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_160_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_160_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::cr0,
        1 => Register::cr1,
        2 => Register::cr2,
        3 => Register::cr3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_161_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_161_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_161_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::r8,
        1 => Register::r9,
        2 => Register::r10,
        3 => Register::r11,
        4 => Register::r12,
        5 => Register::r13,
        6 => Register::r14,
        7 => Register::r15,
        8 => Register::r16,
        9 => Register::r17,
        10 => Register::r18,
        11 => Register::r19,
        12 => Register::r20,
        13 => Register::r21,
        14 => Register::r22,
        15 => Register::r23,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_162_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_162_value(num.try_into().unwrap());
    DisplayElement::Register(value)
}
fn meaning_162_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::r0,
        1 => Register::r1,
        2 => Register::r2,
        3 => Register::r3,
        4 => Register::r4,
        5 => Register::r5,
        6 => Register::r6,
        7 => Register::r7,
        8 => Register::r24,
        9 => Register::r25,
        10 => Register::r26,
        11 => Register::r27,
        12 => Register::r28,
        13 => Register::r29,
        14 => Register::r30,
        15 => Register::r31,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_9_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => DisplayElement::Literal("v0"),
        1 => DisplayElement::Literal("v1"),
        2 => DisplayElement::Literal("v2"),
        3 => DisplayElement::Literal("v3"),
        4 => DisplayElement::Literal("v4"),
        5 => DisplayElement::Literal("v5"),
        6 => DisplayElement::Literal("v6"),
        7 => DisplayElement::Literal("v7"),
        8 => DisplayElement::Literal("v8"),
        9 => DisplayElement::Literal("v9"),
        10 => DisplayElement::Literal("v10"),
        11 => DisplayElement::Literal("v11"),
        12 => DisplayElement::Literal("v12"),
        13 => DisplayElement::Literal("v13"),
        14 => DisplayElement::Literal("v14"),
        15 => DisplayElement::Literal("v15"),
        16 => DisplayElement::Literal("v16"),
        17 => DisplayElement::Literal("v17"),
        18 => DisplayElement::Literal("v18"),
        19 => DisplayElement::Literal("v19"),
        20 => DisplayElement::Literal("v20"),
        21 => DisplayElement::Literal("v21"),
        22 => DisplayElement::Literal("v22"),
        23 => DisplayElement::Literal("v23"),
        24 => DisplayElement::Literal("v24"),
        25 => DisplayElement::Literal("v25"),
        26 => DisplayElement::Literal("v26"),
        27 => DisplayElement::Literal("v27"),
        28 => DisplayElement::Literal("v28"),
        29 => DisplayElement::Literal("v29"),
        30 => DisplayElement::Literal("v30"),
        31 => DisplayElement::Literal("v31"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_A(u8);
impl TokenField_A {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_AA(u8);
impl TokenField_AA {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_A_BITS(u8);
impl TokenField_A_BITS {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_A_BITSS(i8);
impl TokenField_A_BITSS {
    fn execution(&self) -> i8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_AX(u8);
impl TokenField_AX {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_B(u8);
impl TokenField_B {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_B_BITS(u8);
impl TokenField_B_BITS {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BD(i16);
impl TokenField_BD {
    fn execution(&self) -> i16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BF(u8);
impl TokenField_BF {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BFA(u8);
impl TokenField_BFA {
    fn execution(&self) -> Register {
        meaning_1_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_1_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BFA2(u8);
impl TokenField_BFA2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BF2(u8);
impl TokenField_BF2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BH(u8);
impl TokenField_BH {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BH_BITS(u8);
impl TokenField_BH_BITS {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BH_RBE(u16);
impl TokenField_BH_RBE {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BH_RET(u8);
impl TokenField_BH_RET {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BI_BITS(u8);
impl TokenField_BI_BITS {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BI_CC(u8);
impl TokenField_BI_CC {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BI_CR(u8);
impl TokenField_BI_CR {
    fn execution(&self) -> Register {
        meaning_1_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_1_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BIT_A(u8);
impl TokenField_BIT_A {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BIT_L(u8);
impl TokenField_BIT_L {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BIT_R(u8);
impl TokenField_BIT_R {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BIT_0(u8);
impl TokenField_BIT_0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BIT_10(u8);
impl TokenField_BIT_10 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BIT_1(u8);
impl TokenField_BIT_1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BIT_11(u8);
impl TokenField_BIT_11 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BIT_15(u8);
impl TokenField_BIT_15 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BIT_16(u8);
impl TokenField_BIT_16 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BIT_17(u8);
impl TokenField_BIT_17 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BIT_18(u8);
impl TokenField_BIT_18 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BIT_20(u8);
impl TokenField_BIT_20 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BIT_22(u8);
impl TokenField_BIT_22 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BIT_25(u8);
impl TokenField_BIT_25 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BIT_9(u8);
impl TokenField_BIT_9 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BIT_6(u8);
impl TokenField_BIT_6 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_0_1(u8);
impl TokenField_BITS_0_1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_0_17(u32);
impl TokenField_BITS_0_17 {
    fn execution(&self) -> u32 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_0_2(u8);
impl TokenField_BITS_0_2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_0_3(u8);
impl TokenField_BITS_0_3 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_1_10(u16);
impl TokenField_BITS_1_10 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_11_13(u8);
impl TokenField_BITS_11_13 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_11_15(u8);
impl TokenField_BITS_11_15 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_11_17(u8);
impl TokenField_BITS_11_17 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_11_20(u16);
impl TokenField_BITS_11_20 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_11_22(u16);
impl TokenField_BITS_11_22 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_11_24(u16);
impl TokenField_BITS_11_24 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_11_25(u16);
impl TokenField_BITS_11_25 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_12_15(u8);
impl TokenField_BITS_12_15 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_12_19(u8);
impl TokenField_BITS_12_19 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_12_25(u16);
impl TokenField_BITS_12_25 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_13_15(u8);
impl TokenField_BITS_13_15 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_14_15(u8);
impl TokenField_BITS_14_15 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_16_17(u8);
impl TokenField_BITS_16_17 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_16_18(u8);
impl TokenField_BITS_16_18 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_16_19(u8);
impl TokenField_BITS_16_19 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_16_20(u8);
impl TokenField_BITS_16_20 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_16_22(u8);
impl TokenField_BITS_16_22 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_16_25(u16);
impl TokenField_BITS_16_25 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_17_20(u8);
impl TokenField_BITS_17_20 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_17_24(u8);
impl TokenField_BITS_17_24 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_18_19(u8);
impl TokenField_BITS_18_19 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_18_20(u8);
impl TokenField_BITS_18_20 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_1_9(u16);
impl TokenField_BITS_1_9 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_19_20(u8);
impl TokenField_BITS_19_20 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_20_20(u8);
impl TokenField_BITS_20_20 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_21_22(u8);
impl TokenField_BITS_21_22 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_21_23(u8);
impl TokenField_BITS_21_23 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_21_24(u8);
impl TokenField_BITS_21_24 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_21_25(u8);
impl TokenField_BITS_21_25 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_21_28(u8);
impl TokenField_BITS_21_28 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_22_24(u8);
impl TokenField_BITS_22_24 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_22_25(u8);
impl TokenField_BITS_22_25 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_22_26(u8);
impl TokenField_BITS_22_26 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_2_25(u32);
impl TokenField_BITS_2_25 {
    fn execution(&self) -> u32 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_23_24(u8);
impl TokenField_BITS_23_24 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_23_25(u8);
impl TokenField_BITS_23_25 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_2_4(u8);
impl TokenField_BITS_2_4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_24_25(u8);
impl TokenField_BITS_24_25 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_3_7(u8);
impl TokenField_BITS_3_7 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_4_5(u8);
impl TokenField_BITS_4_5 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_6_10(u8);
impl TokenField_BITS_6_10 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BO_0(u8);
impl TokenField_BO_0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BO_1(u8);
impl TokenField_BO_1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BO(u8);
impl TokenField_BO {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BO_2(u8);
impl TokenField_BO_2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BO_3(u8);
impl TokenField_BO_3 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BO_BITS(u8);
impl TokenField_BO_BITS {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BX(u8);
impl TokenField_BX {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_C(u8);
impl TokenField_C {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_COND_BRANCH_CTRL(u8);
impl TokenField_COND_BRANCH_CTRL {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_CR_A(u8);
impl TokenField_CR_A {
    fn execution(&self) -> Register {
        meaning_1_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_1_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_CR_A_CC(u8);
impl TokenField_CR_A_CC {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_CR_B(u8);
impl TokenField_CR_B {
    fn execution(&self) -> Register {
        meaning_1_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_1_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_CR_B_CC(u8);
impl TokenField_CR_B_CC {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_CRBD(u8);
impl TokenField_CRBD {
    fn execution(&self) -> Register {
        meaning_2_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_2_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_CRBR(u8);
impl TokenField_CRBR {
    fn execution(&self) -> Register {
        meaning_2_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_2_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_CR_D(u8);
impl TokenField_CR_D {
    fn execution(&self) -> Register {
        meaning_1_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_1_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_CR_D_CC(u8);
impl TokenField_CR_D_CC {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_crfD(u8);
impl TokenField_crfD {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_CRFD(u8);
impl TokenField_CRFD {
    fn execution(&self) -> Register {
        meaning_1_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_1_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_CRFS(u8);
impl TokenField_CRFS {
    fn execution(&self) -> Register {
        meaning_1_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_1_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_CRM0(u8);
impl TokenField_CRM0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_CRM1(u8);
impl TokenField_CRM1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_CRM(u8);
impl TokenField_CRM {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_CRM2(u8);
impl TokenField_CRM2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_CRM3(u8);
impl TokenField_CRM3 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_CRM4(u8);
impl TokenField_CRM4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_CRM5(u8);
impl TokenField_CRM5 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_CRM6(u8);
impl TokenField_CRM6 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_CRM7(u8);
impl TokenField_CRM7 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_CR_X(u8);
impl TokenField_CR_X {
    fn execution(&self) -> Register {
        meaning_1_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_1_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_CR_X_CC(u8);
impl TokenField_CR_X_CC {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_CT(u8);
impl TokenField_CT {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_CT2(u8);
impl TokenField_CT2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_CX(u8);
impl TokenField_CX {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_D0(i16);
impl TokenField_D0 {
    fn execution(&self) -> i16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_D1(u8);
impl TokenField_D1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_D2(u8);
impl TokenField_D2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_D(u8);
impl TokenField_D {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Dp(u8);
impl TokenField_Dp {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_DC6(u8);
impl TokenField_DC6 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_DCM(u8);
impl TokenField_DCM {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_DCMX(u8);
impl TokenField_DCMX {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_DCRN(u16);
impl TokenField_DCRN {
    fn execution(&self) -> Register {
        meaning_3_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_3_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_DGM(u8);
impl TokenField_DGM {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_DM(u8);
impl TokenField_DM {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_DM2(u8);
impl TokenField_DM2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_DQ(u16);
impl TokenField_DQ {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_DQs(i16);
impl TokenField_DQs {
    fn execution(&self) -> i16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_DS(u16);
impl TokenField_DS {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_DSs(i16);
impl TokenField_DSs {
    fn execution(&self) -> i16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_DX(u8);
impl TokenField_DX {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_DUI(u8);
impl TokenField_DUI {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_DUIS(u16);
impl TokenField_DUIS {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_EX(u8);
impl TokenField_EX {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fA(u8);
impl TokenField_fA {
    fn execution(&self) -> Register {
        meaning_4_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_4_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fB(u8);
impl TokenField_fB {
    fn execution(&self) -> Register {
        meaning_4_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_4_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fC(u8);
impl TokenField_fC {
    fn execution(&self) -> Register {
        meaning_4_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_4_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fD(u8);
impl TokenField_fD {
    fn execution(&self) -> Register {
        meaning_4_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_4_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_FM0(u8);
impl TokenField_FM0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_FM1(u8);
impl TokenField_FM1 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_FM(u8);
impl TokenField_FM {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_FM2(u8);
impl TokenField_FM2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_FM3(u8);
impl TokenField_FM3 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_FM4(u8);
impl TokenField_FM4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_FM5(u8);
impl TokenField_FM5 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_FM6(u8);
impl TokenField_FM6 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_FM7(u8);
impl TokenField_FM7 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_FNC(u8);
impl TokenField_FNC {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fS(u8);
impl TokenField_fS {
    fn execution(&self) -> Register {
        meaning_4_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_4_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_fT(u8);
impl TokenField_fT {
    fn execution(&self) -> Register {
        meaning_4_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_4_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_IMM(u8);
impl TokenField_IMM {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_EVUIMM(u8);
impl TokenField_EVUIMM {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BU_UIMM(u8);
impl TokenField_BU_UIMM {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BU_SIMM(u8);
impl TokenField_BU_SIMM {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_EVUIMM_8(u8);
impl TokenField_EVUIMM_8 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_EVUIMM_4(u8);
impl TokenField_EVUIMM_4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_EVUIMM_2(u8);
impl TokenField_EVUIMM_2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_L(u8);
impl TokenField_L {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_L2(u8);
impl TokenField_L2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_L16(u8);
impl TokenField_L16 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_LEV(u8);
impl TokenField_LEV {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_LI(i32);
impl TokenField_LI {
    fn execution(&self) -> i32 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_LK(u8);
impl TokenField_LK {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_MBH(u8);
impl TokenField_MBH {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_MBL(u8);
impl TokenField_MBL {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_ME(u8);
impl TokenField_ME {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_MO(u8);
impl TokenField_MO {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_MSR_L(u8);
impl TokenField_MSR_L {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_NB(u8);
impl TokenField_NB {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_O(u8);
impl TokenField_O {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OE(u8);
impl TokenField_OE {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP(u8);
impl TokenField_OP {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_PS(u8);
impl TokenField_PS {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Rc(u8);
impl TokenField_Rc {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Rc2(u8);
impl TokenField_Rc2 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_RMC(u8);
impl TokenField_RMC {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_RA(u8);
impl TokenField_RA {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_RB(u8);
impl TokenField_RB {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_RS(u8);
impl TokenField_RS {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_RT(u8);
impl TokenField_RT {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_R0(u8);
impl TokenField_R0 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_R16(u8);
impl TokenField_R16 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_S(u8);
impl TokenField_S {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_SBE(u8);
impl TokenField_SBE {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_SH16(u8);
impl TokenField_SH16 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_SHB(u8);
impl TokenField_SHB {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_SHH(u8);
impl TokenField_SHH {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_SHL(u8);
impl TokenField_SHL {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_SHW(u8);
impl TokenField_SHW {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_S8IMM(i8);
impl TokenField_S8IMM {
    fn execution(&self) -> i8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_S5IMM(i8);
impl TokenField_S5IMM {
    fn execution(&self) -> i8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_SIMM(i16);
impl TokenField_SIMM {
    fn execution(&self) -> i16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_SIMM_DS(i16);
impl TokenField_SIMM_DS {
    fn execution(&self) -> i16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_SIMM_SIGN(u8);
impl TokenField_SIMM_SIGN {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_SIX(u8);
impl TokenField_SIX {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_SP(u8);
impl TokenField_SP {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_SPRVAL(u16);
impl TokenField_SPRVAL {
    fn execution(&self) -> Register {
        meaning_5_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_5_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_SR(u8);
impl TokenField_SR {
    fn execution(&self) -> Register {
        meaning_6_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_6_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_ST(u8);
impl TokenField_ST {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_STRM(u8);
impl TokenField_STRM {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_SX(u8);
impl TokenField_SX {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_SX3(u8);
impl TokenField_SX3 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_T(u8);
impl TokenField_T {
    fn execution(&self) -> Register {
        meaning_7_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_7_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TOA(u8);
impl TokenField_TOA {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TBR(u16);
impl TokenField_TBR {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TH(u8);
impl TokenField_TH {
    fn execution(&self) -> Register {
        meaning_0_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_0_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TMP_6_10(u8);
impl TokenField_TMP_6_10 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TO(u8);
impl TokenField_TO {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TX(u8);
impl TokenField_TX {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_TX3(u8);
impl TokenField_TX3 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_UI(u8);
impl TokenField_UI {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_UI_11_s8(u8);
impl TokenField_UI_11_s8 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_UI_16_s8(u8);
impl TokenField_UI_16_s8 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_UI_16_s16(u16);
impl TokenField_UI_16_s16 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_UIMM8(u8);
impl TokenField_UIMM8 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_UIMM(u16);
impl TokenField_UIMM {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_UIM(u8);
impl TokenField_UIM {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_UIMB(u8);
impl TokenField_UIMB {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_UIMH(u8);
impl TokenField_UIMH {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_UIMW(u8);
impl TokenField_UIMW {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_UIMT(u8);
impl TokenField_UIMT {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrAR(u8);
impl TokenField_vrAR {
    fn execution(&self) -> Register {
        meaning_8_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_8_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrAD(u8);
impl TokenField_vrAD {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_9_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrA_64_0(u8);
impl TokenField_vrA_64_0 {
    fn execution(&self) -> Register {
        meaning_10_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_10_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrA_64_1(u8);
impl TokenField_vrA_64_1 {
    fn execution(&self) -> Register {
        meaning_11_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_11_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrA_32_0(u8);
impl TokenField_vrA_32_0 {
    fn execution(&self) -> Register {
        meaning_12_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_12_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrA_32_1(u8);
impl TokenField_vrA_32_1 {
    fn execution(&self) -> Register {
        meaning_13_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_13_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrA_32_2(u8);
impl TokenField_vrA_32_2 {
    fn execution(&self) -> Register {
        meaning_14_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_14_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrA_32_3(u8);
impl TokenField_vrA_32_3 {
    fn execution(&self) -> Register {
        meaning_15_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_15_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrA_16_0(u8);
impl TokenField_vrA_16_0 {
    fn execution(&self) -> Register {
        meaning_16_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_16_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrA_16_1(u8);
impl TokenField_vrA_16_1 {
    fn execution(&self) -> Register {
        meaning_17_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_17_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrA_16_2(u8);
impl TokenField_vrA_16_2 {
    fn execution(&self) -> Register {
        meaning_18_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_18_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrA_16_3(u8);
impl TokenField_vrA_16_3 {
    fn execution(&self) -> Register {
        meaning_19_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_19_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrA_16_4(u8);
impl TokenField_vrA_16_4 {
    fn execution(&self) -> Register {
        meaning_20_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_20_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrA_16_5(u8);
impl TokenField_vrA_16_5 {
    fn execution(&self) -> Register {
        meaning_21_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_21_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrA_16_6(u8);
impl TokenField_vrA_16_6 {
    fn execution(&self) -> Register {
        meaning_22_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_22_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrA_16_7(u8);
impl TokenField_vrA_16_7 {
    fn execution(&self) -> Register {
        meaning_23_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_23_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrA_8_0(u8);
impl TokenField_vrA_8_0 {
    fn execution(&self) -> Register {
        meaning_24_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_24_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrA_8_1(u8);
impl TokenField_vrA_8_1 {
    fn execution(&self) -> Register {
        meaning_25_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_25_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrA_8_2(u8);
impl TokenField_vrA_8_2 {
    fn execution(&self) -> Register {
        meaning_26_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_26_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrA_8_3(u8);
impl TokenField_vrA_8_3 {
    fn execution(&self) -> Register {
        meaning_27_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_27_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrA_8_4(u8);
impl TokenField_vrA_8_4 {
    fn execution(&self) -> Register {
        meaning_28_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_28_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrA_8_5(u8);
impl TokenField_vrA_8_5 {
    fn execution(&self) -> Register {
        meaning_29_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_29_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrA_8_6(u8);
impl TokenField_vrA_8_6 {
    fn execution(&self) -> Register {
        meaning_30_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_30_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrA_8_7(u8);
impl TokenField_vrA_8_7 {
    fn execution(&self) -> Register {
        meaning_31_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_31_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrA_8_8(u8);
impl TokenField_vrA_8_8 {
    fn execution(&self) -> Register {
        meaning_32_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_32_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrA_8_9(u8);
impl TokenField_vrA_8_9 {
    fn execution(&self) -> Register {
        meaning_33_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_33_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrA_8_10(u8);
impl TokenField_vrA_8_10 {
    fn execution(&self) -> Register {
        meaning_34_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_34_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrA_8_11(u8);
impl TokenField_vrA_8_11 {
    fn execution(&self) -> Register {
        meaning_35_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_35_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrA_8_12(u8);
impl TokenField_vrA_8_12 {
    fn execution(&self) -> Register {
        meaning_36_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_36_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrA_8_13(u8);
impl TokenField_vrA_8_13 {
    fn execution(&self) -> Register {
        meaning_37_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_37_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrA_8_14(u8);
impl TokenField_vrA_8_14 {
    fn execution(&self) -> Register {
        meaning_38_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_38_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrA_8_15(u8);
impl TokenField_vrA_8_15 {
    fn execution(&self) -> Register {
        meaning_39_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_39_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrBR(u8);
impl TokenField_vrBR {
    fn execution(&self) -> Register {
        meaning_8_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_8_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrBD(u8);
impl TokenField_vrBD {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_9_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrB_64_0(u8);
impl TokenField_vrB_64_0 {
    fn execution(&self) -> Register {
        meaning_40_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_40_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrB_64_1(u8);
impl TokenField_vrB_64_1 {
    fn execution(&self) -> Register {
        meaning_41_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_41_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrB_32_0(u8);
impl TokenField_vrB_32_0 {
    fn execution(&self) -> Register {
        meaning_42_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_42_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrB_32_1(u8);
impl TokenField_vrB_32_1 {
    fn execution(&self) -> Register {
        meaning_43_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_43_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrB_32_2(u8);
impl TokenField_vrB_32_2 {
    fn execution(&self) -> Register {
        meaning_44_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_44_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrB_32_3(u8);
impl TokenField_vrB_32_3 {
    fn execution(&self) -> Register {
        meaning_45_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_45_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrB_16_0(u8);
impl TokenField_vrB_16_0 {
    fn execution(&self) -> Register {
        meaning_46_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_46_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrB_16_1(u8);
impl TokenField_vrB_16_1 {
    fn execution(&self) -> Register {
        meaning_47_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_47_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrB_16_2(u8);
impl TokenField_vrB_16_2 {
    fn execution(&self) -> Register {
        meaning_48_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_48_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrB_16_3(u8);
impl TokenField_vrB_16_3 {
    fn execution(&self) -> Register {
        meaning_49_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_49_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrB_16_4(u8);
impl TokenField_vrB_16_4 {
    fn execution(&self) -> Register {
        meaning_50_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_50_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrB_16_5(u8);
impl TokenField_vrB_16_5 {
    fn execution(&self) -> Register {
        meaning_51_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_51_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrB_16_6(u8);
impl TokenField_vrB_16_6 {
    fn execution(&self) -> Register {
        meaning_52_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_52_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrB_16_7(u8);
impl TokenField_vrB_16_7 {
    fn execution(&self) -> Register {
        meaning_53_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_53_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrB_8_0(u8);
impl TokenField_vrB_8_0 {
    fn execution(&self) -> Register {
        meaning_54_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_54_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrB_8_1(u8);
impl TokenField_vrB_8_1 {
    fn execution(&self) -> Register {
        meaning_55_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_55_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrB_8_2(u8);
impl TokenField_vrB_8_2 {
    fn execution(&self) -> Register {
        meaning_56_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_56_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrB_8_3(u8);
impl TokenField_vrB_8_3 {
    fn execution(&self) -> Register {
        meaning_57_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_57_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrB_8_4(u8);
impl TokenField_vrB_8_4 {
    fn execution(&self) -> Register {
        meaning_58_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_58_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrB_8_5(u8);
impl TokenField_vrB_8_5 {
    fn execution(&self) -> Register {
        meaning_59_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_59_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrB_8_6(u8);
impl TokenField_vrB_8_6 {
    fn execution(&self) -> Register {
        meaning_60_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_60_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrB_8_7(u8);
impl TokenField_vrB_8_7 {
    fn execution(&self) -> Register {
        meaning_61_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_61_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrB_8_8(u8);
impl TokenField_vrB_8_8 {
    fn execution(&self) -> Register {
        meaning_62_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_62_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrB_8_9(u8);
impl TokenField_vrB_8_9 {
    fn execution(&self) -> Register {
        meaning_63_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_63_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrB_8_10(u8);
impl TokenField_vrB_8_10 {
    fn execution(&self) -> Register {
        meaning_64_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_64_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrB_8_11(u8);
impl TokenField_vrB_8_11 {
    fn execution(&self) -> Register {
        meaning_65_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_65_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrB_8_12(u8);
impl TokenField_vrB_8_12 {
    fn execution(&self) -> Register {
        meaning_66_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_66_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrB_8_13(u8);
impl TokenField_vrB_8_13 {
    fn execution(&self) -> Register {
        meaning_67_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_67_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrB_8_14(u8);
impl TokenField_vrB_8_14 {
    fn execution(&self) -> Register {
        meaning_68_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_68_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrB_8_15(u8);
impl TokenField_vrB_8_15 {
    fn execution(&self) -> Register {
        meaning_69_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_69_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrCR(u8);
impl TokenField_vrCR {
    fn execution(&self) -> Register {
        meaning_8_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_8_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrCD(u8);
impl TokenField_vrCD {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_9_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrC_64_0(u8);
impl TokenField_vrC_64_0 {
    fn execution(&self) -> Register {
        meaning_70_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_70_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrC_64_1(u8);
impl TokenField_vrC_64_1 {
    fn execution(&self) -> Register {
        meaning_71_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_71_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrC_32_0(u8);
impl TokenField_vrC_32_0 {
    fn execution(&self) -> Register {
        meaning_72_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_72_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrC_32_1(u8);
impl TokenField_vrC_32_1 {
    fn execution(&self) -> Register {
        meaning_73_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_73_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrC_32_2(u8);
impl TokenField_vrC_32_2 {
    fn execution(&self) -> Register {
        meaning_74_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_74_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrC_32_3(u8);
impl TokenField_vrC_32_3 {
    fn execution(&self) -> Register {
        meaning_75_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_75_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrC_16_0(u8);
impl TokenField_vrC_16_0 {
    fn execution(&self) -> Register {
        meaning_76_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_76_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrC_16_1(u8);
impl TokenField_vrC_16_1 {
    fn execution(&self) -> Register {
        meaning_77_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_77_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrC_16_2(u8);
impl TokenField_vrC_16_2 {
    fn execution(&self) -> Register {
        meaning_78_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_78_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrC_16_3(u8);
impl TokenField_vrC_16_3 {
    fn execution(&self) -> Register {
        meaning_79_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_79_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrC_16_4(u8);
impl TokenField_vrC_16_4 {
    fn execution(&self) -> Register {
        meaning_80_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_80_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrC_16_5(u8);
impl TokenField_vrC_16_5 {
    fn execution(&self) -> Register {
        meaning_81_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_81_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrC_16_6(u8);
impl TokenField_vrC_16_6 {
    fn execution(&self) -> Register {
        meaning_82_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_82_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrC_16_7(u8);
impl TokenField_vrC_16_7 {
    fn execution(&self) -> Register {
        meaning_83_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_83_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrC_8_0(u8);
impl TokenField_vrC_8_0 {
    fn execution(&self) -> Register {
        meaning_84_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_84_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrC_8_1(u8);
impl TokenField_vrC_8_1 {
    fn execution(&self) -> Register {
        meaning_85_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_85_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrC_8_2(u8);
impl TokenField_vrC_8_2 {
    fn execution(&self) -> Register {
        meaning_86_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_86_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrC_8_3(u8);
impl TokenField_vrC_8_3 {
    fn execution(&self) -> Register {
        meaning_87_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_87_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrC_8_4(u8);
impl TokenField_vrC_8_4 {
    fn execution(&self) -> Register {
        meaning_88_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_88_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrC_8_5(u8);
impl TokenField_vrC_8_5 {
    fn execution(&self) -> Register {
        meaning_89_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_89_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrC_8_6(u8);
impl TokenField_vrC_8_6 {
    fn execution(&self) -> Register {
        meaning_90_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_90_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrC_8_7(u8);
impl TokenField_vrC_8_7 {
    fn execution(&self) -> Register {
        meaning_91_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_91_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrC_8_8(u8);
impl TokenField_vrC_8_8 {
    fn execution(&self) -> Register {
        meaning_92_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_92_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrC_8_9(u8);
impl TokenField_vrC_8_9 {
    fn execution(&self) -> Register {
        meaning_93_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_93_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrC_8_10(u8);
impl TokenField_vrC_8_10 {
    fn execution(&self) -> Register {
        meaning_94_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_94_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrC_8_11(u8);
impl TokenField_vrC_8_11 {
    fn execution(&self) -> Register {
        meaning_95_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_95_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrC_8_12(u8);
impl TokenField_vrC_8_12 {
    fn execution(&self) -> Register {
        meaning_96_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_96_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrC_8_13(u8);
impl TokenField_vrC_8_13 {
    fn execution(&self) -> Register {
        meaning_97_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_97_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrC_8_14(u8);
impl TokenField_vrC_8_14 {
    fn execution(&self) -> Register {
        meaning_98_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_98_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrC_8_15(u8);
impl TokenField_vrC_8_15 {
    fn execution(&self) -> Register {
        meaning_99_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_99_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrDR(u8);
impl TokenField_vrDR {
    fn execution(&self) -> Register {
        meaning_8_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_8_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrDD(u8);
impl TokenField_vrDD {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_9_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrD_64_0(u8);
impl TokenField_vrD_64_0 {
    fn execution(&self) -> Register {
        meaning_100_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_100_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrD_64_1(u8);
impl TokenField_vrD_64_1 {
    fn execution(&self) -> Register {
        meaning_101_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_101_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrD_32_0(u8);
impl TokenField_vrD_32_0 {
    fn execution(&self) -> Register {
        meaning_102_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_102_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrD_32_1(u8);
impl TokenField_vrD_32_1 {
    fn execution(&self) -> Register {
        meaning_103_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_103_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrD_32_2(u8);
impl TokenField_vrD_32_2 {
    fn execution(&self) -> Register {
        meaning_104_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_104_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrD_32_3(u8);
impl TokenField_vrD_32_3 {
    fn execution(&self) -> Register {
        meaning_105_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_105_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrD_16_0(u8);
impl TokenField_vrD_16_0 {
    fn execution(&self) -> Register {
        meaning_106_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_106_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrD_16_1(u8);
impl TokenField_vrD_16_1 {
    fn execution(&self) -> Register {
        meaning_107_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_107_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrD_16_2(u8);
impl TokenField_vrD_16_2 {
    fn execution(&self) -> Register {
        meaning_108_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_108_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrD_16_3(u8);
impl TokenField_vrD_16_3 {
    fn execution(&self) -> Register {
        meaning_109_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_109_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrD_16_4(u8);
impl TokenField_vrD_16_4 {
    fn execution(&self) -> Register {
        meaning_110_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_110_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrD_16_5(u8);
impl TokenField_vrD_16_5 {
    fn execution(&self) -> Register {
        meaning_111_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_111_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrD_16_6(u8);
impl TokenField_vrD_16_6 {
    fn execution(&self) -> Register {
        meaning_112_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_112_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrD_16_7(u8);
impl TokenField_vrD_16_7 {
    fn execution(&self) -> Register {
        meaning_113_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_113_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrD_8_0(u8);
impl TokenField_vrD_8_0 {
    fn execution(&self) -> Register {
        meaning_114_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_114_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrD_8_1(u8);
impl TokenField_vrD_8_1 {
    fn execution(&self) -> Register {
        meaning_115_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_115_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrD_8_2(u8);
impl TokenField_vrD_8_2 {
    fn execution(&self) -> Register {
        meaning_116_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_116_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrD_8_3(u8);
impl TokenField_vrD_8_3 {
    fn execution(&self) -> Register {
        meaning_117_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_117_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrD_8_4(u8);
impl TokenField_vrD_8_4 {
    fn execution(&self) -> Register {
        meaning_118_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_118_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrD_8_5(u8);
impl TokenField_vrD_8_5 {
    fn execution(&self) -> Register {
        meaning_119_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_119_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrD_8_6(u8);
impl TokenField_vrD_8_6 {
    fn execution(&self) -> Register {
        meaning_120_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_120_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrD_8_7(u8);
impl TokenField_vrD_8_7 {
    fn execution(&self) -> Register {
        meaning_121_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_121_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrD_8_8(u8);
impl TokenField_vrD_8_8 {
    fn execution(&self) -> Register {
        meaning_122_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_122_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrD_8_9(u8);
impl TokenField_vrD_8_9 {
    fn execution(&self) -> Register {
        meaning_123_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_123_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrD_8_10(u8);
impl TokenField_vrD_8_10 {
    fn execution(&self) -> Register {
        meaning_124_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_124_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrD_8_11(u8);
impl TokenField_vrD_8_11 {
    fn execution(&self) -> Register {
        meaning_125_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_125_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrD_8_12(u8);
impl TokenField_vrD_8_12 {
    fn execution(&self) -> Register {
        meaning_126_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_126_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrD_8_13(u8);
impl TokenField_vrD_8_13 {
    fn execution(&self) -> Register {
        meaning_127_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_127_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrD_8_14(u8);
impl TokenField_vrD_8_14 {
    fn execution(&self) -> Register {
        meaning_128_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_128_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrD_8_15(u8);
impl TokenField_vrD_8_15 {
    fn execution(&self) -> Register {
        meaning_129_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_129_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrSR(u8);
impl TokenField_vrSR {
    fn execution(&self) -> Register {
        meaning_8_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_8_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrSD(u8);
impl TokenField_vrSD {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_9_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrS_64_0(u8);
impl TokenField_vrS_64_0 {
    fn execution(&self) -> Register {
        meaning_130_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_130_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrS_64_1(u8);
impl TokenField_vrS_64_1 {
    fn execution(&self) -> Register {
        meaning_131_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_131_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrS_32_0(u8);
impl TokenField_vrS_32_0 {
    fn execution(&self) -> Register {
        meaning_132_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_132_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrS_32_1(u8);
impl TokenField_vrS_32_1 {
    fn execution(&self) -> Register {
        meaning_133_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_133_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrS_32_2(u8);
impl TokenField_vrS_32_2 {
    fn execution(&self) -> Register {
        meaning_134_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_134_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrS_32_3(u8);
impl TokenField_vrS_32_3 {
    fn execution(&self) -> Register {
        meaning_135_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_135_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrS_16_0(u8);
impl TokenField_vrS_16_0 {
    fn execution(&self) -> Register {
        meaning_136_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_136_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrS_16_1(u8);
impl TokenField_vrS_16_1 {
    fn execution(&self) -> Register {
        meaning_137_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_137_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrS_16_2(u8);
impl TokenField_vrS_16_2 {
    fn execution(&self) -> Register {
        meaning_138_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_138_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrS_16_3(u8);
impl TokenField_vrS_16_3 {
    fn execution(&self) -> Register {
        meaning_139_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_139_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrS_16_4(u8);
impl TokenField_vrS_16_4 {
    fn execution(&self) -> Register {
        meaning_140_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_140_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrS_16_5(u8);
impl TokenField_vrS_16_5 {
    fn execution(&self) -> Register {
        meaning_141_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_141_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrS_16_6(u8);
impl TokenField_vrS_16_6 {
    fn execution(&self) -> Register {
        meaning_142_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_142_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrS_16_7(u8);
impl TokenField_vrS_16_7 {
    fn execution(&self) -> Register {
        meaning_143_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_143_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrS_8_0(u8);
impl TokenField_vrS_8_0 {
    fn execution(&self) -> Register {
        meaning_144_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_144_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrS_8_1(u8);
impl TokenField_vrS_8_1 {
    fn execution(&self) -> Register {
        meaning_145_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_145_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrS_8_2(u8);
impl TokenField_vrS_8_2 {
    fn execution(&self) -> Register {
        meaning_146_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_146_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrS_8_3(u8);
impl TokenField_vrS_8_3 {
    fn execution(&self) -> Register {
        meaning_147_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_147_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrS_8_4(u8);
impl TokenField_vrS_8_4 {
    fn execution(&self) -> Register {
        meaning_148_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_148_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrS_8_5(u8);
impl TokenField_vrS_8_5 {
    fn execution(&self) -> Register {
        meaning_149_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_149_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrS_8_6(u8);
impl TokenField_vrS_8_6 {
    fn execution(&self) -> Register {
        meaning_150_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_150_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrS_8_7(u8);
impl TokenField_vrS_8_7 {
    fn execution(&self) -> Register {
        meaning_151_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_151_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrS_8_8(u8);
impl TokenField_vrS_8_8 {
    fn execution(&self) -> Register {
        meaning_152_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_152_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrS_8_9(u8);
impl TokenField_vrS_8_9 {
    fn execution(&self) -> Register {
        meaning_153_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_153_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrS_8_10(u8);
impl TokenField_vrS_8_10 {
    fn execution(&self) -> Register {
        meaning_154_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_154_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrS_8_11(u8);
impl TokenField_vrS_8_11 {
    fn execution(&self) -> Register {
        meaning_155_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_155_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrS_8_12(u8);
impl TokenField_vrS_8_12 {
    fn execution(&self) -> Register {
        meaning_156_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_156_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrS_8_13(u8);
impl TokenField_vrS_8_13 {
    fn execution(&self) -> Register {
        meaning_157_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_157_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrS_8_14(u8);
impl TokenField_vrS_8_14 {
    fn execution(&self) -> Register {
        meaning_158_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_158_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_vrS_8_15(u8);
impl TokenField_vrS_8_15 {
    fn execution(&self) -> Register {
        meaning_159_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_159_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_WC(u8);
impl TokenField_WC {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_XOP_0_10(u16);
impl TokenField_XOP_0_10 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_XOP_0_5(u8);
impl TokenField_XOP_0_5 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_XOP_0_8(u16);
impl TokenField_XOP_0_8 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_XOP_0_9(u16);
impl TokenField_XOP_0_9 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_XOP_1_10(u16);
impl TokenField_XOP_1_10 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_XOP_1_4(u8);
impl TokenField_XOP_1_4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_XOP_1_5(u8);
impl TokenField_XOP_1_5 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_XOP_1_8(u8);
impl TokenField_XOP_1_8 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_XOP_1_9(u16);
impl TokenField_XOP_1_9 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_XOP_2_10(u16);
impl TokenField_XOP_2_10 {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_XOP_2_4(u8);
impl TokenField_XOP_2_4 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_XOP_3_5(u8);
impl TokenField_XOP_3_5 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_XOP_3_10(u8);
impl TokenField_XOP_3_10 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_XOP_3_9(u8);
impl TokenField_XOP_3_9 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_XOP_7_10(u8);
impl TokenField_XOP_7_10 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Avsa(u8);
impl TokenField_Avsa {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Avsb(u8);
impl TokenField_Avsb {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Bvsa(u8);
impl TokenField_Bvsa {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Bvsb(u8);
impl TokenField_Bvsb {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Cvsa(u8);
impl TokenField_Cvsa {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Cvsb(u8);
impl TokenField_Cvsb {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Svsa(u8);
impl TokenField_Svsa {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Svsb(u8);
impl TokenField_Svsb {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Svsbx(u8);
impl TokenField_Svsbx {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Tvsa(u8);
impl TokenField_Tvsa {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Tvsb(u8);
impl TokenField_Tvsb {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_Tvsbx(u8);
impl TokenField_Tvsbx {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BD15_VLE(i16);
impl TokenField_BD15_VLE {
    fn execution(&self) -> i16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BD24_VLE(i32);
impl TokenField_BD24_VLE {
    fn execution(&self) -> i32 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BF_VLE(u8);
impl TokenField_BF_VLE {
    fn execution(&self) -> Register {
        meaning_160_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_160_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BI_CC_VLE(u8);
impl TokenField_BI_CC_VLE {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BI_CR_VLE(u8);
impl TokenField_BI_CR_VLE {
    fn execution(&self) -> Register {
        meaning_160_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_160_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BO_VLE(u8);
impl TokenField_BO_VLE {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_IMM8(u8);
impl TokenField_IMM8 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_IMM_0_10_VLE(u16);
impl TokenField_IMM_0_10_VLE {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_IMM_11_15_VLE(u8);
impl TokenField_IMM_11_15_VLE {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_IMM_16_20_VLE(u8);
impl TokenField_IMM_16_20_VLE {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_IMM_21_25_VLE(u8);
impl TokenField_IMM_21_25_VLE {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_SIMM_11_14_VLE(i8);
impl TokenField_SIMM_11_14_VLE {
    fn execution(&self) -> i8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_SIMM_21_25_VLE(i8);
impl TokenField_SIMM_21_25_VLE {
    fn execution(&self) -> i8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_SCL_VLE(u8);
impl TokenField_SCL_VLE {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_LEV_VLE(u8);
impl TokenField_LEV_VLE {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_XOP_8_VLE(u8);
impl TokenField_XOP_8_VLE {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_XOP_11_VLE(u8);
impl TokenField_XOP_11_VLE {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_XOP_12_VLE(u8);
impl TokenField_XOP_12_VLE {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_XOP_VLE(u8);
impl TokenField_XOP_VLE {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP4_VLE(u8);
impl TokenField_OP4_VLE {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP5_VLE(u8);
impl TokenField_OP5_VLE {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP6_VLE(u8);
impl TokenField_OP6_VLE {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP15_VLE(u16);
impl TokenField_OP15_VLE {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OP16_VLE(u16);
impl TokenField_OP16_VLE {
    fn execution(&self) -> u16 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OIM5_VLE(u8);
impl TokenField_OIM5_VLE {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_OIM7_VLE(u8);
impl TokenField_OIM7_VLE {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_SD4_VLE(u8);
impl TokenField_SD4_VLE {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_UI7_VLE(u8);
impl TokenField_UI7_VLE {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_UI5_VLE(u8);
impl TokenField_UI5_VLE {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_XORR_VLE(u8);
impl TokenField_XORR_VLE {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_XOR_VLE(u8);
impl TokenField_XOR_VLE {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_ARX_VLE(u8);
impl TokenField_ARX_VLE {
    fn execution(&self) -> Register {
        meaning_161_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_161_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_ARY_VLE(u8);
impl TokenField_ARY_VLE {
    fn execution(&self) -> Register {
        meaning_161_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_161_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_RY_VLE(u8);
impl TokenField_RY_VLE {
    fn execution(&self) -> Register {
        meaning_162_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_162_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_RZ_VLE(u8);
impl TokenField_RZ_VLE {
    fn execution(&self) -> Register {
        meaning_162_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_162_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_RX_VLE(u8);
impl TokenField_RX_VLE {
    fn execution(&self) -> Register {
        meaning_162_value(self.0)
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_162_display(self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BO16_VLE(u8);
impl TokenField_BO16_VLE {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BIT9_VLE(u8);
impl TokenField_BIT9_VLE {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BIT8_VLE(u8);
impl TokenField_BIT8_VLE {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BI16_VLE(u8);
impl TokenField_BI16_VLE {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BITS_8_9(u8);
impl TokenField_BITS_8_9 {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_BD8_VLE(i8);
impl TokenField_BD8_VLE {
    fn execution(&self) -> i8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_LK8_VLE(u8);
impl TokenField_LK8_VLE {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
#[derive(Clone, Copy, Debug)]
struct TokenField_LK0_VLE(u8);
impl TokenField_LK0_VLE {
    fn execution(&self) -> u8 {
        self.0
    }
    fn disassembly(&self) -> i64 {
        i64::try_from(self.0).unwrap()
    }
    fn display(&self) -> DisplayElement {
        meaning_number(true, self.0)
    }
}
struct TokenParser<const LEN: usize>([u8; LEN]);
impl<const LEN: usize> TokenParser<LEN> {
    fn new(data: &[u8]) -> Option<Self> {
        let token_slice: &[u8] = data.get(..LEN)?;
        let token_data = <[u8; LEN]>::try_from(token_slice).unwrap();
        Some(Self(token_data))
    }
    fn TokenFieldA(&self) -> TokenField_A {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_A(inner_value)
    }
    fn TokenFieldAA(&self) -> TokenField_AA {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 1u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_AA(inner_value)
    }
    fn TokenFieldA_BITS(&self) -> TokenField_A_BITS {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_A_BITS(inner_value)
    }
    fn TokenFieldA_BITSS(&self) -> TokenField_A_BITSS {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            i8::try_from(value).unwrap()
        };
        TokenField_A_BITSS(inner_value)
    }
    fn TokenFieldAX(&self) -> TokenField_AX {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 2u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_AX(inner_value)
    }
    fn TokenFieldB(&self) -> TokenField_B {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_B(inner_value)
    }
    fn TokenFieldB_BITS(&self) -> TokenField_B_BITS {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_B_BITS(inner_value)
    }
    fn TokenFieldBD(&self) -> TokenField_BD {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i16::<true>(work_value, 2u64 as usize, 14u64 as usize);
            i16::try_from(value).unwrap()
        };
        TokenField_BD(inner_value)
    }
    fn TokenFieldBF(&self) -> TokenField_BF {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 1u64 as usize, 8u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BF(inner_value)
    }
    fn TokenFieldBFA(&self) -> TokenField_BFA {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BFA(inner_value)
    }
    fn TokenFieldBFA2(&self) -> TokenField_BFA2 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 2u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BFA2(inner_value)
    }
    fn TokenFieldBF2(&self) -> TokenField_BF2 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 7u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BF2(inner_value)
    }
    fn TokenFieldBH(&self) -> TokenField_BH {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BH(inner_value)
    }
    fn TokenFieldBH_BITS(&self) -> TokenField_BH_BITS {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BH_BITS(inner_value)
    }
    fn TokenFieldBH_RBE(&self) -> TokenField_BH_RBE {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 3u64 as usize, 10u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_BH_RBE(inner_value)
    }
    fn TokenFieldBH_RET(&self) -> TokenField_BH_RET {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BH_RET(inner_value)
    }
    fn TokenFieldBI_BITS(&self) -> TokenField_BI_BITS {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BI_BITS(inner_value)
    }
    fn TokenFieldBI_CC(&self) -> TokenField_BI_CC {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BI_CC(inner_value)
    }
    fn TokenFieldBI_CR(&self) -> TokenField_BI_CR {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 2u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BI_CR(inner_value)
    }
    fn TokenFieldBIT_A(&self) -> TokenField_BIT_A {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 1u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BIT_A(inner_value)
    }
    fn TokenFieldBIT_L(&self) -> TokenField_BIT_L {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BIT_L(inner_value)
    }
    fn TokenFieldBIT_R(&self) -> TokenField_BIT_R {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BIT_R(inner_value)
    }
    fn TokenFieldBIT_0(&self) -> TokenField_BIT_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BIT_0(inner_value)
    }
    fn TokenFieldBIT_10(&self) -> TokenField_BIT_10 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 2u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BIT_10(inner_value)
    }
    fn TokenFieldBIT_1(&self) -> TokenField_BIT_1 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 1u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BIT_1(inner_value)
    }
    fn TokenFieldBIT_11(&self) -> TokenField_BIT_11 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BIT_11(inner_value)
    }
    fn TokenFieldBIT_15(&self) -> TokenField_BIT_15 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 7u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BIT_15(inner_value)
    }
    fn TokenFieldBIT_16(&self) -> TokenField_BIT_16 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BIT_16(inner_value)
    }
    fn TokenFieldBIT_17(&self) -> TokenField_BIT_17 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 1u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BIT_17(inner_value)
    }
    fn TokenFieldBIT_18(&self) -> TokenField_BIT_18 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 2u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BIT_18(inner_value)
    }
    fn TokenFieldBIT_20(&self) -> TokenField_BIT_20 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BIT_20(inner_value)
    }
    fn TokenFieldBIT_22(&self) -> TokenField_BIT_22 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 6u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BIT_22(inner_value)
    }
    fn TokenFieldBIT_25(&self) -> TokenField_BIT_25 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 1u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BIT_25(inner_value)
    }
    fn TokenFieldBIT_9(&self) -> TokenField_BIT_9 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 1u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BIT_9(inner_value)
    }
    fn TokenFieldBIT_6(&self) -> TokenField_BIT_6 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 6u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BIT_6(inner_value)
    }
    fn TokenFieldBITS_0_1(&self) -> TokenField_BITS_0_1 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_0_1(inner_value)
    }
    fn TokenFieldBITS_0_17(&self) -> TokenField_BITS_0_17 {
        let inner_value = {
            let mut work_value = [0u8; 4u64 as usize];
            let work_start = 1u64 as usize;
            let work_end = 4u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u32::<true>(work_value, 0u64 as usize, 18u64 as usize);
            u32::try_from(value).unwrap()
        };
        TokenField_BITS_0_17(inner_value)
    }
    fn TokenFieldBITS_0_2(&self) -> TokenField_BITS_0_2 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_0_2(inner_value)
    }
    fn TokenFieldBITS_0_3(&self) -> TokenField_BITS_0_3 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_0_3(inner_value)
    }
    fn TokenFieldBITS_1_10(&self) -> TokenField_BITS_1_10 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 1u64 as usize, 10u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_BITS_1_10(inner_value)
    }
    fn TokenFieldBITS_11_13(&self) -> TokenField_BITS_11_13 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_11_13(inner_value)
    }
    fn TokenFieldBITS_11_15(&self) -> TokenField_BITS_11_15 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_11_15(inner_value)
    }
    fn TokenFieldBITS_11_17(&self) -> TokenField_BITS_11_17 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 3u64 as usize, 7u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_11_17(inner_value)
    }
    fn TokenFieldBITS_11_20(&self) -> TokenField_BITS_11_20 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 3u64 as usize, 10u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_BITS_11_20(inner_value)
    }
    fn TokenFieldBITS_11_22(&self) -> TokenField_BITS_11_22 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 3u64 as usize, 12u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_BITS_11_22(inner_value)
    }
    fn TokenFieldBITS_11_24(&self) -> TokenField_BITS_11_24 {
        let inner_value = {
            let mut work_value = [0u8; 4u64 as usize];
            let work_start = 1u64 as usize;
            let work_end = 4u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u32::<true>(work_value, 3u64 as usize, 14u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_BITS_11_24(inner_value)
    }
    fn TokenFieldBITS_11_25(&self) -> TokenField_BITS_11_25 {
        let inner_value = {
            let mut work_value = [0u8; 4u64 as usize];
            let work_start = 1u64 as usize;
            let work_end = 4u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u32::<true>(work_value, 3u64 as usize, 15u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_BITS_11_25(inner_value)
    }
    fn TokenFieldBITS_12_15(&self) -> TokenField_BITS_12_15 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_12_15(inner_value)
    }
    fn TokenFieldBITS_12_19(&self) -> TokenField_BITS_12_19 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 4u64 as usize, 8u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_12_19(inner_value)
    }
    fn TokenFieldBITS_12_25(&self) -> TokenField_BITS_12_25 {
        let inner_value = {
            let mut work_value = [0u8; 4u64 as usize];
            let work_start = 1u64 as usize;
            let work_end = 4u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u32::<true>(work_value, 4u64 as usize, 14u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_BITS_12_25(inner_value)
    }
    fn TokenFieldBITS_13_15(&self) -> TokenField_BITS_13_15 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_13_15(inner_value)
    }
    fn TokenFieldBITS_14_15(&self) -> TokenField_BITS_14_15 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 6u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_14_15(inner_value)
    }
    fn TokenFieldBITS_16_17(&self) -> TokenField_BITS_16_17 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_16_17(inner_value)
    }
    fn TokenFieldBITS_16_18(&self) -> TokenField_BITS_16_18 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_16_18(inner_value)
    }
    fn TokenFieldBITS_16_19(&self) -> TokenField_BITS_16_19 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_16_19(inner_value)
    }
    fn TokenFieldBITS_16_20(&self) -> TokenField_BITS_16_20 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_16_20(inner_value)
    }
    fn TokenFieldBITS_16_22(&self) -> TokenField_BITS_16_22 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 7u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_16_22(inner_value)
    }
    fn TokenFieldBITS_16_25(&self) -> TokenField_BITS_16_25 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 0u64 as usize, 10u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_BITS_16_25(inner_value)
    }
    fn TokenFieldBITS_17_20(&self) -> TokenField_BITS_17_20 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 1u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_17_20(inner_value)
    }
    fn TokenFieldBITS_17_24(&self) -> TokenField_BITS_17_24 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 1u64 as usize, 8u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_17_24(inner_value)
    }
    fn TokenFieldBITS_18_19(&self) -> TokenField_BITS_18_19 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 2u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_18_19(inner_value)
    }
    fn TokenFieldBITS_18_20(&self) -> TokenField_BITS_18_20 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 2u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_18_20(inner_value)
    }
    fn TokenFieldBITS_1_9(&self) -> TokenField_BITS_1_9 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 1u64 as usize, 9u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_BITS_1_9(inner_value)
    }
    fn TokenFieldBITS_19_20(&self) -> TokenField_BITS_19_20 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_19_20(inner_value)
    }
    fn TokenFieldBITS_20_20(&self) -> TokenField_BITS_20_20 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_20_20(inner_value)
    }
    fn TokenFieldBITS_21_22(&self) -> TokenField_BITS_21_22 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_21_22(inner_value)
    }
    fn TokenFieldBITS_21_23(&self) -> TokenField_BITS_21_23 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_21_23(inner_value)
    }
    fn TokenFieldBITS_21_24(&self) -> TokenField_BITS_21_24 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 7u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_21_24(inner_value)
    }
    fn TokenFieldBITS_21_25(&self) -> TokenField_BITS_21_25 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_21_25(inner_value)
    }
    fn TokenFieldBITS_21_28(&self) -> TokenField_BITS_21_28 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 8u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_21_28(inner_value)
    }
    fn TokenFieldBITS_22_24(&self) -> TokenField_BITS_22_24 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_22_24(inner_value)
    }
    fn TokenFieldBITS_22_25(&self) -> TokenField_BITS_22_25 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_22_25(inner_value)
    }
    fn TokenFieldBITS_22_26(&self) -> TokenField_BITS_22_26 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_22_26(inner_value)
    }
    fn TokenFieldBITS_2_25(&self) -> TokenField_BITS_2_25 {
        let inner_value = {
            let mut work_value = [0u8; 4u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 4u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u32::<true>(work_value, 2u64 as usize, 24u64 as usize);
            u32::try_from(value).unwrap()
        };
        TokenField_BITS_2_25(inner_value)
    }
    fn TokenFieldBITS_23_24(&self) -> TokenField_BITS_23_24 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 7u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_23_24(inner_value)
    }
    fn TokenFieldBITS_23_25(&self) -> TokenField_BITS_23_25 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 7u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_23_25(inner_value)
    }
    fn TokenFieldBITS_2_4(&self) -> TokenField_BITS_2_4 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 2u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_2_4(inner_value)
    }
    fn TokenFieldBITS_24_25(&self) -> TokenField_BITS_24_25 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_24_25(inner_value)
    }
    fn TokenFieldBITS_3_7(&self) -> TokenField_BITS_3_7 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_3_7(inner_value)
    }
    fn TokenFieldBITS_4_5(&self) -> TokenField_BITS_4_5 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_4_5(inner_value)
    }
    fn TokenFieldBITS_6_10(&self) -> TokenField_BITS_6_10 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_6_10(inner_value)
    }
    fn TokenFieldBO_0(&self) -> TokenField_BO_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 1u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BO_0(inner_value)
    }
    fn TokenFieldBO_1(&self) -> TokenField_BO_1 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BO_1(inner_value)
    }
    fn TokenFieldBO(&self) -> TokenField_BO {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BO(inner_value)
    }
    fn TokenFieldBO_2(&self) -> TokenField_BO_2 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 7u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BO_2(inner_value)
    }
    fn TokenFieldBO_3(&self) -> TokenField_BO_3 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 6u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BO_3(inner_value)
    }
    fn TokenFieldBO_BITS(&self) -> TokenField_BO_BITS {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BO_BITS(inner_value)
    }
    fn TokenFieldBX(&self) -> TokenField_BX {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 1u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BX(inner_value)
    }
    fn TokenFieldC(&self) -> TokenField_C {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_C(inner_value)
    }
    fn TokenFieldCOND_BRANCH_CTRL(&self) -> TokenField_COND_BRANCH_CTRL {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_COND_BRANCH_CTRL(inner_value)
    }
    fn TokenFieldCR_A(&self) -> TokenField_CR_A {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 2u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_CR_A(inner_value)
    }
    fn TokenFieldCR_A_CC(&self) -> TokenField_CR_A_CC {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_CR_A_CC(inner_value)
    }
    fn TokenFieldCR_B(&self) -> TokenField_CR_B {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_CR_B(inner_value)
    }
    fn TokenFieldCR_B_CC(&self) -> TokenField_CR_B_CC {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_CR_B_CC(inner_value)
    }
    fn TokenFieldCRBD(&self) -> TokenField_CRBD {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_CRBD(inner_value)
    }
    fn TokenFieldCRBR(&self) -> TokenField_CRBR {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_CRBR(inner_value)
    }
    fn TokenFieldCR_D(&self) -> TokenField_CR_D {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 7u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_CR_D(inner_value)
    }
    fn TokenFieldCR_D_CC(&self) -> TokenField_CR_D_CC {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_CR_D_CC(inner_value)
    }
    fn TokenFieldcrfD(&self) -> TokenField_crfD {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 7u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_crfD(inner_value)
    }
    fn TokenFieldCRFD(&self) -> TokenField_CRFD {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 7u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_CRFD(inner_value)
    }
    fn TokenFieldCRFS(&self) -> TokenField_CRFS {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 2u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_CRFS(inner_value)
    }
    fn TokenFieldCRM0(&self) -> TokenField_CRM0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_CRM0(inner_value)
    }
    fn TokenFieldCRM1(&self) -> TokenField_CRM1 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 2u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_CRM1(inner_value)
    }
    fn TokenFieldCRM(&self) -> TokenField_CRM {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 4u64 as usize, 8u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_CRM(inner_value)
    }
    fn TokenFieldCRM2(&self) -> TokenField_CRM2 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 1u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_CRM2(inner_value)
    }
    fn TokenFieldCRM3(&self) -> TokenField_CRM3 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_CRM3(inner_value)
    }
    fn TokenFieldCRM4(&self) -> TokenField_CRM4 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 7u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_CRM4(inner_value)
    }
    fn TokenFieldCRM5(&self) -> TokenField_CRM5 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 6u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_CRM5(inner_value)
    }
    fn TokenFieldCRM6(&self) -> TokenField_CRM6 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_CRM6(inner_value)
    }
    fn TokenFieldCRM7(&self) -> TokenField_CRM7 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_CRM7(inner_value)
    }
    fn TokenFieldCR_X(&self) -> TokenField_CR_X {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_CR_X(inner_value)
    }
    fn TokenFieldCR_X_CC(&self) -> TokenField_CR_X_CC {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 6u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_CR_X_CC(inner_value)
    }
    fn TokenFieldCT(&self) -> TokenField_CT {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_CT(inner_value)
    }
    fn TokenFieldCT2(&self) -> TokenField_CT2 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_CT2(inner_value)
    }
    fn TokenFieldCX(&self) -> TokenField_CX {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_CX(inner_value)
    }
    fn TokenFieldD0(&self) -> TokenField_D0 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i16::<true>(work_value, 6u64 as usize, 10u64 as usize);
            i16::try_from(value).unwrap()
        };
        TokenField_D0(inner_value)
    }
    fn TokenFieldD1(&self) -> TokenField_D1 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_D1(inner_value)
    }
    fn TokenFieldD2(&self) -> TokenField_D2 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_D2(inner_value)
    }
    fn TokenFieldD(&self) -> TokenField_D {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_D(inner_value)
    }
    fn TokenFieldDp(&self) -> TokenField_Dp {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_Dp(inner_value)
    }
    fn TokenFieldDC6(&self) -> TokenField_DC6 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 6u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_DC6(inner_value)
    }
    fn TokenFieldDCM(&self) -> TokenField_DCM {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 2u64 as usize, 6u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_DCM(inner_value)
    }
    fn TokenFieldDCMX(&self) -> TokenField_DCMX {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 7u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_DCMX(inner_value)
    }
    fn TokenFieldDCRN(&self) -> TokenField_DCRN {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 3u64 as usize, 10u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_DCRN(inner_value)
    }
    fn TokenFieldDGM(&self) -> TokenField_DGM {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 2u64 as usize, 6u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_DGM(inner_value)
    }
    fn TokenFieldDM(&self) -> TokenField_DM {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_DM(inner_value)
    }
    fn TokenFieldDM2(&self) -> TokenField_DM2 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 2u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_DM2(inner_value)
    }
    fn TokenFieldDQ(&self) -> TokenField_DQ {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 4u64 as usize, 12u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_DQ(inner_value)
    }
    fn TokenFieldDQs(&self) -> TokenField_DQs {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i16::<true>(work_value, 4u64 as usize, 12u64 as usize);
            i16::try_from(value).unwrap()
        };
        TokenField_DQs(inner_value)
    }
    fn TokenFieldDS(&self) -> TokenField_DS {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 2u64 as usize, 14u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_DS(inner_value)
    }
    fn TokenFieldDSs(&self) -> TokenField_DSs {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i16::<true>(work_value, 2u64 as usize, 14u64 as usize);
            i16::try_from(value).unwrap()
        };
        TokenField_DSs(inner_value)
    }
    fn TokenFieldDX(&self) -> TokenField_DX {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_DX(inner_value)
    }
    fn TokenFieldDUI(&self) -> TokenField_DUI {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_DUI(inner_value)
    }
    fn TokenFieldDUIS(&self) -> TokenField_DUIS {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 3u64 as usize, 10u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_DUIS(inner_value)
    }
    fn TokenFieldEX(&self) -> TokenField_EX {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_EX(inner_value)
    }
    fn TokenFieldfA(&self) -> TokenField_fA {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fA(inner_value)
    }
    fn TokenFieldfB(&self) -> TokenField_fB {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fB(inner_value)
    }
    fn TokenFieldfC(&self) -> TokenField_fC {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fC(inner_value)
    }
    fn TokenFieldfD(&self) -> TokenField_fD {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fD(inner_value)
    }
    fn TokenFieldFM0(&self) -> TokenField_FM0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_FM0(inner_value)
    }
    fn TokenFieldFM1(&self) -> TokenField_FM1 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 7u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_FM1(inner_value)
    }
    fn TokenFieldFM(&self) -> TokenField_FM {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 1u64 as usize, 8u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_FM(inner_value)
    }
    fn TokenFieldFM2(&self) -> TokenField_FM2 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 6u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_FM2(inner_value)
    }
    fn TokenFieldFM3(&self) -> TokenField_FM3 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_FM3(inner_value)
    }
    fn TokenFieldFM4(&self) -> TokenField_FM4 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_FM4(inner_value)
    }
    fn TokenFieldFM5(&self) -> TokenField_FM5 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_FM5(inner_value)
    }
    fn TokenFieldFM6(&self) -> TokenField_FM6 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 2u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_FM6(inner_value)
    }
    fn TokenFieldFM7(&self) -> TokenField_FM7 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 1u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_FM7(inner_value)
    }
    fn TokenFieldFNC(&self) -> TokenField_FNC {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_FNC(inner_value)
    }
    fn TokenFieldfS(&self) -> TokenField_fS {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fS(inner_value)
    }
    fn TokenFieldfT(&self) -> TokenField_fT {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_fT(inner_value)
    }
    fn TokenFieldIMM(&self) -> TokenField_IMM {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_IMM(inner_value)
    }
    fn TokenFieldEVUIMM(&self) -> TokenField_EVUIMM {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_EVUIMM(inner_value)
    }
    fn TokenFieldBU_UIMM(&self) -> TokenField_BU_UIMM {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BU_UIMM(inner_value)
    }
    fn TokenFieldBU_SIMM(&self) -> TokenField_BU_SIMM {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BU_SIMM(inner_value)
    }
    fn TokenFieldEVUIMM_8(&self) -> TokenField_EVUIMM_8 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_EVUIMM_8(inner_value)
    }
    fn TokenFieldEVUIMM_4(&self) -> TokenField_EVUIMM_4 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_EVUIMM_4(inner_value)
    }
    fn TokenFieldEVUIMM_2(&self) -> TokenField_EVUIMM_2 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_EVUIMM_2(inner_value)
    }
    fn TokenFieldL(&self) -> TokenField_L {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_L(inner_value)
    }
    fn TokenFieldL2(&self) -> TokenField_L2 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_L2(inner_value)
    }
    fn TokenFieldL16(&self) -> TokenField_L16 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_L16(inner_value)
    }
    fn TokenFieldLEV(&self) -> TokenField_LEV {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 7u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_LEV(inner_value)
    }
    fn TokenFieldLI(&self) -> TokenField_LI {
        let inner_value = {
            let mut work_value = [0u8; 4u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 4u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i32::<true>(work_value, 2u64 as usize, 24u64 as usize);
            i32::try_from(value).unwrap()
        };
        TokenField_LI(inner_value)
    }
    fn TokenFieldLK(&self) -> TokenField_LK {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_LK(inner_value)
    }
    fn TokenFieldMBH(&self) -> TokenField_MBH {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_MBH(inner_value)
    }
    fn TokenFieldMBL(&self) -> TokenField_MBL {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_MBL(inner_value)
    }
    fn TokenFieldME(&self) -> TokenField_ME {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 1u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_ME(inner_value)
    }
    fn TokenFieldMO(&self) -> TokenField_MO {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_MO(inner_value)
    }
    fn TokenFieldMSR_L(&self) -> TokenField_MSR_L {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_MSR_L(inner_value)
    }
    fn TokenFieldNB(&self) -> TokenField_NB {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_NB(inner_value)
    }
    fn TokenFieldO(&self) -> TokenField_O {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 1u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_O(inner_value)
    }
    fn TokenFieldOE(&self) -> TokenField_OE {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 2u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OE(inner_value)
    }
    fn TokenFieldOP(&self) -> TokenField_OP {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 2u64 as usize, 6u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP(inner_value)
    }
    fn TokenFieldPS(&self) -> TokenField_PS {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 1u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_PS(inner_value)
    }
    fn TokenFieldRc(&self) -> TokenField_Rc {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_Rc(inner_value)
    }
    fn TokenFieldRc2(&self) -> TokenField_Rc2 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 2u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_Rc2(inner_value)
    }
    fn TokenFieldRMC(&self) -> TokenField_RMC {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 1u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_RMC(inner_value)
    }
    fn TokenFieldRA(&self) -> TokenField_RA {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_RA(inner_value)
    }
    fn TokenFieldRB(&self) -> TokenField_RB {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_RB(inner_value)
    }
    fn TokenFieldRS(&self) -> TokenField_RS {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_RS(inner_value)
    }
    fn TokenFieldRT(&self) -> TokenField_RT {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_RT(inner_value)
    }
    fn TokenFieldR0(&self) -> TokenField_R0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_R0(inner_value)
    }
    fn TokenFieldR16(&self) -> TokenField_R16 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_R16(inner_value)
    }
    fn TokenFieldS(&self) -> TokenField_S {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_S(inner_value)
    }
    fn TokenFieldSBE(&self) -> TokenField_SBE {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_SBE(inner_value)
    }
    fn TokenFieldSH16(&self) -> TokenField_SH16 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 2u64 as usize, 6u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_SH16(inner_value)
    }
    fn TokenFieldSHB(&self) -> TokenField_SHB {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_SHB(inner_value)
    }
    fn TokenFieldSHH(&self) -> TokenField_SHH {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 1u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_SHH(inner_value)
    }
    fn TokenFieldSHL(&self) -> TokenField_SHL {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_SHL(inner_value)
    }
    fn TokenFieldSHW(&self) -> TokenField_SHW {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_SHW(inner_value)
    }
    fn TokenFieldS8IMM(&self) -> TokenField_S8IMM {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i8::<true>(work_value, 0u64 as usize, 8u64 as usize);
            i8::try_from(value).unwrap()
        };
        TokenField_S8IMM(inner_value)
    }
    fn TokenFieldS5IMM(&self) -> TokenField_S5IMM {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            i8::try_from(value).unwrap()
        };
        TokenField_S5IMM(inner_value)
    }
    fn TokenFieldSIMM(&self) -> TokenField_SIMM {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i16::<true>(work_value, 0u64 as usize, 16u64 as usize);
            i16::try_from(value).unwrap()
        };
        TokenField_SIMM(inner_value)
    }
    fn TokenFieldSIMM_DS(&self) -> TokenField_SIMM_DS {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i16::<true>(work_value, 2u64 as usize, 14u64 as usize);
            i16::try_from(value).unwrap()
        };
        TokenField_SIMM_DS(inner_value)
    }
    fn TokenFieldSIMM_SIGN(&self) -> TokenField_SIMM_SIGN {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 7u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_SIMM_SIGN(inner_value)
    }
    fn TokenFieldSIX(&self) -> TokenField_SIX {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_SIX(inner_value)
    }
    fn TokenFieldSP(&self) -> TokenField_SP {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_SP(inner_value)
    }
    fn TokenFieldSPRVAL(&self) -> TokenField_SPRVAL {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 3u64 as usize, 10u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_SPRVAL(inner_value)
    }
    fn TokenFieldSR(&self) -> TokenField_SR {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_SR(inner_value)
    }
    fn TokenFieldST(&self) -> TokenField_ST {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 7u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_ST(inner_value)
    }
    fn TokenFieldSTRM(&self) -> TokenField_STRM {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_STRM(inner_value)
    }
    fn TokenFieldSX(&self) -> TokenField_SX {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_SX(inner_value)
    }
    fn TokenFieldSX3(&self) -> TokenField_SX3 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_SX3(inner_value)
    }
    fn TokenFieldT(&self) -> TokenField_T {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_T(inner_value)
    }
    fn TokenFieldTOA(&self) -> TokenField_TOA {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TOA(inner_value)
    }
    fn TokenFieldTBR(&self) -> TokenField_TBR {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 3u64 as usize, 10u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_TBR(inner_value)
    }
    fn TokenFieldTH(&self) -> TokenField_TH {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TH(inner_value)
    }
    fn TokenFieldTMP_6_10(&self) -> TokenField_TMP_6_10 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TMP_6_10(inner_value)
    }
    fn TokenFieldTO(&self) -> TokenField_TO {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TO(inner_value)
    }
    fn TokenFieldTX(&self) -> TokenField_TX {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TX(inner_value)
    }
    fn TokenFieldTX3(&self) -> TokenField_TX3 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_TX3(inner_value)
    }
    fn TokenFieldUI(&self) -> TokenField_UI {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_UI(inner_value)
    }
    fn TokenFieldUI_11_s8(&self) -> TokenField_UI_11_s8 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_UI_11_s8(inner_value)
    }
    fn TokenFieldUI_16_s8(&self) -> TokenField_UI_16_s8 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_UI_16_s8(inner_value)
    }
    fn TokenFieldUI_16_s16(&self) -> TokenField_UI_16_s16 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 0u64 as usize, 16u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_UI_16_s16(inner_value)
    }
    fn TokenFieldUIMM8(&self) -> TokenField_UIMM8 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 3u64 as usize, 8u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_UIMM8(inner_value)
    }
    fn TokenFieldUIMM(&self) -> TokenField_UIMM {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 0u64 as usize, 16u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_UIMM(inner_value)
    }
    fn TokenFieldUIM(&self) -> TokenField_UIM {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_UIM(inner_value)
    }
    fn TokenFieldUIMB(&self) -> TokenField_UIMB {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_UIMB(inner_value)
    }
    fn TokenFieldUIMH(&self) -> TokenField_UIMH {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_UIMH(inner_value)
    }
    fn TokenFieldUIMW(&self) -> TokenField_UIMW {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_UIMW(inner_value)
    }
    fn TokenFieldUIMT(&self) -> TokenField_UIMT {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 6u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_UIMT(inner_value)
    }
    fn TokenFieldvrAR(&self) -> TokenField_vrAR {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrAR(inner_value)
    }
    fn TokenFieldvrAD(&self) -> TokenField_vrAD {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrAD(inner_value)
    }
    fn TokenFieldvrA_64_0(&self) -> TokenField_vrA_64_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrA_64_0(inner_value)
    }
    fn TokenFieldvrA_64_1(&self) -> TokenField_vrA_64_1 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrA_64_1(inner_value)
    }
    fn TokenFieldvrA_32_0(&self) -> TokenField_vrA_32_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrA_32_0(inner_value)
    }
    fn TokenFieldvrA_32_1(&self) -> TokenField_vrA_32_1 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrA_32_1(inner_value)
    }
    fn TokenFieldvrA_32_2(&self) -> TokenField_vrA_32_2 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrA_32_2(inner_value)
    }
    fn TokenFieldvrA_32_3(&self) -> TokenField_vrA_32_3 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrA_32_3(inner_value)
    }
    fn TokenFieldvrA_16_0(&self) -> TokenField_vrA_16_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrA_16_0(inner_value)
    }
    fn TokenFieldvrA_16_1(&self) -> TokenField_vrA_16_1 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrA_16_1(inner_value)
    }
    fn TokenFieldvrA_16_2(&self) -> TokenField_vrA_16_2 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrA_16_2(inner_value)
    }
    fn TokenFieldvrA_16_3(&self) -> TokenField_vrA_16_3 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrA_16_3(inner_value)
    }
    fn TokenFieldvrA_16_4(&self) -> TokenField_vrA_16_4 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrA_16_4(inner_value)
    }
    fn TokenFieldvrA_16_5(&self) -> TokenField_vrA_16_5 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrA_16_5(inner_value)
    }
    fn TokenFieldvrA_16_6(&self) -> TokenField_vrA_16_6 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrA_16_6(inner_value)
    }
    fn TokenFieldvrA_16_7(&self) -> TokenField_vrA_16_7 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrA_16_7(inner_value)
    }
    fn TokenFieldvrA_8_0(&self) -> TokenField_vrA_8_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrA_8_0(inner_value)
    }
    fn TokenFieldvrA_8_1(&self) -> TokenField_vrA_8_1 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrA_8_1(inner_value)
    }
    fn TokenFieldvrA_8_2(&self) -> TokenField_vrA_8_2 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrA_8_2(inner_value)
    }
    fn TokenFieldvrA_8_3(&self) -> TokenField_vrA_8_3 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrA_8_3(inner_value)
    }
    fn TokenFieldvrA_8_4(&self) -> TokenField_vrA_8_4 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrA_8_4(inner_value)
    }
    fn TokenFieldvrA_8_5(&self) -> TokenField_vrA_8_5 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrA_8_5(inner_value)
    }
    fn TokenFieldvrA_8_6(&self) -> TokenField_vrA_8_6 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrA_8_6(inner_value)
    }
    fn TokenFieldvrA_8_7(&self) -> TokenField_vrA_8_7 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrA_8_7(inner_value)
    }
    fn TokenFieldvrA_8_8(&self) -> TokenField_vrA_8_8 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrA_8_8(inner_value)
    }
    fn TokenFieldvrA_8_9(&self) -> TokenField_vrA_8_9 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrA_8_9(inner_value)
    }
    fn TokenFieldvrA_8_10(&self) -> TokenField_vrA_8_10 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrA_8_10(inner_value)
    }
    fn TokenFieldvrA_8_11(&self) -> TokenField_vrA_8_11 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrA_8_11(inner_value)
    }
    fn TokenFieldvrA_8_12(&self) -> TokenField_vrA_8_12 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrA_8_12(inner_value)
    }
    fn TokenFieldvrA_8_13(&self) -> TokenField_vrA_8_13 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrA_8_13(inner_value)
    }
    fn TokenFieldvrA_8_14(&self) -> TokenField_vrA_8_14 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrA_8_14(inner_value)
    }
    fn TokenFieldvrA_8_15(&self) -> TokenField_vrA_8_15 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrA_8_15(inner_value)
    }
    fn TokenFieldvrBR(&self) -> TokenField_vrBR {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrBR(inner_value)
    }
    fn TokenFieldvrBD(&self) -> TokenField_vrBD {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrBD(inner_value)
    }
    fn TokenFieldvrB_64_0(&self) -> TokenField_vrB_64_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrB_64_0(inner_value)
    }
    fn TokenFieldvrB_64_1(&self) -> TokenField_vrB_64_1 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrB_64_1(inner_value)
    }
    fn TokenFieldvrB_32_0(&self) -> TokenField_vrB_32_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrB_32_0(inner_value)
    }
    fn TokenFieldvrB_32_1(&self) -> TokenField_vrB_32_1 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrB_32_1(inner_value)
    }
    fn TokenFieldvrB_32_2(&self) -> TokenField_vrB_32_2 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrB_32_2(inner_value)
    }
    fn TokenFieldvrB_32_3(&self) -> TokenField_vrB_32_3 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrB_32_3(inner_value)
    }
    fn TokenFieldvrB_16_0(&self) -> TokenField_vrB_16_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrB_16_0(inner_value)
    }
    fn TokenFieldvrB_16_1(&self) -> TokenField_vrB_16_1 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrB_16_1(inner_value)
    }
    fn TokenFieldvrB_16_2(&self) -> TokenField_vrB_16_2 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrB_16_2(inner_value)
    }
    fn TokenFieldvrB_16_3(&self) -> TokenField_vrB_16_3 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrB_16_3(inner_value)
    }
    fn TokenFieldvrB_16_4(&self) -> TokenField_vrB_16_4 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrB_16_4(inner_value)
    }
    fn TokenFieldvrB_16_5(&self) -> TokenField_vrB_16_5 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrB_16_5(inner_value)
    }
    fn TokenFieldvrB_16_6(&self) -> TokenField_vrB_16_6 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrB_16_6(inner_value)
    }
    fn TokenFieldvrB_16_7(&self) -> TokenField_vrB_16_7 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrB_16_7(inner_value)
    }
    fn TokenFieldvrB_8_0(&self) -> TokenField_vrB_8_0 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrB_8_0(inner_value)
    }
    fn TokenFieldvrB_8_1(&self) -> TokenField_vrB_8_1 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrB_8_1(inner_value)
    }
    fn TokenFieldvrB_8_2(&self) -> TokenField_vrB_8_2 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrB_8_2(inner_value)
    }
    fn TokenFieldvrB_8_3(&self) -> TokenField_vrB_8_3 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrB_8_3(inner_value)
    }
    fn TokenFieldvrB_8_4(&self) -> TokenField_vrB_8_4 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrB_8_4(inner_value)
    }
    fn TokenFieldvrB_8_5(&self) -> TokenField_vrB_8_5 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrB_8_5(inner_value)
    }
    fn TokenFieldvrB_8_6(&self) -> TokenField_vrB_8_6 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrB_8_6(inner_value)
    }
    fn TokenFieldvrB_8_7(&self) -> TokenField_vrB_8_7 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrB_8_7(inner_value)
    }
    fn TokenFieldvrB_8_8(&self) -> TokenField_vrB_8_8 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrB_8_8(inner_value)
    }
    fn TokenFieldvrB_8_9(&self) -> TokenField_vrB_8_9 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrB_8_9(inner_value)
    }
    fn TokenFieldvrB_8_10(&self) -> TokenField_vrB_8_10 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrB_8_10(inner_value)
    }
    fn TokenFieldvrB_8_11(&self) -> TokenField_vrB_8_11 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrB_8_11(inner_value)
    }
    fn TokenFieldvrB_8_12(&self) -> TokenField_vrB_8_12 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrB_8_12(inner_value)
    }
    fn TokenFieldvrB_8_13(&self) -> TokenField_vrB_8_13 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrB_8_13(inner_value)
    }
    fn TokenFieldvrB_8_14(&self) -> TokenField_vrB_8_14 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrB_8_14(inner_value)
    }
    fn TokenFieldvrB_8_15(&self) -> TokenField_vrB_8_15 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrB_8_15(inner_value)
    }
    fn TokenFieldvrCR(&self) -> TokenField_vrCR {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrCR(inner_value)
    }
    fn TokenFieldvrCD(&self) -> TokenField_vrCD {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrCD(inner_value)
    }
    fn TokenFieldvrC_64_0(&self) -> TokenField_vrC_64_0 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrC_64_0(inner_value)
    }
    fn TokenFieldvrC_64_1(&self) -> TokenField_vrC_64_1 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrC_64_1(inner_value)
    }
    fn TokenFieldvrC_32_0(&self) -> TokenField_vrC_32_0 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrC_32_0(inner_value)
    }
    fn TokenFieldvrC_32_1(&self) -> TokenField_vrC_32_1 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrC_32_1(inner_value)
    }
    fn TokenFieldvrC_32_2(&self) -> TokenField_vrC_32_2 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrC_32_2(inner_value)
    }
    fn TokenFieldvrC_32_3(&self) -> TokenField_vrC_32_3 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrC_32_3(inner_value)
    }
    fn TokenFieldvrC_16_0(&self) -> TokenField_vrC_16_0 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrC_16_0(inner_value)
    }
    fn TokenFieldvrC_16_1(&self) -> TokenField_vrC_16_1 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrC_16_1(inner_value)
    }
    fn TokenFieldvrC_16_2(&self) -> TokenField_vrC_16_2 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrC_16_2(inner_value)
    }
    fn TokenFieldvrC_16_3(&self) -> TokenField_vrC_16_3 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrC_16_3(inner_value)
    }
    fn TokenFieldvrC_16_4(&self) -> TokenField_vrC_16_4 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrC_16_4(inner_value)
    }
    fn TokenFieldvrC_16_5(&self) -> TokenField_vrC_16_5 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrC_16_5(inner_value)
    }
    fn TokenFieldvrC_16_6(&self) -> TokenField_vrC_16_6 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrC_16_6(inner_value)
    }
    fn TokenFieldvrC_16_7(&self) -> TokenField_vrC_16_7 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrC_16_7(inner_value)
    }
    fn TokenFieldvrC_8_0(&self) -> TokenField_vrC_8_0 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrC_8_0(inner_value)
    }
    fn TokenFieldvrC_8_1(&self) -> TokenField_vrC_8_1 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrC_8_1(inner_value)
    }
    fn TokenFieldvrC_8_2(&self) -> TokenField_vrC_8_2 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrC_8_2(inner_value)
    }
    fn TokenFieldvrC_8_3(&self) -> TokenField_vrC_8_3 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrC_8_3(inner_value)
    }
    fn TokenFieldvrC_8_4(&self) -> TokenField_vrC_8_4 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrC_8_4(inner_value)
    }
    fn TokenFieldvrC_8_5(&self) -> TokenField_vrC_8_5 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrC_8_5(inner_value)
    }
    fn TokenFieldvrC_8_6(&self) -> TokenField_vrC_8_6 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrC_8_6(inner_value)
    }
    fn TokenFieldvrC_8_7(&self) -> TokenField_vrC_8_7 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrC_8_7(inner_value)
    }
    fn TokenFieldvrC_8_8(&self) -> TokenField_vrC_8_8 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrC_8_8(inner_value)
    }
    fn TokenFieldvrC_8_9(&self) -> TokenField_vrC_8_9 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrC_8_9(inner_value)
    }
    fn TokenFieldvrC_8_10(&self) -> TokenField_vrC_8_10 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrC_8_10(inner_value)
    }
    fn TokenFieldvrC_8_11(&self) -> TokenField_vrC_8_11 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrC_8_11(inner_value)
    }
    fn TokenFieldvrC_8_12(&self) -> TokenField_vrC_8_12 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrC_8_12(inner_value)
    }
    fn TokenFieldvrC_8_13(&self) -> TokenField_vrC_8_13 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrC_8_13(inner_value)
    }
    fn TokenFieldvrC_8_14(&self) -> TokenField_vrC_8_14 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrC_8_14(inner_value)
    }
    fn TokenFieldvrC_8_15(&self) -> TokenField_vrC_8_15 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrC_8_15(inner_value)
    }
    fn TokenFieldvrDR(&self) -> TokenField_vrDR {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrDR(inner_value)
    }
    fn TokenFieldvrDD(&self) -> TokenField_vrDD {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrDD(inner_value)
    }
    fn TokenFieldvrD_64_0(&self) -> TokenField_vrD_64_0 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrD_64_0(inner_value)
    }
    fn TokenFieldvrD_64_1(&self) -> TokenField_vrD_64_1 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrD_64_1(inner_value)
    }
    fn TokenFieldvrD_32_0(&self) -> TokenField_vrD_32_0 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrD_32_0(inner_value)
    }
    fn TokenFieldvrD_32_1(&self) -> TokenField_vrD_32_1 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrD_32_1(inner_value)
    }
    fn TokenFieldvrD_32_2(&self) -> TokenField_vrD_32_2 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrD_32_2(inner_value)
    }
    fn TokenFieldvrD_32_3(&self) -> TokenField_vrD_32_3 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrD_32_3(inner_value)
    }
    fn TokenFieldvrD_16_0(&self) -> TokenField_vrD_16_0 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrD_16_0(inner_value)
    }
    fn TokenFieldvrD_16_1(&self) -> TokenField_vrD_16_1 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrD_16_1(inner_value)
    }
    fn TokenFieldvrD_16_2(&self) -> TokenField_vrD_16_2 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrD_16_2(inner_value)
    }
    fn TokenFieldvrD_16_3(&self) -> TokenField_vrD_16_3 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrD_16_3(inner_value)
    }
    fn TokenFieldvrD_16_4(&self) -> TokenField_vrD_16_4 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrD_16_4(inner_value)
    }
    fn TokenFieldvrD_16_5(&self) -> TokenField_vrD_16_5 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrD_16_5(inner_value)
    }
    fn TokenFieldvrD_16_6(&self) -> TokenField_vrD_16_6 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrD_16_6(inner_value)
    }
    fn TokenFieldvrD_16_7(&self) -> TokenField_vrD_16_7 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrD_16_7(inner_value)
    }
    fn TokenFieldvrD_8_0(&self) -> TokenField_vrD_8_0 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrD_8_0(inner_value)
    }
    fn TokenFieldvrD_8_1(&self) -> TokenField_vrD_8_1 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrD_8_1(inner_value)
    }
    fn TokenFieldvrD_8_2(&self) -> TokenField_vrD_8_2 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrD_8_2(inner_value)
    }
    fn TokenFieldvrD_8_3(&self) -> TokenField_vrD_8_3 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrD_8_3(inner_value)
    }
    fn TokenFieldvrD_8_4(&self) -> TokenField_vrD_8_4 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrD_8_4(inner_value)
    }
    fn TokenFieldvrD_8_5(&self) -> TokenField_vrD_8_5 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrD_8_5(inner_value)
    }
    fn TokenFieldvrD_8_6(&self) -> TokenField_vrD_8_6 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrD_8_6(inner_value)
    }
    fn TokenFieldvrD_8_7(&self) -> TokenField_vrD_8_7 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrD_8_7(inner_value)
    }
    fn TokenFieldvrD_8_8(&self) -> TokenField_vrD_8_8 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrD_8_8(inner_value)
    }
    fn TokenFieldvrD_8_9(&self) -> TokenField_vrD_8_9 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrD_8_9(inner_value)
    }
    fn TokenFieldvrD_8_10(&self) -> TokenField_vrD_8_10 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrD_8_10(inner_value)
    }
    fn TokenFieldvrD_8_11(&self) -> TokenField_vrD_8_11 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrD_8_11(inner_value)
    }
    fn TokenFieldvrD_8_12(&self) -> TokenField_vrD_8_12 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrD_8_12(inner_value)
    }
    fn TokenFieldvrD_8_13(&self) -> TokenField_vrD_8_13 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrD_8_13(inner_value)
    }
    fn TokenFieldvrD_8_14(&self) -> TokenField_vrD_8_14 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrD_8_14(inner_value)
    }
    fn TokenFieldvrD_8_15(&self) -> TokenField_vrD_8_15 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrD_8_15(inner_value)
    }
    fn TokenFieldvrSR(&self) -> TokenField_vrSR {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrSR(inner_value)
    }
    fn TokenFieldvrSD(&self) -> TokenField_vrSD {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrSD(inner_value)
    }
    fn TokenFieldvrS_64_0(&self) -> TokenField_vrS_64_0 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrS_64_0(inner_value)
    }
    fn TokenFieldvrS_64_1(&self) -> TokenField_vrS_64_1 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrS_64_1(inner_value)
    }
    fn TokenFieldvrS_32_0(&self) -> TokenField_vrS_32_0 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrS_32_0(inner_value)
    }
    fn TokenFieldvrS_32_1(&self) -> TokenField_vrS_32_1 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrS_32_1(inner_value)
    }
    fn TokenFieldvrS_32_2(&self) -> TokenField_vrS_32_2 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrS_32_2(inner_value)
    }
    fn TokenFieldvrS_32_3(&self) -> TokenField_vrS_32_3 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrS_32_3(inner_value)
    }
    fn TokenFieldvrS_16_0(&self) -> TokenField_vrS_16_0 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrS_16_0(inner_value)
    }
    fn TokenFieldvrS_16_1(&self) -> TokenField_vrS_16_1 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrS_16_1(inner_value)
    }
    fn TokenFieldvrS_16_2(&self) -> TokenField_vrS_16_2 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrS_16_2(inner_value)
    }
    fn TokenFieldvrS_16_3(&self) -> TokenField_vrS_16_3 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrS_16_3(inner_value)
    }
    fn TokenFieldvrS_16_4(&self) -> TokenField_vrS_16_4 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrS_16_4(inner_value)
    }
    fn TokenFieldvrS_16_5(&self) -> TokenField_vrS_16_5 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrS_16_5(inner_value)
    }
    fn TokenFieldvrS_16_6(&self) -> TokenField_vrS_16_6 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrS_16_6(inner_value)
    }
    fn TokenFieldvrS_16_7(&self) -> TokenField_vrS_16_7 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrS_16_7(inner_value)
    }
    fn TokenFieldvrS_8_0(&self) -> TokenField_vrS_8_0 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrS_8_0(inner_value)
    }
    fn TokenFieldvrS_8_1(&self) -> TokenField_vrS_8_1 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrS_8_1(inner_value)
    }
    fn TokenFieldvrS_8_2(&self) -> TokenField_vrS_8_2 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrS_8_2(inner_value)
    }
    fn TokenFieldvrS_8_3(&self) -> TokenField_vrS_8_3 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrS_8_3(inner_value)
    }
    fn TokenFieldvrS_8_4(&self) -> TokenField_vrS_8_4 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrS_8_4(inner_value)
    }
    fn TokenFieldvrS_8_5(&self) -> TokenField_vrS_8_5 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrS_8_5(inner_value)
    }
    fn TokenFieldvrS_8_6(&self) -> TokenField_vrS_8_6 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrS_8_6(inner_value)
    }
    fn TokenFieldvrS_8_7(&self) -> TokenField_vrS_8_7 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrS_8_7(inner_value)
    }
    fn TokenFieldvrS_8_8(&self) -> TokenField_vrS_8_8 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrS_8_8(inner_value)
    }
    fn TokenFieldvrS_8_9(&self) -> TokenField_vrS_8_9 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrS_8_9(inner_value)
    }
    fn TokenFieldvrS_8_10(&self) -> TokenField_vrS_8_10 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrS_8_10(inner_value)
    }
    fn TokenFieldvrS_8_11(&self) -> TokenField_vrS_8_11 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrS_8_11(inner_value)
    }
    fn TokenFieldvrS_8_12(&self) -> TokenField_vrS_8_12 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrS_8_12(inner_value)
    }
    fn TokenFieldvrS_8_13(&self) -> TokenField_vrS_8_13 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrS_8_13(inner_value)
    }
    fn TokenFieldvrS_8_14(&self) -> TokenField_vrS_8_14 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrS_8_14(inner_value)
    }
    fn TokenFieldvrS_8_15(&self) -> TokenField_vrS_8_15 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_vrS_8_15(inner_value)
    }
    fn TokenFieldWC(&self) -> TokenField_WC {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_WC(inner_value)
    }
    fn TokenFieldXOP_0_10(&self) -> TokenField_XOP_0_10 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 0u64 as usize, 11u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_XOP_0_10(inner_value)
    }
    fn TokenFieldXOP_0_5(&self) -> TokenField_XOP_0_5 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 6u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_XOP_0_5(inner_value)
    }
    fn TokenFieldXOP_0_8(&self) -> TokenField_XOP_0_8 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 0u64 as usize, 9u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_XOP_0_8(inner_value)
    }
    fn TokenFieldXOP_0_9(&self) -> TokenField_XOP_0_9 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 0u64 as usize, 10u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_XOP_0_9(inner_value)
    }
    fn TokenFieldXOP_1_10(&self) -> TokenField_XOP_1_10 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 1u64 as usize, 10u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_XOP_1_10(inner_value)
    }
    fn TokenFieldXOP_1_4(&self) -> TokenField_XOP_1_4 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 1u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_XOP_1_4(inner_value)
    }
    fn TokenFieldXOP_1_5(&self) -> TokenField_XOP_1_5 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 1u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_XOP_1_5(inner_value)
    }
    fn TokenFieldXOP_1_8(&self) -> TokenField_XOP_1_8 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 1u64 as usize, 8u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_XOP_1_8(inner_value)
    }
    fn TokenFieldXOP_1_9(&self) -> TokenField_XOP_1_9 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 1u64 as usize, 9u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_XOP_1_9(inner_value)
    }
    fn TokenFieldXOP_2_10(&self) -> TokenField_XOP_2_10 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 2u64 as usize, 9u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_XOP_2_10(inner_value)
    }
    fn TokenFieldXOP_2_4(&self) -> TokenField_XOP_2_4 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 2u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_XOP_2_4(inner_value)
    }
    fn TokenFieldXOP_3_5(&self) -> TokenField_XOP_3_5 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 3u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_XOP_3_5(inner_value)
    }
    fn TokenFieldXOP_3_10(&self) -> TokenField_XOP_3_10 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 3u64 as usize, 8u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_XOP_3_10(inner_value)
    }
    fn TokenFieldXOP_3_9(&self) -> TokenField_XOP_3_9 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 3u64 as usize, 7u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_XOP_3_9(inner_value)
    }
    fn TokenFieldXOP_7_10(&self) -> TokenField_XOP_7_10 {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 7u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_XOP_7_10(inner_value)
    }
    fn TokenFieldAvsa(&self) -> TokenField_Avsa {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_Avsa(inner_value)
    }
    fn TokenFieldAvsb(&self) -> TokenField_Avsb {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_Avsb(inner_value)
    }
    fn TokenFieldBvsa(&self) -> TokenField_Bvsa {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_Bvsa(inner_value)
    }
    fn TokenFieldBvsb(&self) -> TokenField_Bvsb {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_Bvsb(inner_value)
    }
    fn TokenFieldCvsa(&self) -> TokenField_Cvsa {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_Cvsa(inner_value)
    }
    fn TokenFieldCvsb(&self) -> TokenField_Cvsb {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_Cvsb(inner_value)
    }
    fn TokenFieldSvsa(&self) -> TokenField_Svsa {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_Svsa(inner_value)
    }
    fn TokenFieldSvsb(&self) -> TokenField_Svsb {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_Svsb(inner_value)
    }
    fn TokenFieldSvsbx(&self) -> TokenField_Svsbx {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_Svsbx(inner_value)
    }
    fn TokenFieldTvsa(&self) -> TokenField_Tvsa {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_Tvsa(inner_value)
    }
    fn TokenFieldTvsb(&self) -> TokenField_Tvsb {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_Tvsb(inner_value)
    }
    fn TokenFieldTvsbx(&self) -> TokenField_Tvsbx {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_Tvsbx(inner_value)
    }
    fn TokenFieldBD15_VLE(&self) -> TokenField_BD15_VLE {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i16::<true>(work_value, 1u64 as usize, 15u64 as usize);
            i16::try_from(value).unwrap()
        };
        TokenField_BD15_VLE(inner_value)
    }
    fn TokenFieldBD24_VLE(&self) -> TokenField_BD24_VLE {
        let inner_value = {
            let mut work_value = [0u8; 4u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 4u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i32::<true>(work_value, 1u64 as usize, 24u64 as usize);
            i32::try_from(value).unwrap()
        };
        TokenField_BD24_VLE(inner_value)
    }
    fn TokenFieldBF_VLE(&self) -> TokenField_BF_VLE {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 5u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BF_VLE(inner_value)
    }
    fn TokenFieldBI_CC_VLE(&self) -> TokenField_BI_CC_VLE {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BI_CC_VLE(inner_value)
    }
    fn TokenFieldBI_CR_VLE(&self) -> TokenField_BI_CR_VLE {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 2u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BI_CR_VLE(inner_value)
    }
    fn TokenFieldBO_VLE(&self) -> TokenField_BO_VLE {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BO_VLE(inner_value)
    }
    fn TokenFieldIMM8(&self) -> TokenField_IMM8 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 3u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 8u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_IMM8(inner_value)
    }
    fn TokenFieldIMM_0_10_VLE(&self) -> TokenField_IMM_0_10_VLE {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 4u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 0u64 as usize, 11u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_IMM_0_10_VLE(inner_value)
    }
    fn TokenFieldIMM_11_15_VLE(&self) -> TokenField_IMM_11_15_VLE {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_IMM_11_15_VLE(inner_value)
    }
    fn TokenFieldIMM_16_20_VLE(&self) -> TokenField_IMM_16_20_VLE {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_IMM_16_20_VLE(inner_value)
    }
    fn TokenFieldIMM_21_25_VLE(&self) -> TokenField_IMM_21_25_VLE {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_IMM_21_25_VLE(inner_value)
    }
    fn TokenFieldSIMM_11_14_VLE(&self) -> TokenField_SIMM_11_14_VLE {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i8::<true>(work_value, 3u64 as usize, 4u64 as usize);
            i8::try_from(value).unwrap()
        };
        TokenField_SIMM_11_14_VLE(inner_value)
    }
    fn TokenFieldSIMM_21_25_VLE(&self) -> TokenField_SIMM_21_25_VLE {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i16::<true>(work_value, 5u64 as usize, 5u64 as usize);
            i8::try_from(value).unwrap()
        };
        TokenField_SIMM_21_25_VLE(inner_value)
    }
    fn TokenFieldSCL_VLE(&self) -> TokenField_SCL_VLE {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_SCL_VLE(inner_value)
    }
    fn TokenFieldLEV_VLE(&self) -> TokenField_LEV_VLE {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_LEV_VLE(inner_value)
    }
    fn TokenFieldXOP_8_VLE(&self) -> TokenField_XOP_8_VLE {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 8u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_XOP_8_VLE(inner_value)
    }
    fn TokenFieldXOP_11_VLE(&self) -> TokenField_XOP_11_VLE {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_XOP_11_VLE(inner_value)
    }
    fn TokenFieldXOP_12_VLE(&self) -> TokenField_XOP_12_VLE {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 2u64 as usize;
            let token_end = 3u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_XOP_12_VLE(inner_value)
    }
    fn TokenFieldXOP_VLE(&self) -> TokenField_XOP_VLE {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 6u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_XOP_VLE(inner_value)
    }
    fn TokenFieldOP4_VLE(&self) -> TokenField_OP4_VLE {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP4_VLE(inner_value)
    }
    fn TokenFieldOP5_VLE(&self) -> TokenField_OP5_VLE {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 3u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP5_VLE(inner_value)
    }
    fn TokenFieldOP6_VLE(&self) -> TokenField_OP6_VLE {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 2u64 as usize, 6u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OP6_VLE(inner_value)
    }
    fn TokenFieldOP15_VLE(&self) -> TokenField_OP15_VLE {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 1u64 as usize, 15u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_OP15_VLE(inner_value)
    }
    fn TokenFieldOP16_VLE(&self) -> TokenField_OP16_VLE {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 0u64 as usize, 16u64 as usize);
            u16::try_from(value).unwrap()
        };
        TokenField_OP16_VLE(inner_value)
    }
    fn TokenFieldOIM5_VLE(&self) -> TokenField_OIM5_VLE {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 4u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OIM5_VLE(inner_value)
    }
    fn TokenFieldOIM7_VLE(&self) -> TokenField_OIM7_VLE {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 4u64 as usize, 7u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_OIM7_VLE(inner_value)
    }
    fn TokenFieldSD4_VLE(&self) -> TokenField_SD4_VLE {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_SD4_VLE(inner_value)
    }
    fn TokenFieldUI7_VLE(&self) -> TokenField_UI7_VLE {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 4u64 as usize, 7u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_UI7_VLE(inner_value)
    }
    fn TokenFieldUI5_VLE(&self) -> TokenField_UI5_VLE {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 4u64 as usize, 5u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_UI5_VLE(inner_value)
    }
    fn TokenFieldXORR_VLE(&self) -> TokenField_XORR_VLE {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_XORR_VLE(inner_value)
    }
    fn TokenFieldXOR_VLE(&self) -> TokenField_XOR_VLE {
        let inner_value = {
            let mut work_value = [0u8; 2u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 2u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u16::<true>(work_value, 4u64 as usize, 6u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_XOR_VLE(inner_value)
    }
    fn TokenFieldARX_VLE(&self) -> TokenField_ARX_VLE {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_ARX_VLE(inner_value)
    }
    fn TokenFieldARY_VLE(&self) -> TokenField_ARY_VLE {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_ARY_VLE(inner_value)
    }
    fn TokenFieldRY_VLE(&self) -> TokenField_RY_VLE {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_RY_VLE(inner_value)
    }
    fn TokenFieldRZ_VLE(&self) -> TokenField_RZ_VLE {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 4u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_RZ_VLE(inner_value)
    }
    fn TokenFieldRX_VLE(&self) -> TokenField_RX_VLE {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 4u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_RX_VLE(inner_value)
    }
    fn TokenFieldBO16_VLE(&self) -> TokenField_BO16_VLE {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 2u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BO16_VLE(inner_value)
    }
    fn TokenFieldBIT9_VLE(&self) -> TokenField_BIT9_VLE {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 1u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BIT9_VLE(inner_value)
    }
    fn TokenFieldBIT8_VLE(&self) -> TokenField_BIT8_VLE {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BIT8_VLE(inner_value)
    }
    fn TokenFieldBI16_VLE(&self) -> TokenField_BI16_VLE {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BI16_VLE(inner_value)
    }
    fn TokenFieldBITS_8_9(&self) -> TokenField_BITS_8_9 {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 2u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_BITS_8_9(inner_value)
    }
    fn TokenFieldBD8_VLE(&self) -> TokenField_BD8_VLE {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_i8::<true>(work_value, 0u64 as usize, 8u64 as usize);
            i8::try_from(value).unwrap()
        };
        TokenField_BD8_VLE(inner_value)
    }
    fn TokenFieldLK8_VLE(&self) -> TokenField_LK8_VLE {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 0u64 as usize;
            let token_end = 1u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_LK8_VLE(inner_value)
    }
    fn TokenFieldLK0_VLE(&self) -> TokenField_LK0_VLE {
        let inner_value = {
            let mut work_value = [0u8; 1u64 as usize];
            let work_start = 0u64 as usize;
            let work_end = 1u64 as usize;
            let token_start = 1u64 as usize;
            let token_end = 2u64 as usize;
            work_value[work_start..work_end]
                .copy_from_slice(&self.0[token_start..token_end]);
            let value =
                read_u8::<true>(work_value, 0u64 as usize, 1u64 as usize);
            u8::try_from(value).unwrap()
        };
        TokenField_LK0_VLE(inner_value)
    }
}
#[derive(Clone, Copy, Debug)]
pub enum Register {
    r0,
    r1,
    r2,
    r3,
    r4,
    r5,
    r6,
    r7,
    r8,
    r9,
    r10,
    r11,
    r12,
    r13,
    r14,
    r15,
    r16,
    r17,
    r18,
    r19,
    r20,
    r21,
    r22,
    r23,
    r24,
    r25,
    r26,
    r27,
    r28,
    r29,
    r30,
    r31,
    xer_so,
    xer_ov,
    xer_ov32,
    xer_ca,
    xer_ca32,
    xer_count,
    fp_fx,
    fp_fex,
    fp_vx,
    fp_ox,
    fp_ux,
    fp_zx,
    fp_xx,
    fp_vxsnan,
    fp_vxisi,
    fp_vxidi,
    fp_vxzdz,
    fp_vximz,
    fp_vxvc,
    fp_fr,
    fp_fi,
    fp_c,
    fp_cc0,
    fp_cc1,
    fp_cc2,
    fp_cc3,
    fp_reserve1,
    fp_vxsoft,
    fp_vxsqrt,
    fp_vxcvi,
    fp_ve,
    fp_oe,
    fp_ue,
    fp_ze,
    fp_xe,
    fp_ni,
    fp_rn0,
    fp_rn1,
    MSR,
    RESERVE_ADDRESS,
    RESERVE,
    RESERVE_LENGTH,
    pc,
    sr0,
    sr1,
    sr2,
    sr3,
    sr4,
    sr5,
    sr6,
    sr7,
    sr8,
    sr9,
    sr10,
    sr11,
    sr12,
    sr13,
    sr14,
    sr15,
    cr0,
    cr1,
    cr2,
    cr3,
    cr4,
    cr5,
    cr6,
    cr7,
    crall,
    tea,
    r2Save,
    spr000,
    XER,
    spr002,
    spr003,
    spr004,
    spr005,
    spr006,
    spr007,
    LR,
    CTR,
    spr00a,
    spr00b,
    spr00c,
    spr00d,
    spr00e,
    spr00f,
    spr010,
    spr011,
    spr012,
    spr013,
    spr014,
    spr015,
    spr016,
    spr017,
    spr018,
    spr019,
    SRR0,
    SRR1,
    spr01c,
    spr01d,
    spr01e,
    spr01f,
    spr020,
    spr021,
    spr022,
    spr023,
    spr024,
    spr025,
    spr026,
    spr027,
    spr028,
    spr029,
    spr02a,
    spr02b,
    spr02c,
    spr02d,
    spr02e,
    spr02f,
    spr030,
    spr031,
    spr032,
    spr033,
    spr034,
    spr035,
    spr036,
    spr037,
    spr038,
    spr039,
    CSRR0,
    CSRR1,
    spr03c,
    spr03d,
    spr03e,
    spr03f,
    spr040,
    spr041,
    spr042,
    spr043,
    spr044,
    spr045,
    spr046,
    spr047,
    spr048,
    spr049,
    spr04a,
    spr04b,
    spr04c,
    spr04d,
    spr04e,
    spr04f,
    spr050,
    spr051,
    spr052,
    spr053,
    spr054,
    spr055,
    spr056,
    spr057,
    spr058,
    spr059,
    spr05a,
    spr05b,
    spr05c,
    spr05d,
    spr05e,
    spr05f,
    spr060,
    spr061,
    spr062,
    spr063,
    spr064,
    spr065,
    spr066,
    spr067,
    spr068,
    spr069,
    spr06a,
    spr06b,
    spr06c,
    spr06d,
    spr06e,
    spr06f,
    spr070,
    spr071,
    spr072,
    spr073,
    spr074,
    spr075,
    spr076,
    spr077,
    spr078,
    spr079,
    spr07a,
    spr07b,
    spr07c,
    spr07d,
    spr07e,
    spr07f,
    spr080,
    spr081,
    spr082,
    spr083,
    spr084,
    spr085,
    spr086,
    spr087,
    spr088,
    spr089,
    spr08a,
    spr08b,
    spr08c,
    spr08d,
    spr08e,
    spr08f,
    spr090,
    spr091,
    spr092,
    spr093,
    spr094,
    spr095,
    spr096,
    spr097,
    spr098,
    spr099,
    spr09a,
    spr09b,
    spr09c,
    spr09d,
    spr09e,
    spr09f,
    spr0a0,
    spr0a1,
    spr0a2,
    spr0a3,
    spr0a4,
    spr0a5,
    spr0a6,
    spr0a7,
    spr0a8,
    spr0a9,
    spr0aa,
    spr0ab,
    spr0ac,
    spr0ad,
    spr0ae,
    spr0af,
    spr0b0,
    spr0b1,
    spr0b2,
    spr0b3,
    spr0b4,
    spr0b5,
    spr0b6,
    spr0b7,
    spr0b8,
    spr0b9,
    spr0ba,
    spr0bb,
    spr0bc,
    spr0bd,
    spr0be,
    spr0bf,
    spr0c0,
    spr0c1,
    spr0c2,
    spr0c3,
    spr0c4,
    spr0c5,
    spr0c6,
    spr0c7,
    spr0c8,
    spr0c9,
    spr0ca,
    spr0cb,
    spr0cc,
    spr0cd,
    spr0ce,
    spr0cf,
    spr0d0,
    spr0d1,
    spr0d2,
    spr0d3,
    spr0d4,
    spr0d5,
    spr0d6,
    spr0d7,
    spr0d8,
    spr0d9,
    spr0da,
    spr0db,
    spr0dc,
    spr0dd,
    spr0de,
    spr0df,
    spr0e0,
    spr0e1,
    spr0e2,
    spr0e3,
    spr0e4,
    spr0e5,
    spr0e6,
    spr0e7,
    spr0e8,
    spr0e9,
    spr0ea,
    spr0eb,
    spr0ec,
    spr0ed,
    spr0ee,
    spr0ef,
    spr0f0,
    spr0f1,
    spr0f2,
    spr0f3,
    spr0f4,
    spr0f5,
    spr0f6,
    spr0f7,
    spr0f8,
    spr0f9,
    spr0fa,
    spr0fb,
    spr0fc,
    spr0fd,
    spr0fe,
    spr0ff,
    spr100,
    spr101,
    spr102,
    spr103,
    spr104,
    spr105,
    spr106,
    spr107,
    spr108,
    spr109,
    spr10a,
    spr10b,
    TBLr,
    TBUr,
    spr10e,
    spr10f,
    spr110,
    spr111,
    spr112,
    spr113,
    spr114,
    spr115,
    spr116,
    spr117,
    spr118,
    spr119,
    spr11a,
    spr11b,
    TBLw,
    TBUw,
    spr11e,
    spr11f,
    spr120,
    spr121,
    spr122,
    spr123,
    spr124,
    spr125,
    spr126,
    spr127,
    spr128,
    spr129,
    spr12a,
    spr12b,
    spr12c,
    spr12d,
    spr12e,
    spr12f,
    spr130,
    spr131,
    spr132,
    spr133,
    spr134,
    spr135,
    spr136,
    spr137,
    spr138,
    spr139,
    spr13a,
    spr13b,
    spr13c,
    spr13d,
    spr13e,
    spr13f,
    spr140,
    spr141,
    spr142,
    spr143,
    spr144,
    spr145,
    spr146,
    spr147,
    spr148,
    spr149,
    spr14a,
    spr14b,
    spr14c,
    spr14d,
    spr14e,
    spr14f,
    spr150,
    spr151,
    spr152,
    spr153,
    spr154,
    spr155,
    spr156,
    spr157,
    spr158,
    spr159,
    spr15a,
    spr15b,
    spr15c,
    spr15d,
    spr15e,
    spr15f,
    spr160,
    spr161,
    spr162,
    spr163,
    spr164,
    spr165,
    spr166,
    spr167,
    spr168,
    spr169,
    spr16a,
    spr16b,
    spr16c,
    spr16d,
    spr16e,
    spr16f,
    spr170,
    spr171,
    spr172,
    spr173,
    spr174,
    spr175,
    spr176,
    spr177,
    spr178,
    spr179,
    spr17a,
    spr17b,
    spr17c,
    spr17d,
    spr17e,
    spr17f,
    spr180,
    spr181,
    spr182,
    spr183,
    spr184,
    spr185,
    spr186,
    spr187,
    spr188,
    spr189,
    spr18a,
    spr18b,
    spr18c,
    spr18d,
    spr18e,
    spr18f,
    spr190,
    spr191,
    spr192,
    spr193,
    spr194,
    spr195,
    spr196,
    spr197,
    spr198,
    spr199,
    spr19a,
    spr19b,
    spr19c,
    spr19d,
    spr19e,
    spr19f,
    spr1a0,
    spr1a1,
    spr1a2,
    spr1a3,
    spr1a4,
    spr1a5,
    spr1a6,
    spr1a7,
    spr1a8,
    spr1a9,
    spr1aa,
    spr1ab,
    spr1ac,
    spr1ad,
    spr1ae,
    spr1af,
    spr1b0,
    spr1b1,
    spr1b2,
    spr1b3,
    spr1b4,
    spr1b5,
    spr1b6,
    spr1b7,
    spr1b8,
    spr1b9,
    spr1ba,
    spr1bb,
    spr1bc,
    spr1bd,
    spr1be,
    spr1bf,
    spr1c0,
    spr1c1,
    spr1c2,
    spr1c3,
    spr1c4,
    spr1c5,
    spr1c6,
    spr1c7,
    spr1c8,
    spr1c9,
    spr1ca,
    spr1cb,
    spr1cc,
    spr1cd,
    spr1ce,
    spr1cf,
    spr1d0,
    spr1d1,
    spr1d2,
    spr1d3,
    spr1d4,
    spr1d5,
    spr1d6,
    spr1d7,
    spr1d8,
    spr1d9,
    spr1da,
    spr1db,
    spr1dc,
    spr1dd,
    spr1de,
    spr1df,
    spr1e0,
    spr1e1,
    spr1e2,
    spr1e3,
    spr1e4,
    spr1e5,
    spr1e6,
    spr1e7,
    spr1e8,
    spr1e9,
    spr1ea,
    spr1eb,
    spr1ec,
    spr1ed,
    spr1ee,
    spr1ef,
    spr1f0,
    spr1f1,
    spr1f2,
    spr1f3,
    spr1f4,
    spr1f5,
    spr1f6,
    spr1f7,
    spr1f8,
    spr1f9,
    spr1fa,
    spr1fb,
    spr1fc,
    spr1fd,
    spr1fe,
    spr1ff,
    spr200,
    spr201,
    spr202,
    spr203,
    spr204,
    spr205,
    spr206,
    spr207,
    spr208,
    spr209,
    spr20a,
    spr20b,
    spr20c,
    spr20d,
    spr20e,
    spr20f,
    spr210,
    spr211,
    spr212,
    spr213,
    spr214,
    spr215,
    spr216,
    spr217,
    spr218,
    spr219,
    spr21a,
    spr21b,
    spr21c,
    spr21d,
    spr21e,
    spr21f,
    spr220,
    spr221,
    spr222,
    spr223,
    spr224,
    spr225,
    spr226,
    spr227,
    spr228,
    spr229,
    spr22a,
    spr22b,
    spr22c,
    spr22d,
    spr22e,
    spr22f,
    spr230,
    spr231,
    spr232,
    spr233,
    spr234,
    spr235,
    spr236,
    spr237,
    spr238,
    spr239,
    spr23a,
    spr23b,
    spr23c,
    spr23d,
    spr23e,
    spr23f,
    spr240,
    spr241,
    spr242,
    spr243,
    spr244,
    spr245,
    spr246,
    spr247,
    spr248,
    spr249,
    spr24a,
    spr24b,
    spr24c,
    spr24d,
    spr24e,
    spr24f,
    spr250,
    spr251,
    spr252,
    spr253,
    spr254,
    spr255,
    spr256,
    spr257,
    spr258,
    spr259,
    spr25a,
    spr25b,
    spr25c,
    spr25d,
    spr25e,
    spr25f,
    spr260,
    spr261,
    spr262,
    spr263,
    spr264,
    spr265,
    spr266,
    spr267,
    spr268,
    spr269,
    spr26a,
    spr26b,
    spr26c,
    spr26d,
    spr26e,
    spr26f,
    spr270,
    spr271,
    spr272,
    spr273,
    spr274,
    spr275,
    spr276,
    spr277,
    spr278,
    spr279,
    spr27a,
    spr27b,
    spr27c,
    spr27d,
    spr27e,
    spr27f,
    spr280,
    spr281,
    spr282,
    spr283,
    spr284,
    spr285,
    spr286,
    spr287,
    spr288,
    spr289,
    spr28a,
    spr28b,
    spr28c,
    spr28d,
    spr28e,
    spr28f,
    spr290,
    spr291,
    spr292,
    spr293,
    spr294,
    spr295,
    spr296,
    spr297,
    spr298,
    spr299,
    spr29a,
    spr29b,
    spr29c,
    spr29d,
    spr29e,
    spr29f,
    spr2a0,
    spr2a1,
    spr2a2,
    spr2a3,
    spr2a4,
    spr2a5,
    spr2a6,
    spr2a7,
    spr2a8,
    spr2a9,
    spr2aa,
    spr2ab,
    spr2ac,
    spr2ad,
    spr2ae,
    spr2af,
    spr2b0,
    spr2b1,
    spr2b2,
    spr2b3,
    spr2b4,
    spr2b5,
    spr2b6,
    spr2b7,
    spr2b8,
    spr2b9,
    spr2ba,
    spr2bb,
    spr2bc,
    spr2bd,
    spr2be,
    spr2bf,
    spr2c0,
    spr2c1,
    spr2c2,
    spr2c3,
    spr2c4,
    spr2c5,
    spr2c6,
    spr2c7,
    spr2c8,
    spr2c9,
    spr2ca,
    spr2cb,
    spr2cc,
    spr2cd,
    spr2ce,
    spr2cf,
    spr2d0,
    spr2d1,
    spr2d2,
    spr2d3,
    spr2d4,
    spr2d5,
    spr2d6,
    spr2d7,
    spr2d8,
    spr2d9,
    spr2da,
    spr2db,
    spr2dc,
    spr2dd,
    spr2de,
    spr2df,
    spr2e0,
    spr2e1,
    spr2e2,
    spr2e3,
    spr2e4,
    spr2e5,
    spr2e6,
    spr2e7,
    spr2e8,
    spr2e9,
    spr2ea,
    spr2eb,
    spr2ec,
    spr2ed,
    spr2ee,
    spr2ef,
    spr2f0,
    spr2f1,
    spr2f2,
    spr2f3,
    spr2f4,
    spr2f5,
    spr2f6,
    spr2f7,
    spr2f8,
    spr2f9,
    spr2fa,
    spr2fb,
    spr2fc,
    spr2fd,
    spr2fe,
    spr2ff,
    spr300,
    spr301,
    spr302,
    spr303,
    spr304,
    spr305,
    spr306,
    spr307,
    spr308,
    spr309,
    spr30a,
    spr30b,
    spr30c,
    spr30d,
    spr30e,
    spr30f,
    spr310,
    spr311,
    spr312,
    spr313,
    spr314,
    spr315,
    spr316,
    spr317,
    spr318,
    spr319,
    spr31a,
    spr31b,
    spr31c,
    spr31d,
    spr31e,
    spr31f,
    spr320,
    spr321,
    spr322,
    spr323,
    spr324,
    spr325,
    spr326,
    spr327,
    spr328,
    spr329,
    spr32a,
    spr32b,
    spr32c,
    spr32d,
    spr32e,
    TAR,
    spr330,
    spr331,
    spr332,
    spr333,
    spr334,
    spr335,
    spr336,
    spr337,
    spr338,
    spr339,
    spr33a,
    spr33b,
    spr33c,
    spr33d,
    spr33e,
    spr33f,
    spr340,
    spr341,
    spr342,
    spr343,
    spr344,
    spr345,
    spr346,
    spr347,
    spr348,
    spr349,
    spr34a,
    spr34b,
    spr34c,
    spr34d,
    spr34e,
    spr34f,
    spr350,
    spr351,
    spr352,
    spr353,
    spr354,
    spr355,
    spr356,
    spr357,
    spr358,
    spr359,
    spr35a,
    spr35b,
    spr35c,
    spr35d,
    spr35e,
    spr35f,
    spr360,
    spr361,
    spr362,
    spr363,
    spr364,
    spr365,
    spr366,
    spr367,
    spr368,
    spr369,
    spr36a,
    spr36b,
    spr36c,
    spr36d,
    spr36e,
    spr36f,
    spr370,
    spr371,
    spr372,
    spr373,
    spr374,
    spr375,
    spr376,
    spr377,
    spr378,
    spr379,
    spr37a,
    spr37b,
    spr37c,
    spr37d,
    spr37e,
    spr37f,
    spr380,
    spr381,
    spr382,
    spr383,
    spr384,
    spr385,
    spr386,
    spr387,
    spr388,
    spr389,
    spr38a,
    spr38b,
    spr38c,
    spr38d,
    spr38e,
    spr38f,
    spr390,
    spr391,
    spr392,
    spr393,
    spr394,
    spr395,
    spr396,
    spr397,
    spr398,
    spr399,
    spr39a,
    spr39b,
    spr39c,
    spr39d,
    spr39e,
    spr39f,
    spr3a0,
    spr3a1,
    spr3a2,
    spr3a3,
    spr3a4,
    spr3a5,
    spr3a6,
    spr3a7,
    spr3a8,
    spr3a9,
    spr3aa,
    spr3ab,
    spr3ac,
    spr3ad,
    spr3ae,
    spr3af,
    spr3b0,
    spr3b1,
    spr3b2,
    spr3b3,
    spr3b4,
    spr3b5,
    spr3b6,
    spr3b7,
    spr3b8,
    spr3b9,
    spr3ba,
    spr3bb,
    spr3bc,
    spr3bd,
    spr3be,
    spr3bf,
    spr3c0,
    spr3c1,
    spr3c2,
    spr3c3,
    spr3c4,
    spr3c5,
    spr3c6,
    spr3c7,
    spr3c8,
    spr3c9,
    spr3ca,
    spr3cb,
    spr3cc,
    spr3cd,
    spr3ce,
    spr3cf,
    spr3d0,
    spr3d1,
    spr3d2,
    spr3d3,
    spr3d4,
    spr3d5,
    spr3d6,
    spr3d7,
    spr3d8,
    spr3d9,
    spr3da,
    spr3db,
    spr3dc,
    spr3dd,
    spr3de,
    spr3df,
    spr3e0,
    spr3e1,
    spr3e2,
    spr3e3,
    spr3e4,
    spr3e5,
    spr3e6,
    spr3e7,
    spr3e8,
    spr3e9,
    spr3ea,
    spr3eb,
    spr3ec,
    spr3ed,
    spr3ee,
    spr3ef,
    spr3f0,
    spr3f1,
    spr3f2,
    spr3f3,
    spr3f4,
    spr3f5,
    spr3f6,
    spr3f7,
    spr3f8,
    spr3f9,
    spr3fa,
    spr3fb,
    spr3fc,
    spr3fd,
    spr3fe,
    spr3ff,
    vs0,
    vs1,
    vs2,
    vs3,
    vs4,
    vs5,
    vs6,
    vs7,
    vs8,
    vs9,
    vs10,
    vs11,
    vs12,
    vs13,
    vs14,
    vs15,
    vs16,
    vs17,
    vs18,
    vs19,
    vs20,
    vs21,
    vs22,
    vs23,
    vs24,
    vs25,
    vs26,
    vs27,
    vs28,
    vs29,
    vs30,
    vs31,
    vs32,
    vs33,
    vs34,
    vs35,
    vs36,
    vs37,
    vs38,
    vs39,
    vs40,
    vs41,
    vs42,
    vs43,
    vs44,
    vs45,
    vs46,
    vs47,
    vs48,
    vs49,
    vs50,
    vs51,
    vs52,
    vs53,
    vs54,
    vs55,
    vs56,
    vs57,
    vs58,
    vs59,
    vs60,
    vs61,
    vs62,
    vs63,
    f0,
    f1,
    f2,
    f3,
    f4,
    f5,
    f6,
    f7,
    f8,
    f9,
    f10,
    f11,
    f12,
    f13,
    f14,
    f15,
    f16,
    f17,
    f18,
    f19,
    f20,
    f21,
    f22,
    f23,
    f24,
    f25,
    f26,
    f27,
    f28,
    f29,
    f30,
    f31,
    vr0_64_0,
    vr0_64_1,
    vr1_64_0,
    vr1_64_1,
    vr2_64_0,
    vr2_64_1,
    vr3_64_0,
    vr3_64_1,
    vr4_64_0,
    vr4_64_1,
    vr5_64_0,
    vr5_64_1,
    vr6_64_0,
    vr6_64_1,
    vr7_64_0,
    vr7_64_1,
    vr8_64_0,
    vr8_64_1,
    vr9_64_0,
    vr9_64_1,
    vr10_64_0,
    vr10_64_1,
    vr11_64_0,
    vr11_64_1,
    vr12_64_0,
    vr12_64_1,
    vr13_64_0,
    vr13_64_1,
    vr14_64_0,
    vr14_64_1,
    vr15_64_0,
    vr15_64_1,
    vr16_64_0,
    vr16_64_1,
    vr17_64_0,
    vr17_64_1,
    vr18_64_0,
    vr18_64_1,
    vr19_64_0,
    vr19_64_1,
    vr20_64_0,
    vr20_64_1,
    vr21_64_0,
    vr21_64_1,
    vr22_64_0,
    vr22_64_1,
    vr23_64_0,
    vr23_64_1,
    vr24_64_0,
    vr24_64_1,
    vr25_64_0,
    vr25_64_1,
    vr26_64_0,
    vr26_64_1,
    vr27_64_0,
    vr27_64_1,
    vr28_64_0,
    vr28_64_1,
    vr29_64_0,
    vr29_64_1,
    vr30_64_0,
    vr30_64_1,
    vr31_64_0,
    vr31_64_1,
    vr0_32_0,
    vr0_32_1,
    vr0_32_2,
    vr0_32_3,
    vr1_32_0,
    vr1_32_1,
    vr1_32_2,
    vr1_32_3,
    vr2_32_0,
    vr2_32_1,
    vr2_32_2,
    vr2_32_3,
    vr3_32_0,
    vr3_32_1,
    vr3_32_2,
    vr3_32_3,
    vr4_32_0,
    vr4_32_1,
    vr4_32_2,
    vr4_32_3,
    vr5_32_0,
    vr5_32_1,
    vr5_32_2,
    vr5_32_3,
    vr6_32_0,
    vr6_32_1,
    vr6_32_2,
    vr6_32_3,
    vr7_32_0,
    vr7_32_1,
    vr7_32_2,
    vr7_32_3,
    vr8_32_0,
    vr8_32_1,
    vr8_32_2,
    vr8_32_3,
    vr9_32_0,
    vr9_32_1,
    vr9_32_2,
    vr9_32_3,
    vr10_32_0,
    vr10_32_1,
    vr10_32_2,
    vr10_32_3,
    vr11_32_0,
    vr11_32_1,
    vr11_32_2,
    vr11_32_3,
    vr12_32_0,
    vr12_32_1,
    vr12_32_2,
    vr12_32_3,
    vr13_32_0,
    vr13_32_1,
    vr13_32_2,
    vr13_32_3,
    vr14_32_0,
    vr14_32_1,
    vr14_32_2,
    vr14_32_3,
    vr15_32_0,
    vr15_32_1,
    vr15_32_2,
    vr15_32_3,
    vr16_32_0,
    vr16_32_1,
    vr16_32_2,
    vr16_32_3,
    vr17_32_0,
    vr17_32_1,
    vr17_32_2,
    vr17_32_3,
    vr18_32_0,
    vr18_32_1,
    vr18_32_2,
    vr18_32_3,
    vr19_32_0,
    vr19_32_1,
    vr19_32_2,
    vr19_32_3,
    vr20_32_0,
    vr20_32_1,
    vr20_32_2,
    vr20_32_3,
    vr21_32_0,
    vr21_32_1,
    vr21_32_2,
    vr21_32_3,
    vr22_32_0,
    vr22_32_1,
    vr22_32_2,
    vr22_32_3,
    vr23_32_0,
    vr23_32_1,
    vr23_32_2,
    vr23_32_3,
    vr24_32_0,
    vr24_32_1,
    vr24_32_2,
    vr24_32_3,
    vr25_32_0,
    vr25_32_1,
    vr25_32_2,
    vr25_32_3,
    vr26_32_0,
    vr26_32_1,
    vr26_32_2,
    vr26_32_3,
    vr27_32_0,
    vr27_32_1,
    vr27_32_2,
    vr27_32_3,
    vr28_32_0,
    vr28_32_1,
    vr28_32_2,
    vr28_32_3,
    vr29_32_0,
    vr29_32_1,
    vr29_32_2,
    vr29_32_3,
    vr30_32_0,
    vr30_32_1,
    vr30_32_2,
    vr30_32_3,
    vr31_32_0,
    vr31_32_1,
    vr31_32_2,
    vr31_32_3,
    vr0_16_0,
    vr0_16_1,
    vr0_16_2,
    vr0_16_3,
    vr0_16_4,
    vr0_16_5,
    vr0_16_6,
    vr0_16_7,
    vr1_16_0,
    vr1_16_1,
    vr1_16_2,
    vr1_16_3,
    vr1_16_4,
    vr1_16_5,
    vr1_16_6,
    vr1_16_7,
    vr2_16_0,
    vr2_16_1,
    vr2_16_2,
    vr2_16_3,
    vr2_16_4,
    vr2_16_5,
    vr2_16_6,
    vr2_16_7,
    vr3_16_0,
    vr3_16_1,
    vr3_16_2,
    vr3_16_3,
    vr3_16_4,
    vr3_16_5,
    vr3_16_6,
    vr3_16_7,
    vr4_16_0,
    vr4_16_1,
    vr4_16_2,
    vr4_16_3,
    vr4_16_4,
    vr4_16_5,
    vr4_16_6,
    vr4_16_7,
    vr5_16_0,
    vr5_16_1,
    vr5_16_2,
    vr5_16_3,
    vr5_16_4,
    vr5_16_5,
    vr5_16_6,
    vr5_16_7,
    vr6_16_0,
    vr6_16_1,
    vr6_16_2,
    vr6_16_3,
    vr6_16_4,
    vr6_16_5,
    vr6_16_6,
    vr6_16_7,
    vr7_16_0,
    vr7_16_1,
    vr7_16_2,
    vr7_16_3,
    vr7_16_4,
    vr7_16_5,
    vr7_16_6,
    vr7_16_7,
    vr8_16_0,
    vr8_16_1,
    vr8_16_2,
    vr8_16_3,
    vr8_16_4,
    vr8_16_5,
    vr8_16_6,
    vr8_16_7,
    vr9_16_0,
    vr9_16_1,
    vr9_16_2,
    vr9_16_3,
    vr9_16_4,
    vr9_16_5,
    vr9_16_6,
    vr9_16_7,
    vr10_16_0,
    vr10_16_1,
    vr10_16_2,
    vr10_16_3,
    vr10_16_4,
    vr10_16_5,
    vr10_16_6,
    vr10_16_7,
    vr11_16_0,
    vr11_16_1,
    vr11_16_2,
    vr11_16_3,
    vr11_16_4,
    vr11_16_5,
    vr11_16_6,
    vr11_16_7,
    vr12_16_0,
    vr12_16_1,
    vr12_16_2,
    vr12_16_3,
    vr12_16_4,
    vr12_16_5,
    vr12_16_6,
    vr12_16_7,
    vr13_16_0,
    vr13_16_1,
    vr13_16_2,
    vr13_16_3,
    vr13_16_4,
    vr13_16_5,
    vr13_16_6,
    vr13_16_7,
    vr14_16_0,
    vr14_16_1,
    vr14_16_2,
    vr14_16_3,
    vr14_16_4,
    vr14_16_5,
    vr14_16_6,
    vr14_16_7,
    vr15_16_0,
    vr15_16_1,
    vr15_16_2,
    vr15_16_3,
    vr15_16_4,
    vr15_16_5,
    vr15_16_6,
    vr15_16_7,
    vr16_16_0,
    vr16_16_1,
    vr16_16_2,
    vr16_16_3,
    vr16_16_4,
    vr16_16_5,
    vr16_16_6,
    vr16_16_7,
    vr17_16_0,
    vr17_16_1,
    vr17_16_2,
    vr17_16_3,
    vr17_16_4,
    vr17_16_5,
    vr17_16_6,
    vr17_16_7,
    vr18_16_0,
    vr18_16_1,
    vr18_16_2,
    vr18_16_3,
    vr18_16_4,
    vr18_16_5,
    vr18_16_6,
    vr18_16_7,
    vr19_16_0,
    vr19_16_1,
    vr19_16_2,
    vr19_16_3,
    vr19_16_4,
    vr19_16_5,
    vr19_16_6,
    vr19_16_7,
    vr20_16_0,
    vr20_16_1,
    vr20_16_2,
    vr20_16_3,
    vr20_16_4,
    vr20_16_5,
    vr20_16_6,
    vr20_16_7,
    vr21_16_0,
    vr21_16_1,
    vr21_16_2,
    vr21_16_3,
    vr21_16_4,
    vr21_16_5,
    vr21_16_6,
    vr21_16_7,
    vr22_16_0,
    vr22_16_1,
    vr22_16_2,
    vr22_16_3,
    vr22_16_4,
    vr22_16_5,
    vr22_16_6,
    vr22_16_7,
    vr23_16_0,
    vr23_16_1,
    vr23_16_2,
    vr23_16_3,
    vr23_16_4,
    vr23_16_5,
    vr23_16_6,
    vr23_16_7,
    vr24_16_0,
    vr24_16_1,
    vr24_16_2,
    vr24_16_3,
    vr24_16_4,
    vr24_16_5,
    vr24_16_6,
    vr24_16_7,
    vr25_16_0,
    vr25_16_1,
    vr25_16_2,
    vr25_16_3,
    vr25_16_4,
    vr25_16_5,
    vr25_16_6,
    vr25_16_7,
    vr26_16_0,
    vr26_16_1,
    vr26_16_2,
    vr26_16_3,
    vr26_16_4,
    vr26_16_5,
    vr26_16_6,
    vr26_16_7,
    vr27_16_0,
    vr27_16_1,
    vr27_16_2,
    vr27_16_3,
    vr27_16_4,
    vr27_16_5,
    vr27_16_6,
    vr27_16_7,
    vr28_16_0,
    vr28_16_1,
    vr28_16_2,
    vr28_16_3,
    vr28_16_4,
    vr28_16_5,
    vr28_16_6,
    vr28_16_7,
    vr29_16_0,
    vr29_16_1,
    vr29_16_2,
    vr29_16_3,
    vr29_16_4,
    vr29_16_5,
    vr29_16_6,
    vr29_16_7,
    vr30_16_0,
    vr30_16_1,
    vr30_16_2,
    vr30_16_3,
    vr30_16_4,
    vr30_16_5,
    vr30_16_6,
    vr30_16_7,
    vr31_16_0,
    vr31_16_1,
    vr31_16_2,
    vr31_16_3,
    vr31_16_4,
    vr31_16_5,
    vr31_16_6,
    vr31_16_7,
    vr0_8_0,
    vr0_8_1,
    vr0_8_2,
    vr0_8_3,
    vr0_8_4,
    vr0_8_5,
    vr0_8_6,
    vr0_8_7,
    vr0_8_8,
    vr0_8_9,
    vr0_8_10,
    vr0_8_11,
    vr0_8_12,
    vr0_8_13,
    vr0_8_14,
    vr0_8_15,
    vr1_8_0,
    vr1_8_1,
    vr1_8_2,
    vr1_8_3,
    vr1_8_4,
    vr1_8_5,
    vr1_8_6,
    vr1_8_7,
    vr1_8_8,
    vr1_8_9,
    vr1_8_10,
    vr1_8_11,
    vr1_8_12,
    vr1_8_13,
    vr1_8_14,
    vr1_8_15,
    vr2_8_0,
    vr2_8_1,
    vr2_8_2,
    vr2_8_3,
    vr2_8_4,
    vr2_8_5,
    vr2_8_6,
    vr2_8_7,
    vr2_8_8,
    vr2_8_9,
    vr2_8_10,
    vr2_8_11,
    vr2_8_12,
    vr2_8_13,
    vr2_8_14,
    vr2_8_15,
    vr3_8_0,
    vr3_8_1,
    vr3_8_2,
    vr3_8_3,
    vr3_8_4,
    vr3_8_5,
    vr3_8_6,
    vr3_8_7,
    vr3_8_8,
    vr3_8_9,
    vr3_8_10,
    vr3_8_11,
    vr3_8_12,
    vr3_8_13,
    vr3_8_14,
    vr3_8_15,
    vr4_8_0,
    vr4_8_1,
    vr4_8_2,
    vr4_8_3,
    vr4_8_4,
    vr4_8_5,
    vr4_8_6,
    vr4_8_7,
    vr4_8_8,
    vr4_8_9,
    vr4_8_10,
    vr4_8_11,
    vr4_8_12,
    vr4_8_13,
    vr4_8_14,
    vr4_8_15,
    vr5_8_0,
    vr5_8_1,
    vr5_8_2,
    vr5_8_3,
    vr5_8_4,
    vr5_8_5,
    vr5_8_6,
    vr5_8_7,
    vr5_8_8,
    vr5_8_9,
    vr5_8_10,
    vr5_8_11,
    vr5_8_12,
    vr5_8_13,
    vr5_8_14,
    vr5_8_15,
    vr6_8_0,
    vr6_8_1,
    vr6_8_2,
    vr6_8_3,
    vr6_8_4,
    vr6_8_5,
    vr6_8_6,
    vr6_8_7,
    vr6_8_8,
    vr6_8_9,
    vr6_8_10,
    vr6_8_11,
    vr6_8_12,
    vr6_8_13,
    vr6_8_14,
    vr6_8_15,
    vr7_8_0,
    vr7_8_1,
    vr7_8_2,
    vr7_8_3,
    vr7_8_4,
    vr7_8_5,
    vr7_8_6,
    vr7_8_7,
    vr7_8_8,
    vr7_8_9,
    vr7_8_10,
    vr7_8_11,
    vr7_8_12,
    vr7_8_13,
    vr7_8_14,
    vr7_8_15,
    vr8_8_0,
    vr8_8_1,
    vr8_8_2,
    vr8_8_3,
    vr8_8_4,
    vr8_8_5,
    vr8_8_6,
    vr8_8_7,
    vr8_8_8,
    vr8_8_9,
    vr8_8_10,
    vr8_8_11,
    vr8_8_12,
    vr8_8_13,
    vr8_8_14,
    vr8_8_15,
    vr9_8_0,
    vr9_8_1,
    vr9_8_2,
    vr9_8_3,
    vr9_8_4,
    vr9_8_5,
    vr9_8_6,
    vr9_8_7,
    vr9_8_8,
    vr9_8_9,
    vr9_8_10,
    vr9_8_11,
    vr9_8_12,
    vr9_8_13,
    vr9_8_14,
    vr9_8_15,
    vr10_8_0,
    vr10_8_1,
    vr10_8_2,
    vr10_8_3,
    vr10_8_4,
    vr10_8_5,
    vr10_8_6,
    vr10_8_7,
    vr10_8_8,
    vr10_8_9,
    vr10_8_10,
    vr10_8_11,
    vr10_8_12,
    vr10_8_13,
    vr10_8_14,
    vr10_8_15,
    vr11_8_0,
    vr11_8_1,
    vr11_8_2,
    vr11_8_3,
    vr11_8_4,
    vr11_8_5,
    vr11_8_6,
    vr11_8_7,
    vr11_8_8,
    vr11_8_9,
    vr11_8_10,
    vr11_8_11,
    vr11_8_12,
    vr11_8_13,
    vr11_8_14,
    vr11_8_15,
    vr12_8_0,
    vr12_8_1,
    vr12_8_2,
    vr12_8_3,
    vr12_8_4,
    vr12_8_5,
    vr12_8_6,
    vr12_8_7,
    vr12_8_8,
    vr12_8_9,
    vr12_8_10,
    vr12_8_11,
    vr12_8_12,
    vr12_8_13,
    vr12_8_14,
    vr12_8_15,
    vr13_8_0,
    vr13_8_1,
    vr13_8_2,
    vr13_8_3,
    vr13_8_4,
    vr13_8_5,
    vr13_8_6,
    vr13_8_7,
    vr13_8_8,
    vr13_8_9,
    vr13_8_10,
    vr13_8_11,
    vr13_8_12,
    vr13_8_13,
    vr13_8_14,
    vr13_8_15,
    vr14_8_0,
    vr14_8_1,
    vr14_8_2,
    vr14_8_3,
    vr14_8_4,
    vr14_8_5,
    vr14_8_6,
    vr14_8_7,
    vr14_8_8,
    vr14_8_9,
    vr14_8_10,
    vr14_8_11,
    vr14_8_12,
    vr14_8_13,
    vr14_8_14,
    vr14_8_15,
    vr15_8_0,
    vr15_8_1,
    vr15_8_2,
    vr15_8_3,
    vr15_8_4,
    vr15_8_5,
    vr15_8_6,
    vr15_8_7,
    vr15_8_8,
    vr15_8_9,
    vr15_8_10,
    vr15_8_11,
    vr15_8_12,
    vr15_8_13,
    vr15_8_14,
    vr15_8_15,
    vr16_8_0,
    vr16_8_1,
    vr16_8_2,
    vr16_8_3,
    vr16_8_4,
    vr16_8_5,
    vr16_8_6,
    vr16_8_7,
    vr16_8_8,
    vr16_8_9,
    vr16_8_10,
    vr16_8_11,
    vr16_8_12,
    vr16_8_13,
    vr16_8_14,
    vr16_8_15,
    vr17_8_0,
    vr17_8_1,
    vr17_8_2,
    vr17_8_3,
    vr17_8_4,
    vr17_8_5,
    vr17_8_6,
    vr17_8_7,
    vr17_8_8,
    vr17_8_9,
    vr17_8_10,
    vr17_8_11,
    vr17_8_12,
    vr17_8_13,
    vr17_8_14,
    vr17_8_15,
    vr18_8_0,
    vr18_8_1,
    vr18_8_2,
    vr18_8_3,
    vr18_8_4,
    vr18_8_5,
    vr18_8_6,
    vr18_8_7,
    vr18_8_8,
    vr18_8_9,
    vr18_8_10,
    vr18_8_11,
    vr18_8_12,
    vr18_8_13,
    vr18_8_14,
    vr18_8_15,
    vr19_8_0,
    vr19_8_1,
    vr19_8_2,
    vr19_8_3,
    vr19_8_4,
    vr19_8_5,
    vr19_8_6,
    vr19_8_7,
    vr19_8_8,
    vr19_8_9,
    vr19_8_10,
    vr19_8_11,
    vr19_8_12,
    vr19_8_13,
    vr19_8_14,
    vr19_8_15,
    vr20_8_0,
    vr20_8_1,
    vr20_8_2,
    vr20_8_3,
    vr20_8_4,
    vr20_8_5,
    vr20_8_6,
    vr20_8_7,
    vr20_8_8,
    vr20_8_9,
    vr20_8_10,
    vr20_8_11,
    vr20_8_12,
    vr20_8_13,
    vr20_8_14,
    vr20_8_15,
    vr21_8_0,
    vr21_8_1,
    vr21_8_2,
    vr21_8_3,
    vr21_8_4,
    vr21_8_5,
    vr21_8_6,
    vr21_8_7,
    vr21_8_8,
    vr21_8_9,
    vr21_8_10,
    vr21_8_11,
    vr21_8_12,
    vr21_8_13,
    vr21_8_14,
    vr21_8_15,
    vr22_8_0,
    vr22_8_1,
    vr22_8_2,
    vr22_8_3,
    vr22_8_4,
    vr22_8_5,
    vr22_8_6,
    vr22_8_7,
    vr22_8_8,
    vr22_8_9,
    vr22_8_10,
    vr22_8_11,
    vr22_8_12,
    vr22_8_13,
    vr22_8_14,
    vr22_8_15,
    vr23_8_0,
    vr23_8_1,
    vr23_8_2,
    vr23_8_3,
    vr23_8_4,
    vr23_8_5,
    vr23_8_6,
    vr23_8_7,
    vr23_8_8,
    vr23_8_9,
    vr23_8_10,
    vr23_8_11,
    vr23_8_12,
    vr23_8_13,
    vr23_8_14,
    vr23_8_15,
    vr24_8_0,
    vr24_8_1,
    vr24_8_2,
    vr24_8_3,
    vr24_8_4,
    vr24_8_5,
    vr24_8_6,
    vr24_8_7,
    vr24_8_8,
    vr24_8_9,
    vr24_8_10,
    vr24_8_11,
    vr24_8_12,
    vr24_8_13,
    vr24_8_14,
    vr24_8_15,
    vr25_8_0,
    vr25_8_1,
    vr25_8_2,
    vr25_8_3,
    vr25_8_4,
    vr25_8_5,
    vr25_8_6,
    vr25_8_7,
    vr25_8_8,
    vr25_8_9,
    vr25_8_10,
    vr25_8_11,
    vr25_8_12,
    vr25_8_13,
    vr25_8_14,
    vr25_8_15,
    vr26_8_0,
    vr26_8_1,
    vr26_8_2,
    vr26_8_3,
    vr26_8_4,
    vr26_8_5,
    vr26_8_6,
    vr26_8_7,
    vr26_8_8,
    vr26_8_9,
    vr26_8_10,
    vr26_8_11,
    vr26_8_12,
    vr26_8_13,
    vr26_8_14,
    vr26_8_15,
    vr27_8_0,
    vr27_8_1,
    vr27_8_2,
    vr27_8_3,
    vr27_8_4,
    vr27_8_5,
    vr27_8_6,
    vr27_8_7,
    vr27_8_8,
    vr27_8_9,
    vr27_8_10,
    vr27_8_11,
    vr27_8_12,
    vr27_8_13,
    vr27_8_14,
    vr27_8_15,
    vr28_8_0,
    vr28_8_1,
    vr28_8_2,
    vr28_8_3,
    vr28_8_4,
    vr28_8_5,
    vr28_8_6,
    vr28_8_7,
    vr28_8_8,
    vr28_8_9,
    vr28_8_10,
    vr28_8_11,
    vr28_8_12,
    vr28_8_13,
    vr28_8_14,
    vr28_8_15,
    vr29_8_0,
    vr29_8_1,
    vr29_8_2,
    vr29_8_3,
    vr29_8_4,
    vr29_8_5,
    vr29_8_6,
    vr29_8_7,
    vr29_8_8,
    vr29_8_9,
    vr29_8_10,
    vr29_8_11,
    vr29_8_12,
    vr29_8_13,
    vr29_8_14,
    vr29_8_15,
    vr30_8_0,
    vr30_8_1,
    vr30_8_2,
    vr30_8_3,
    vr30_8_4,
    vr30_8_5,
    vr30_8_6,
    vr30_8_7,
    vr30_8_8,
    vr30_8_9,
    vr30_8_10,
    vr30_8_11,
    vr30_8_12,
    vr30_8_13,
    vr30_8_14,
    vr30_8_15,
    vr31_8_0,
    vr31_8_1,
    vr31_8_2,
    vr31_8_3,
    vr31_8_4,
    vr31_8_5,
    vr31_8_6,
    vr31_8_7,
    vr31_8_8,
    vr31_8_9,
    vr31_8_10,
    vr31_8_11,
    vr31_8_12,
    vr31_8_13,
    vr31_8_14,
    vr31_8_15,
    contextreg,
    dcr000,
    dcr001,
    dcr002,
    dcr003,
    dcr004,
    dcr005,
    dcr006,
    dcr007,
    dcr008,
    dcr009,
    dcr00a,
    dcr00b,
    dcr00c,
    dcr00d,
    dcr00e,
    dcr00f,
    dcr010,
    dcr011,
    dcr012,
    dcr013,
    dcr014,
    dcr015,
    dcr016,
    dcr017,
    dcr018,
    dcr019,
    dcr01a,
    dcr01b,
    dcr01c,
    dcr01d,
    dcr01e,
    dcr01f,
    dcr020,
    dcr021,
    dcr022,
    dcr023,
    dcr024,
    dcr025,
    dcr026,
    dcr027,
    dcr028,
    dcr029,
    dcr02a,
    dcr02b,
    dcr02c,
    dcr02d,
    dcr02e,
    dcr02f,
    dcr030,
    dcr031,
    dcr032,
    dcr033,
    dcr034,
    dcr035,
    dcr036,
    dcr037,
    dcr038,
    dcr039,
    dcr03a,
    dcr03b,
    dcr03c,
    dcr03d,
    dcr03e,
    dcr03f,
    dcr040,
    dcr041,
    dcr042,
    dcr043,
    dcr044,
    dcr045,
    dcr046,
    dcr047,
    dcr048,
    dcr049,
    dcr04a,
    dcr04b,
    dcr04c,
    dcr04d,
    dcr04e,
    dcr04f,
    dcr050,
    dcr051,
    dcr052,
    dcr053,
    dcr054,
    dcr055,
    dcr056,
    dcr057,
    dcr058,
    dcr059,
    dcr05a,
    dcr05b,
    dcr05c,
    dcr05d,
    dcr05e,
    dcr05f,
    dcr060,
    dcr061,
    dcr062,
    dcr063,
    dcr064,
    dcr065,
    dcr066,
    dcr067,
    dcr068,
    dcr069,
    dcr06a,
    dcr06b,
    dcr06c,
    dcr06d,
    dcr06e,
    dcr06f,
    dcr070,
    dcr071,
    dcr072,
    dcr073,
    dcr074,
    dcr075,
    dcr076,
    dcr077,
    dcr078,
    dcr079,
    dcr07a,
    dcr07b,
    dcr07c,
    dcr07d,
    dcr07e,
    dcr07f,
    dcr080,
    dcr081,
    dcr082,
    dcr083,
    dcr084,
    dcr085,
    dcr086,
    dcr087,
    dcr088,
    dcr089,
    dcr08a,
    dcr08b,
    dcr08c,
    dcr08d,
    dcr08e,
    dcr08f,
    dcr090,
    dcr091,
    dcr092,
    dcr093,
    dcr094,
    dcr095,
    dcr096,
    dcr097,
    dcr098,
    dcr099,
    dcr09a,
    dcr09b,
    dcr09c,
    dcr09d,
    dcr09e,
    dcr09f,
    dcr0a0,
    dcr0a1,
    dcr0a2,
    dcr0a3,
    dcr0a4,
    dcr0a5,
    dcr0a6,
    dcr0a7,
    dcr0a8,
    dcr0a9,
    dcr0aa,
    dcr0ab,
    dcr0ac,
    dcr0ad,
    dcr0ae,
    dcr0af,
    dcr0b0,
    dcr0b1,
    dcr0b2,
    dcr0b3,
    dcr0b4,
    dcr0b5,
    dcr0b6,
    dcr0b7,
    dcr0b8,
    dcr0b9,
    dcr0ba,
    dcr0bb,
    dcr0bc,
    dcr0bd,
    dcr0be,
    dcr0bf,
    dcr0c0,
    dcr0c1,
    dcr0c2,
    dcr0c3,
    dcr0c4,
    dcr0c5,
    dcr0c6,
    dcr0c7,
    dcr0c8,
    dcr0c9,
    dcr0ca,
    dcr0cb,
    dcr0cc,
    dcr0cd,
    dcr0ce,
    dcr0cf,
    dcr0d0,
    dcr0d1,
    dcr0d2,
    dcr0d3,
    dcr0d4,
    dcr0d5,
    dcr0d6,
    dcr0d7,
    dcr0d8,
    dcr0d9,
    dcr0da,
    dcr0db,
    dcr0dc,
    dcr0dd,
    dcr0de,
    dcr0df,
    dcr0e0,
    dcr0e1,
    dcr0e2,
    dcr0e3,
    dcr0e4,
    dcr0e5,
    dcr0e6,
    dcr0e7,
    dcr0e8,
    dcr0e9,
    dcr0ea,
    dcr0eb,
    dcr0ec,
    dcr0ed,
    dcr0ee,
    dcr0ef,
    dcr0f0,
    dcr0f1,
    dcr0f2,
    dcr0f3,
    dcr0f4,
    dcr0f5,
    dcr0f6,
    dcr0f7,
    dcr0f8,
    dcr0f9,
    dcr0fa,
    dcr0fb,
    dcr0fc,
    dcr0fd,
    dcr0fe,
    dcr0ff,
    dcr100,
    dcr101,
    dcr102,
    dcr103,
    dcr104,
    dcr105,
    dcr106,
    dcr107,
    dcr108,
    dcr109,
    dcr10a,
    dcr10b,
    dcr10c,
    dcr10d,
    dcr10e,
    dcr10f,
    dcr110,
    dcr111,
    dcr112,
    dcr113,
    dcr114,
    dcr115,
    dcr116,
    dcr117,
    dcr118,
    dcr119,
    dcr11a,
    dcr11b,
    dcr11c,
    dcr11d,
    dcr11e,
    dcr11f,
    dcr120,
    dcr121,
    dcr122,
    dcr123,
    dcr124,
    dcr125,
    dcr126,
    dcr127,
    dcr128,
    dcr129,
    dcr12a,
    dcr12b,
    dcr12c,
    dcr12d,
    dcr12e,
    dcr12f,
    dcr130,
    dcr131,
    dcr132,
    dcr133,
    dcr134,
    dcr135,
    dcr136,
    dcr137,
    dcr138,
    dcr139,
    dcr13a,
    dcr13b,
    dcr13c,
    dcr13d,
    dcr13e,
    dcr13f,
    dcr140,
    dcr141,
    dcr142,
    dcr143,
    dcr144,
    dcr145,
    dcr146,
    dcr147,
    dcr148,
    dcr149,
    dcr14a,
    dcr14b,
    dcr14c,
    dcr14d,
    dcr14e,
    dcr14f,
    dcr150,
    dcr151,
    dcr152,
    dcr153,
    dcr154,
    dcr155,
    dcr156,
    dcr157,
    dcr158,
    dcr159,
    dcr15a,
    dcr15b,
    dcr15c,
    dcr15d,
    dcr15e,
    dcr15f,
    dcr160,
    dcr161,
    dcr162,
    dcr163,
    dcr164,
    dcr165,
    dcr166,
    dcr167,
    dcr168,
    dcr169,
    dcr16a,
    dcr16b,
    dcr16c,
    dcr16d,
    dcr16e,
    dcr16f,
    dcr170,
    dcr171,
    dcr172,
    dcr173,
    dcr174,
    dcr175,
    dcr176,
    dcr177,
    dcr178,
    dcr179,
    dcr17a,
    dcr17b,
    dcr17c,
    dcr17d,
    dcr17e,
    dcr17f,
    dcr180,
    dcr181,
    dcr182,
    dcr183,
    dcr184,
    dcr185,
    dcr186,
    dcr187,
    dcr188,
    dcr189,
    dcr18a,
    dcr18b,
    dcr18c,
    dcr18d,
    dcr18e,
    dcr18f,
    dcr190,
    dcr191,
    dcr192,
    dcr193,
    dcr194,
    dcr195,
    dcr196,
    dcr197,
    dcr198,
    dcr199,
    dcr19a,
    dcr19b,
    dcr19c,
    dcr19d,
    dcr19e,
    dcr19f,
    dcr1a0,
    dcr1a1,
    dcr1a2,
    dcr1a3,
    dcr1a4,
    dcr1a5,
    dcr1a6,
    dcr1a7,
    dcr1a8,
    dcr1a9,
    dcr1aa,
    dcr1ab,
    dcr1ac,
    dcr1ad,
    dcr1ae,
    dcr1af,
    dcr1b0,
    dcr1b1,
    dcr1b2,
    dcr1b3,
    dcr1b4,
    dcr1b5,
    dcr1b6,
    dcr1b7,
    dcr1b8,
    dcr1b9,
    dcr1ba,
    dcr1bb,
    dcr1bc,
    dcr1bd,
    dcr1be,
    dcr1bf,
    dcr1c0,
    dcr1c1,
    dcr1c2,
    dcr1c3,
    dcr1c4,
    dcr1c5,
    dcr1c6,
    dcr1c7,
    dcr1c8,
    dcr1c9,
    dcr1ca,
    dcr1cb,
    dcr1cc,
    dcr1cd,
    dcr1ce,
    dcr1cf,
    dcr1d0,
    dcr1d1,
    dcr1d2,
    dcr1d3,
    dcr1d4,
    dcr1d5,
    dcr1d6,
    dcr1d7,
    dcr1d8,
    dcr1d9,
    dcr1da,
    dcr1db,
    dcr1dc,
    dcr1dd,
    dcr1de,
    dcr1df,
    dcr1e0,
    dcr1e1,
    dcr1e2,
    dcr1e3,
    dcr1e4,
    dcr1e5,
    dcr1e6,
    dcr1e7,
    dcr1e8,
    dcr1e9,
    dcr1ea,
    dcr1eb,
    dcr1ec,
    dcr1ed,
    dcr1ee,
    dcr1ef,
    dcr1f0,
    dcr1f1,
    dcr1f2,
    dcr1f3,
    dcr1f4,
    dcr1f5,
    dcr1f6,
    dcr1f7,
    dcr1f8,
    dcr1f9,
    dcr1fa,
    dcr1fb,
    dcr1fc,
    dcr1fd,
    dcr1fe,
    dcr1ff,
    dcr200,
    dcr201,
    dcr202,
    dcr203,
    dcr204,
    dcr205,
    dcr206,
    dcr207,
    dcr208,
    dcr209,
    dcr20a,
    dcr20b,
    dcr20c,
    dcr20d,
    dcr20e,
    dcr20f,
    dcr210,
    dcr211,
    dcr212,
    dcr213,
    dcr214,
    dcr215,
    dcr216,
    dcr217,
    dcr218,
    dcr219,
    dcr21a,
    dcr21b,
    dcr21c,
    dcr21d,
    dcr21e,
    dcr21f,
    dcr220,
    dcr221,
    dcr222,
    dcr223,
    dcr224,
    dcr225,
    dcr226,
    dcr227,
    dcr228,
    dcr229,
    dcr22a,
    dcr22b,
    dcr22c,
    dcr22d,
    dcr22e,
    dcr22f,
    dcr230,
    dcr231,
    dcr232,
    dcr233,
    dcr234,
    dcr235,
    dcr236,
    dcr237,
    dcr238,
    dcr239,
    dcr23a,
    dcr23b,
    dcr23c,
    dcr23d,
    dcr23e,
    dcr23f,
    dcr240,
    dcr241,
    dcr242,
    dcr243,
    dcr244,
    dcr245,
    dcr246,
    dcr247,
    dcr248,
    dcr249,
    dcr24a,
    dcr24b,
    dcr24c,
    dcr24d,
    dcr24e,
    dcr24f,
    dcr250,
    dcr251,
    dcr252,
    dcr253,
    dcr254,
    dcr255,
    dcr256,
    dcr257,
    dcr258,
    dcr259,
    dcr25a,
    dcr25b,
    dcr25c,
    dcr25d,
    dcr25e,
    dcr25f,
    dcr260,
    dcr261,
    dcr262,
    dcr263,
    dcr264,
    dcr265,
    dcr266,
    dcr267,
    dcr268,
    dcr269,
    dcr26a,
    dcr26b,
    dcr26c,
    dcr26d,
    dcr26e,
    dcr26f,
    dcr270,
    dcr271,
    dcr272,
    dcr273,
    dcr274,
    dcr275,
    dcr276,
    dcr277,
    dcr278,
    dcr279,
    dcr27a,
    dcr27b,
    dcr27c,
    dcr27d,
    dcr27e,
    dcr27f,
    dcr280,
    dcr281,
    dcr282,
    dcr283,
    dcr284,
    dcr285,
    dcr286,
    dcr287,
    dcr288,
    dcr289,
    dcr28a,
    dcr28b,
    dcr28c,
    dcr28d,
    dcr28e,
    dcr28f,
    dcr290,
    dcr291,
    dcr292,
    dcr293,
    dcr294,
    dcr295,
    dcr296,
    dcr297,
    dcr298,
    dcr299,
    dcr29a,
    dcr29b,
    dcr29c,
    dcr29d,
    dcr29e,
    dcr29f,
    dcr2a0,
    dcr2a1,
    dcr2a2,
    dcr2a3,
    dcr2a4,
    dcr2a5,
    dcr2a6,
    dcr2a7,
    dcr2a8,
    dcr2a9,
    dcr2aa,
    dcr2ab,
    dcr2ac,
    dcr2ad,
    dcr2ae,
    dcr2af,
    dcr2b0,
    dcr2b1,
    dcr2b2,
    dcr2b3,
    dcr2b4,
    dcr2b5,
    dcr2b6,
    dcr2b7,
    dcr2b8,
    dcr2b9,
    dcr2ba,
    dcr2bb,
    dcr2bc,
    dcr2bd,
    dcr2be,
    dcr2bf,
    dcr2c0,
    dcr2c1,
    dcr2c2,
    dcr2c3,
    dcr2c4,
    dcr2c5,
    dcr2c6,
    dcr2c7,
    dcr2c8,
    dcr2c9,
    dcr2ca,
    dcr2cb,
    dcr2cc,
    dcr2cd,
    dcr2ce,
    dcr2cf,
    dcr2d0,
    dcr2d1,
    dcr2d2,
    dcr2d3,
    dcr2d4,
    dcr2d5,
    dcr2d6,
    dcr2d7,
    dcr2d8,
    dcr2d9,
    dcr2da,
    dcr2db,
    dcr2dc,
    dcr2dd,
    dcr2de,
    dcr2df,
    dcr2e0,
    dcr2e1,
    dcr2e2,
    dcr2e3,
    dcr2e4,
    dcr2e5,
    dcr2e6,
    dcr2e7,
    dcr2e8,
    dcr2e9,
    dcr2ea,
    dcr2eb,
    dcr2ec,
    dcr2ed,
    dcr2ee,
    dcr2ef,
    dcr2f0,
    dcr2f1,
    dcr2f2,
    dcr2f3,
    dcr2f4,
    dcr2f5,
    dcr2f6,
    dcr2f7,
    dcr2f8,
    dcr2f9,
    dcr2fa,
    dcr2fb,
    dcr2fc,
    dcr2fd,
    dcr2fe,
    dcr2ff,
    dcr300,
    dcr301,
    dcr302,
    dcr303,
    dcr304,
    dcr305,
    dcr306,
    dcr307,
    dcr308,
    dcr309,
    dcr30a,
    dcr30b,
    dcr30c,
    dcr30d,
    dcr30e,
    dcr30f,
    dcr310,
    dcr311,
    dcr312,
    dcr313,
    dcr314,
    dcr315,
    dcr316,
    dcr317,
    dcr318,
    dcr319,
    dcr31a,
    dcr31b,
    dcr31c,
    dcr31d,
    dcr31e,
    dcr31f,
    dcr320,
    dcr321,
    dcr322,
    dcr323,
    dcr324,
    dcr325,
    dcr326,
    dcr327,
    dcr328,
    dcr329,
    dcr32a,
    dcr32b,
    dcr32c,
    dcr32d,
    dcr32e,
    dcr32f,
    dcr330,
    dcr331,
    dcr332,
    dcr333,
    dcr334,
    dcr335,
    dcr336,
    dcr337,
    dcr338,
    dcr339,
    dcr33a,
    dcr33b,
    dcr33c,
    dcr33d,
    dcr33e,
    dcr33f,
    dcr340,
    dcr341,
    dcr342,
    dcr343,
    dcr344,
    dcr345,
    dcr346,
    dcr347,
    dcr348,
    dcr349,
    dcr34a,
    dcr34b,
    dcr34c,
    dcr34d,
    dcr34e,
    dcr34f,
    dcr350,
    dcr351,
    dcr352,
    dcr353,
    dcr354,
    dcr355,
    dcr356,
    dcr357,
    dcr358,
    dcr359,
    dcr35a,
    dcr35b,
    dcr35c,
    dcr35d,
    dcr35e,
    dcr35f,
    dcr360,
    dcr361,
    dcr362,
    dcr363,
    dcr364,
    dcr365,
    dcr366,
    dcr367,
    dcr368,
    dcr369,
    dcr36a,
    dcr36b,
    dcr36c,
    dcr36d,
    dcr36e,
    dcr36f,
    dcr370,
    dcr371,
    dcr372,
    dcr373,
    dcr374,
    dcr375,
    dcr376,
    dcr377,
    dcr378,
    dcr379,
    dcr37a,
    dcr37b,
    dcr37c,
    dcr37d,
    dcr37e,
    dcr37f,
    dcr380,
    dcr381,
    dcr382,
    dcr383,
    dcr384,
    dcr385,
    dcr386,
    dcr387,
    dcr388,
    dcr389,
    dcr38a,
    dcr38b,
    dcr38c,
    dcr38d,
    dcr38e,
    dcr38f,
    dcr390,
    dcr391,
    dcr392,
    dcr393,
    dcr394,
    dcr395,
    dcr396,
    dcr397,
    dcr398,
    dcr399,
    dcr39a,
    dcr39b,
    dcr39c,
    dcr39d,
    dcr39e,
    dcr39f,
    dcr3a0,
    dcr3a1,
    dcr3a2,
    dcr3a3,
    dcr3a4,
    dcr3a5,
    dcr3a6,
    dcr3a7,
    dcr3a8,
    dcr3a9,
    dcr3aa,
    dcr3ab,
    dcr3ac,
    dcr3ad,
    dcr3ae,
    dcr3af,
    dcr3b0,
    dcr3b1,
    dcr3b2,
    dcr3b3,
    dcr3b4,
    dcr3b5,
    dcr3b6,
    dcr3b7,
    dcr3b8,
    dcr3b9,
    dcr3ba,
    dcr3bb,
    dcr3bc,
    dcr3bd,
    dcr3be,
    dcr3bf,
    dcr3c0,
    dcr3c1,
    dcr3c2,
    dcr3c3,
    dcr3c4,
    dcr3c5,
    dcr3c6,
    dcr3c7,
    dcr3c8,
    dcr3c9,
    dcr3ca,
    dcr3cb,
    dcr3cc,
    dcr3cd,
    dcr3ce,
    dcr3cf,
    dcr3d0,
    dcr3d1,
    dcr3d2,
    dcr3d3,
    dcr3d4,
    dcr3d5,
    dcr3d6,
    dcr3d7,
    dcr3d8,
    dcr3d9,
    dcr3da,
    dcr3db,
    dcr3dc,
    dcr3dd,
    dcr3de,
    dcr3df,
    dcr3e0,
    dcr3e1,
    dcr3e2,
    dcr3e3,
    dcr3e4,
    dcr3e5,
    dcr3e6,
    dcr3e7,
    dcr3e8,
    dcr3e9,
    dcr3ea,
    dcr3eb,
    dcr3ec,
    dcr3ed,
    dcr3ee,
    dcr3ef,
    dcr3f0,
    dcr3f1,
    dcr3f2,
    dcr3f3,
    dcr3f4,
    dcr3f5,
    dcr3f6,
    dcr3f7,
    dcr3f8,
    dcr3f9,
    dcr3fa,
    dcr3fb,
    dcr3fc,
    dcr3fd,
    dcr3fe,
    dcr3ff,
    ACC,
}
impl core::fmt::Display for Register {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::r0 => write!(f, "r0"),
            Self::r1 => write!(f, "r1"),
            Self::r2 => write!(f, "r2"),
            Self::r3 => write!(f, "r3"),
            Self::r4 => write!(f, "r4"),
            Self::r5 => write!(f, "r5"),
            Self::r6 => write!(f, "r6"),
            Self::r7 => write!(f, "r7"),
            Self::r8 => write!(f, "r8"),
            Self::r9 => write!(f, "r9"),
            Self::r10 => write!(f, "r10"),
            Self::r11 => write!(f, "r11"),
            Self::r12 => write!(f, "r12"),
            Self::r13 => write!(f, "r13"),
            Self::r14 => write!(f, "r14"),
            Self::r15 => write!(f, "r15"),
            Self::r16 => write!(f, "r16"),
            Self::r17 => write!(f, "r17"),
            Self::r18 => write!(f, "r18"),
            Self::r19 => write!(f, "r19"),
            Self::r20 => write!(f, "r20"),
            Self::r21 => write!(f, "r21"),
            Self::r22 => write!(f, "r22"),
            Self::r23 => write!(f, "r23"),
            Self::r24 => write!(f, "r24"),
            Self::r25 => write!(f, "r25"),
            Self::r26 => write!(f, "r26"),
            Self::r27 => write!(f, "r27"),
            Self::r28 => write!(f, "r28"),
            Self::r29 => write!(f, "r29"),
            Self::r30 => write!(f, "r30"),
            Self::r31 => write!(f, "r31"),
            Self::xer_so => write!(f, "xer_so"),
            Self::xer_ov => write!(f, "xer_ov"),
            Self::xer_ov32 => write!(f, "xer_ov32"),
            Self::xer_ca => write!(f, "xer_ca"),
            Self::xer_ca32 => write!(f, "xer_ca32"),
            Self::xer_count => write!(f, "xer_count"),
            Self::fp_fx => write!(f, "fp_fx"),
            Self::fp_fex => write!(f, "fp_fex"),
            Self::fp_vx => write!(f, "fp_vx"),
            Self::fp_ox => write!(f, "fp_ox"),
            Self::fp_ux => write!(f, "fp_ux"),
            Self::fp_zx => write!(f, "fp_zx"),
            Self::fp_xx => write!(f, "fp_xx"),
            Self::fp_vxsnan => write!(f, "fp_vxsnan"),
            Self::fp_vxisi => write!(f, "fp_vxisi"),
            Self::fp_vxidi => write!(f, "fp_vxidi"),
            Self::fp_vxzdz => write!(f, "fp_vxzdz"),
            Self::fp_vximz => write!(f, "fp_vximz"),
            Self::fp_vxvc => write!(f, "fp_vxvc"),
            Self::fp_fr => write!(f, "fp_fr"),
            Self::fp_fi => write!(f, "fp_fi"),
            Self::fp_c => write!(f, "fp_c"),
            Self::fp_cc0 => write!(f, "fp_cc0"),
            Self::fp_cc1 => write!(f, "fp_cc1"),
            Self::fp_cc2 => write!(f, "fp_cc2"),
            Self::fp_cc3 => write!(f, "fp_cc3"),
            Self::fp_reserve1 => write!(f, "fp_reserve1"),
            Self::fp_vxsoft => write!(f, "fp_vxsoft"),
            Self::fp_vxsqrt => write!(f, "fp_vxsqrt"),
            Self::fp_vxcvi => write!(f, "fp_vxcvi"),
            Self::fp_ve => write!(f, "fp_ve"),
            Self::fp_oe => write!(f, "fp_oe"),
            Self::fp_ue => write!(f, "fp_ue"),
            Self::fp_ze => write!(f, "fp_ze"),
            Self::fp_xe => write!(f, "fp_xe"),
            Self::fp_ni => write!(f, "fp_ni"),
            Self::fp_rn0 => write!(f, "fp_rn0"),
            Self::fp_rn1 => write!(f, "fp_rn1"),
            Self::MSR => write!(f, "MSR"),
            Self::RESERVE_ADDRESS => write!(f, "RESERVE_ADDRESS"),
            Self::RESERVE => write!(f, "RESERVE"),
            Self::RESERVE_LENGTH => write!(f, "RESERVE_LENGTH"),
            Self::pc => write!(f, "pc"),
            Self::sr0 => write!(f, "sr0"),
            Self::sr1 => write!(f, "sr1"),
            Self::sr2 => write!(f, "sr2"),
            Self::sr3 => write!(f, "sr3"),
            Self::sr4 => write!(f, "sr4"),
            Self::sr5 => write!(f, "sr5"),
            Self::sr6 => write!(f, "sr6"),
            Self::sr7 => write!(f, "sr7"),
            Self::sr8 => write!(f, "sr8"),
            Self::sr9 => write!(f, "sr9"),
            Self::sr10 => write!(f, "sr10"),
            Self::sr11 => write!(f, "sr11"),
            Self::sr12 => write!(f, "sr12"),
            Self::sr13 => write!(f, "sr13"),
            Self::sr14 => write!(f, "sr14"),
            Self::sr15 => write!(f, "sr15"),
            Self::cr0 => write!(f, "cr0"),
            Self::cr1 => write!(f, "cr1"),
            Self::cr2 => write!(f, "cr2"),
            Self::cr3 => write!(f, "cr3"),
            Self::cr4 => write!(f, "cr4"),
            Self::cr5 => write!(f, "cr5"),
            Self::cr6 => write!(f, "cr6"),
            Self::cr7 => write!(f, "cr7"),
            Self::crall => write!(f, "crall"),
            Self::tea => write!(f, "tea"),
            Self::r2Save => write!(f, "r2Save"),
            Self::spr000 => write!(f, "spr000"),
            Self::XER => write!(f, "XER"),
            Self::spr002 => write!(f, "spr002"),
            Self::spr003 => write!(f, "spr003"),
            Self::spr004 => write!(f, "spr004"),
            Self::spr005 => write!(f, "spr005"),
            Self::spr006 => write!(f, "spr006"),
            Self::spr007 => write!(f, "spr007"),
            Self::LR => write!(f, "LR"),
            Self::CTR => write!(f, "CTR"),
            Self::spr00a => write!(f, "spr00a"),
            Self::spr00b => write!(f, "spr00b"),
            Self::spr00c => write!(f, "spr00c"),
            Self::spr00d => write!(f, "spr00d"),
            Self::spr00e => write!(f, "spr00e"),
            Self::spr00f => write!(f, "spr00f"),
            Self::spr010 => write!(f, "spr010"),
            Self::spr011 => write!(f, "spr011"),
            Self::spr012 => write!(f, "spr012"),
            Self::spr013 => write!(f, "spr013"),
            Self::spr014 => write!(f, "spr014"),
            Self::spr015 => write!(f, "spr015"),
            Self::spr016 => write!(f, "spr016"),
            Self::spr017 => write!(f, "spr017"),
            Self::spr018 => write!(f, "spr018"),
            Self::spr019 => write!(f, "spr019"),
            Self::SRR0 => write!(f, "SRR0"),
            Self::SRR1 => write!(f, "SRR1"),
            Self::spr01c => write!(f, "spr01c"),
            Self::spr01d => write!(f, "spr01d"),
            Self::spr01e => write!(f, "spr01e"),
            Self::spr01f => write!(f, "spr01f"),
            Self::spr020 => write!(f, "spr020"),
            Self::spr021 => write!(f, "spr021"),
            Self::spr022 => write!(f, "spr022"),
            Self::spr023 => write!(f, "spr023"),
            Self::spr024 => write!(f, "spr024"),
            Self::spr025 => write!(f, "spr025"),
            Self::spr026 => write!(f, "spr026"),
            Self::spr027 => write!(f, "spr027"),
            Self::spr028 => write!(f, "spr028"),
            Self::spr029 => write!(f, "spr029"),
            Self::spr02a => write!(f, "spr02a"),
            Self::spr02b => write!(f, "spr02b"),
            Self::spr02c => write!(f, "spr02c"),
            Self::spr02d => write!(f, "spr02d"),
            Self::spr02e => write!(f, "spr02e"),
            Self::spr02f => write!(f, "spr02f"),
            Self::spr030 => write!(f, "spr030"),
            Self::spr031 => write!(f, "spr031"),
            Self::spr032 => write!(f, "spr032"),
            Self::spr033 => write!(f, "spr033"),
            Self::spr034 => write!(f, "spr034"),
            Self::spr035 => write!(f, "spr035"),
            Self::spr036 => write!(f, "spr036"),
            Self::spr037 => write!(f, "spr037"),
            Self::spr038 => write!(f, "spr038"),
            Self::spr039 => write!(f, "spr039"),
            Self::CSRR0 => write!(f, "CSRR0"),
            Self::CSRR1 => write!(f, "CSRR1"),
            Self::spr03c => write!(f, "spr03c"),
            Self::spr03d => write!(f, "spr03d"),
            Self::spr03e => write!(f, "spr03e"),
            Self::spr03f => write!(f, "spr03f"),
            Self::spr040 => write!(f, "spr040"),
            Self::spr041 => write!(f, "spr041"),
            Self::spr042 => write!(f, "spr042"),
            Self::spr043 => write!(f, "spr043"),
            Self::spr044 => write!(f, "spr044"),
            Self::spr045 => write!(f, "spr045"),
            Self::spr046 => write!(f, "spr046"),
            Self::spr047 => write!(f, "spr047"),
            Self::spr048 => write!(f, "spr048"),
            Self::spr049 => write!(f, "spr049"),
            Self::spr04a => write!(f, "spr04a"),
            Self::spr04b => write!(f, "spr04b"),
            Self::spr04c => write!(f, "spr04c"),
            Self::spr04d => write!(f, "spr04d"),
            Self::spr04e => write!(f, "spr04e"),
            Self::spr04f => write!(f, "spr04f"),
            Self::spr050 => write!(f, "spr050"),
            Self::spr051 => write!(f, "spr051"),
            Self::spr052 => write!(f, "spr052"),
            Self::spr053 => write!(f, "spr053"),
            Self::spr054 => write!(f, "spr054"),
            Self::spr055 => write!(f, "spr055"),
            Self::spr056 => write!(f, "spr056"),
            Self::spr057 => write!(f, "spr057"),
            Self::spr058 => write!(f, "spr058"),
            Self::spr059 => write!(f, "spr059"),
            Self::spr05a => write!(f, "spr05a"),
            Self::spr05b => write!(f, "spr05b"),
            Self::spr05c => write!(f, "spr05c"),
            Self::spr05d => write!(f, "spr05d"),
            Self::spr05e => write!(f, "spr05e"),
            Self::spr05f => write!(f, "spr05f"),
            Self::spr060 => write!(f, "spr060"),
            Self::spr061 => write!(f, "spr061"),
            Self::spr062 => write!(f, "spr062"),
            Self::spr063 => write!(f, "spr063"),
            Self::spr064 => write!(f, "spr064"),
            Self::spr065 => write!(f, "spr065"),
            Self::spr066 => write!(f, "spr066"),
            Self::spr067 => write!(f, "spr067"),
            Self::spr068 => write!(f, "spr068"),
            Self::spr069 => write!(f, "spr069"),
            Self::spr06a => write!(f, "spr06a"),
            Self::spr06b => write!(f, "spr06b"),
            Self::spr06c => write!(f, "spr06c"),
            Self::spr06d => write!(f, "spr06d"),
            Self::spr06e => write!(f, "spr06e"),
            Self::spr06f => write!(f, "spr06f"),
            Self::spr070 => write!(f, "spr070"),
            Self::spr071 => write!(f, "spr071"),
            Self::spr072 => write!(f, "spr072"),
            Self::spr073 => write!(f, "spr073"),
            Self::spr074 => write!(f, "spr074"),
            Self::spr075 => write!(f, "spr075"),
            Self::spr076 => write!(f, "spr076"),
            Self::spr077 => write!(f, "spr077"),
            Self::spr078 => write!(f, "spr078"),
            Self::spr079 => write!(f, "spr079"),
            Self::spr07a => write!(f, "spr07a"),
            Self::spr07b => write!(f, "spr07b"),
            Self::spr07c => write!(f, "spr07c"),
            Self::spr07d => write!(f, "spr07d"),
            Self::spr07e => write!(f, "spr07e"),
            Self::spr07f => write!(f, "spr07f"),
            Self::spr080 => write!(f, "spr080"),
            Self::spr081 => write!(f, "spr081"),
            Self::spr082 => write!(f, "spr082"),
            Self::spr083 => write!(f, "spr083"),
            Self::spr084 => write!(f, "spr084"),
            Self::spr085 => write!(f, "spr085"),
            Self::spr086 => write!(f, "spr086"),
            Self::spr087 => write!(f, "spr087"),
            Self::spr088 => write!(f, "spr088"),
            Self::spr089 => write!(f, "spr089"),
            Self::spr08a => write!(f, "spr08a"),
            Self::spr08b => write!(f, "spr08b"),
            Self::spr08c => write!(f, "spr08c"),
            Self::spr08d => write!(f, "spr08d"),
            Self::spr08e => write!(f, "spr08e"),
            Self::spr08f => write!(f, "spr08f"),
            Self::spr090 => write!(f, "spr090"),
            Self::spr091 => write!(f, "spr091"),
            Self::spr092 => write!(f, "spr092"),
            Self::spr093 => write!(f, "spr093"),
            Self::spr094 => write!(f, "spr094"),
            Self::spr095 => write!(f, "spr095"),
            Self::spr096 => write!(f, "spr096"),
            Self::spr097 => write!(f, "spr097"),
            Self::spr098 => write!(f, "spr098"),
            Self::spr099 => write!(f, "spr099"),
            Self::spr09a => write!(f, "spr09a"),
            Self::spr09b => write!(f, "spr09b"),
            Self::spr09c => write!(f, "spr09c"),
            Self::spr09d => write!(f, "spr09d"),
            Self::spr09e => write!(f, "spr09e"),
            Self::spr09f => write!(f, "spr09f"),
            Self::spr0a0 => write!(f, "spr0a0"),
            Self::spr0a1 => write!(f, "spr0a1"),
            Self::spr0a2 => write!(f, "spr0a2"),
            Self::spr0a3 => write!(f, "spr0a3"),
            Self::spr0a4 => write!(f, "spr0a4"),
            Self::spr0a5 => write!(f, "spr0a5"),
            Self::spr0a6 => write!(f, "spr0a6"),
            Self::spr0a7 => write!(f, "spr0a7"),
            Self::spr0a8 => write!(f, "spr0a8"),
            Self::spr0a9 => write!(f, "spr0a9"),
            Self::spr0aa => write!(f, "spr0aa"),
            Self::spr0ab => write!(f, "spr0ab"),
            Self::spr0ac => write!(f, "spr0ac"),
            Self::spr0ad => write!(f, "spr0ad"),
            Self::spr0ae => write!(f, "spr0ae"),
            Self::spr0af => write!(f, "spr0af"),
            Self::spr0b0 => write!(f, "spr0b0"),
            Self::spr0b1 => write!(f, "spr0b1"),
            Self::spr0b2 => write!(f, "spr0b2"),
            Self::spr0b3 => write!(f, "spr0b3"),
            Self::spr0b4 => write!(f, "spr0b4"),
            Self::spr0b5 => write!(f, "spr0b5"),
            Self::spr0b6 => write!(f, "spr0b6"),
            Self::spr0b7 => write!(f, "spr0b7"),
            Self::spr0b8 => write!(f, "spr0b8"),
            Self::spr0b9 => write!(f, "spr0b9"),
            Self::spr0ba => write!(f, "spr0ba"),
            Self::spr0bb => write!(f, "spr0bb"),
            Self::spr0bc => write!(f, "spr0bc"),
            Self::spr0bd => write!(f, "spr0bd"),
            Self::spr0be => write!(f, "spr0be"),
            Self::spr0bf => write!(f, "spr0bf"),
            Self::spr0c0 => write!(f, "spr0c0"),
            Self::spr0c1 => write!(f, "spr0c1"),
            Self::spr0c2 => write!(f, "spr0c2"),
            Self::spr0c3 => write!(f, "spr0c3"),
            Self::spr0c4 => write!(f, "spr0c4"),
            Self::spr0c5 => write!(f, "spr0c5"),
            Self::spr0c6 => write!(f, "spr0c6"),
            Self::spr0c7 => write!(f, "spr0c7"),
            Self::spr0c8 => write!(f, "spr0c8"),
            Self::spr0c9 => write!(f, "spr0c9"),
            Self::spr0ca => write!(f, "spr0ca"),
            Self::spr0cb => write!(f, "spr0cb"),
            Self::spr0cc => write!(f, "spr0cc"),
            Self::spr0cd => write!(f, "spr0cd"),
            Self::spr0ce => write!(f, "spr0ce"),
            Self::spr0cf => write!(f, "spr0cf"),
            Self::spr0d0 => write!(f, "spr0d0"),
            Self::spr0d1 => write!(f, "spr0d1"),
            Self::spr0d2 => write!(f, "spr0d2"),
            Self::spr0d3 => write!(f, "spr0d3"),
            Self::spr0d4 => write!(f, "spr0d4"),
            Self::spr0d5 => write!(f, "spr0d5"),
            Self::spr0d6 => write!(f, "spr0d6"),
            Self::spr0d7 => write!(f, "spr0d7"),
            Self::spr0d8 => write!(f, "spr0d8"),
            Self::spr0d9 => write!(f, "spr0d9"),
            Self::spr0da => write!(f, "spr0da"),
            Self::spr0db => write!(f, "spr0db"),
            Self::spr0dc => write!(f, "spr0dc"),
            Self::spr0dd => write!(f, "spr0dd"),
            Self::spr0de => write!(f, "spr0de"),
            Self::spr0df => write!(f, "spr0df"),
            Self::spr0e0 => write!(f, "spr0e0"),
            Self::spr0e1 => write!(f, "spr0e1"),
            Self::spr0e2 => write!(f, "spr0e2"),
            Self::spr0e3 => write!(f, "spr0e3"),
            Self::spr0e4 => write!(f, "spr0e4"),
            Self::spr0e5 => write!(f, "spr0e5"),
            Self::spr0e6 => write!(f, "spr0e6"),
            Self::spr0e7 => write!(f, "spr0e7"),
            Self::spr0e8 => write!(f, "spr0e8"),
            Self::spr0e9 => write!(f, "spr0e9"),
            Self::spr0ea => write!(f, "spr0ea"),
            Self::spr0eb => write!(f, "spr0eb"),
            Self::spr0ec => write!(f, "spr0ec"),
            Self::spr0ed => write!(f, "spr0ed"),
            Self::spr0ee => write!(f, "spr0ee"),
            Self::spr0ef => write!(f, "spr0ef"),
            Self::spr0f0 => write!(f, "spr0f0"),
            Self::spr0f1 => write!(f, "spr0f1"),
            Self::spr0f2 => write!(f, "spr0f2"),
            Self::spr0f3 => write!(f, "spr0f3"),
            Self::spr0f4 => write!(f, "spr0f4"),
            Self::spr0f5 => write!(f, "spr0f5"),
            Self::spr0f6 => write!(f, "spr0f6"),
            Self::spr0f7 => write!(f, "spr0f7"),
            Self::spr0f8 => write!(f, "spr0f8"),
            Self::spr0f9 => write!(f, "spr0f9"),
            Self::spr0fa => write!(f, "spr0fa"),
            Self::spr0fb => write!(f, "spr0fb"),
            Self::spr0fc => write!(f, "spr0fc"),
            Self::spr0fd => write!(f, "spr0fd"),
            Self::spr0fe => write!(f, "spr0fe"),
            Self::spr0ff => write!(f, "spr0ff"),
            Self::spr100 => write!(f, "spr100"),
            Self::spr101 => write!(f, "spr101"),
            Self::spr102 => write!(f, "spr102"),
            Self::spr103 => write!(f, "spr103"),
            Self::spr104 => write!(f, "spr104"),
            Self::spr105 => write!(f, "spr105"),
            Self::spr106 => write!(f, "spr106"),
            Self::spr107 => write!(f, "spr107"),
            Self::spr108 => write!(f, "spr108"),
            Self::spr109 => write!(f, "spr109"),
            Self::spr10a => write!(f, "spr10a"),
            Self::spr10b => write!(f, "spr10b"),
            Self::TBLr => write!(f, "TBLr"),
            Self::TBUr => write!(f, "TBUr"),
            Self::spr10e => write!(f, "spr10e"),
            Self::spr10f => write!(f, "spr10f"),
            Self::spr110 => write!(f, "spr110"),
            Self::spr111 => write!(f, "spr111"),
            Self::spr112 => write!(f, "spr112"),
            Self::spr113 => write!(f, "spr113"),
            Self::spr114 => write!(f, "spr114"),
            Self::spr115 => write!(f, "spr115"),
            Self::spr116 => write!(f, "spr116"),
            Self::spr117 => write!(f, "spr117"),
            Self::spr118 => write!(f, "spr118"),
            Self::spr119 => write!(f, "spr119"),
            Self::spr11a => write!(f, "spr11a"),
            Self::spr11b => write!(f, "spr11b"),
            Self::TBLw => write!(f, "TBLw"),
            Self::TBUw => write!(f, "TBUw"),
            Self::spr11e => write!(f, "spr11e"),
            Self::spr11f => write!(f, "spr11f"),
            Self::spr120 => write!(f, "spr120"),
            Self::spr121 => write!(f, "spr121"),
            Self::spr122 => write!(f, "spr122"),
            Self::spr123 => write!(f, "spr123"),
            Self::spr124 => write!(f, "spr124"),
            Self::spr125 => write!(f, "spr125"),
            Self::spr126 => write!(f, "spr126"),
            Self::spr127 => write!(f, "spr127"),
            Self::spr128 => write!(f, "spr128"),
            Self::spr129 => write!(f, "spr129"),
            Self::spr12a => write!(f, "spr12a"),
            Self::spr12b => write!(f, "spr12b"),
            Self::spr12c => write!(f, "spr12c"),
            Self::spr12d => write!(f, "spr12d"),
            Self::spr12e => write!(f, "spr12e"),
            Self::spr12f => write!(f, "spr12f"),
            Self::spr130 => write!(f, "spr130"),
            Self::spr131 => write!(f, "spr131"),
            Self::spr132 => write!(f, "spr132"),
            Self::spr133 => write!(f, "spr133"),
            Self::spr134 => write!(f, "spr134"),
            Self::spr135 => write!(f, "spr135"),
            Self::spr136 => write!(f, "spr136"),
            Self::spr137 => write!(f, "spr137"),
            Self::spr138 => write!(f, "spr138"),
            Self::spr139 => write!(f, "spr139"),
            Self::spr13a => write!(f, "spr13a"),
            Self::spr13b => write!(f, "spr13b"),
            Self::spr13c => write!(f, "spr13c"),
            Self::spr13d => write!(f, "spr13d"),
            Self::spr13e => write!(f, "spr13e"),
            Self::spr13f => write!(f, "spr13f"),
            Self::spr140 => write!(f, "spr140"),
            Self::spr141 => write!(f, "spr141"),
            Self::spr142 => write!(f, "spr142"),
            Self::spr143 => write!(f, "spr143"),
            Self::spr144 => write!(f, "spr144"),
            Self::spr145 => write!(f, "spr145"),
            Self::spr146 => write!(f, "spr146"),
            Self::spr147 => write!(f, "spr147"),
            Self::spr148 => write!(f, "spr148"),
            Self::spr149 => write!(f, "spr149"),
            Self::spr14a => write!(f, "spr14a"),
            Self::spr14b => write!(f, "spr14b"),
            Self::spr14c => write!(f, "spr14c"),
            Self::spr14d => write!(f, "spr14d"),
            Self::spr14e => write!(f, "spr14e"),
            Self::spr14f => write!(f, "spr14f"),
            Self::spr150 => write!(f, "spr150"),
            Self::spr151 => write!(f, "spr151"),
            Self::spr152 => write!(f, "spr152"),
            Self::spr153 => write!(f, "spr153"),
            Self::spr154 => write!(f, "spr154"),
            Self::spr155 => write!(f, "spr155"),
            Self::spr156 => write!(f, "spr156"),
            Self::spr157 => write!(f, "spr157"),
            Self::spr158 => write!(f, "spr158"),
            Self::spr159 => write!(f, "spr159"),
            Self::spr15a => write!(f, "spr15a"),
            Self::spr15b => write!(f, "spr15b"),
            Self::spr15c => write!(f, "spr15c"),
            Self::spr15d => write!(f, "spr15d"),
            Self::spr15e => write!(f, "spr15e"),
            Self::spr15f => write!(f, "spr15f"),
            Self::spr160 => write!(f, "spr160"),
            Self::spr161 => write!(f, "spr161"),
            Self::spr162 => write!(f, "spr162"),
            Self::spr163 => write!(f, "spr163"),
            Self::spr164 => write!(f, "spr164"),
            Self::spr165 => write!(f, "spr165"),
            Self::spr166 => write!(f, "spr166"),
            Self::spr167 => write!(f, "spr167"),
            Self::spr168 => write!(f, "spr168"),
            Self::spr169 => write!(f, "spr169"),
            Self::spr16a => write!(f, "spr16a"),
            Self::spr16b => write!(f, "spr16b"),
            Self::spr16c => write!(f, "spr16c"),
            Self::spr16d => write!(f, "spr16d"),
            Self::spr16e => write!(f, "spr16e"),
            Self::spr16f => write!(f, "spr16f"),
            Self::spr170 => write!(f, "spr170"),
            Self::spr171 => write!(f, "spr171"),
            Self::spr172 => write!(f, "spr172"),
            Self::spr173 => write!(f, "spr173"),
            Self::spr174 => write!(f, "spr174"),
            Self::spr175 => write!(f, "spr175"),
            Self::spr176 => write!(f, "spr176"),
            Self::spr177 => write!(f, "spr177"),
            Self::spr178 => write!(f, "spr178"),
            Self::spr179 => write!(f, "spr179"),
            Self::spr17a => write!(f, "spr17a"),
            Self::spr17b => write!(f, "spr17b"),
            Self::spr17c => write!(f, "spr17c"),
            Self::spr17d => write!(f, "spr17d"),
            Self::spr17e => write!(f, "spr17e"),
            Self::spr17f => write!(f, "spr17f"),
            Self::spr180 => write!(f, "spr180"),
            Self::spr181 => write!(f, "spr181"),
            Self::spr182 => write!(f, "spr182"),
            Self::spr183 => write!(f, "spr183"),
            Self::spr184 => write!(f, "spr184"),
            Self::spr185 => write!(f, "spr185"),
            Self::spr186 => write!(f, "spr186"),
            Self::spr187 => write!(f, "spr187"),
            Self::spr188 => write!(f, "spr188"),
            Self::spr189 => write!(f, "spr189"),
            Self::spr18a => write!(f, "spr18a"),
            Self::spr18b => write!(f, "spr18b"),
            Self::spr18c => write!(f, "spr18c"),
            Self::spr18d => write!(f, "spr18d"),
            Self::spr18e => write!(f, "spr18e"),
            Self::spr18f => write!(f, "spr18f"),
            Self::spr190 => write!(f, "spr190"),
            Self::spr191 => write!(f, "spr191"),
            Self::spr192 => write!(f, "spr192"),
            Self::spr193 => write!(f, "spr193"),
            Self::spr194 => write!(f, "spr194"),
            Self::spr195 => write!(f, "spr195"),
            Self::spr196 => write!(f, "spr196"),
            Self::spr197 => write!(f, "spr197"),
            Self::spr198 => write!(f, "spr198"),
            Self::spr199 => write!(f, "spr199"),
            Self::spr19a => write!(f, "spr19a"),
            Self::spr19b => write!(f, "spr19b"),
            Self::spr19c => write!(f, "spr19c"),
            Self::spr19d => write!(f, "spr19d"),
            Self::spr19e => write!(f, "spr19e"),
            Self::spr19f => write!(f, "spr19f"),
            Self::spr1a0 => write!(f, "spr1a0"),
            Self::spr1a1 => write!(f, "spr1a1"),
            Self::spr1a2 => write!(f, "spr1a2"),
            Self::spr1a3 => write!(f, "spr1a3"),
            Self::spr1a4 => write!(f, "spr1a4"),
            Self::spr1a5 => write!(f, "spr1a5"),
            Self::spr1a6 => write!(f, "spr1a6"),
            Self::spr1a7 => write!(f, "spr1a7"),
            Self::spr1a8 => write!(f, "spr1a8"),
            Self::spr1a9 => write!(f, "spr1a9"),
            Self::spr1aa => write!(f, "spr1aa"),
            Self::spr1ab => write!(f, "spr1ab"),
            Self::spr1ac => write!(f, "spr1ac"),
            Self::spr1ad => write!(f, "spr1ad"),
            Self::spr1ae => write!(f, "spr1ae"),
            Self::spr1af => write!(f, "spr1af"),
            Self::spr1b0 => write!(f, "spr1b0"),
            Self::spr1b1 => write!(f, "spr1b1"),
            Self::spr1b2 => write!(f, "spr1b2"),
            Self::spr1b3 => write!(f, "spr1b3"),
            Self::spr1b4 => write!(f, "spr1b4"),
            Self::spr1b5 => write!(f, "spr1b5"),
            Self::spr1b6 => write!(f, "spr1b6"),
            Self::spr1b7 => write!(f, "spr1b7"),
            Self::spr1b8 => write!(f, "spr1b8"),
            Self::spr1b9 => write!(f, "spr1b9"),
            Self::spr1ba => write!(f, "spr1ba"),
            Self::spr1bb => write!(f, "spr1bb"),
            Self::spr1bc => write!(f, "spr1bc"),
            Self::spr1bd => write!(f, "spr1bd"),
            Self::spr1be => write!(f, "spr1be"),
            Self::spr1bf => write!(f, "spr1bf"),
            Self::spr1c0 => write!(f, "spr1c0"),
            Self::spr1c1 => write!(f, "spr1c1"),
            Self::spr1c2 => write!(f, "spr1c2"),
            Self::spr1c3 => write!(f, "spr1c3"),
            Self::spr1c4 => write!(f, "spr1c4"),
            Self::spr1c5 => write!(f, "spr1c5"),
            Self::spr1c6 => write!(f, "spr1c6"),
            Self::spr1c7 => write!(f, "spr1c7"),
            Self::spr1c8 => write!(f, "spr1c8"),
            Self::spr1c9 => write!(f, "spr1c9"),
            Self::spr1ca => write!(f, "spr1ca"),
            Self::spr1cb => write!(f, "spr1cb"),
            Self::spr1cc => write!(f, "spr1cc"),
            Self::spr1cd => write!(f, "spr1cd"),
            Self::spr1ce => write!(f, "spr1ce"),
            Self::spr1cf => write!(f, "spr1cf"),
            Self::spr1d0 => write!(f, "spr1d0"),
            Self::spr1d1 => write!(f, "spr1d1"),
            Self::spr1d2 => write!(f, "spr1d2"),
            Self::spr1d3 => write!(f, "spr1d3"),
            Self::spr1d4 => write!(f, "spr1d4"),
            Self::spr1d5 => write!(f, "spr1d5"),
            Self::spr1d6 => write!(f, "spr1d6"),
            Self::spr1d7 => write!(f, "spr1d7"),
            Self::spr1d8 => write!(f, "spr1d8"),
            Self::spr1d9 => write!(f, "spr1d9"),
            Self::spr1da => write!(f, "spr1da"),
            Self::spr1db => write!(f, "spr1db"),
            Self::spr1dc => write!(f, "spr1dc"),
            Self::spr1dd => write!(f, "spr1dd"),
            Self::spr1de => write!(f, "spr1de"),
            Self::spr1df => write!(f, "spr1df"),
            Self::spr1e0 => write!(f, "spr1e0"),
            Self::spr1e1 => write!(f, "spr1e1"),
            Self::spr1e2 => write!(f, "spr1e2"),
            Self::spr1e3 => write!(f, "spr1e3"),
            Self::spr1e4 => write!(f, "spr1e4"),
            Self::spr1e5 => write!(f, "spr1e5"),
            Self::spr1e6 => write!(f, "spr1e6"),
            Self::spr1e7 => write!(f, "spr1e7"),
            Self::spr1e8 => write!(f, "spr1e8"),
            Self::spr1e9 => write!(f, "spr1e9"),
            Self::spr1ea => write!(f, "spr1ea"),
            Self::spr1eb => write!(f, "spr1eb"),
            Self::spr1ec => write!(f, "spr1ec"),
            Self::spr1ed => write!(f, "spr1ed"),
            Self::spr1ee => write!(f, "spr1ee"),
            Self::spr1ef => write!(f, "spr1ef"),
            Self::spr1f0 => write!(f, "spr1f0"),
            Self::spr1f1 => write!(f, "spr1f1"),
            Self::spr1f2 => write!(f, "spr1f2"),
            Self::spr1f3 => write!(f, "spr1f3"),
            Self::spr1f4 => write!(f, "spr1f4"),
            Self::spr1f5 => write!(f, "spr1f5"),
            Self::spr1f6 => write!(f, "spr1f6"),
            Self::spr1f7 => write!(f, "spr1f7"),
            Self::spr1f8 => write!(f, "spr1f8"),
            Self::spr1f9 => write!(f, "spr1f9"),
            Self::spr1fa => write!(f, "spr1fa"),
            Self::spr1fb => write!(f, "spr1fb"),
            Self::spr1fc => write!(f, "spr1fc"),
            Self::spr1fd => write!(f, "spr1fd"),
            Self::spr1fe => write!(f, "spr1fe"),
            Self::spr1ff => write!(f, "spr1ff"),
            Self::spr200 => write!(f, "spr200"),
            Self::spr201 => write!(f, "spr201"),
            Self::spr202 => write!(f, "spr202"),
            Self::spr203 => write!(f, "spr203"),
            Self::spr204 => write!(f, "spr204"),
            Self::spr205 => write!(f, "spr205"),
            Self::spr206 => write!(f, "spr206"),
            Self::spr207 => write!(f, "spr207"),
            Self::spr208 => write!(f, "spr208"),
            Self::spr209 => write!(f, "spr209"),
            Self::spr20a => write!(f, "spr20a"),
            Self::spr20b => write!(f, "spr20b"),
            Self::spr20c => write!(f, "spr20c"),
            Self::spr20d => write!(f, "spr20d"),
            Self::spr20e => write!(f, "spr20e"),
            Self::spr20f => write!(f, "spr20f"),
            Self::spr210 => write!(f, "spr210"),
            Self::spr211 => write!(f, "spr211"),
            Self::spr212 => write!(f, "spr212"),
            Self::spr213 => write!(f, "spr213"),
            Self::spr214 => write!(f, "spr214"),
            Self::spr215 => write!(f, "spr215"),
            Self::spr216 => write!(f, "spr216"),
            Self::spr217 => write!(f, "spr217"),
            Self::spr218 => write!(f, "spr218"),
            Self::spr219 => write!(f, "spr219"),
            Self::spr21a => write!(f, "spr21a"),
            Self::spr21b => write!(f, "spr21b"),
            Self::spr21c => write!(f, "spr21c"),
            Self::spr21d => write!(f, "spr21d"),
            Self::spr21e => write!(f, "spr21e"),
            Self::spr21f => write!(f, "spr21f"),
            Self::spr220 => write!(f, "spr220"),
            Self::spr221 => write!(f, "spr221"),
            Self::spr222 => write!(f, "spr222"),
            Self::spr223 => write!(f, "spr223"),
            Self::spr224 => write!(f, "spr224"),
            Self::spr225 => write!(f, "spr225"),
            Self::spr226 => write!(f, "spr226"),
            Self::spr227 => write!(f, "spr227"),
            Self::spr228 => write!(f, "spr228"),
            Self::spr229 => write!(f, "spr229"),
            Self::spr22a => write!(f, "spr22a"),
            Self::spr22b => write!(f, "spr22b"),
            Self::spr22c => write!(f, "spr22c"),
            Self::spr22d => write!(f, "spr22d"),
            Self::spr22e => write!(f, "spr22e"),
            Self::spr22f => write!(f, "spr22f"),
            Self::spr230 => write!(f, "spr230"),
            Self::spr231 => write!(f, "spr231"),
            Self::spr232 => write!(f, "spr232"),
            Self::spr233 => write!(f, "spr233"),
            Self::spr234 => write!(f, "spr234"),
            Self::spr235 => write!(f, "spr235"),
            Self::spr236 => write!(f, "spr236"),
            Self::spr237 => write!(f, "spr237"),
            Self::spr238 => write!(f, "spr238"),
            Self::spr239 => write!(f, "spr239"),
            Self::spr23a => write!(f, "spr23a"),
            Self::spr23b => write!(f, "spr23b"),
            Self::spr23c => write!(f, "spr23c"),
            Self::spr23d => write!(f, "spr23d"),
            Self::spr23e => write!(f, "spr23e"),
            Self::spr23f => write!(f, "spr23f"),
            Self::spr240 => write!(f, "spr240"),
            Self::spr241 => write!(f, "spr241"),
            Self::spr242 => write!(f, "spr242"),
            Self::spr243 => write!(f, "spr243"),
            Self::spr244 => write!(f, "spr244"),
            Self::spr245 => write!(f, "spr245"),
            Self::spr246 => write!(f, "spr246"),
            Self::spr247 => write!(f, "spr247"),
            Self::spr248 => write!(f, "spr248"),
            Self::spr249 => write!(f, "spr249"),
            Self::spr24a => write!(f, "spr24a"),
            Self::spr24b => write!(f, "spr24b"),
            Self::spr24c => write!(f, "spr24c"),
            Self::spr24d => write!(f, "spr24d"),
            Self::spr24e => write!(f, "spr24e"),
            Self::spr24f => write!(f, "spr24f"),
            Self::spr250 => write!(f, "spr250"),
            Self::spr251 => write!(f, "spr251"),
            Self::spr252 => write!(f, "spr252"),
            Self::spr253 => write!(f, "spr253"),
            Self::spr254 => write!(f, "spr254"),
            Self::spr255 => write!(f, "spr255"),
            Self::spr256 => write!(f, "spr256"),
            Self::spr257 => write!(f, "spr257"),
            Self::spr258 => write!(f, "spr258"),
            Self::spr259 => write!(f, "spr259"),
            Self::spr25a => write!(f, "spr25a"),
            Self::spr25b => write!(f, "spr25b"),
            Self::spr25c => write!(f, "spr25c"),
            Self::spr25d => write!(f, "spr25d"),
            Self::spr25e => write!(f, "spr25e"),
            Self::spr25f => write!(f, "spr25f"),
            Self::spr260 => write!(f, "spr260"),
            Self::spr261 => write!(f, "spr261"),
            Self::spr262 => write!(f, "spr262"),
            Self::spr263 => write!(f, "spr263"),
            Self::spr264 => write!(f, "spr264"),
            Self::spr265 => write!(f, "spr265"),
            Self::spr266 => write!(f, "spr266"),
            Self::spr267 => write!(f, "spr267"),
            Self::spr268 => write!(f, "spr268"),
            Self::spr269 => write!(f, "spr269"),
            Self::spr26a => write!(f, "spr26a"),
            Self::spr26b => write!(f, "spr26b"),
            Self::spr26c => write!(f, "spr26c"),
            Self::spr26d => write!(f, "spr26d"),
            Self::spr26e => write!(f, "spr26e"),
            Self::spr26f => write!(f, "spr26f"),
            Self::spr270 => write!(f, "spr270"),
            Self::spr271 => write!(f, "spr271"),
            Self::spr272 => write!(f, "spr272"),
            Self::spr273 => write!(f, "spr273"),
            Self::spr274 => write!(f, "spr274"),
            Self::spr275 => write!(f, "spr275"),
            Self::spr276 => write!(f, "spr276"),
            Self::spr277 => write!(f, "spr277"),
            Self::spr278 => write!(f, "spr278"),
            Self::spr279 => write!(f, "spr279"),
            Self::spr27a => write!(f, "spr27a"),
            Self::spr27b => write!(f, "spr27b"),
            Self::spr27c => write!(f, "spr27c"),
            Self::spr27d => write!(f, "spr27d"),
            Self::spr27e => write!(f, "spr27e"),
            Self::spr27f => write!(f, "spr27f"),
            Self::spr280 => write!(f, "spr280"),
            Self::spr281 => write!(f, "spr281"),
            Self::spr282 => write!(f, "spr282"),
            Self::spr283 => write!(f, "spr283"),
            Self::spr284 => write!(f, "spr284"),
            Self::spr285 => write!(f, "spr285"),
            Self::spr286 => write!(f, "spr286"),
            Self::spr287 => write!(f, "spr287"),
            Self::spr288 => write!(f, "spr288"),
            Self::spr289 => write!(f, "spr289"),
            Self::spr28a => write!(f, "spr28a"),
            Self::spr28b => write!(f, "spr28b"),
            Self::spr28c => write!(f, "spr28c"),
            Self::spr28d => write!(f, "spr28d"),
            Self::spr28e => write!(f, "spr28e"),
            Self::spr28f => write!(f, "spr28f"),
            Self::spr290 => write!(f, "spr290"),
            Self::spr291 => write!(f, "spr291"),
            Self::spr292 => write!(f, "spr292"),
            Self::spr293 => write!(f, "spr293"),
            Self::spr294 => write!(f, "spr294"),
            Self::spr295 => write!(f, "spr295"),
            Self::spr296 => write!(f, "spr296"),
            Self::spr297 => write!(f, "spr297"),
            Self::spr298 => write!(f, "spr298"),
            Self::spr299 => write!(f, "spr299"),
            Self::spr29a => write!(f, "spr29a"),
            Self::spr29b => write!(f, "spr29b"),
            Self::spr29c => write!(f, "spr29c"),
            Self::spr29d => write!(f, "spr29d"),
            Self::spr29e => write!(f, "spr29e"),
            Self::spr29f => write!(f, "spr29f"),
            Self::spr2a0 => write!(f, "spr2a0"),
            Self::spr2a1 => write!(f, "spr2a1"),
            Self::spr2a2 => write!(f, "spr2a2"),
            Self::spr2a3 => write!(f, "spr2a3"),
            Self::spr2a4 => write!(f, "spr2a4"),
            Self::spr2a5 => write!(f, "spr2a5"),
            Self::spr2a6 => write!(f, "spr2a6"),
            Self::spr2a7 => write!(f, "spr2a7"),
            Self::spr2a8 => write!(f, "spr2a8"),
            Self::spr2a9 => write!(f, "spr2a9"),
            Self::spr2aa => write!(f, "spr2aa"),
            Self::spr2ab => write!(f, "spr2ab"),
            Self::spr2ac => write!(f, "spr2ac"),
            Self::spr2ad => write!(f, "spr2ad"),
            Self::spr2ae => write!(f, "spr2ae"),
            Self::spr2af => write!(f, "spr2af"),
            Self::spr2b0 => write!(f, "spr2b0"),
            Self::spr2b1 => write!(f, "spr2b1"),
            Self::spr2b2 => write!(f, "spr2b2"),
            Self::spr2b3 => write!(f, "spr2b3"),
            Self::spr2b4 => write!(f, "spr2b4"),
            Self::spr2b5 => write!(f, "spr2b5"),
            Self::spr2b6 => write!(f, "spr2b6"),
            Self::spr2b7 => write!(f, "spr2b7"),
            Self::spr2b8 => write!(f, "spr2b8"),
            Self::spr2b9 => write!(f, "spr2b9"),
            Self::spr2ba => write!(f, "spr2ba"),
            Self::spr2bb => write!(f, "spr2bb"),
            Self::spr2bc => write!(f, "spr2bc"),
            Self::spr2bd => write!(f, "spr2bd"),
            Self::spr2be => write!(f, "spr2be"),
            Self::spr2bf => write!(f, "spr2bf"),
            Self::spr2c0 => write!(f, "spr2c0"),
            Self::spr2c1 => write!(f, "spr2c1"),
            Self::spr2c2 => write!(f, "spr2c2"),
            Self::spr2c3 => write!(f, "spr2c3"),
            Self::spr2c4 => write!(f, "spr2c4"),
            Self::spr2c5 => write!(f, "spr2c5"),
            Self::spr2c6 => write!(f, "spr2c6"),
            Self::spr2c7 => write!(f, "spr2c7"),
            Self::spr2c8 => write!(f, "spr2c8"),
            Self::spr2c9 => write!(f, "spr2c9"),
            Self::spr2ca => write!(f, "spr2ca"),
            Self::spr2cb => write!(f, "spr2cb"),
            Self::spr2cc => write!(f, "spr2cc"),
            Self::spr2cd => write!(f, "spr2cd"),
            Self::spr2ce => write!(f, "spr2ce"),
            Self::spr2cf => write!(f, "spr2cf"),
            Self::spr2d0 => write!(f, "spr2d0"),
            Self::spr2d1 => write!(f, "spr2d1"),
            Self::spr2d2 => write!(f, "spr2d2"),
            Self::spr2d3 => write!(f, "spr2d3"),
            Self::spr2d4 => write!(f, "spr2d4"),
            Self::spr2d5 => write!(f, "spr2d5"),
            Self::spr2d6 => write!(f, "spr2d6"),
            Self::spr2d7 => write!(f, "spr2d7"),
            Self::spr2d8 => write!(f, "spr2d8"),
            Self::spr2d9 => write!(f, "spr2d9"),
            Self::spr2da => write!(f, "spr2da"),
            Self::spr2db => write!(f, "spr2db"),
            Self::spr2dc => write!(f, "spr2dc"),
            Self::spr2dd => write!(f, "spr2dd"),
            Self::spr2de => write!(f, "spr2de"),
            Self::spr2df => write!(f, "spr2df"),
            Self::spr2e0 => write!(f, "spr2e0"),
            Self::spr2e1 => write!(f, "spr2e1"),
            Self::spr2e2 => write!(f, "spr2e2"),
            Self::spr2e3 => write!(f, "spr2e3"),
            Self::spr2e4 => write!(f, "spr2e4"),
            Self::spr2e5 => write!(f, "spr2e5"),
            Self::spr2e6 => write!(f, "spr2e6"),
            Self::spr2e7 => write!(f, "spr2e7"),
            Self::spr2e8 => write!(f, "spr2e8"),
            Self::spr2e9 => write!(f, "spr2e9"),
            Self::spr2ea => write!(f, "spr2ea"),
            Self::spr2eb => write!(f, "spr2eb"),
            Self::spr2ec => write!(f, "spr2ec"),
            Self::spr2ed => write!(f, "spr2ed"),
            Self::spr2ee => write!(f, "spr2ee"),
            Self::spr2ef => write!(f, "spr2ef"),
            Self::spr2f0 => write!(f, "spr2f0"),
            Self::spr2f1 => write!(f, "spr2f1"),
            Self::spr2f2 => write!(f, "spr2f2"),
            Self::spr2f3 => write!(f, "spr2f3"),
            Self::spr2f4 => write!(f, "spr2f4"),
            Self::spr2f5 => write!(f, "spr2f5"),
            Self::spr2f6 => write!(f, "spr2f6"),
            Self::spr2f7 => write!(f, "spr2f7"),
            Self::spr2f8 => write!(f, "spr2f8"),
            Self::spr2f9 => write!(f, "spr2f9"),
            Self::spr2fa => write!(f, "spr2fa"),
            Self::spr2fb => write!(f, "spr2fb"),
            Self::spr2fc => write!(f, "spr2fc"),
            Self::spr2fd => write!(f, "spr2fd"),
            Self::spr2fe => write!(f, "spr2fe"),
            Self::spr2ff => write!(f, "spr2ff"),
            Self::spr300 => write!(f, "spr300"),
            Self::spr301 => write!(f, "spr301"),
            Self::spr302 => write!(f, "spr302"),
            Self::spr303 => write!(f, "spr303"),
            Self::spr304 => write!(f, "spr304"),
            Self::spr305 => write!(f, "spr305"),
            Self::spr306 => write!(f, "spr306"),
            Self::spr307 => write!(f, "spr307"),
            Self::spr308 => write!(f, "spr308"),
            Self::spr309 => write!(f, "spr309"),
            Self::spr30a => write!(f, "spr30a"),
            Self::spr30b => write!(f, "spr30b"),
            Self::spr30c => write!(f, "spr30c"),
            Self::spr30d => write!(f, "spr30d"),
            Self::spr30e => write!(f, "spr30e"),
            Self::spr30f => write!(f, "spr30f"),
            Self::spr310 => write!(f, "spr310"),
            Self::spr311 => write!(f, "spr311"),
            Self::spr312 => write!(f, "spr312"),
            Self::spr313 => write!(f, "spr313"),
            Self::spr314 => write!(f, "spr314"),
            Self::spr315 => write!(f, "spr315"),
            Self::spr316 => write!(f, "spr316"),
            Self::spr317 => write!(f, "spr317"),
            Self::spr318 => write!(f, "spr318"),
            Self::spr319 => write!(f, "spr319"),
            Self::spr31a => write!(f, "spr31a"),
            Self::spr31b => write!(f, "spr31b"),
            Self::spr31c => write!(f, "spr31c"),
            Self::spr31d => write!(f, "spr31d"),
            Self::spr31e => write!(f, "spr31e"),
            Self::spr31f => write!(f, "spr31f"),
            Self::spr320 => write!(f, "spr320"),
            Self::spr321 => write!(f, "spr321"),
            Self::spr322 => write!(f, "spr322"),
            Self::spr323 => write!(f, "spr323"),
            Self::spr324 => write!(f, "spr324"),
            Self::spr325 => write!(f, "spr325"),
            Self::spr326 => write!(f, "spr326"),
            Self::spr327 => write!(f, "spr327"),
            Self::spr328 => write!(f, "spr328"),
            Self::spr329 => write!(f, "spr329"),
            Self::spr32a => write!(f, "spr32a"),
            Self::spr32b => write!(f, "spr32b"),
            Self::spr32c => write!(f, "spr32c"),
            Self::spr32d => write!(f, "spr32d"),
            Self::spr32e => write!(f, "spr32e"),
            Self::TAR => write!(f, "TAR"),
            Self::spr330 => write!(f, "spr330"),
            Self::spr331 => write!(f, "spr331"),
            Self::spr332 => write!(f, "spr332"),
            Self::spr333 => write!(f, "spr333"),
            Self::spr334 => write!(f, "spr334"),
            Self::spr335 => write!(f, "spr335"),
            Self::spr336 => write!(f, "spr336"),
            Self::spr337 => write!(f, "spr337"),
            Self::spr338 => write!(f, "spr338"),
            Self::spr339 => write!(f, "spr339"),
            Self::spr33a => write!(f, "spr33a"),
            Self::spr33b => write!(f, "spr33b"),
            Self::spr33c => write!(f, "spr33c"),
            Self::spr33d => write!(f, "spr33d"),
            Self::spr33e => write!(f, "spr33e"),
            Self::spr33f => write!(f, "spr33f"),
            Self::spr340 => write!(f, "spr340"),
            Self::spr341 => write!(f, "spr341"),
            Self::spr342 => write!(f, "spr342"),
            Self::spr343 => write!(f, "spr343"),
            Self::spr344 => write!(f, "spr344"),
            Self::spr345 => write!(f, "spr345"),
            Self::spr346 => write!(f, "spr346"),
            Self::spr347 => write!(f, "spr347"),
            Self::spr348 => write!(f, "spr348"),
            Self::spr349 => write!(f, "spr349"),
            Self::spr34a => write!(f, "spr34a"),
            Self::spr34b => write!(f, "spr34b"),
            Self::spr34c => write!(f, "spr34c"),
            Self::spr34d => write!(f, "spr34d"),
            Self::spr34e => write!(f, "spr34e"),
            Self::spr34f => write!(f, "spr34f"),
            Self::spr350 => write!(f, "spr350"),
            Self::spr351 => write!(f, "spr351"),
            Self::spr352 => write!(f, "spr352"),
            Self::spr353 => write!(f, "spr353"),
            Self::spr354 => write!(f, "spr354"),
            Self::spr355 => write!(f, "spr355"),
            Self::spr356 => write!(f, "spr356"),
            Self::spr357 => write!(f, "spr357"),
            Self::spr358 => write!(f, "spr358"),
            Self::spr359 => write!(f, "spr359"),
            Self::spr35a => write!(f, "spr35a"),
            Self::spr35b => write!(f, "spr35b"),
            Self::spr35c => write!(f, "spr35c"),
            Self::spr35d => write!(f, "spr35d"),
            Self::spr35e => write!(f, "spr35e"),
            Self::spr35f => write!(f, "spr35f"),
            Self::spr360 => write!(f, "spr360"),
            Self::spr361 => write!(f, "spr361"),
            Self::spr362 => write!(f, "spr362"),
            Self::spr363 => write!(f, "spr363"),
            Self::spr364 => write!(f, "spr364"),
            Self::spr365 => write!(f, "spr365"),
            Self::spr366 => write!(f, "spr366"),
            Self::spr367 => write!(f, "spr367"),
            Self::spr368 => write!(f, "spr368"),
            Self::spr369 => write!(f, "spr369"),
            Self::spr36a => write!(f, "spr36a"),
            Self::spr36b => write!(f, "spr36b"),
            Self::spr36c => write!(f, "spr36c"),
            Self::spr36d => write!(f, "spr36d"),
            Self::spr36e => write!(f, "spr36e"),
            Self::spr36f => write!(f, "spr36f"),
            Self::spr370 => write!(f, "spr370"),
            Self::spr371 => write!(f, "spr371"),
            Self::spr372 => write!(f, "spr372"),
            Self::spr373 => write!(f, "spr373"),
            Self::spr374 => write!(f, "spr374"),
            Self::spr375 => write!(f, "spr375"),
            Self::spr376 => write!(f, "spr376"),
            Self::spr377 => write!(f, "spr377"),
            Self::spr378 => write!(f, "spr378"),
            Self::spr379 => write!(f, "spr379"),
            Self::spr37a => write!(f, "spr37a"),
            Self::spr37b => write!(f, "spr37b"),
            Self::spr37c => write!(f, "spr37c"),
            Self::spr37d => write!(f, "spr37d"),
            Self::spr37e => write!(f, "spr37e"),
            Self::spr37f => write!(f, "spr37f"),
            Self::spr380 => write!(f, "spr380"),
            Self::spr381 => write!(f, "spr381"),
            Self::spr382 => write!(f, "spr382"),
            Self::spr383 => write!(f, "spr383"),
            Self::spr384 => write!(f, "spr384"),
            Self::spr385 => write!(f, "spr385"),
            Self::spr386 => write!(f, "spr386"),
            Self::spr387 => write!(f, "spr387"),
            Self::spr388 => write!(f, "spr388"),
            Self::spr389 => write!(f, "spr389"),
            Self::spr38a => write!(f, "spr38a"),
            Self::spr38b => write!(f, "spr38b"),
            Self::spr38c => write!(f, "spr38c"),
            Self::spr38d => write!(f, "spr38d"),
            Self::spr38e => write!(f, "spr38e"),
            Self::spr38f => write!(f, "spr38f"),
            Self::spr390 => write!(f, "spr390"),
            Self::spr391 => write!(f, "spr391"),
            Self::spr392 => write!(f, "spr392"),
            Self::spr393 => write!(f, "spr393"),
            Self::spr394 => write!(f, "spr394"),
            Self::spr395 => write!(f, "spr395"),
            Self::spr396 => write!(f, "spr396"),
            Self::spr397 => write!(f, "spr397"),
            Self::spr398 => write!(f, "spr398"),
            Self::spr399 => write!(f, "spr399"),
            Self::spr39a => write!(f, "spr39a"),
            Self::spr39b => write!(f, "spr39b"),
            Self::spr39c => write!(f, "spr39c"),
            Self::spr39d => write!(f, "spr39d"),
            Self::spr39e => write!(f, "spr39e"),
            Self::spr39f => write!(f, "spr39f"),
            Self::spr3a0 => write!(f, "spr3a0"),
            Self::spr3a1 => write!(f, "spr3a1"),
            Self::spr3a2 => write!(f, "spr3a2"),
            Self::spr3a3 => write!(f, "spr3a3"),
            Self::spr3a4 => write!(f, "spr3a4"),
            Self::spr3a5 => write!(f, "spr3a5"),
            Self::spr3a6 => write!(f, "spr3a6"),
            Self::spr3a7 => write!(f, "spr3a7"),
            Self::spr3a8 => write!(f, "spr3a8"),
            Self::spr3a9 => write!(f, "spr3a9"),
            Self::spr3aa => write!(f, "spr3aa"),
            Self::spr3ab => write!(f, "spr3ab"),
            Self::spr3ac => write!(f, "spr3ac"),
            Self::spr3ad => write!(f, "spr3ad"),
            Self::spr3ae => write!(f, "spr3ae"),
            Self::spr3af => write!(f, "spr3af"),
            Self::spr3b0 => write!(f, "spr3b0"),
            Self::spr3b1 => write!(f, "spr3b1"),
            Self::spr3b2 => write!(f, "spr3b2"),
            Self::spr3b3 => write!(f, "spr3b3"),
            Self::spr3b4 => write!(f, "spr3b4"),
            Self::spr3b5 => write!(f, "spr3b5"),
            Self::spr3b6 => write!(f, "spr3b6"),
            Self::spr3b7 => write!(f, "spr3b7"),
            Self::spr3b8 => write!(f, "spr3b8"),
            Self::spr3b9 => write!(f, "spr3b9"),
            Self::spr3ba => write!(f, "spr3ba"),
            Self::spr3bb => write!(f, "spr3bb"),
            Self::spr3bc => write!(f, "spr3bc"),
            Self::spr3bd => write!(f, "spr3bd"),
            Self::spr3be => write!(f, "spr3be"),
            Self::spr3bf => write!(f, "spr3bf"),
            Self::spr3c0 => write!(f, "spr3c0"),
            Self::spr3c1 => write!(f, "spr3c1"),
            Self::spr3c2 => write!(f, "spr3c2"),
            Self::spr3c3 => write!(f, "spr3c3"),
            Self::spr3c4 => write!(f, "spr3c4"),
            Self::spr3c5 => write!(f, "spr3c5"),
            Self::spr3c6 => write!(f, "spr3c6"),
            Self::spr3c7 => write!(f, "spr3c7"),
            Self::spr3c8 => write!(f, "spr3c8"),
            Self::spr3c9 => write!(f, "spr3c9"),
            Self::spr3ca => write!(f, "spr3ca"),
            Self::spr3cb => write!(f, "spr3cb"),
            Self::spr3cc => write!(f, "spr3cc"),
            Self::spr3cd => write!(f, "spr3cd"),
            Self::spr3ce => write!(f, "spr3ce"),
            Self::spr3cf => write!(f, "spr3cf"),
            Self::spr3d0 => write!(f, "spr3d0"),
            Self::spr3d1 => write!(f, "spr3d1"),
            Self::spr3d2 => write!(f, "spr3d2"),
            Self::spr3d3 => write!(f, "spr3d3"),
            Self::spr3d4 => write!(f, "spr3d4"),
            Self::spr3d5 => write!(f, "spr3d5"),
            Self::spr3d6 => write!(f, "spr3d6"),
            Self::spr3d7 => write!(f, "spr3d7"),
            Self::spr3d8 => write!(f, "spr3d8"),
            Self::spr3d9 => write!(f, "spr3d9"),
            Self::spr3da => write!(f, "spr3da"),
            Self::spr3db => write!(f, "spr3db"),
            Self::spr3dc => write!(f, "spr3dc"),
            Self::spr3dd => write!(f, "spr3dd"),
            Self::spr3de => write!(f, "spr3de"),
            Self::spr3df => write!(f, "spr3df"),
            Self::spr3e0 => write!(f, "spr3e0"),
            Self::spr3e1 => write!(f, "spr3e1"),
            Self::spr3e2 => write!(f, "spr3e2"),
            Self::spr3e3 => write!(f, "spr3e3"),
            Self::spr3e4 => write!(f, "spr3e4"),
            Self::spr3e5 => write!(f, "spr3e5"),
            Self::spr3e6 => write!(f, "spr3e6"),
            Self::spr3e7 => write!(f, "spr3e7"),
            Self::spr3e8 => write!(f, "spr3e8"),
            Self::spr3e9 => write!(f, "spr3e9"),
            Self::spr3ea => write!(f, "spr3ea"),
            Self::spr3eb => write!(f, "spr3eb"),
            Self::spr3ec => write!(f, "spr3ec"),
            Self::spr3ed => write!(f, "spr3ed"),
            Self::spr3ee => write!(f, "spr3ee"),
            Self::spr3ef => write!(f, "spr3ef"),
            Self::spr3f0 => write!(f, "spr3f0"),
            Self::spr3f1 => write!(f, "spr3f1"),
            Self::spr3f2 => write!(f, "spr3f2"),
            Self::spr3f3 => write!(f, "spr3f3"),
            Self::spr3f4 => write!(f, "spr3f4"),
            Self::spr3f5 => write!(f, "spr3f5"),
            Self::spr3f6 => write!(f, "spr3f6"),
            Self::spr3f7 => write!(f, "spr3f7"),
            Self::spr3f8 => write!(f, "spr3f8"),
            Self::spr3f9 => write!(f, "spr3f9"),
            Self::spr3fa => write!(f, "spr3fa"),
            Self::spr3fb => write!(f, "spr3fb"),
            Self::spr3fc => write!(f, "spr3fc"),
            Self::spr3fd => write!(f, "spr3fd"),
            Self::spr3fe => write!(f, "spr3fe"),
            Self::spr3ff => write!(f, "spr3ff"),
            Self::vs0 => write!(f, "vs0"),
            Self::vs1 => write!(f, "vs1"),
            Self::vs2 => write!(f, "vs2"),
            Self::vs3 => write!(f, "vs3"),
            Self::vs4 => write!(f, "vs4"),
            Self::vs5 => write!(f, "vs5"),
            Self::vs6 => write!(f, "vs6"),
            Self::vs7 => write!(f, "vs7"),
            Self::vs8 => write!(f, "vs8"),
            Self::vs9 => write!(f, "vs9"),
            Self::vs10 => write!(f, "vs10"),
            Self::vs11 => write!(f, "vs11"),
            Self::vs12 => write!(f, "vs12"),
            Self::vs13 => write!(f, "vs13"),
            Self::vs14 => write!(f, "vs14"),
            Self::vs15 => write!(f, "vs15"),
            Self::vs16 => write!(f, "vs16"),
            Self::vs17 => write!(f, "vs17"),
            Self::vs18 => write!(f, "vs18"),
            Self::vs19 => write!(f, "vs19"),
            Self::vs20 => write!(f, "vs20"),
            Self::vs21 => write!(f, "vs21"),
            Self::vs22 => write!(f, "vs22"),
            Self::vs23 => write!(f, "vs23"),
            Self::vs24 => write!(f, "vs24"),
            Self::vs25 => write!(f, "vs25"),
            Self::vs26 => write!(f, "vs26"),
            Self::vs27 => write!(f, "vs27"),
            Self::vs28 => write!(f, "vs28"),
            Self::vs29 => write!(f, "vs29"),
            Self::vs30 => write!(f, "vs30"),
            Self::vs31 => write!(f, "vs31"),
            Self::vs32 => write!(f, "vs32"),
            Self::vs33 => write!(f, "vs33"),
            Self::vs34 => write!(f, "vs34"),
            Self::vs35 => write!(f, "vs35"),
            Self::vs36 => write!(f, "vs36"),
            Self::vs37 => write!(f, "vs37"),
            Self::vs38 => write!(f, "vs38"),
            Self::vs39 => write!(f, "vs39"),
            Self::vs40 => write!(f, "vs40"),
            Self::vs41 => write!(f, "vs41"),
            Self::vs42 => write!(f, "vs42"),
            Self::vs43 => write!(f, "vs43"),
            Self::vs44 => write!(f, "vs44"),
            Self::vs45 => write!(f, "vs45"),
            Self::vs46 => write!(f, "vs46"),
            Self::vs47 => write!(f, "vs47"),
            Self::vs48 => write!(f, "vs48"),
            Self::vs49 => write!(f, "vs49"),
            Self::vs50 => write!(f, "vs50"),
            Self::vs51 => write!(f, "vs51"),
            Self::vs52 => write!(f, "vs52"),
            Self::vs53 => write!(f, "vs53"),
            Self::vs54 => write!(f, "vs54"),
            Self::vs55 => write!(f, "vs55"),
            Self::vs56 => write!(f, "vs56"),
            Self::vs57 => write!(f, "vs57"),
            Self::vs58 => write!(f, "vs58"),
            Self::vs59 => write!(f, "vs59"),
            Self::vs60 => write!(f, "vs60"),
            Self::vs61 => write!(f, "vs61"),
            Self::vs62 => write!(f, "vs62"),
            Self::vs63 => write!(f, "vs63"),
            Self::f0 => write!(f, "f0"),
            Self::f1 => write!(f, "f1"),
            Self::f2 => write!(f, "f2"),
            Self::f3 => write!(f, "f3"),
            Self::f4 => write!(f, "f4"),
            Self::f5 => write!(f, "f5"),
            Self::f6 => write!(f, "f6"),
            Self::f7 => write!(f, "f7"),
            Self::f8 => write!(f, "f8"),
            Self::f9 => write!(f, "f9"),
            Self::f10 => write!(f, "f10"),
            Self::f11 => write!(f, "f11"),
            Self::f12 => write!(f, "f12"),
            Self::f13 => write!(f, "f13"),
            Self::f14 => write!(f, "f14"),
            Self::f15 => write!(f, "f15"),
            Self::f16 => write!(f, "f16"),
            Self::f17 => write!(f, "f17"),
            Self::f18 => write!(f, "f18"),
            Self::f19 => write!(f, "f19"),
            Self::f20 => write!(f, "f20"),
            Self::f21 => write!(f, "f21"),
            Self::f22 => write!(f, "f22"),
            Self::f23 => write!(f, "f23"),
            Self::f24 => write!(f, "f24"),
            Self::f25 => write!(f, "f25"),
            Self::f26 => write!(f, "f26"),
            Self::f27 => write!(f, "f27"),
            Self::f28 => write!(f, "f28"),
            Self::f29 => write!(f, "f29"),
            Self::f30 => write!(f, "f30"),
            Self::f31 => write!(f, "f31"),
            Self::vr0_64_0 => write!(f, "vr0_64_0"),
            Self::vr0_64_1 => write!(f, "vr0_64_1"),
            Self::vr1_64_0 => write!(f, "vr1_64_0"),
            Self::vr1_64_1 => write!(f, "vr1_64_1"),
            Self::vr2_64_0 => write!(f, "vr2_64_0"),
            Self::vr2_64_1 => write!(f, "vr2_64_1"),
            Self::vr3_64_0 => write!(f, "vr3_64_0"),
            Self::vr3_64_1 => write!(f, "vr3_64_1"),
            Self::vr4_64_0 => write!(f, "vr4_64_0"),
            Self::vr4_64_1 => write!(f, "vr4_64_1"),
            Self::vr5_64_0 => write!(f, "vr5_64_0"),
            Self::vr5_64_1 => write!(f, "vr5_64_1"),
            Self::vr6_64_0 => write!(f, "vr6_64_0"),
            Self::vr6_64_1 => write!(f, "vr6_64_1"),
            Self::vr7_64_0 => write!(f, "vr7_64_0"),
            Self::vr7_64_1 => write!(f, "vr7_64_1"),
            Self::vr8_64_0 => write!(f, "vr8_64_0"),
            Self::vr8_64_1 => write!(f, "vr8_64_1"),
            Self::vr9_64_0 => write!(f, "vr9_64_0"),
            Self::vr9_64_1 => write!(f, "vr9_64_1"),
            Self::vr10_64_0 => write!(f, "vr10_64_0"),
            Self::vr10_64_1 => write!(f, "vr10_64_1"),
            Self::vr11_64_0 => write!(f, "vr11_64_0"),
            Self::vr11_64_1 => write!(f, "vr11_64_1"),
            Self::vr12_64_0 => write!(f, "vr12_64_0"),
            Self::vr12_64_1 => write!(f, "vr12_64_1"),
            Self::vr13_64_0 => write!(f, "vr13_64_0"),
            Self::vr13_64_1 => write!(f, "vr13_64_1"),
            Self::vr14_64_0 => write!(f, "vr14_64_0"),
            Self::vr14_64_1 => write!(f, "vr14_64_1"),
            Self::vr15_64_0 => write!(f, "vr15_64_0"),
            Self::vr15_64_1 => write!(f, "vr15_64_1"),
            Self::vr16_64_0 => write!(f, "vr16_64_0"),
            Self::vr16_64_1 => write!(f, "vr16_64_1"),
            Self::vr17_64_0 => write!(f, "vr17_64_0"),
            Self::vr17_64_1 => write!(f, "vr17_64_1"),
            Self::vr18_64_0 => write!(f, "vr18_64_0"),
            Self::vr18_64_1 => write!(f, "vr18_64_1"),
            Self::vr19_64_0 => write!(f, "vr19_64_0"),
            Self::vr19_64_1 => write!(f, "vr19_64_1"),
            Self::vr20_64_0 => write!(f, "vr20_64_0"),
            Self::vr20_64_1 => write!(f, "vr20_64_1"),
            Self::vr21_64_0 => write!(f, "vr21_64_0"),
            Self::vr21_64_1 => write!(f, "vr21_64_1"),
            Self::vr22_64_0 => write!(f, "vr22_64_0"),
            Self::vr22_64_1 => write!(f, "vr22_64_1"),
            Self::vr23_64_0 => write!(f, "vr23_64_0"),
            Self::vr23_64_1 => write!(f, "vr23_64_1"),
            Self::vr24_64_0 => write!(f, "vr24_64_0"),
            Self::vr24_64_1 => write!(f, "vr24_64_1"),
            Self::vr25_64_0 => write!(f, "vr25_64_0"),
            Self::vr25_64_1 => write!(f, "vr25_64_1"),
            Self::vr26_64_0 => write!(f, "vr26_64_0"),
            Self::vr26_64_1 => write!(f, "vr26_64_1"),
            Self::vr27_64_0 => write!(f, "vr27_64_0"),
            Self::vr27_64_1 => write!(f, "vr27_64_1"),
            Self::vr28_64_0 => write!(f, "vr28_64_0"),
            Self::vr28_64_1 => write!(f, "vr28_64_1"),
            Self::vr29_64_0 => write!(f, "vr29_64_0"),
            Self::vr29_64_1 => write!(f, "vr29_64_1"),
            Self::vr30_64_0 => write!(f, "vr30_64_0"),
            Self::vr30_64_1 => write!(f, "vr30_64_1"),
            Self::vr31_64_0 => write!(f, "vr31_64_0"),
            Self::vr31_64_1 => write!(f, "vr31_64_1"),
            Self::vr0_32_0 => write!(f, "vr0_32_0"),
            Self::vr0_32_1 => write!(f, "vr0_32_1"),
            Self::vr0_32_2 => write!(f, "vr0_32_2"),
            Self::vr0_32_3 => write!(f, "vr0_32_3"),
            Self::vr1_32_0 => write!(f, "vr1_32_0"),
            Self::vr1_32_1 => write!(f, "vr1_32_1"),
            Self::vr1_32_2 => write!(f, "vr1_32_2"),
            Self::vr1_32_3 => write!(f, "vr1_32_3"),
            Self::vr2_32_0 => write!(f, "vr2_32_0"),
            Self::vr2_32_1 => write!(f, "vr2_32_1"),
            Self::vr2_32_2 => write!(f, "vr2_32_2"),
            Self::vr2_32_3 => write!(f, "vr2_32_3"),
            Self::vr3_32_0 => write!(f, "vr3_32_0"),
            Self::vr3_32_1 => write!(f, "vr3_32_1"),
            Self::vr3_32_2 => write!(f, "vr3_32_2"),
            Self::vr3_32_3 => write!(f, "vr3_32_3"),
            Self::vr4_32_0 => write!(f, "vr4_32_0"),
            Self::vr4_32_1 => write!(f, "vr4_32_1"),
            Self::vr4_32_2 => write!(f, "vr4_32_2"),
            Self::vr4_32_3 => write!(f, "vr4_32_3"),
            Self::vr5_32_0 => write!(f, "vr5_32_0"),
            Self::vr5_32_1 => write!(f, "vr5_32_1"),
            Self::vr5_32_2 => write!(f, "vr5_32_2"),
            Self::vr5_32_3 => write!(f, "vr5_32_3"),
            Self::vr6_32_0 => write!(f, "vr6_32_0"),
            Self::vr6_32_1 => write!(f, "vr6_32_1"),
            Self::vr6_32_2 => write!(f, "vr6_32_2"),
            Self::vr6_32_3 => write!(f, "vr6_32_3"),
            Self::vr7_32_0 => write!(f, "vr7_32_0"),
            Self::vr7_32_1 => write!(f, "vr7_32_1"),
            Self::vr7_32_2 => write!(f, "vr7_32_2"),
            Self::vr7_32_3 => write!(f, "vr7_32_3"),
            Self::vr8_32_0 => write!(f, "vr8_32_0"),
            Self::vr8_32_1 => write!(f, "vr8_32_1"),
            Self::vr8_32_2 => write!(f, "vr8_32_2"),
            Self::vr8_32_3 => write!(f, "vr8_32_3"),
            Self::vr9_32_0 => write!(f, "vr9_32_0"),
            Self::vr9_32_1 => write!(f, "vr9_32_1"),
            Self::vr9_32_2 => write!(f, "vr9_32_2"),
            Self::vr9_32_3 => write!(f, "vr9_32_3"),
            Self::vr10_32_0 => write!(f, "vr10_32_0"),
            Self::vr10_32_1 => write!(f, "vr10_32_1"),
            Self::vr10_32_2 => write!(f, "vr10_32_2"),
            Self::vr10_32_3 => write!(f, "vr10_32_3"),
            Self::vr11_32_0 => write!(f, "vr11_32_0"),
            Self::vr11_32_1 => write!(f, "vr11_32_1"),
            Self::vr11_32_2 => write!(f, "vr11_32_2"),
            Self::vr11_32_3 => write!(f, "vr11_32_3"),
            Self::vr12_32_0 => write!(f, "vr12_32_0"),
            Self::vr12_32_1 => write!(f, "vr12_32_1"),
            Self::vr12_32_2 => write!(f, "vr12_32_2"),
            Self::vr12_32_3 => write!(f, "vr12_32_3"),
            Self::vr13_32_0 => write!(f, "vr13_32_0"),
            Self::vr13_32_1 => write!(f, "vr13_32_1"),
            Self::vr13_32_2 => write!(f, "vr13_32_2"),
            Self::vr13_32_3 => write!(f, "vr13_32_3"),
            Self::vr14_32_0 => write!(f, "vr14_32_0"),
            Self::vr14_32_1 => write!(f, "vr14_32_1"),
            Self::vr14_32_2 => write!(f, "vr14_32_2"),
            Self::vr14_32_3 => write!(f, "vr14_32_3"),
            Self::vr15_32_0 => write!(f, "vr15_32_0"),
            Self::vr15_32_1 => write!(f, "vr15_32_1"),
            Self::vr15_32_2 => write!(f, "vr15_32_2"),
            Self::vr15_32_3 => write!(f, "vr15_32_3"),
            Self::vr16_32_0 => write!(f, "vr16_32_0"),
            Self::vr16_32_1 => write!(f, "vr16_32_1"),
            Self::vr16_32_2 => write!(f, "vr16_32_2"),
            Self::vr16_32_3 => write!(f, "vr16_32_3"),
            Self::vr17_32_0 => write!(f, "vr17_32_0"),
            Self::vr17_32_1 => write!(f, "vr17_32_1"),
            Self::vr17_32_2 => write!(f, "vr17_32_2"),
            Self::vr17_32_3 => write!(f, "vr17_32_3"),
            Self::vr18_32_0 => write!(f, "vr18_32_0"),
            Self::vr18_32_1 => write!(f, "vr18_32_1"),
            Self::vr18_32_2 => write!(f, "vr18_32_2"),
            Self::vr18_32_3 => write!(f, "vr18_32_3"),
            Self::vr19_32_0 => write!(f, "vr19_32_0"),
            Self::vr19_32_1 => write!(f, "vr19_32_1"),
            Self::vr19_32_2 => write!(f, "vr19_32_2"),
            Self::vr19_32_3 => write!(f, "vr19_32_3"),
            Self::vr20_32_0 => write!(f, "vr20_32_0"),
            Self::vr20_32_1 => write!(f, "vr20_32_1"),
            Self::vr20_32_2 => write!(f, "vr20_32_2"),
            Self::vr20_32_3 => write!(f, "vr20_32_3"),
            Self::vr21_32_0 => write!(f, "vr21_32_0"),
            Self::vr21_32_1 => write!(f, "vr21_32_1"),
            Self::vr21_32_2 => write!(f, "vr21_32_2"),
            Self::vr21_32_3 => write!(f, "vr21_32_3"),
            Self::vr22_32_0 => write!(f, "vr22_32_0"),
            Self::vr22_32_1 => write!(f, "vr22_32_1"),
            Self::vr22_32_2 => write!(f, "vr22_32_2"),
            Self::vr22_32_3 => write!(f, "vr22_32_3"),
            Self::vr23_32_0 => write!(f, "vr23_32_0"),
            Self::vr23_32_1 => write!(f, "vr23_32_1"),
            Self::vr23_32_2 => write!(f, "vr23_32_2"),
            Self::vr23_32_3 => write!(f, "vr23_32_3"),
            Self::vr24_32_0 => write!(f, "vr24_32_0"),
            Self::vr24_32_1 => write!(f, "vr24_32_1"),
            Self::vr24_32_2 => write!(f, "vr24_32_2"),
            Self::vr24_32_3 => write!(f, "vr24_32_3"),
            Self::vr25_32_0 => write!(f, "vr25_32_0"),
            Self::vr25_32_1 => write!(f, "vr25_32_1"),
            Self::vr25_32_2 => write!(f, "vr25_32_2"),
            Self::vr25_32_3 => write!(f, "vr25_32_3"),
            Self::vr26_32_0 => write!(f, "vr26_32_0"),
            Self::vr26_32_1 => write!(f, "vr26_32_1"),
            Self::vr26_32_2 => write!(f, "vr26_32_2"),
            Self::vr26_32_3 => write!(f, "vr26_32_3"),
            Self::vr27_32_0 => write!(f, "vr27_32_0"),
            Self::vr27_32_1 => write!(f, "vr27_32_1"),
            Self::vr27_32_2 => write!(f, "vr27_32_2"),
            Self::vr27_32_3 => write!(f, "vr27_32_3"),
            Self::vr28_32_0 => write!(f, "vr28_32_0"),
            Self::vr28_32_1 => write!(f, "vr28_32_1"),
            Self::vr28_32_2 => write!(f, "vr28_32_2"),
            Self::vr28_32_3 => write!(f, "vr28_32_3"),
            Self::vr29_32_0 => write!(f, "vr29_32_0"),
            Self::vr29_32_1 => write!(f, "vr29_32_1"),
            Self::vr29_32_2 => write!(f, "vr29_32_2"),
            Self::vr29_32_3 => write!(f, "vr29_32_3"),
            Self::vr30_32_0 => write!(f, "vr30_32_0"),
            Self::vr30_32_1 => write!(f, "vr30_32_1"),
            Self::vr30_32_2 => write!(f, "vr30_32_2"),
            Self::vr30_32_3 => write!(f, "vr30_32_3"),
            Self::vr31_32_0 => write!(f, "vr31_32_0"),
            Self::vr31_32_1 => write!(f, "vr31_32_1"),
            Self::vr31_32_2 => write!(f, "vr31_32_2"),
            Self::vr31_32_3 => write!(f, "vr31_32_3"),
            Self::vr0_16_0 => write!(f, "vr0_16_0"),
            Self::vr0_16_1 => write!(f, "vr0_16_1"),
            Self::vr0_16_2 => write!(f, "vr0_16_2"),
            Self::vr0_16_3 => write!(f, "vr0_16_3"),
            Self::vr0_16_4 => write!(f, "vr0_16_4"),
            Self::vr0_16_5 => write!(f, "vr0_16_5"),
            Self::vr0_16_6 => write!(f, "vr0_16_6"),
            Self::vr0_16_7 => write!(f, "vr0_16_7"),
            Self::vr1_16_0 => write!(f, "vr1_16_0"),
            Self::vr1_16_1 => write!(f, "vr1_16_1"),
            Self::vr1_16_2 => write!(f, "vr1_16_2"),
            Self::vr1_16_3 => write!(f, "vr1_16_3"),
            Self::vr1_16_4 => write!(f, "vr1_16_4"),
            Self::vr1_16_5 => write!(f, "vr1_16_5"),
            Self::vr1_16_6 => write!(f, "vr1_16_6"),
            Self::vr1_16_7 => write!(f, "vr1_16_7"),
            Self::vr2_16_0 => write!(f, "vr2_16_0"),
            Self::vr2_16_1 => write!(f, "vr2_16_1"),
            Self::vr2_16_2 => write!(f, "vr2_16_2"),
            Self::vr2_16_3 => write!(f, "vr2_16_3"),
            Self::vr2_16_4 => write!(f, "vr2_16_4"),
            Self::vr2_16_5 => write!(f, "vr2_16_5"),
            Self::vr2_16_6 => write!(f, "vr2_16_6"),
            Self::vr2_16_7 => write!(f, "vr2_16_7"),
            Self::vr3_16_0 => write!(f, "vr3_16_0"),
            Self::vr3_16_1 => write!(f, "vr3_16_1"),
            Self::vr3_16_2 => write!(f, "vr3_16_2"),
            Self::vr3_16_3 => write!(f, "vr3_16_3"),
            Self::vr3_16_4 => write!(f, "vr3_16_4"),
            Self::vr3_16_5 => write!(f, "vr3_16_5"),
            Self::vr3_16_6 => write!(f, "vr3_16_6"),
            Self::vr3_16_7 => write!(f, "vr3_16_7"),
            Self::vr4_16_0 => write!(f, "vr4_16_0"),
            Self::vr4_16_1 => write!(f, "vr4_16_1"),
            Self::vr4_16_2 => write!(f, "vr4_16_2"),
            Self::vr4_16_3 => write!(f, "vr4_16_3"),
            Self::vr4_16_4 => write!(f, "vr4_16_4"),
            Self::vr4_16_5 => write!(f, "vr4_16_5"),
            Self::vr4_16_6 => write!(f, "vr4_16_6"),
            Self::vr4_16_7 => write!(f, "vr4_16_7"),
            Self::vr5_16_0 => write!(f, "vr5_16_0"),
            Self::vr5_16_1 => write!(f, "vr5_16_1"),
            Self::vr5_16_2 => write!(f, "vr5_16_2"),
            Self::vr5_16_3 => write!(f, "vr5_16_3"),
            Self::vr5_16_4 => write!(f, "vr5_16_4"),
            Self::vr5_16_5 => write!(f, "vr5_16_5"),
            Self::vr5_16_6 => write!(f, "vr5_16_6"),
            Self::vr5_16_7 => write!(f, "vr5_16_7"),
            Self::vr6_16_0 => write!(f, "vr6_16_0"),
            Self::vr6_16_1 => write!(f, "vr6_16_1"),
            Self::vr6_16_2 => write!(f, "vr6_16_2"),
            Self::vr6_16_3 => write!(f, "vr6_16_3"),
            Self::vr6_16_4 => write!(f, "vr6_16_4"),
            Self::vr6_16_5 => write!(f, "vr6_16_5"),
            Self::vr6_16_6 => write!(f, "vr6_16_6"),
            Self::vr6_16_7 => write!(f, "vr6_16_7"),
            Self::vr7_16_0 => write!(f, "vr7_16_0"),
            Self::vr7_16_1 => write!(f, "vr7_16_1"),
            Self::vr7_16_2 => write!(f, "vr7_16_2"),
            Self::vr7_16_3 => write!(f, "vr7_16_3"),
            Self::vr7_16_4 => write!(f, "vr7_16_4"),
            Self::vr7_16_5 => write!(f, "vr7_16_5"),
            Self::vr7_16_6 => write!(f, "vr7_16_6"),
            Self::vr7_16_7 => write!(f, "vr7_16_7"),
            Self::vr8_16_0 => write!(f, "vr8_16_0"),
            Self::vr8_16_1 => write!(f, "vr8_16_1"),
            Self::vr8_16_2 => write!(f, "vr8_16_2"),
            Self::vr8_16_3 => write!(f, "vr8_16_3"),
            Self::vr8_16_4 => write!(f, "vr8_16_4"),
            Self::vr8_16_5 => write!(f, "vr8_16_5"),
            Self::vr8_16_6 => write!(f, "vr8_16_6"),
            Self::vr8_16_7 => write!(f, "vr8_16_7"),
            Self::vr9_16_0 => write!(f, "vr9_16_0"),
            Self::vr9_16_1 => write!(f, "vr9_16_1"),
            Self::vr9_16_2 => write!(f, "vr9_16_2"),
            Self::vr9_16_3 => write!(f, "vr9_16_3"),
            Self::vr9_16_4 => write!(f, "vr9_16_4"),
            Self::vr9_16_5 => write!(f, "vr9_16_5"),
            Self::vr9_16_6 => write!(f, "vr9_16_6"),
            Self::vr9_16_7 => write!(f, "vr9_16_7"),
            Self::vr10_16_0 => write!(f, "vr10_16_0"),
            Self::vr10_16_1 => write!(f, "vr10_16_1"),
            Self::vr10_16_2 => write!(f, "vr10_16_2"),
            Self::vr10_16_3 => write!(f, "vr10_16_3"),
            Self::vr10_16_4 => write!(f, "vr10_16_4"),
            Self::vr10_16_5 => write!(f, "vr10_16_5"),
            Self::vr10_16_6 => write!(f, "vr10_16_6"),
            Self::vr10_16_7 => write!(f, "vr10_16_7"),
            Self::vr11_16_0 => write!(f, "vr11_16_0"),
            Self::vr11_16_1 => write!(f, "vr11_16_1"),
            Self::vr11_16_2 => write!(f, "vr11_16_2"),
            Self::vr11_16_3 => write!(f, "vr11_16_3"),
            Self::vr11_16_4 => write!(f, "vr11_16_4"),
            Self::vr11_16_5 => write!(f, "vr11_16_5"),
            Self::vr11_16_6 => write!(f, "vr11_16_6"),
            Self::vr11_16_7 => write!(f, "vr11_16_7"),
            Self::vr12_16_0 => write!(f, "vr12_16_0"),
            Self::vr12_16_1 => write!(f, "vr12_16_1"),
            Self::vr12_16_2 => write!(f, "vr12_16_2"),
            Self::vr12_16_3 => write!(f, "vr12_16_3"),
            Self::vr12_16_4 => write!(f, "vr12_16_4"),
            Self::vr12_16_5 => write!(f, "vr12_16_5"),
            Self::vr12_16_6 => write!(f, "vr12_16_6"),
            Self::vr12_16_7 => write!(f, "vr12_16_7"),
            Self::vr13_16_0 => write!(f, "vr13_16_0"),
            Self::vr13_16_1 => write!(f, "vr13_16_1"),
            Self::vr13_16_2 => write!(f, "vr13_16_2"),
            Self::vr13_16_3 => write!(f, "vr13_16_3"),
            Self::vr13_16_4 => write!(f, "vr13_16_4"),
            Self::vr13_16_5 => write!(f, "vr13_16_5"),
            Self::vr13_16_6 => write!(f, "vr13_16_6"),
            Self::vr13_16_7 => write!(f, "vr13_16_7"),
            Self::vr14_16_0 => write!(f, "vr14_16_0"),
            Self::vr14_16_1 => write!(f, "vr14_16_1"),
            Self::vr14_16_2 => write!(f, "vr14_16_2"),
            Self::vr14_16_3 => write!(f, "vr14_16_3"),
            Self::vr14_16_4 => write!(f, "vr14_16_4"),
            Self::vr14_16_5 => write!(f, "vr14_16_5"),
            Self::vr14_16_6 => write!(f, "vr14_16_6"),
            Self::vr14_16_7 => write!(f, "vr14_16_7"),
            Self::vr15_16_0 => write!(f, "vr15_16_0"),
            Self::vr15_16_1 => write!(f, "vr15_16_1"),
            Self::vr15_16_2 => write!(f, "vr15_16_2"),
            Self::vr15_16_3 => write!(f, "vr15_16_3"),
            Self::vr15_16_4 => write!(f, "vr15_16_4"),
            Self::vr15_16_5 => write!(f, "vr15_16_5"),
            Self::vr15_16_6 => write!(f, "vr15_16_6"),
            Self::vr15_16_7 => write!(f, "vr15_16_7"),
            Self::vr16_16_0 => write!(f, "vr16_16_0"),
            Self::vr16_16_1 => write!(f, "vr16_16_1"),
            Self::vr16_16_2 => write!(f, "vr16_16_2"),
            Self::vr16_16_3 => write!(f, "vr16_16_3"),
            Self::vr16_16_4 => write!(f, "vr16_16_4"),
            Self::vr16_16_5 => write!(f, "vr16_16_5"),
            Self::vr16_16_6 => write!(f, "vr16_16_6"),
            Self::vr16_16_7 => write!(f, "vr16_16_7"),
            Self::vr17_16_0 => write!(f, "vr17_16_0"),
            Self::vr17_16_1 => write!(f, "vr17_16_1"),
            Self::vr17_16_2 => write!(f, "vr17_16_2"),
            Self::vr17_16_3 => write!(f, "vr17_16_3"),
            Self::vr17_16_4 => write!(f, "vr17_16_4"),
            Self::vr17_16_5 => write!(f, "vr17_16_5"),
            Self::vr17_16_6 => write!(f, "vr17_16_6"),
            Self::vr17_16_7 => write!(f, "vr17_16_7"),
            Self::vr18_16_0 => write!(f, "vr18_16_0"),
            Self::vr18_16_1 => write!(f, "vr18_16_1"),
            Self::vr18_16_2 => write!(f, "vr18_16_2"),
            Self::vr18_16_3 => write!(f, "vr18_16_3"),
            Self::vr18_16_4 => write!(f, "vr18_16_4"),
            Self::vr18_16_5 => write!(f, "vr18_16_5"),
            Self::vr18_16_6 => write!(f, "vr18_16_6"),
            Self::vr18_16_7 => write!(f, "vr18_16_7"),
            Self::vr19_16_0 => write!(f, "vr19_16_0"),
            Self::vr19_16_1 => write!(f, "vr19_16_1"),
            Self::vr19_16_2 => write!(f, "vr19_16_2"),
            Self::vr19_16_3 => write!(f, "vr19_16_3"),
            Self::vr19_16_4 => write!(f, "vr19_16_4"),
            Self::vr19_16_5 => write!(f, "vr19_16_5"),
            Self::vr19_16_6 => write!(f, "vr19_16_6"),
            Self::vr19_16_7 => write!(f, "vr19_16_7"),
            Self::vr20_16_0 => write!(f, "vr20_16_0"),
            Self::vr20_16_1 => write!(f, "vr20_16_1"),
            Self::vr20_16_2 => write!(f, "vr20_16_2"),
            Self::vr20_16_3 => write!(f, "vr20_16_3"),
            Self::vr20_16_4 => write!(f, "vr20_16_4"),
            Self::vr20_16_5 => write!(f, "vr20_16_5"),
            Self::vr20_16_6 => write!(f, "vr20_16_6"),
            Self::vr20_16_7 => write!(f, "vr20_16_7"),
            Self::vr21_16_0 => write!(f, "vr21_16_0"),
            Self::vr21_16_1 => write!(f, "vr21_16_1"),
            Self::vr21_16_2 => write!(f, "vr21_16_2"),
            Self::vr21_16_3 => write!(f, "vr21_16_3"),
            Self::vr21_16_4 => write!(f, "vr21_16_4"),
            Self::vr21_16_5 => write!(f, "vr21_16_5"),
            Self::vr21_16_6 => write!(f, "vr21_16_6"),
            Self::vr21_16_7 => write!(f, "vr21_16_7"),
            Self::vr22_16_0 => write!(f, "vr22_16_0"),
            Self::vr22_16_1 => write!(f, "vr22_16_1"),
            Self::vr22_16_2 => write!(f, "vr22_16_2"),
            Self::vr22_16_3 => write!(f, "vr22_16_3"),
            Self::vr22_16_4 => write!(f, "vr22_16_4"),
            Self::vr22_16_5 => write!(f, "vr22_16_5"),
            Self::vr22_16_6 => write!(f, "vr22_16_6"),
            Self::vr22_16_7 => write!(f, "vr22_16_7"),
            Self::vr23_16_0 => write!(f, "vr23_16_0"),
            Self::vr23_16_1 => write!(f, "vr23_16_1"),
            Self::vr23_16_2 => write!(f, "vr23_16_2"),
            Self::vr23_16_3 => write!(f, "vr23_16_3"),
            Self::vr23_16_4 => write!(f, "vr23_16_4"),
            Self::vr23_16_5 => write!(f, "vr23_16_5"),
            Self::vr23_16_6 => write!(f, "vr23_16_6"),
            Self::vr23_16_7 => write!(f, "vr23_16_7"),
            Self::vr24_16_0 => write!(f, "vr24_16_0"),
            Self::vr24_16_1 => write!(f, "vr24_16_1"),
            Self::vr24_16_2 => write!(f, "vr24_16_2"),
            Self::vr24_16_3 => write!(f, "vr24_16_3"),
            Self::vr24_16_4 => write!(f, "vr24_16_4"),
            Self::vr24_16_5 => write!(f, "vr24_16_5"),
            Self::vr24_16_6 => write!(f, "vr24_16_6"),
            Self::vr24_16_7 => write!(f, "vr24_16_7"),
            Self::vr25_16_0 => write!(f, "vr25_16_0"),
            Self::vr25_16_1 => write!(f, "vr25_16_1"),
            Self::vr25_16_2 => write!(f, "vr25_16_2"),
            Self::vr25_16_3 => write!(f, "vr25_16_3"),
            Self::vr25_16_4 => write!(f, "vr25_16_4"),
            Self::vr25_16_5 => write!(f, "vr25_16_5"),
            Self::vr25_16_6 => write!(f, "vr25_16_6"),
            Self::vr25_16_7 => write!(f, "vr25_16_7"),
            Self::vr26_16_0 => write!(f, "vr26_16_0"),
            Self::vr26_16_1 => write!(f, "vr26_16_1"),
            Self::vr26_16_2 => write!(f, "vr26_16_2"),
            Self::vr26_16_3 => write!(f, "vr26_16_3"),
            Self::vr26_16_4 => write!(f, "vr26_16_4"),
            Self::vr26_16_5 => write!(f, "vr26_16_5"),
            Self::vr26_16_6 => write!(f, "vr26_16_6"),
            Self::vr26_16_7 => write!(f, "vr26_16_7"),
            Self::vr27_16_0 => write!(f, "vr27_16_0"),
            Self::vr27_16_1 => write!(f, "vr27_16_1"),
            Self::vr27_16_2 => write!(f, "vr27_16_2"),
            Self::vr27_16_3 => write!(f, "vr27_16_3"),
            Self::vr27_16_4 => write!(f, "vr27_16_4"),
            Self::vr27_16_5 => write!(f, "vr27_16_5"),
            Self::vr27_16_6 => write!(f, "vr27_16_6"),
            Self::vr27_16_7 => write!(f, "vr27_16_7"),
            Self::vr28_16_0 => write!(f, "vr28_16_0"),
            Self::vr28_16_1 => write!(f, "vr28_16_1"),
            Self::vr28_16_2 => write!(f, "vr28_16_2"),
            Self::vr28_16_3 => write!(f, "vr28_16_3"),
            Self::vr28_16_4 => write!(f, "vr28_16_4"),
            Self::vr28_16_5 => write!(f, "vr28_16_5"),
            Self::vr28_16_6 => write!(f, "vr28_16_6"),
            Self::vr28_16_7 => write!(f, "vr28_16_7"),
            Self::vr29_16_0 => write!(f, "vr29_16_0"),
            Self::vr29_16_1 => write!(f, "vr29_16_1"),
            Self::vr29_16_2 => write!(f, "vr29_16_2"),
            Self::vr29_16_3 => write!(f, "vr29_16_3"),
            Self::vr29_16_4 => write!(f, "vr29_16_4"),
            Self::vr29_16_5 => write!(f, "vr29_16_5"),
            Self::vr29_16_6 => write!(f, "vr29_16_6"),
            Self::vr29_16_7 => write!(f, "vr29_16_7"),
            Self::vr30_16_0 => write!(f, "vr30_16_0"),
            Self::vr30_16_1 => write!(f, "vr30_16_1"),
            Self::vr30_16_2 => write!(f, "vr30_16_2"),
            Self::vr30_16_3 => write!(f, "vr30_16_3"),
            Self::vr30_16_4 => write!(f, "vr30_16_4"),
            Self::vr30_16_5 => write!(f, "vr30_16_5"),
            Self::vr30_16_6 => write!(f, "vr30_16_6"),
            Self::vr30_16_7 => write!(f, "vr30_16_7"),
            Self::vr31_16_0 => write!(f, "vr31_16_0"),
            Self::vr31_16_1 => write!(f, "vr31_16_1"),
            Self::vr31_16_2 => write!(f, "vr31_16_2"),
            Self::vr31_16_3 => write!(f, "vr31_16_3"),
            Self::vr31_16_4 => write!(f, "vr31_16_4"),
            Self::vr31_16_5 => write!(f, "vr31_16_5"),
            Self::vr31_16_6 => write!(f, "vr31_16_6"),
            Self::vr31_16_7 => write!(f, "vr31_16_7"),
            Self::vr0_8_0 => write!(f, "vr0_8_0"),
            Self::vr0_8_1 => write!(f, "vr0_8_1"),
            Self::vr0_8_2 => write!(f, "vr0_8_2"),
            Self::vr0_8_3 => write!(f, "vr0_8_3"),
            Self::vr0_8_4 => write!(f, "vr0_8_4"),
            Self::vr0_8_5 => write!(f, "vr0_8_5"),
            Self::vr0_8_6 => write!(f, "vr0_8_6"),
            Self::vr0_8_7 => write!(f, "vr0_8_7"),
            Self::vr0_8_8 => write!(f, "vr0_8_8"),
            Self::vr0_8_9 => write!(f, "vr0_8_9"),
            Self::vr0_8_10 => write!(f, "vr0_8_10"),
            Self::vr0_8_11 => write!(f, "vr0_8_11"),
            Self::vr0_8_12 => write!(f, "vr0_8_12"),
            Self::vr0_8_13 => write!(f, "vr0_8_13"),
            Self::vr0_8_14 => write!(f, "vr0_8_14"),
            Self::vr0_8_15 => write!(f, "vr0_8_15"),
            Self::vr1_8_0 => write!(f, "vr1_8_0"),
            Self::vr1_8_1 => write!(f, "vr1_8_1"),
            Self::vr1_8_2 => write!(f, "vr1_8_2"),
            Self::vr1_8_3 => write!(f, "vr1_8_3"),
            Self::vr1_8_4 => write!(f, "vr1_8_4"),
            Self::vr1_8_5 => write!(f, "vr1_8_5"),
            Self::vr1_8_6 => write!(f, "vr1_8_6"),
            Self::vr1_8_7 => write!(f, "vr1_8_7"),
            Self::vr1_8_8 => write!(f, "vr1_8_8"),
            Self::vr1_8_9 => write!(f, "vr1_8_9"),
            Self::vr1_8_10 => write!(f, "vr1_8_10"),
            Self::vr1_8_11 => write!(f, "vr1_8_11"),
            Self::vr1_8_12 => write!(f, "vr1_8_12"),
            Self::vr1_8_13 => write!(f, "vr1_8_13"),
            Self::vr1_8_14 => write!(f, "vr1_8_14"),
            Self::vr1_8_15 => write!(f, "vr1_8_15"),
            Self::vr2_8_0 => write!(f, "vr2_8_0"),
            Self::vr2_8_1 => write!(f, "vr2_8_1"),
            Self::vr2_8_2 => write!(f, "vr2_8_2"),
            Self::vr2_8_3 => write!(f, "vr2_8_3"),
            Self::vr2_8_4 => write!(f, "vr2_8_4"),
            Self::vr2_8_5 => write!(f, "vr2_8_5"),
            Self::vr2_8_6 => write!(f, "vr2_8_6"),
            Self::vr2_8_7 => write!(f, "vr2_8_7"),
            Self::vr2_8_8 => write!(f, "vr2_8_8"),
            Self::vr2_8_9 => write!(f, "vr2_8_9"),
            Self::vr2_8_10 => write!(f, "vr2_8_10"),
            Self::vr2_8_11 => write!(f, "vr2_8_11"),
            Self::vr2_8_12 => write!(f, "vr2_8_12"),
            Self::vr2_8_13 => write!(f, "vr2_8_13"),
            Self::vr2_8_14 => write!(f, "vr2_8_14"),
            Self::vr2_8_15 => write!(f, "vr2_8_15"),
            Self::vr3_8_0 => write!(f, "vr3_8_0"),
            Self::vr3_8_1 => write!(f, "vr3_8_1"),
            Self::vr3_8_2 => write!(f, "vr3_8_2"),
            Self::vr3_8_3 => write!(f, "vr3_8_3"),
            Self::vr3_8_4 => write!(f, "vr3_8_4"),
            Self::vr3_8_5 => write!(f, "vr3_8_5"),
            Self::vr3_8_6 => write!(f, "vr3_8_6"),
            Self::vr3_8_7 => write!(f, "vr3_8_7"),
            Self::vr3_8_8 => write!(f, "vr3_8_8"),
            Self::vr3_8_9 => write!(f, "vr3_8_9"),
            Self::vr3_8_10 => write!(f, "vr3_8_10"),
            Self::vr3_8_11 => write!(f, "vr3_8_11"),
            Self::vr3_8_12 => write!(f, "vr3_8_12"),
            Self::vr3_8_13 => write!(f, "vr3_8_13"),
            Self::vr3_8_14 => write!(f, "vr3_8_14"),
            Self::vr3_8_15 => write!(f, "vr3_8_15"),
            Self::vr4_8_0 => write!(f, "vr4_8_0"),
            Self::vr4_8_1 => write!(f, "vr4_8_1"),
            Self::vr4_8_2 => write!(f, "vr4_8_2"),
            Self::vr4_8_3 => write!(f, "vr4_8_3"),
            Self::vr4_8_4 => write!(f, "vr4_8_4"),
            Self::vr4_8_5 => write!(f, "vr4_8_5"),
            Self::vr4_8_6 => write!(f, "vr4_8_6"),
            Self::vr4_8_7 => write!(f, "vr4_8_7"),
            Self::vr4_8_8 => write!(f, "vr4_8_8"),
            Self::vr4_8_9 => write!(f, "vr4_8_9"),
            Self::vr4_8_10 => write!(f, "vr4_8_10"),
            Self::vr4_8_11 => write!(f, "vr4_8_11"),
            Self::vr4_8_12 => write!(f, "vr4_8_12"),
            Self::vr4_8_13 => write!(f, "vr4_8_13"),
            Self::vr4_8_14 => write!(f, "vr4_8_14"),
            Self::vr4_8_15 => write!(f, "vr4_8_15"),
            Self::vr5_8_0 => write!(f, "vr5_8_0"),
            Self::vr5_8_1 => write!(f, "vr5_8_1"),
            Self::vr5_8_2 => write!(f, "vr5_8_2"),
            Self::vr5_8_3 => write!(f, "vr5_8_3"),
            Self::vr5_8_4 => write!(f, "vr5_8_4"),
            Self::vr5_8_5 => write!(f, "vr5_8_5"),
            Self::vr5_8_6 => write!(f, "vr5_8_6"),
            Self::vr5_8_7 => write!(f, "vr5_8_7"),
            Self::vr5_8_8 => write!(f, "vr5_8_8"),
            Self::vr5_8_9 => write!(f, "vr5_8_9"),
            Self::vr5_8_10 => write!(f, "vr5_8_10"),
            Self::vr5_8_11 => write!(f, "vr5_8_11"),
            Self::vr5_8_12 => write!(f, "vr5_8_12"),
            Self::vr5_8_13 => write!(f, "vr5_8_13"),
            Self::vr5_8_14 => write!(f, "vr5_8_14"),
            Self::vr5_8_15 => write!(f, "vr5_8_15"),
            Self::vr6_8_0 => write!(f, "vr6_8_0"),
            Self::vr6_8_1 => write!(f, "vr6_8_1"),
            Self::vr6_8_2 => write!(f, "vr6_8_2"),
            Self::vr6_8_3 => write!(f, "vr6_8_3"),
            Self::vr6_8_4 => write!(f, "vr6_8_4"),
            Self::vr6_8_5 => write!(f, "vr6_8_5"),
            Self::vr6_8_6 => write!(f, "vr6_8_6"),
            Self::vr6_8_7 => write!(f, "vr6_8_7"),
            Self::vr6_8_8 => write!(f, "vr6_8_8"),
            Self::vr6_8_9 => write!(f, "vr6_8_9"),
            Self::vr6_8_10 => write!(f, "vr6_8_10"),
            Self::vr6_8_11 => write!(f, "vr6_8_11"),
            Self::vr6_8_12 => write!(f, "vr6_8_12"),
            Self::vr6_8_13 => write!(f, "vr6_8_13"),
            Self::vr6_8_14 => write!(f, "vr6_8_14"),
            Self::vr6_8_15 => write!(f, "vr6_8_15"),
            Self::vr7_8_0 => write!(f, "vr7_8_0"),
            Self::vr7_8_1 => write!(f, "vr7_8_1"),
            Self::vr7_8_2 => write!(f, "vr7_8_2"),
            Self::vr7_8_3 => write!(f, "vr7_8_3"),
            Self::vr7_8_4 => write!(f, "vr7_8_4"),
            Self::vr7_8_5 => write!(f, "vr7_8_5"),
            Self::vr7_8_6 => write!(f, "vr7_8_6"),
            Self::vr7_8_7 => write!(f, "vr7_8_7"),
            Self::vr7_8_8 => write!(f, "vr7_8_8"),
            Self::vr7_8_9 => write!(f, "vr7_8_9"),
            Self::vr7_8_10 => write!(f, "vr7_8_10"),
            Self::vr7_8_11 => write!(f, "vr7_8_11"),
            Self::vr7_8_12 => write!(f, "vr7_8_12"),
            Self::vr7_8_13 => write!(f, "vr7_8_13"),
            Self::vr7_8_14 => write!(f, "vr7_8_14"),
            Self::vr7_8_15 => write!(f, "vr7_8_15"),
            Self::vr8_8_0 => write!(f, "vr8_8_0"),
            Self::vr8_8_1 => write!(f, "vr8_8_1"),
            Self::vr8_8_2 => write!(f, "vr8_8_2"),
            Self::vr8_8_3 => write!(f, "vr8_8_3"),
            Self::vr8_8_4 => write!(f, "vr8_8_4"),
            Self::vr8_8_5 => write!(f, "vr8_8_5"),
            Self::vr8_8_6 => write!(f, "vr8_8_6"),
            Self::vr8_8_7 => write!(f, "vr8_8_7"),
            Self::vr8_8_8 => write!(f, "vr8_8_8"),
            Self::vr8_8_9 => write!(f, "vr8_8_9"),
            Self::vr8_8_10 => write!(f, "vr8_8_10"),
            Self::vr8_8_11 => write!(f, "vr8_8_11"),
            Self::vr8_8_12 => write!(f, "vr8_8_12"),
            Self::vr8_8_13 => write!(f, "vr8_8_13"),
            Self::vr8_8_14 => write!(f, "vr8_8_14"),
            Self::vr8_8_15 => write!(f, "vr8_8_15"),
            Self::vr9_8_0 => write!(f, "vr9_8_0"),
            Self::vr9_8_1 => write!(f, "vr9_8_1"),
            Self::vr9_8_2 => write!(f, "vr9_8_2"),
            Self::vr9_8_3 => write!(f, "vr9_8_3"),
            Self::vr9_8_4 => write!(f, "vr9_8_4"),
            Self::vr9_8_5 => write!(f, "vr9_8_5"),
            Self::vr9_8_6 => write!(f, "vr9_8_6"),
            Self::vr9_8_7 => write!(f, "vr9_8_7"),
            Self::vr9_8_8 => write!(f, "vr9_8_8"),
            Self::vr9_8_9 => write!(f, "vr9_8_9"),
            Self::vr9_8_10 => write!(f, "vr9_8_10"),
            Self::vr9_8_11 => write!(f, "vr9_8_11"),
            Self::vr9_8_12 => write!(f, "vr9_8_12"),
            Self::vr9_8_13 => write!(f, "vr9_8_13"),
            Self::vr9_8_14 => write!(f, "vr9_8_14"),
            Self::vr9_8_15 => write!(f, "vr9_8_15"),
            Self::vr10_8_0 => write!(f, "vr10_8_0"),
            Self::vr10_8_1 => write!(f, "vr10_8_1"),
            Self::vr10_8_2 => write!(f, "vr10_8_2"),
            Self::vr10_8_3 => write!(f, "vr10_8_3"),
            Self::vr10_8_4 => write!(f, "vr10_8_4"),
            Self::vr10_8_5 => write!(f, "vr10_8_5"),
            Self::vr10_8_6 => write!(f, "vr10_8_6"),
            Self::vr10_8_7 => write!(f, "vr10_8_7"),
            Self::vr10_8_8 => write!(f, "vr10_8_8"),
            Self::vr10_8_9 => write!(f, "vr10_8_9"),
            Self::vr10_8_10 => write!(f, "vr10_8_10"),
            Self::vr10_8_11 => write!(f, "vr10_8_11"),
            Self::vr10_8_12 => write!(f, "vr10_8_12"),
            Self::vr10_8_13 => write!(f, "vr10_8_13"),
            Self::vr10_8_14 => write!(f, "vr10_8_14"),
            Self::vr10_8_15 => write!(f, "vr10_8_15"),
            Self::vr11_8_0 => write!(f, "vr11_8_0"),
            Self::vr11_8_1 => write!(f, "vr11_8_1"),
            Self::vr11_8_2 => write!(f, "vr11_8_2"),
            Self::vr11_8_3 => write!(f, "vr11_8_3"),
            Self::vr11_8_4 => write!(f, "vr11_8_4"),
            Self::vr11_8_5 => write!(f, "vr11_8_5"),
            Self::vr11_8_6 => write!(f, "vr11_8_6"),
            Self::vr11_8_7 => write!(f, "vr11_8_7"),
            Self::vr11_8_8 => write!(f, "vr11_8_8"),
            Self::vr11_8_9 => write!(f, "vr11_8_9"),
            Self::vr11_8_10 => write!(f, "vr11_8_10"),
            Self::vr11_8_11 => write!(f, "vr11_8_11"),
            Self::vr11_8_12 => write!(f, "vr11_8_12"),
            Self::vr11_8_13 => write!(f, "vr11_8_13"),
            Self::vr11_8_14 => write!(f, "vr11_8_14"),
            Self::vr11_8_15 => write!(f, "vr11_8_15"),
            Self::vr12_8_0 => write!(f, "vr12_8_0"),
            Self::vr12_8_1 => write!(f, "vr12_8_1"),
            Self::vr12_8_2 => write!(f, "vr12_8_2"),
            Self::vr12_8_3 => write!(f, "vr12_8_3"),
            Self::vr12_8_4 => write!(f, "vr12_8_4"),
            Self::vr12_8_5 => write!(f, "vr12_8_5"),
            Self::vr12_8_6 => write!(f, "vr12_8_6"),
            Self::vr12_8_7 => write!(f, "vr12_8_7"),
            Self::vr12_8_8 => write!(f, "vr12_8_8"),
            Self::vr12_8_9 => write!(f, "vr12_8_9"),
            Self::vr12_8_10 => write!(f, "vr12_8_10"),
            Self::vr12_8_11 => write!(f, "vr12_8_11"),
            Self::vr12_8_12 => write!(f, "vr12_8_12"),
            Self::vr12_8_13 => write!(f, "vr12_8_13"),
            Self::vr12_8_14 => write!(f, "vr12_8_14"),
            Self::vr12_8_15 => write!(f, "vr12_8_15"),
            Self::vr13_8_0 => write!(f, "vr13_8_0"),
            Self::vr13_8_1 => write!(f, "vr13_8_1"),
            Self::vr13_8_2 => write!(f, "vr13_8_2"),
            Self::vr13_8_3 => write!(f, "vr13_8_3"),
            Self::vr13_8_4 => write!(f, "vr13_8_4"),
            Self::vr13_8_5 => write!(f, "vr13_8_5"),
            Self::vr13_8_6 => write!(f, "vr13_8_6"),
            Self::vr13_8_7 => write!(f, "vr13_8_7"),
            Self::vr13_8_8 => write!(f, "vr13_8_8"),
            Self::vr13_8_9 => write!(f, "vr13_8_9"),
            Self::vr13_8_10 => write!(f, "vr13_8_10"),
            Self::vr13_8_11 => write!(f, "vr13_8_11"),
            Self::vr13_8_12 => write!(f, "vr13_8_12"),
            Self::vr13_8_13 => write!(f, "vr13_8_13"),
            Self::vr13_8_14 => write!(f, "vr13_8_14"),
            Self::vr13_8_15 => write!(f, "vr13_8_15"),
            Self::vr14_8_0 => write!(f, "vr14_8_0"),
            Self::vr14_8_1 => write!(f, "vr14_8_1"),
            Self::vr14_8_2 => write!(f, "vr14_8_2"),
            Self::vr14_8_3 => write!(f, "vr14_8_3"),
            Self::vr14_8_4 => write!(f, "vr14_8_4"),
            Self::vr14_8_5 => write!(f, "vr14_8_5"),
            Self::vr14_8_6 => write!(f, "vr14_8_6"),
            Self::vr14_8_7 => write!(f, "vr14_8_7"),
            Self::vr14_8_8 => write!(f, "vr14_8_8"),
            Self::vr14_8_9 => write!(f, "vr14_8_9"),
            Self::vr14_8_10 => write!(f, "vr14_8_10"),
            Self::vr14_8_11 => write!(f, "vr14_8_11"),
            Self::vr14_8_12 => write!(f, "vr14_8_12"),
            Self::vr14_8_13 => write!(f, "vr14_8_13"),
            Self::vr14_8_14 => write!(f, "vr14_8_14"),
            Self::vr14_8_15 => write!(f, "vr14_8_15"),
            Self::vr15_8_0 => write!(f, "vr15_8_0"),
            Self::vr15_8_1 => write!(f, "vr15_8_1"),
            Self::vr15_8_2 => write!(f, "vr15_8_2"),
            Self::vr15_8_3 => write!(f, "vr15_8_3"),
            Self::vr15_8_4 => write!(f, "vr15_8_4"),
            Self::vr15_8_5 => write!(f, "vr15_8_5"),
            Self::vr15_8_6 => write!(f, "vr15_8_6"),
            Self::vr15_8_7 => write!(f, "vr15_8_7"),
            Self::vr15_8_8 => write!(f, "vr15_8_8"),
            Self::vr15_8_9 => write!(f, "vr15_8_9"),
            Self::vr15_8_10 => write!(f, "vr15_8_10"),
            Self::vr15_8_11 => write!(f, "vr15_8_11"),
            Self::vr15_8_12 => write!(f, "vr15_8_12"),
            Self::vr15_8_13 => write!(f, "vr15_8_13"),
            Self::vr15_8_14 => write!(f, "vr15_8_14"),
            Self::vr15_8_15 => write!(f, "vr15_8_15"),
            Self::vr16_8_0 => write!(f, "vr16_8_0"),
            Self::vr16_8_1 => write!(f, "vr16_8_1"),
            Self::vr16_8_2 => write!(f, "vr16_8_2"),
            Self::vr16_8_3 => write!(f, "vr16_8_3"),
            Self::vr16_8_4 => write!(f, "vr16_8_4"),
            Self::vr16_8_5 => write!(f, "vr16_8_5"),
            Self::vr16_8_6 => write!(f, "vr16_8_6"),
            Self::vr16_8_7 => write!(f, "vr16_8_7"),
            Self::vr16_8_8 => write!(f, "vr16_8_8"),
            Self::vr16_8_9 => write!(f, "vr16_8_9"),
            Self::vr16_8_10 => write!(f, "vr16_8_10"),
            Self::vr16_8_11 => write!(f, "vr16_8_11"),
            Self::vr16_8_12 => write!(f, "vr16_8_12"),
            Self::vr16_8_13 => write!(f, "vr16_8_13"),
            Self::vr16_8_14 => write!(f, "vr16_8_14"),
            Self::vr16_8_15 => write!(f, "vr16_8_15"),
            Self::vr17_8_0 => write!(f, "vr17_8_0"),
            Self::vr17_8_1 => write!(f, "vr17_8_1"),
            Self::vr17_8_2 => write!(f, "vr17_8_2"),
            Self::vr17_8_3 => write!(f, "vr17_8_3"),
            Self::vr17_8_4 => write!(f, "vr17_8_4"),
            Self::vr17_8_5 => write!(f, "vr17_8_5"),
            Self::vr17_8_6 => write!(f, "vr17_8_6"),
            Self::vr17_8_7 => write!(f, "vr17_8_7"),
            Self::vr17_8_8 => write!(f, "vr17_8_8"),
            Self::vr17_8_9 => write!(f, "vr17_8_9"),
            Self::vr17_8_10 => write!(f, "vr17_8_10"),
            Self::vr17_8_11 => write!(f, "vr17_8_11"),
            Self::vr17_8_12 => write!(f, "vr17_8_12"),
            Self::vr17_8_13 => write!(f, "vr17_8_13"),
            Self::vr17_8_14 => write!(f, "vr17_8_14"),
            Self::vr17_8_15 => write!(f, "vr17_8_15"),
            Self::vr18_8_0 => write!(f, "vr18_8_0"),
            Self::vr18_8_1 => write!(f, "vr18_8_1"),
            Self::vr18_8_2 => write!(f, "vr18_8_2"),
            Self::vr18_8_3 => write!(f, "vr18_8_3"),
            Self::vr18_8_4 => write!(f, "vr18_8_4"),
            Self::vr18_8_5 => write!(f, "vr18_8_5"),
            Self::vr18_8_6 => write!(f, "vr18_8_6"),
            Self::vr18_8_7 => write!(f, "vr18_8_7"),
            Self::vr18_8_8 => write!(f, "vr18_8_8"),
            Self::vr18_8_9 => write!(f, "vr18_8_9"),
            Self::vr18_8_10 => write!(f, "vr18_8_10"),
            Self::vr18_8_11 => write!(f, "vr18_8_11"),
            Self::vr18_8_12 => write!(f, "vr18_8_12"),
            Self::vr18_8_13 => write!(f, "vr18_8_13"),
            Self::vr18_8_14 => write!(f, "vr18_8_14"),
            Self::vr18_8_15 => write!(f, "vr18_8_15"),
            Self::vr19_8_0 => write!(f, "vr19_8_0"),
            Self::vr19_8_1 => write!(f, "vr19_8_1"),
            Self::vr19_8_2 => write!(f, "vr19_8_2"),
            Self::vr19_8_3 => write!(f, "vr19_8_3"),
            Self::vr19_8_4 => write!(f, "vr19_8_4"),
            Self::vr19_8_5 => write!(f, "vr19_8_5"),
            Self::vr19_8_6 => write!(f, "vr19_8_6"),
            Self::vr19_8_7 => write!(f, "vr19_8_7"),
            Self::vr19_8_8 => write!(f, "vr19_8_8"),
            Self::vr19_8_9 => write!(f, "vr19_8_9"),
            Self::vr19_8_10 => write!(f, "vr19_8_10"),
            Self::vr19_8_11 => write!(f, "vr19_8_11"),
            Self::vr19_8_12 => write!(f, "vr19_8_12"),
            Self::vr19_8_13 => write!(f, "vr19_8_13"),
            Self::vr19_8_14 => write!(f, "vr19_8_14"),
            Self::vr19_8_15 => write!(f, "vr19_8_15"),
            Self::vr20_8_0 => write!(f, "vr20_8_0"),
            Self::vr20_8_1 => write!(f, "vr20_8_1"),
            Self::vr20_8_2 => write!(f, "vr20_8_2"),
            Self::vr20_8_3 => write!(f, "vr20_8_3"),
            Self::vr20_8_4 => write!(f, "vr20_8_4"),
            Self::vr20_8_5 => write!(f, "vr20_8_5"),
            Self::vr20_8_6 => write!(f, "vr20_8_6"),
            Self::vr20_8_7 => write!(f, "vr20_8_7"),
            Self::vr20_8_8 => write!(f, "vr20_8_8"),
            Self::vr20_8_9 => write!(f, "vr20_8_9"),
            Self::vr20_8_10 => write!(f, "vr20_8_10"),
            Self::vr20_8_11 => write!(f, "vr20_8_11"),
            Self::vr20_8_12 => write!(f, "vr20_8_12"),
            Self::vr20_8_13 => write!(f, "vr20_8_13"),
            Self::vr20_8_14 => write!(f, "vr20_8_14"),
            Self::vr20_8_15 => write!(f, "vr20_8_15"),
            Self::vr21_8_0 => write!(f, "vr21_8_0"),
            Self::vr21_8_1 => write!(f, "vr21_8_1"),
            Self::vr21_8_2 => write!(f, "vr21_8_2"),
            Self::vr21_8_3 => write!(f, "vr21_8_3"),
            Self::vr21_8_4 => write!(f, "vr21_8_4"),
            Self::vr21_8_5 => write!(f, "vr21_8_5"),
            Self::vr21_8_6 => write!(f, "vr21_8_6"),
            Self::vr21_8_7 => write!(f, "vr21_8_7"),
            Self::vr21_8_8 => write!(f, "vr21_8_8"),
            Self::vr21_8_9 => write!(f, "vr21_8_9"),
            Self::vr21_8_10 => write!(f, "vr21_8_10"),
            Self::vr21_8_11 => write!(f, "vr21_8_11"),
            Self::vr21_8_12 => write!(f, "vr21_8_12"),
            Self::vr21_8_13 => write!(f, "vr21_8_13"),
            Self::vr21_8_14 => write!(f, "vr21_8_14"),
            Self::vr21_8_15 => write!(f, "vr21_8_15"),
            Self::vr22_8_0 => write!(f, "vr22_8_0"),
            Self::vr22_8_1 => write!(f, "vr22_8_1"),
            Self::vr22_8_2 => write!(f, "vr22_8_2"),
            Self::vr22_8_3 => write!(f, "vr22_8_3"),
            Self::vr22_8_4 => write!(f, "vr22_8_4"),
            Self::vr22_8_5 => write!(f, "vr22_8_5"),
            Self::vr22_8_6 => write!(f, "vr22_8_6"),
            Self::vr22_8_7 => write!(f, "vr22_8_7"),
            Self::vr22_8_8 => write!(f, "vr22_8_8"),
            Self::vr22_8_9 => write!(f, "vr22_8_9"),
            Self::vr22_8_10 => write!(f, "vr22_8_10"),
            Self::vr22_8_11 => write!(f, "vr22_8_11"),
            Self::vr22_8_12 => write!(f, "vr22_8_12"),
            Self::vr22_8_13 => write!(f, "vr22_8_13"),
            Self::vr22_8_14 => write!(f, "vr22_8_14"),
            Self::vr22_8_15 => write!(f, "vr22_8_15"),
            Self::vr23_8_0 => write!(f, "vr23_8_0"),
            Self::vr23_8_1 => write!(f, "vr23_8_1"),
            Self::vr23_8_2 => write!(f, "vr23_8_2"),
            Self::vr23_8_3 => write!(f, "vr23_8_3"),
            Self::vr23_8_4 => write!(f, "vr23_8_4"),
            Self::vr23_8_5 => write!(f, "vr23_8_5"),
            Self::vr23_8_6 => write!(f, "vr23_8_6"),
            Self::vr23_8_7 => write!(f, "vr23_8_7"),
            Self::vr23_8_8 => write!(f, "vr23_8_8"),
            Self::vr23_8_9 => write!(f, "vr23_8_9"),
            Self::vr23_8_10 => write!(f, "vr23_8_10"),
            Self::vr23_8_11 => write!(f, "vr23_8_11"),
            Self::vr23_8_12 => write!(f, "vr23_8_12"),
            Self::vr23_8_13 => write!(f, "vr23_8_13"),
            Self::vr23_8_14 => write!(f, "vr23_8_14"),
            Self::vr23_8_15 => write!(f, "vr23_8_15"),
            Self::vr24_8_0 => write!(f, "vr24_8_0"),
            Self::vr24_8_1 => write!(f, "vr24_8_1"),
            Self::vr24_8_2 => write!(f, "vr24_8_2"),
            Self::vr24_8_3 => write!(f, "vr24_8_3"),
            Self::vr24_8_4 => write!(f, "vr24_8_4"),
            Self::vr24_8_5 => write!(f, "vr24_8_5"),
            Self::vr24_8_6 => write!(f, "vr24_8_6"),
            Self::vr24_8_7 => write!(f, "vr24_8_7"),
            Self::vr24_8_8 => write!(f, "vr24_8_8"),
            Self::vr24_8_9 => write!(f, "vr24_8_9"),
            Self::vr24_8_10 => write!(f, "vr24_8_10"),
            Self::vr24_8_11 => write!(f, "vr24_8_11"),
            Self::vr24_8_12 => write!(f, "vr24_8_12"),
            Self::vr24_8_13 => write!(f, "vr24_8_13"),
            Self::vr24_8_14 => write!(f, "vr24_8_14"),
            Self::vr24_8_15 => write!(f, "vr24_8_15"),
            Self::vr25_8_0 => write!(f, "vr25_8_0"),
            Self::vr25_8_1 => write!(f, "vr25_8_1"),
            Self::vr25_8_2 => write!(f, "vr25_8_2"),
            Self::vr25_8_3 => write!(f, "vr25_8_3"),
            Self::vr25_8_4 => write!(f, "vr25_8_4"),
            Self::vr25_8_5 => write!(f, "vr25_8_5"),
            Self::vr25_8_6 => write!(f, "vr25_8_6"),
            Self::vr25_8_7 => write!(f, "vr25_8_7"),
            Self::vr25_8_8 => write!(f, "vr25_8_8"),
            Self::vr25_8_9 => write!(f, "vr25_8_9"),
            Self::vr25_8_10 => write!(f, "vr25_8_10"),
            Self::vr25_8_11 => write!(f, "vr25_8_11"),
            Self::vr25_8_12 => write!(f, "vr25_8_12"),
            Self::vr25_8_13 => write!(f, "vr25_8_13"),
            Self::vr25_8_14 => write!(f, "vr25_8_14"),
            Self::vr25_8_15 => write!(f, "vr25_8_15"),
            Self::vr26_8_0 => write!(f, "vr26_8_0"),
            Self::vr26_8_1 => write!(f, "vr26_8_1"),
            Self::vr26_8_2 => write!(f, "vr26_8_2"),
            Self::vr26_8_3 => write!(f, "vr26_8_3"),
            Self::vr26_8_4 => write!(f, "vr26_8_4"),
            Self::vr26_8_5 => write!(f, "vr26_8_5"),
            Self::vr26_8_6 => write!(f, "vr26_8_6"),
            Self::vr26_8_7 => write!(f, "vr26_8_7"),
            Self::vr26_8_8 => write!(f, "vr26_8_8"),
            Self::vr26_8_9 => write!(f, "vr26_8_9"),
            Self::vr26_8_10 => write!(f, "vr26_8_10"),
            Self::vr26_8_11 => write!(f, "vr26_8_11"),
            Self::vr26_8_12 => write!(f, "vr26_8_12"),
            Self::vr26_8_13 => write!(f, "vr26_8_13"),
            Self::vr26_8_14 => write!(f, "vr26_8_14"),
            Self::vr26_8_15 => write!(f, "vr26_8_15"),
            Self::vr27_8_0 => write!(f, "vr27_8_0"),
            Self::vr27_8_1 => write!(f, "vr27_8_1"),
            Self::vr27_8_2 => write!(f, "vr27_8_2"),
            Self::vr27_8_3 => write!(f, "vr27_8_3"),
            Self::vr27_8_4 => write!(f, "vr27_8_4"),
            Self::vr27_8_5 => write!(f, "vr27_8_5"),
            Self::vr27_8_6 => write!(f, "vr27_8_6"),
            Self::vr27_8_7 => write!(f, "vr27_8_7"),
            Self::vr27_8_8 => write!(f, "vr27_8_8"),
            Self::vr27_8_9 => write!(f, "vr27_8_9"),
            Self::vr27_8_10 => write!(f, "vr27_8_10"),
            Self::vr27_8_11 => write!(f, "vr27_8_11"),
            Self::vr27_8_12 => write!(f, "vr27_8_12"),
            Self::vr27_8_13 => write!(f, "vr27_8_13"),
            Self::vr27_8_14 => write!(f, "vr27_8_14"),
            Self::vr27_8_15 => write!(f, "vr27_8_15"),
            Self::vr28_8_0 => write!(f, "vr28_8_0"),
            Self::vr28_8_1 => write!(f, "vr28_8_1"),
            Self::vr28_8_2 => write!(f, "vr28_8_2"),
            Self::vr28_8_3 => write!(f, "vr28_8_3"),
            Self::vr28_8_4 => write!(f, "vr28_8_4"),
            Self::vr28_8_5 => write!(f, "vr28_8_5"),
            Self::vr28_8_6 => write!(f, "vr28_8_6"),
            Self::vr28_8_7 => write!(f, "vr28_8_7"),
            Self::vr28_8_8 => write!(f, "vr28_8_8"),
            Self::vr28_8_9 => write!(f, "vr28_8_9"),
            Self::vr28_8_10 => write!(f, "vr28_8_10"),
            Self::vr28_8_11 => write!(f, "vr28_8_11"),
            Self::vr28_8_12 => write!(f, "vr28_8_12"),
            Self::vr28_8_13 => write!(f, "vr28_8_13"),
            Self::vr28_8_14 => write!(f, "vr28_8_14"),
            Self::vr28_8_15 => write!(f, "vr28_8_15"),
            Self::vr29_8_0 => write!(f, "vr29_8_0"),
            Self::vr29_8_1 => write!(f, "vr29_8_1"),
            Self::vr29_8_2 => write!(f, "vr29_8_2"),
            Self::vr29_8_3 => write!(f, "vr29_8_3"),
            Self::vr29_8_4 => write!(f, "vr29_8_4"),
            Self::vr29_8_5 => write!(f, "vr29_8_5"),
            Self::vr29_8_6 => write!(f, "vr29_8_6"),
            Self::vr29_8_7 => write!(f, "vr29_8_7"),
            Self::vr29_8_8 => write!(f, "vr29_8_8"),
            Self::vr29_8_9 => write!(f, "vr29_8_9"),
            Self::vr29_8_10 => write!(f, "vr29_8_10"),
            Self::vr29_8_11 => write!(f, "vr29_8_11"),
            Self::vr29_8_12 => write!(f, "vr29_8_12"),
            Self::vr29_8_13 => write!(f, "vr29_8_13"),
            Self::vr29_8_14 => write!(f, "vr29_8_14"),
            Self::vr29_8_15 => write!(f, "vr29_8_15"),
            Self::vr30_8_0 => write!(f, "vr30_8_0"),
            Self::vr30_8_1 => write!(f, "vr30_8_1"),
            Self::vr30_8_2 => write!(f, "vr30_8_2"),
            Self::vr30_8_3 => write!(f, "vr30_8_3"),
            Self::vr30_8_4 => write!(f, "vr30_8_4"),
            Self::vr30_8_5 => write!(f, "vr30_8_5"),
            Self::vr30_8_6 => write!(f, "vr30_8_6"),
            Self::vr30_8_7 => write!(f, "vr30_8_7"),
            Self::vr30_8_8 => write!(f, "vr30_8_8"),
            Self::vr30_8_9 => write!(f, "vr30_8_9"),
            Self::vr30_8_10 => write!(f, "vr30_8_10"),
            Self::vr30_8_11 => write!(f, "vr30_8_11"),
            Self::vr30_8_12 => write!(f, "vr30_8_12"),
            Self::vr30_8_13 => write!(f, "vr30_8_13"),
            Self::vr30_8_14 => write!(f, "vr30_8_14"),
            Self::vr30_8_15 => write!(f, "vr30_8_15"),
            Self::vr31_8_0 => write!(f, "vr31_8_0"),
            Self::vr31_8_1 => write!(f, "vr31_8_1"),
            Self::vr31_8_2 => write!(f, "vr31_8_2"),
            Self::vr31_8_3 => write!(f, "vr31_8_3"),
            Self::vr31_8_4 => write!(f, "vr31_8_4"),
            Self::vr31_8_5 => write!(f, "vr31_8_5"),
            Self::vr31_8_6 => write!(f, "vr31_8_6"),
            Self::vr31_8_7 => write!(f, "vr31_8_7"),
            Self::vr31_8_8 => write!(f, "vr31_8_8"),
            Self::vr31_8_9 => write!(f, "vr31_8_9"),
            Self::vr31_8_10 => write!(f, "vr31_8_10"),
            Self::vr31_8_11 => write!(f, "vr31_8_11"),
            Self::vr31_8_12 => write!(f, "vr31_8_12"),
            Self::vr31_8_13 => write!(f, "vr31_8_13"),
            Self::vr31_8_14 => write!(f, "vr31_8_14"),
            Self::vr31_8_15 => write!(f, "vr31_8_15"),
            Self::contextreg => write!(f, "contextreg"),
            Self::dcr000 => write!(f, "dcr000"),
            Self::dcr001 => write!(f, "dcr001"),
            Self::dcr002 => write!(f, "dcr002"),
            Self::dcr003 => write!(f, "dcr003"),
            Self::dcr004 => write!(f, "dcr004"),
            Self::dcr005 => write!(f, "dcr005"),
            Self::dcr006 => write!(f, "dcr006"),
            Self::dcr007 => write!(f, "dcr007"),
            Self::dcr008 => write!(f, "dcr008"),
            Self::dcr009 => write!(f, "dcr009"),
            Self::dcr00a => write!(f, "dcr00a"),
            Self::dcr00b => write!(f, "dcr00b"),
            Self::dcr00c => write!(f, "dcr00c"),
            Self::dcr00d => write!(f, "dcr00d"),
            Self::dcr00e => write!(f, "dcr00e"),
            Self::dcr00f => write!(f, "dcr00f"),
            Self::dcr010 => write!(f, "dcr010"),
            Self::dcr011 => write!(f, "dcr011"),
            Self::dcr012 => write!(f, "dcr012"),
            Self::dcr013 => write!(f, "dcr013"),
            Self::dcr014 => write!(f, "dcr014"),
            Self::dcr015 => write!(f, "dcr015"),
            Self::dcr016 => write!(f, "dcr016"),
            Self::dcr017 => write!(f, "dcr017"),
            Self::dcr018 => write!(f, "dcr018"),
            Self::dcr019 => write!(f, "dcr019"),
            Self::dcr01a => write!(f, "dcr01a"),
            Self::dcr01b => write!(f, "dcr01b"),
            Self::dcr01c => write!(f, "dcr01c"),
            Self::dcr01d => write!(f, "dcr01d"),
            Self::dcr01e => write!(f, "dcr01e"),
            Self::dcr01f => write!(f, "dcr01f"),
            Self::dcr020 => write!(f, "dcr020"),
            Self::dcr021 => write!(f, "dcr021"),
            Self::dcr022 => write!(f, "dcr022"),
            Self::dcr023 => write!(f, "dcr023"),
            Self::dcr024 => write!(f, "dcr024"),
            Self::dcr025 => write!(f, "dcr025"),
            Self::dcr026 => write!(f, "dcr026"),
            Self::dcr027 => write!(f, "dcr027"),
            Self::dcr028 => write!(f, "dcr028"),
            Self::dcr029 => write!(f, "dcr029"),
            Self::dcr02a => write!(f, "dcr02a"),
            Self::dcr02b => write!(f, "dcr02b"),
            Self::dcr02c => write!(f, "dcr02c"),
            Self::dcr02d => write!(f, "dcr02d"),
            Self::dcr02e => write!(f, "dcr02e"),
            Self::dcr02f => write!(f, "dcr02f"),
            Self::dcr030 => write!(f, "dcr030"),
            Self::dcr031 => write!(f, "dcr031"),
            Self::dcr032 => write!(f, "dcr032"),
            Self::dcr033 => write!(f, "dcr033"),
            Self::dcr034 => write!(f, "dcr034"),
            Self::dcr035 => write!(f, "dcr035"),
            Self::dcr036 => write!(f, "dcr036"),
            Self::dcr037 => write!(f, "dcr037"),
            Self::dcr038 => write!(f, "dcr038"),
            Self::dcr039 => write!(f, "dcr039"),
            Self::dcr03a => write!(f, "dcr03a"),
            Self::dcr03b => write!(f, "dcr03b"),
            Self::dcr03c => write!(f, "dcr03c"),
            Self::dcr03d => write!(f, "dcr03d"),
            Self::dcr03e => write!(f, "dcr03e"),
            Self::dcr03f => write!(f, "dcr03f"),
            Self::dcr040 => write!(f, "dcr040"),
            Self::dcr041 => write!(f, "dcr041"),
            Self::dcr042 => write!(f, "dcr042"),
            Self::dcr043 => write!(f, "dcr043"),
            Self::dcr044 => write!(f, "dcr044"),
            Self::dcr045 => write!(f, "dcr045"),
            Self::dcr046 => write!(f, "dcr046"),
            Self::dcr047 => write!(f, "dcr047"),
            Self::dcr048 => write!(f, "dcr048"),
            Self::dcr049 => write!(f, "dcr049"),
            Self::dcr04a => write!(f, "dcr04a"),
            Self::dcr04b => write!(f, "dcr04b"),
            Self::dcr04c => write!(f, "dcr04c"),
            Self::dcr04d => write!(f, "dcr04d"),
            Self::dcr04e => write!(f, "dcr04e"),
            Self::dcr04f => write!(f, "dcr04f"),
            Self::dcr050 => write!(f, "dcr050"),
            Self::dcr051 => write!(f, "dcr051"),
            Self::dcr052 => write!(f, "dcr052"),
            Self::dcr053 => write!(f, "dcr053"),
            Self::dcr054 => write!(f, "dcr054"),
            Self::dcr055 => write!(f, "dcr055"),
            Self::dcr056 => write!(f, "dcr056"),
            Self::dcr057 => write!(f, "dcr057"),
            Self::dcr058 => write!(f, "dcr058"),
            Self::dcr059 => write!(f, "dcr059"),
            Self::dcr05a => write!(f, "dcr05a"),
            Self::dcr05b => write!(f, "dcr05b"),
            Self::dcr05c => write!(f, "dcr05c"),
            Self::dcr05d => write!(f, "dcr05d"),
            Self::dcr05e => write!(f, "dcr05e"),
            Self::dcr05f => write!(f, "dcr05f"),
            Self::dcr060 => write!(f, "dcr060"),
            Self::dcr061 => write!(f, "dcr061"),
            Self::dcr062 => write!(f, "dcr062"),
            Self::dcr063 => write!(f, "dcr063"),
            Self::dcr064 => write!(f, "dcr064"),
            Self::dcr065 => write!(f, "dcr065"),
            Self::dcr066 => write!(f, "dcr066"),
            Self::dcr067 => write!(f, "dcr067"),
            Self::dcr068 => write!(f, "dcr068"),
            Self::dcr069 => write!(f, "dcr069"),
            Self::dcr06a => write!(f, "dcr06a"),
            Self::dcr06b => write!(f, "dcr06b"),
            Self::dcr06c => write!(f, "dcr06c"),
            Self::dcr06d => write!(f, "dcr06d"),
            Self::dcr06e => write!(f, "dcr06e"),
            Self::dcr06f => write!(f, "dcr06f"),
            Self::dcr070 => write!(f, "dcr070"),
            Self::dcr071 => write!(f, "dcr071"),
            Self::dcr072 => write!(f, "dcr072"),
            Self::dcr073 => write!(f, "dcr073"),
            Self::dcr074 => write!(f, "dcr074"),
            Self::dcr075 => write!(f, "dcr075"),
            Self::dcr076 => write!(f, "dcr076"),
            Self::dcr077 => write!(f, "dcr077"),
            Self::dcr078 => write!(f, "dcr078"),
            Self::dcr079 => write!(f, "dcr079"),
            Self::dcr07a => write!(f, "dcr07a"),
            Self::dcr07b => write!(f, "dcr07b"),
            Self::dcr07c => write!(f, "dcr07c"),
            Self::dcr07d => write!(f, "dcr07d"),
            Self::dcr07e => write!(f, "dcr07e"),
            Self::dcr07f => write!(f, "dcr07f"),
            Self::dcr080 => write!(f, "dcr080"),
            Self::dcr081 => write!(f, "dcr081"),
            Self::dcr082 => write!(f, "dcr082"),
            Self::dcr083 => write!(f, "dcr083"),
            Self::dcr084 => write!(f, "dcr084"),
            Self::dcr085 => write!(f, "dcr085"),
            Self::dcr086 => write!(f, "dcr086"),
            Self::dcr087 => write!(f, "dcr087"),
            Self::dcr088 => write!(f, "dcr088"),
            Self::dcr089 => write!(f, "dcr089"),
            Self::dcr08a => write!(f, "dcr08a"),
            Self::dcr08b => write!(f, "dcr08b"),
            Self::dcr08c => write!(f, "dcr08c"),
            Self::dcr08d => write!(f, "dcr08d"),
            Self::dcr08e => write!(f, "dcr08e"),
            Self::dcr08f => write!(f, "dcr08f"),
            Self::dcr090 => write!(f, "dcr090"),
            Self::dcr091 => write!(f, "dcr091"),
            Self::dcr092 => write!(f, "dcr092"),
            Self::dcr093 => write!(f, "dcr093"),
            Self::dcr094 => write!(f, "dcr094"),
            Self::dcr095 => write!(f, "dcr095"),
            Self::dcr096 => write!(f, "dcr096"),
            Self::dcr097 => write!(f, "dcr097"),
            Self::dcr098 => write!(f, "dcr098"),
            Self::dcr099 => write!(f, "dcr099"),
            Self::dcr09a => write!(f, "dcr09a"),
            Self::dcr09b => write!(f, "dcr09b"),
            Self::dcr09c => write!(f, "dcr09c"),
            Self::dcr09d => write!(f, "dcr09d"),
            Self::dcr09e => write!(f, "dcr09e"),
            Self::dcr09f => write!(f, "dcr09f"),
            Self::dcr0a0 => write!(f, "dcr0a0"),
            Self::dcr0a1 => write!(f, "dcr0a1"),
            Self::dcr0a2 => write!(f, "dcr0a2"),
            Self::dcr0a3 => write!(f, "dcr0a3"),
            Self::dcr0a4 => write!(f, "dcr0a4"),
            Self::dcr0a5 => write!(f, "dcr0a5"),
            Self::dcr0a6 => write!(f, "dcr0a6"),
            Self::dcr0a7 => write!(f, "dcr0a7"),
            Self::dcr0a8 => write!(f, "dcr0a8"),
            Self::dcr0a9 => write!(f, "dcr0a9"),
            Self::dcr0aa => write!(f, "dcr0aa"),
            Self::dcr0ab => write!(f, "dcr0ab"),
            Self::dcr0ac => write!(f, "dcr0ac"),
            Self::dcr0ad => write!(f, "dcr0ad"),
            Self::dcr0ae => write!(f, "dcr0ae"),
            Self::dcr0af => write!(f, "dcr0af"),
            Self::dcr0b0 => write!(f, "dcr0b0"),
            Self::dcr0b1 => write!(f, "dcr0b1"),
            Self::dcr0b2 => write!(f, "dcr0b2"),
            Self::dcr0b3 => write!(f, "dcr0b3"),
            Self::dcr0b4 => write!(f, "dcr0b4"),
            Self::dcr0b5 => write!(f, "dcr0b5"),
            Self::dcr0b6 => write!(f, "dcr0b6"),
            Self::dcr0b7 => write!(f, "dcr0b7"),
            Self::dcr0b8 => write!(f, "dcr0b8"),
            Self::dcr0b9 => write!(f, "dcr0b9"),
            Self::dcr0ba => write!(f, "dcr0ba"),
            Self::dcr0bb => write!(f, "dcr0bb"),
            Self::dcr0bc => write!(f, "dcr0bc"),
            Self::dcr0bd => write!(f, "dcr0bd"),
            Self::dcr0be => write!(f, "dcr0be"),
            Self::dcr0bf => write!(f, "dcr0bf"),
            Self::dcr0c0 => write!(f, "dcr0c0"),
            Self::dcr0c1 => write!(f, "dcr0c1"),
            Self::dcr0c2 => write!(f, "dcr0c2"),
            Self::dcr0c3 => write!(f, "dcr0c3"),
            Self::dcr0c4 => write!(f, "dcr0c4"),
            Self::dcr0c5 => write!(f, "dcr0c5"),
            Self::dcr0c6 => write!(f, "dcr0c6"),
            Self::dcr0c7 => write!(f, "dcr0c7"),
            Self::dcr0c8 => write!(f, "dcr0c8"),
            Self::dcr0c9 => write!(f, "dcr0c9"),
            Self::dcr0ca => write!(f, "dcr0ca"),
            Self::dcr0cb => write!(f, "dcr0cb"),
            Self::dcr0cc => write!(f, "dcr0cc"),
            Self::dcr0cd => write!(f, "dcr0cd"),
            Self::dcr0ce => write!(f, "dcr0ce"),
            Self::dcr0cf => write!(f, "dcr0cf"),
            Self::dcr0d0 => write!(f, "dcr0d0"),
            Self::dcr0d1 => write!(f, "dcr0d1"),
            Self::dcr0d2 => write!(f, "dcr0d2"),
            Self::dcr0d3 => write!(f, "dcr0d3"),
            Self::dcr0d4 => write!(f, "dcr0d4"),
            Self::dcr0d5 => write!(f, "dcr0d5"),
            Self::dcr0d6 => write!(f, "dcr0d6"),
            Self::dcr0d7 => write!(f, "dcr0d7"),
            Self::dcr0d8 => write!(f, "dcr0d8"),
            Self::dcr0d9 => write!(f, "dcr0d9"),
            Self::dcr0da => write!(f, "dcr0da"),
            Self::dcr0db => write!(f, "dcr0db"),
            Self::dcr0dc => write!(f, "dcr0dc"),
            Self::dcr0dd => write!(f, "dcr0dd"),
            Self::dcr0de => write!(f, "dcr0de"),
            Self::dcr0df => write!(f, "dcr0df"),
            Self::dcr0e0 => write!(f, "dcr0e0"),
            Self::dcr0e1 => write!(f, "dcr0e1"),
            Self::dcr0e2 => write!(f, "dcr0e2"),
            Self::dcr0e3 => write!(f, "dcr0e3"),
            Self::dcr0e4 => write!(f, "dcr0e4"),
            Self::dcr0e5 => write!(f, "dcr0e5"),
            Self::dcr0e6 => write!(f, "dcr0e6"),
            Self::dcr0e7 => write!(f, "dcr0e7"),
            Self::dcr0e8 => write!(f, "dcr0e8"),
            Self::dcr0e9 => write!(f, "dcr0e9"),
            Self::dcr0ea => write!(f, "dcr0ea"),
            Self::dcr0eb => write!(f, "dcr0eb"),
            Self::dcr0ec => write!(f, "dcr0ec"),
            Self::dcr0ed => write!(f, "dcr0ed"),
            Self::dcr0ee => write!(f, "dcr0ee"),
            Self::dcr0ef => write!(f, "dcr0ef"),
            Self::dcr0f0 => write!(f, "dcr0f0"),
            Self::dcr0f1 => write!(f, "dcr0f1"),
            Self::dcr0f2 => write!(f, "dcr0f2"),
            Self::dcr0f3 => write!(f, "dcr0f3"),
            Self::dcr0f4 => write!(f, "dcr0f4"),
            Self::dcr0f5 => write!(f, "dcr0f5"),
            Self::dcr0f6 => write!(f, "dcr0f6"),
            Self::dcr0f7 => write!(f, "dcr0f7"),
            Self::dcr0f8 => write!(f, "dcr0f8"),
            Self::dcr0f9 => write!(f, "dcr0f9"),
            Self::dcr0fa => write!(f, "dcr0fa"),
            Self::dcr0fb => write!(f, "dcr0fb"),
            Self::dcr0fc => write!(f, "dcr0fc"),
            Self::dcr0fd => write!(f, "dcr0fd"),
            Self::dcr0fe => write!(f, "dcr0fe"),
            Self::dcr0ff => write!(f, "dcr0ff"),
            Self::dcr100 => write!(f, "dcr100"),
            Self::dcr101 => write!(f, "dcr101"),
            Self::dcr102 => write!(f, "dcr102"),
            Self::dcr103 => write!(f, "dcr103"),
            Self::dcr104 => write!(f, "dcr104"),
            Self::dcr105 => write!(f, "dcr105"),
            Self::dcr106 => write!(f, "dcr106"),
            Self::dcr107 => write!(f, "dcr107"),
            Self::dcr108 => write!(f, "dcr108"),
            Self::dcr109 => write!(f, "dcr109"),
            Self::dcr10a => write!(f, "dcr10a"),
            Self::dcr10b => write!(f, "dcr10b"),
            Self::dcr10c => write!(f, "dcr10c"),
            Self::dcr10d => write!(f, "dcr10d"),
            Self::dcr10e => write!(f, "dcr10e"),
            Self::dcr10f => write!(f, "dcr10f"),
            Self::dcr110 => write!(f, "dcr110"),
            Self::dcr111 => write!(f, "dcr111"),
            Self::dcr112 => write!(f, "dcr112"),
            Self::dcr113 => write!(f, "dcr113"),
            Self::dcr114 => write!(f, "dcr114"),
            Self::dcr115 => write!(f, "dcr115"),
            Self::dcr116 => write!(f, "dcr116"),
            Self::dcr117 => write!(f, "dcr117"),
            Self::dcr118 => write!(f, "dcr118"),
            Self::dcr119 => write!(f, "dcr119"),
            Self::dcr11a => write!(f, "dcr11a"),
            Self::dcr11b => write!(f, "dcr11b"),
            Self::dcr11c => write!(f, "dcr11c"),
            Self::dcr11d => write!(f, "dcr11d"),
            Self::dcr11e => write!(f, "dcr11e"),
            Self::dcr11f => write!(f, "dcr11f"),
            Self::dcr120 => write!(f, "dcr120"),
            Self::dcr121 => write!(f, "dcr121"),
            Self::dcr122 => write!(f, "dcr122"),
            Self::dcr123 => write!(f, "dcr123"),
            Self::dcr124 => write!(f, "dcr124"),
            Self::dcr125 => write!(f, "dcr125"),
            Self::dcr126 => write!(f, "dcr126"),
            Self::dcr127 => write!(f, "dcr127"),
            Self::dcr128 => write!(f, "dcr128"),
            Self::dcr129 => write!(f, "dcr129"),
            Self::dcr12a => write!(f, "dcr12a"),
            Self::dcr12b => write!(f, "dcr12b"),
            Self::dcr12c => write!(f, "dcr12c"),
            Self::dcr12d => write!(f, "dcr12d"),
            Self::dcr12e => write!(f, "dcr12e"),
            Self::dcr12f => write!(f, "dcr12f"),
            Self::dcr130 => write!(f, "dcr130"),
            Self::dcr131 => write!(f, "dcr131"),
            Self::dcr132 => write!(f, "dcr132"),
            Self::dcr133 => write!(f, "dcr133"),
            Self::dcr134 => write!(f, "dcr134"),
            Self::dcr135 => write!(f, "dcr135"),
            Self::dcr136 => write!(f, "dcr136"),
            Self::dcr137 => write!(f, "dcr137"),
            Self::dcr138 => write!(f, "dcr138"),
            Self::dcr139 => write!(f, "dcr139"),
            Self::dcr13a => write!(f, "dcr13a"),
            Self::dcr13b => write!(f, "dcr13b"),
            Self::dcr13c => write!(f, "dcr13c"),
            Self::dcr13d => write!(f, "dcr13d"),
            Self::dcr13e => write!(f, "dcr13e"),
            Self::dcr13f => write!(f, "dcr13f"),
            Self::dcr140 => write!(f, "dcr140"),
            Self::dcr141 => write!(f, "dcr141"),
            Self::dcr142 => write!(f, "dcr142"),
            Self::dcr143 => write!(f, "dcr143"),
            Self::dcr144 => write!(f, "dcr144"),
            Self::dcr145 => write!(f, "dcr145"),
            Self::dcr146 => write!(f, "dcr146"),
            Self::dcr147 => write!(f, "dcr147"),
            Self::dcr148 => write!(f, "dcr148"),
            Self::dcr149 => write!(f, "dcr149"),
            Self::dcr14a => write!(f, "dcr14a"),
            Self::dcr14b => write!(f, "dcr14b"),
            Self::dcr14c => write!(f, "dcr14c"),
            Self::dcr14d => write!(f, "dcr14d"),
            Self::dcr14e => write!(f, "dcr14e"),
            Self::dcr14f => write!(f, "dcr14f"),
            Self::dcr150 => write!(f, "dcr150"),
            Self::dcr151 => write!(f, "dcr151"),
            Self::dcr152 => write!(f, "dcr152"),
            Self::dcr153 => write!(f, "dcr153"),
            Self::dcr154 => write!(f, "dcr154"),
            Self::dcr155 => write!(f, "dcr155"),
            Self::dcr156 => write!(f, "dcr156"),
            Self::dcr157 => write!(f, "dcr157"),
            Self::dcr158 => write!(f, "dcr158"),
            Self::dcr159 => write!(f, "dcr159"),
            Self::dcr15a => write!(f, "dcr15a"),
            Self::dcr15b => write!(f, "dcr15b"),
            Self::dcr15c => write!(f, "dcr15c"),
            Self::dcr15d => write!(f, "dcr15d"),
            Self::dcr15e => write!(f, "dcr15e"),
            Self::dcr15f => write!(f, "dcr15f"),
            Self::dcr160 => write!(f, "dcr160"),
            Self::dcr161 => write!(f, "dcr161"),
            Self::dcr162 => write!(f, "dcr162"),
            Self::dcr163 => write!(f, "dcr163"),
            Self::dcr164 => write!(f, "dcr164"),
            Self::dcr165 => write!(f, "dcr165"),
            Self::dcr166 => write!(f, "dcr166"),
            Self::dcr167 => write!(f, "dcr167"),
            Self::dcr168 => write!(f, "dcr168"),
            Self::dcr169 => write!(f, "dcr169"),
            Self::dcr16a => write!(f, "dcr16a"),
            Self::dcr16b => write!(f, "dcr16b"),
            Self::dcr16c => write!(f, "dcr16c"),
            Self::dcr16d => write!(f, "dcr16d"),
            Self::dcr16e => write!(f, "dcr16e"),
            Self::dcr16f => write!(f, "dcr16f"),
            Self::dcr170 => write!(f, "dcr170"),
            Self::dcr171 => write!(f, "dcr171"),
            Self::dcr172 => write!(f, "dcr172"),
            Self::dcr173 => write!(f, "dcr173"),
            Self::dcr174 => write!(f, "dcr174"),
            Self::dcr175 => write!(f, "dcr175"),
            Self::dcr176 => write!(f, "dcr176"),
            Self::dcr177 => write!(f, "dcr177"),
            Self::dcr178 => write!(f, "dcr178"),
            Self::dcr179 => write!(f, "dcr179"),
            Self::dcr17a => write!(f, "dcr17a"),
            Self::dcr17b => write!(f, "dcr17b"),
            Self::dcr17c => write!(f, "dcr17c"),
            Self::dcr17d => write!(f, "dcr17d"),
            Self::dcr17e => write!(f, "dcr17e"),
            Self::dcr17f => write!(f, "dcr17f"),
            Self::dcr180 => write!(f, "dcr180"),
            Self::dcr181 => write!(f, "dcr181"),
            Self::dcr182 => write!(f, "dcr182"),
            Self::dcr183 => write!(f, "dcr183"),
            Self::dcr184 => write!(f, "dcr184"),
            Self::dcr185 => write!(f, "dcr185"),
            Self::dcr186 => write!(f, "dcr186"),
            Self::dcr187 => write!(f, "dcr187"),
            Self::dcr188 => write!(f, "dcr188"),
            Self::dcr189 => write!(f, "dcr189"),
            Self::dcr18a => write!(f, "dcr18a"),
            Self::dcr18b => write!(f, "dcr18b"),
            Self::dcr18c => write!(f, "dcr18c"),
            Self::dcr18d => write!(f, "dcr18d"),
            Self::dcr18e => write!(f, "dcr18e"),
            Self::dcr18f => write!(f, "dcr18f"),
            Self::dcr190 => write!(f, "dcr190"),
            Self::dcr191 => write!(f, "dcr191"),
            Self::dcr192 => write!(f, "dcr192"),
            Self::dcr193 => write!(f, "dcr193"),
            Self::dcr194 => write!(f, "dcr194"),
            Self::dcr195 => write!(f, "dcr195"),
            Self::dcr196 => write!(f, "dcr196"),
            Self::dcr197 => write!(f, "dcr197"),
            Self::dcr198 => write!(f, "dcr198"),
            Self::dcr199 => write!(f, "dcr199"),
            Self::dcr19a => write!(f, "dcr19a"),
            Self::dcr19b => write!(f, "dcr19b"),
            Self::dcr19c => write!(f, "dcr19c"),
            Self::dcr19d => write!(f, "dcr19d"),
            Self::dcr19e => write!(f, "dcr19e"),
            Self::dcr19f => write!(f, "dcr19f"),
            Self::dcr1a0 => write!(f, "dcr1a0"),
            Self::dcr1a1 => write!(f, "dcr1a1"),
            Self::dcr1a2 => write!(f, "dcr1a2"),
            Self::dcr1a3 => write!(f, "dcr1a3"),
            Self::dcr1a4 => write!(f, "dcr1a4"),
            Self::dcr1a5 => write!(f, "dcr1a5"),
            Self::dcr1a6 => write!(f, "dcr1a6"),
            Self::dcr1a7 => write!(f, "dcr1a7"),
            Self::dcr1a8 => write!(f, "dcr1a8"),
            Self::dcr1a9 => write!(f, "dcr1a9"),
            Self::dcr1aa => write!(f, "dcr1aa"),
            Self::dcr1ab => write!(f, "dcr1ab"),
            Self::dcr1ac => write!(f, "dcr1ac"),
            Self::dcr1ad => write!(f, "dcr1ad"),
            Self::dcr1ae => write!(f, "dcr1ae"),
            Self::dcr1af => write!(f, "dcr1af"),
            Self::dcr1b0 => write!(f, "dcr1b0"),
            Self::dcr1b1 => write!(f, "dcr1b1"),
            Self::dcr1b2 => write!(f, "dcr1b2"),
            Self::dcr1b3 => write!(f, "dcr1b3"),
            Self::dcr1b4 => write!(f, "dcr1b4"),
            Self::dcr1b5 => write!(f, "dcr1b5"),
            Self::dcr1b6 => write!(f, "dcr1b6"),
            Self::dcr1b7 => write!(f, "dcr1b7"),
            Self::dcr1b8 => write!(f, "dcr1b8"),
            Self::dcr1b9 => write!(f, "dcr1b9"),
            Self::dcr1ba => write!(f, "dcr1ba"),
            Self::dcr1bb => write!(f, "dcr1bb"),
            Self::dcr1bc => write!(f, "dcr1bc"),
            Self::dcr1bd => write!(f, "dcr1bd"),
            Self::dcr1be => write!(f, "dcr1be"),
            Self::dcr1bf => write!(f, "dcr1bf"),
            Self::dcr1c0 => write!(f, "dcr1c0"),
            Self::dcr1c1 => write!(f, "dcr1c1"),
            Self::dcr1c2 => write!(f, "dcr1c2"),
            Self::dcr1c3 => write!(f, "dcr1c3"),
            Self::dcr1c4 => write!(f, "dcr1c4"),
            Self::dcr1c5 => write!(f, "dcr1c5"),
            Self::dcr1c6 => write!(f, "dcr1c6"),
            Self::dcr1c7 => write!(f, "dcr1c7"),
            Self::dcr1c8 => write!(f, "dcr1c8"),
            Self::dcr1c9 => write!(f, "dcr1c9"),
            Self::dcr1ca => write!(f, "dcr1ca"),
            Self::dcr1cb => write!(f, "dcr1cb"),
            Self::dcr1cc => write!(f, "dcr1cc"),
            Self::dcr1cd => write!(f, "dcr1cd"),
            Self::dcr1ce => write!(f, "dcr1ce"),
            Self::dcr1cf => write!(f, "dcr1cf"),
            Self::dcr1d0 => write!(f, "dcr1d0"),
            Self::dcr1d1 => write!(f, "dcr1d1"),
            Self::dcr1d2 => write!(f, "dcr1d2"),
            Self::dcr1d3 => write!(f, "dcr1d3"),
            Self::dcr1d4 => write!(f, "dcr1d4"),
            Self::dcr1d5 => write!(f, "dcr1d5"),
            Self::dcr1d6 => write!(f, "dcr1d6"),
            Self::dcr1d7 => write!(f, "dcr1d7"),
            Self::dcr1d8 => write!(f, "dcr1d8"),
            Self::dcr1d9 => write!(f, "dcr1d9"),
            Self::dcr1da => write!(f, "dcr1da"),
            Self::dcr1db => write!(f, "dcr1db"),
            Self::dcr1dc => write!(f, "dcr1dc"),
            Self::dcr1dd => write!(f, "dcr1dd"),
            Self::dcr1de => write!(f, "dcr1de"),
            Self::dcr1df => write!(f, "dcr1df"),
            Self::dcr1e0 => write!(f, "dcr1e0"),
            Self::dcr1e1 => write!(f, "dcr1e1"),
            Self::dcr1e2 => write!(f, "dcr1e2"),
            Self::dcr1e3 => write!(f, "dcr1e3"),
            Self::dcr1e4 => write!(f, "dcr1e4"),
            Self::dcr1e5 => write!(f, "dcr1e5"),
            Self::dcr1e6 => write!(f, "dcr1e6"),
            Self::dcr1e7 => write!(f, "dcr1e7"),
            Self::dcr1e8 => write!(f, "dcr1e8"),
            Self::dcr1e9 => write!(f, "dcr1e9"),
            Self::dcr1ea => write!(f, "dcr1ea"),
            Self::dcr1eb => write!(f, "dcr1eb"),
            Self::dcr1ec => write!(f, "dcr1ec"),
            Self::dcr1ed => write!(f, "dcr1ed"),
            Self::dcr1ee => write!(f, "dcr1ee"),
            Self::dcr1ef => write!(f, "dcr1ef"),
            Self::dcr1f0 => write!(f, "dcr1f0"),
            Self::dcr1f1 => write!(f, "dcr1f1"),
            Self::dcr1f2 => write!(f, "dcr1f2"),
            Self::dcr1f3 => write!(f, "dcr1f3"),
            Self::dcr1f4 => write!(f, "dcr1f4"),
            Self::dcr1f5 => write!(f, "dcr1f5"),
            Self::dcr1f6 => write!(f, "dcr1f6"),
            Self::dcr1f7 => write!(f, "dcr1f7"),
            Self::dcr1f8 => write!(f, "dcr1f8"),
            Self::dcr1f9 => write!(f, "dcr1f9"),
            Self::dcr1fa => write!(f, "dcr1fa"),
            Self::dcr1fb => write!(f, "dcr1fb"),
            Self::dcr1fc => write!(f, "dcr1fc"),
            Self::dcr1fd => write!(f, "dcr1fd"),
            Self::dcr1fe => write!(f, "dcr1fe"),
            Self::dcr1ff => write!(f, "dcr1ff"),
            Self::dcr200 => write!(f, "dcr200"),
            Self::dcr201 => write!(f, "dcr201"),
            Self::dcr202 => write!(f, "dcr202"),
            Self::dcr203 => write!(f, "dcr203"),
            Self::dcr204 => write!(f, "dcr204"),
            Self::dcr205 => write!(f, "dcr205"),
            Self::dcr206 => write!(f, "dcr206"),
            Self::dcr207 => write!(f, "dcr207"),
            Self::dcr208 => write!(f, "dcr208"),
            Self::dcr209 => write!(f, "dcr209"),
            Self::dcr20a => write!(f, "dcr20a"),
            Self::dcr20b => write!(f, "dcr20b"),
            Self::dcr20c => write!(f, "dcr20c"),
            Self::dcr20d => write!(f, "dcr20d"),
            Self::dcr20e => write!(f, "dcr20e"),
            Self::dcr20f => write!(f, "dcr20f"),
            Self::dcr210 => write!(f, "dcr210"),
            Self::dcr211 => write!(f, "dcr211"),
            Self::dcr212 => write!(f, "dcr212"),
            Self::dcr213 => write!(f, "dcr213"),
            Self::dcr214 => write!(f, "dcr214"),
            Self::dcr215 => write!(f, "dcr215"),
            Self::dcr216 => write!(f, "dcr216"),
            Self::dcr217 => write!(f, "dcr217"),
            Self::dcr218 => write!(f, "dcr218"),
            Self::dcr219 => write!(f, "dcr219"),
            Self::dcr21a => write!(f, "dcr21a"),
            Self::dcr21b => write!(f, "dcr21b"),
            Self::dcr21c => write!(f, "dcr21c"),
            Self::dcr21d => write!(f, "dcr21d"),
            Self::dcr21e => write!(f, "dcr21e"),
            Self::dcr21f => write!(f, "dcr21f"),
            Self::dcr220 => write!(f, "dcr220"),
            Self::dcr221 => write!(f, "dcr221"),
            Self::dcr222 => write!(f, "dcr222"),
            Self::dcr223 => write!(f, "dcr223"),
            Self::dcr224 => write!(f, "dcr224"),
            Self::dcr225 => write!(f, "dcr225"),
            Self::dcr226 => write!(f, "dcr226"),
            Self::dcr227 => write!(f, "dcr227"),
            Self::dcr228 => write!(f, "dcr228"),
            Self::dcr229 => write!(f, "dcr229"),
            Self::dcr22a => write!(f, "dcr22a"),
            Self::dcr22b => write!(f, "dcr22b"),
            Self::dcr22c => write!(f, "dcr22c"),
            Self::dcr22d => write!(f, "dcr22d"),
            Self::dcr22e => write!(f, "dcr22e"),
            Self::dcr22f => write!(f, "dcr22f"),
            Self::dcr230 => write!(f, "dcr230"),
            Self::dcr231 => write!(f, "dcr231"),
            Self::dcr232 => write!(f, "dcr232"),
            Self::dcr233 => write!(f, "dcr233"),
            Self::dcr234 => write!(f, "dcr234"),
            Self::dcr235 => write!(f, "dcr235"),
            Self::dcr236 => write!(f, "dcr236"),
            Self::dcr237 => write!(f, "dcr237"),
            Self::dcr238 => write!(f, "dcr238"),
            Self::dcr239 => write!(f, "dcr239"),
            Self::dcr23a => write!(f, "dcr23a"),
            Self::dcr23b => write!(f, "dcr23b"),
            Self::dcr23c => write!(f, "dcr23c"),
            Self::dcr23d => write!(f, "dcr23d"),
            Self::dcr23e => write!(f, "dcr23e"),
            Self::dcr23f => write!(f, "dcr23f"),
            Self::dcr240 => write!(f, "dcr240"),
            Self::dcr241 => write!(f, "dcr241"),
            Self::dcr242 => write!(f, "dcr242"),
            Self::dcr243 => write!(f, "dcr243"),
            Self::dcr244 => write!(f, "dcr244"),
            Self::dcr245 => write!(f, "dcr245"),
            Self::dcr246 => write!(f, "dcr246"),
            Self::dcr247 => write!(f, "dcr247"),
            Self::dcr248 => write!(f, "dcr248"),
            Self::dcr249 => write!(f, "dcr249"),
            Self::dcr24a => write!(f, "dcr24a"),
            Self::dcr24b => write!(f, "dcr24b"),
            Self::dcr24c => write!(f, "dcr24c"),
            Self::dcr24d => write!(f, "dcr24d"),
            Self::dcr24e => write!(f, "dcr24e"),
            Self::dcr24f => write!(f, "dcr24f"),
            Self::dcr250 => write!(f, "dcr250"),
            Self::dcr251 => write!(f, "dcr251"),
            Self::dcr252 => write!(f, "dcr252"),
            Self::dcr253 => write!(f, "dcr253"),
            Self::dcr254 => write!(f, "dcr254"),
            Self::dcr255 => write!(f, "dcr255"),
            Self::dcr256 => write!(f, "dcr256"),
            Self::dcr257 => write!(f, "dcr257"),
            Self::dcr258 => write!(f, "dcr258"),
            Self::dcr259 => write!(f, "dcr259"),
            Self::dcr25a => write!(f, "dcr25a"),
            Self::dcr25b => write!(f, "dcr25b"),
            Self::dcr25c => write!(f, "dcr25c"),
            Self::dcr25d => write!(f, "dcr25d"),
            Self::dcr25e => write!(f, "dcr25e"),
            Self::dcr25f => write!(f, "dcr25f"),
            Self::dcr260 => write!(f, "dcr260"),
            Self::dcr261 => write!(f, "dcr261"),
            Self::dcr262 => write!(f, "dcr262"),
            Self::dcr263 => write!(f, "dcr263"),
            Self::dcr264 => write!(f, "dcr264"),
            Self::dcr265 => write!(f, "dcr265"),
            Self::dcr266 => write!(f, "dcr266"),
            Self::dcr267 => write!(f, "dcr267"),
            Self::dcr268 => write!(f, "dcr268"),
            Self::dcr269 => write!(f, "dcr269"),
            Self::dcr26a => write!(f, "dcr26a"),
            Self::dcr26b => write!(f, "dcr26b"),
            Self::dcr26c => write!(f, "dcr26c"),
            Self::dcr26d => write!(f, "dcr26d"),
            Self::dcr26e => write!(f, "dcr26e"),
            Self::dcr26f => write!(f, "dcr26f"),
            Self::dcr270 => write!(f, "dcr270"),
            Self::dcr271 => write!(f, "dcr271"),
            Self::dcr272 => write!(f, "dcr272"),
            Self::dcr273 => write!(f, "dcr273"),
            Self::dcr274 => write!(f, "dcr274"),
            Self::dcr275 => write!(f, "dcr275"),
            Self::dcr276 => write!(f, "dcr276"),
            Self::dcr277 => write!(f, "dcr277"),
            Self::dcr278 => write!(f, "dcr278"),
            Self::dcr279 => write!(f, "dcr279"),
            Self::dcr27a => write!(f, "dcr27a"),
            Self::dcr27b => write!(f, "dcr27b"),
            Self::dcr27c => write!(f, "dcr27c"),
            Self::dcr27d => write!(f, "dcr27d"),
            Self::dcr27e => write!(f, "dcr27e"),
            Self::dcr27f => write!(f, "dcr27f"),
            Self::dcr280 => write!(f, "dcr280"),
            Self::dcr281 => write!(f, "dcr281"),
            Self::dcr282 => write!(f, "dcr282"),
            Self::dcr283 => write!(f, "dcr283"),
            Self::dcr284 => write!(f, "dcr284"),
            Self::dcr285 => write!(f, "dcr285"),
            Self::dcr286 => write!(f, "dcr286"),
            Self::dcr287 => write!(f, "dcr287"),
            Self::dcr288 => write!(f, "dcr288"),
            Self::dcr289 => write!(f, "dcr289"),
            Self::dcr28a => write!(f, "dcr28a"),
            Self::dcr28b => write!(f, "dcr28b"),
            Self::dcr28c => write!(f, "dcr28c"),
            Self::dcr28d => write!(f, "dcr28d"),
            Self::dcr28e => write!(f, "dcr28e"),
            Self::dcr28f => write!(f, "dcr28f"),
            Self::dcr290 => write!(f, "dcr290"),
            Self::dcr291 => write!(f, "dcr291"),
            Self::dcr292 => write!(f, "dcr292"),
            Self::dcr293 => write!(f, "dcr293"),
            Self::dcr294 => write!(f, "dcr294"),
            Self::dcr295 => write!(f, "dcr295"),
            Self::dcr296 => write!(f, "dcr296"),
            Self::dcr297 => write!(f, "dcr297"),
            Self::dcr298 => write!(f, "dcr298"),
            Self::dcr299 => write!(f, "dcr299"),
            Self::dcr29a => write!(f, "dcr29a"),
            Self::dcr29b => write!(f, "dcr29b"),
            Self::dcr29c => write!(f, "dcr29c"),
            Self::dcr29d => write!(f, "dcr29d"),
            Self::dcr29e => write!(f, "dcr29e"),
            Self::dcr29f => write!(f, "dcr29f"),
            Self::dcr2a0 => write!(f, "dcr2a0"),
            Self::dcr2a1 => write!(f, "dcr2a1"),
            Self::dcr2a2 => write!(f, "dcr2a2"),
            Self::dcr2a3 => write!(f, "dcr2a3"),
            Self::dcr2a4 => write!(f, "dcr2a4"),
            Self::dcr2a5 => write!(f, "dcr2a5"),
            Self::dcr2a6 => write!(f, "dcr2a6"),
            Self::dcr2a7 => write!(f, "dcr2a7"),
            Self::dcr2a8 => write!(f, "dcr2a8"),
            Self::dcr2a9 => write!(f, "dcr2a9"),
            Self::dcr2aa => write!(f, "dcr2aa"),
            Self::dcr2ab => write!(f, "dcr2ab"),
            Self::dcr2ac => write!(f, "dcr2ac"),
            Self::dcr2ad => write!(f, "dcr2ad"),
            Self::dcr2ae => write!(f, "dcr2ae"),
            Self::dcr2af => write!(f, "dcr2af"),
            Self::dcr2b0 => write!(f, "dcr2b0"),
            Self::dcr2b1 => write!(f, "dcr2b1"),
            Self::dcr2b2 => write!(f, "dcr2b2"),
            Self::dcr2b3 => write!(f, "dcr2b3"),
            Self::dcr2b4 => write!(f, "dcr2b4"),
            Self::dcr2b5 => write!(f, "dcr2b5"),
            Self::dcr2b6 => write!(f, "dcr2b6"),
            Self::dcr2b7 => write!(f, "dcr2b7"),
            Self::dcr2b8 => write!(f, "dcr2b8"),
            Self::dcr2b9 => write!(f, "dcr2b9"),
            Self::dcr2ba => write!(f, "dcr2ba"),
            Self::dcr2bb => write!(f, "dcr2bb"),
            Self::dcr2bc => write!(f, "dcr2bc"),
            Self::dcr2bd => write!(f, "dcr2bd"),
            Self::dcr2be => write!(f, "dcr2be"),
            Self::dcr2bf => write!(f, "dcr2bf"),
            Self::dcr2c0 => write!(f, "dcr2c0"),
            Self::dcr2c1 => write!(f, "dcr2c1"),
            Self::dcr2c2 => write!(f, "dcr2c2"),
            Self::dcr2c3 => write!(f, "dcr2c3"),
            Self::dcr2c4 => write!(f, "dcr2c4"),
            Self::dcr2c5 => write!(f, "dcr2c5"),
            Self::dcr2c6 => write!(f, "dcr2c6"),
            Self::dcr2c7 => write!(f, "dcr2c7"),
            Self::dcr2c8 => write!(f, "dcr2c8"),
            Self::dcr2c9 => write!(f, "dcr2c9"),
            Self::dcr2ca => write!(f, "dcr2ca"),
            Self::dcr2cb => write!(f, "dcr2cb"),
            Self::dcr2cc => write!(f, "dcr2cc"),
            Self::dcr2cd => write!(f, "dcr2cd"),
            Self::dcr2ce => write!(f, "dcr2ce"),
            Self::dcr2cf => write!(f, "dcr2cf"),
            Self::dcr2d0 => write!(f, "dcr2d0"),
            Self::dcr2d1 => write!(f, "dcr2d1"),
            Self::dcr2d2 => write!(f, "dcr2d2"),
            Self::dcr2d3 => write!(f, "dcr2d3"),
            Self::dcr2d4 => write!(f, "dcr2d4"),
            Self::dcr2d5 => write!(f, "dcr2d5"),
            Self::dcr2d6 => write!(f, "dcr2d6"),
            Self::dcr2d7 => write!(f, "dcr2d7"),
            Self::dcr2d8 => write!(f, "dcr2d8"),
            Self::dcr2d9 => write!(f, "dcr2d9"),
            Self::dcr2da => write!(f, "dcr2da"),
            Self::dcr2db => write!(f, "dcr2db"),
            Self::dcr2dc => write!(f, "dcr2dc"),
            Self::dcr2dd => write!(f, "dcr2dd"),
            Self::dcr2de => write!(f, "dcr2de"),
            Self::dcr2df => write!(f, "dcr2df"),
            Self::dcr2e0 => write!(f, "dcr2e0"),
            Self::dcr2e1 => write!(f, "dcr2e1"),
            Self::dcr2e2 => write!(f, "dcr2e2"),
            Self::dcr2e3 => write!(f, "dcr2e3"),
            Self::dcr2e4 => write!(f, "dcr2e4"),
            Self::dcr2e5 => write!(f, "dcr2e5"),
            Self::dcr2e6 => write!(f, "dcr2e6"),
            Self::dcr2e7 => write!(f, "dcr2e7"),
            Self::dcr2e8 => write!(f, "dcr2e8"),
            Self::dcr2e9 => write!(f, "dcr2e9"),
            Self::dcr2ea => write!(f, "dcr2ea"),
            Self::dcr2eb => write!(f, "dcr2eb"),
            Self::dcr2ec => write!(f, "dcr2ec"),
            Self::dcr2ed => write!(f, "dcr2ed"),
            Self::dcr2ee => write!(f, "dcr2ee"),
            Self::dcr2ef => write!(f, "dcr2ef"),
            Self::dcr2f0 => write!(f, "dcr2f0"),
            Self::dcr2f1 => write!(f, "dcr2f1"),
            Self::dcr2f2 => write!(f, "dcr2f2"),
            Self::dcr2f3 => write!(f, "dcr2f3"),
            Self::dcr2f4 => write!(f, "dcr2f4"),
            Self::dcr2f5 => write!(f, "dcr2f5"),
            Self::dcr2f6 => write!(f, "dcr2f6"),
            Self::dcr2f7 => write!(f, "dcr2f7"),
            Self::dcr2f8 => write!(f, "dcr2f8"),
            Self::dcr2f9 => write!(f, "dcr2f9"),
            Self::dcr2fa => write!(f, "dcr2fa"),
            Self::dcr2fb => write!(f, "dcr2fb"),
            Self::dcr2fc => write!(f, "dcr2fc"),
            Self::dcr2fd => write!(f, "dcr2fd"),
            Self::dcr2fe => write!(f, "dcr2fe"),
            Self::dcr2ff => write!(f, "dcr2ff"),
            Self::dcr300 => write!(f, "dcr300"),
            Self::dcr301 => write!(f, "dcr301"),
            Self::dcr302 => write!(f, "dcr302"),
            Self::dcr303 => write!(f, "dcr303"),
            Self::dcr304 => write!(f, "dcr304"),
            Self::dcr305 => write!(f, "dcr305"),
            Self::dcr306 => write!(f, "dcr306"),
            Self::dcr307 => write!(f, "dcr307"),
            Self::dcr308 => write!(f, "dcr308"),
            Self::dcr309 => write!(f, "dcr309"),
            Self::dcr30a => write!(f, "dcr30a"),
            Self::dcr30b => write!(f, "dcr30b"),
            Self::dcr30c => write!(f, "dcr30c"),
            Self::dcr30d => write!(f, "dcr30d"),
            Self::dcr30e => write!(f, "dcr30e"),
            Self::dcr30f => write!(f, "dcr30f"),
            Self::dcr310 => write!(f, "dcr310"),
            Self::dcr311 => write!(f, "dcr311"),
            Self::dcr312 => write!(f, "dcr312"),
            Self::dcr313 => write!(f, "dcr313"),
            Self::dcr314 => write!(f, "dcr314"),
            Self::dcr315 => write!(f, "dcr315"),
            Self::dcr316 => write!(f, "dcr316"),
            Self::dcr317 => write!(f, "dcr317"),
            Self::dcr318 => write!(f, "dcr318"),
            Self::dcr319 => write!(f, "dcr319"),
            Self::dcr31a => write!(f, "dcr31a"),
            Self::dcr31b => write!(f, "dcr31b"),
            Self::dcr31c => write!(f, "dcr31c"),
            Self::dcr31d => write!(f, "dcr31d"),
            Self::dcr31e => write!(f, "dcr31e"),
            Self::dcr31f => write!(f, "dcr31f"),
            Self::dcr320 => write!(f, "dcr320"),
            Self::dcr321 => write!(f, "dcr321"),
            Self::dcr322 => write!(f, "dcr322"),
            Self::dcr323 => write!(f, "dcr323"),
            Self::dcr324 => write!(f, "dcr324"),
            Self::dcr325 => write!(f, "dcr325"),
            Self::dcr326 => write!(f, "dcr326"),
            Self::dcr327 => write!(f, "dcr327"),
            Self::dcr328 => write!(f, "dcr328"),
            Self::dcr329 => write!(f, "dcr329"),
            Self::dcr32a => write!(f, "dcr32a"),
            Self::dcr32b => write!(f, "dcr32b"),
            Self::dcr32c => write!(f, "dcr32c"),
            Self::dcr32d => write!(f, "dcr32d"),
            Self::dcr32e => write!(f, "dcr32e"),
            Self::dcr32f => write!(f, "dcr32f"),
            Self::dcr330 => write!(f, "dcr330"),
            Self::dcr331 => write!(f, "dcr331"),
            Self::dcr332 => write!(f, "dcr332"),
            Self::dcr333 => write!(f, "dcr333"),
            Self::dcr334 => write!(f, "dcr334"),
            Self::dcr335 => write!(f, "dcr335"),
            Self::dcr336 => write!(f, "dcr336"),
            Self::dcr337 => write!(f, "dcr337"),
            Self::dcr338 => write!(f, "dcr338"),
            Self::dcr339 => write!(f, "dcr339"),
            Self::dcr33a => write!(f, "dcr33a"),
            Self::dcr33b => write!(f, "dcr33b"),
            Self::dcr33c => write!(f, "dcr33c"),
            Self::dcr33d => write!(f, "dcr33d"),
            Self::dcr33e => write!(f, "dcr33e"),
            Self::dcr33f => write!(f, "dcr33f"),
            Self::dcr340 => write!(f, "dcr340"),
            Self::dcr341 => write!(f, "dcr341"),
            Self::dcr342 => write!(f, "dcr342"),
            Self::dcr343 => write!(f, "dcr343"),
            Self::dcr344 => write!(f, "dcr344"),
            Self::dcr345 => write!(f, "dcr345"),
            Self::dcr346 => write!(f, "dcr346"),
            Self::dcr347 => write!(f, "dcr347"),
            Self::dcr348 => write!(f, "dcr348"),
            Self::dcr349 => write!(f, "dcr349"),
            Self::dcr34a => write!(f, "dcr34a"),
            Self::dcr34b => write!(f, "dcr34b"),
            Self::dcr34c => write!(f, "dcr34c"),
            Self::dcr34d => write!(f, "dcr34d"),
            Self::dcr34e => write!(f, "dcr34e"),
            Self::dcr34f => write!(f, "dcr34f"),
            Self::dcr350 => write!(f, "dcr350"),
            Self::dcr351 => write!(f, "dcr351"),
            Self::dcr352 => write!(f, "dcr352"),
            Self::dcr353 => write!(f, "dcr353"),
            Self::dcr354 => write!(f, "dcr354"),
            Self::dcr355 => write!(f, "dcr355"),
            Self::dcr356 => write!(f, "dcr356"),
            Self::dcr357 => write!(f, "dcr357"),
            Self::dcr358 => write!(f, "dcr358"),
            Self::dcr359 => write!(f, "dcr359"),
            Self::dcr35a => write!(f, "dcr35a"),
            Self::dcr35b => write!(f, "dcr35b"),
            Self::dcr35c => write!(f, "dcr35c"),
            Self::dcr35d => write!(f, "dcr35d"),
            Self::dcr35e => write!(f, "dcr35e"),
            Self::dcr35f => write!(f, "dcr35f"),
            Self::dcr360 => write!(f, "dcr360"),
            Self::dcr361 => write!(f, "dcr361"),
            Self::dcr362 => write!(f, "dcr362"),
            Self::dcr363 => write!(f, "dcr363"),
            Self::dcr364 => write!(f, "dcr364"),
            Self::dcr365 => write!(f, "dcr365"),
            Self::dcr366 => write!(f, "dcr366"),
            Self::dcr367 => write!(f, "dcr367"),
            Self::dcr368 => write!(f, "dcr368"),
            Self::dcr369 => write!(f, "dcr369"),
            Self::dcr36a => write!(f, "dcr36a"),
            Self::dcr36b => write!(f, "dcr36b"),
            Self::dcr36c => write!(f, "dcr36c"),
            Self::dcr36d => write!(f, "dcr36d"),
            Self::dcr36e => write!(f, "dcr36e"),
            Self::dcr36f => write!(f, "dcr36f"),
            Self::dcr370 => write!(f, "dcr370"),
            Self::dcr371 => write!(f, "dcr371"),
            Self::dcr372 => write!(f, "dcr372"),
            Self::dcr373 => write!(f, "dcr373"),
            Self::dcr374 => write!(f, "dcr374"),
            Self::dcr375 => write!(f, "dcr375"),
            Self::dcr376 => write!(f, "dcr376"),
            Self::dcr377 => write!(f, "dcr377"),
            Self::dcr378 => write!(f, "dcr378"),
            Self::dcr379 => write!(f, "dcr379"),
            Self::dcr37a => write!(f, "dcr37a"),
            Self::dcr37b => write!(f, "dcr37b"),
            Self::dcr37c => write!(f, "dcr37c"),
            Self::dcr37d => write!(f, "dcr37d"),
            Self::dcr37e => write!(f, "dcr37e"),
            Self::dcr37f => write!(f, "dcr37f"),
            Self::dcr380 => write!(f, "dcr380"),
            Self::dcr381 => write!(f, "dcr381"),
            Self::dcr382 => write!(f, "dcr382"),
            Self::dcr383 => write!(f, "dcr383"),
            Self::dcr384 => write!(f, "dcr384"),
            Self::dcr385 => write!(f, "dcr385"),
            Self::dcr386 => write!(f, "dcr386"),
            Self::dcr387 => write!(f, "dcr387"),
            Self::dcr388 => write!(f, "dcr388"),
            Self::dcr389 => write!(f, "dcr389"),
            Self::dcr38a => write!(f, "dcr38a"),
            Self::dcr38b => write!(f, "dcr38b"),
            Self::dcr38c => write!(f, "dcr38c"),
            Self::dcr38d => write!(f, "dcr38d"),
            Self::dcr38e => write!(f, "dcr38e"),
            Self::dcr38f => write!(f, "dcr38f"),
            Self::dcr390 => write!(f, "dcr390"),
            Self::dcr391 => write!(f, "dcr391"),
            Self::dcr392 => write!(f, "dcr392"),
            Self::dcr393 => write!(f, "dcr393"),
            Self::dcr394 => write!(f, "dcr394"),
            Self::dcr395 => write!(f, "dcr395"),
            Self::dcr396 => write!(f, "dcr396"),
            Self::dcr397 => write!(f, "dcr397"),
            Self::dcr398 => write!(f, "dcr398"),
            Self::dcr399 => write!(f, "dcr399"),
            Self::dcr39a => write!(f, "dcr39a"),
            Self::dcr39b => write!(f, "dcr39b"),
            Self::dcr39c => write!(f, "dcr39c"),
            Self::dcr39d => write!(f, "dcr39d"),
            Self::dcr39e => write!(f, "dcr39e"),
            Self::dcr39f => write!(f, "dcr39f"),
            Self::dcr3a0 => write!(f, "dcr3a0"),
            Self::dcr3a1 => write!(f, "dcr3a1"),
            Self::dcr3a2 => write!(f, "dcr3a2"),
            Self::dcr3a3 => write!(f, "dcr3a3"),
            Self::dcr3a4 => write!(f, "dcr3a4"),
            Self::dcr3a5 => write!(f, "dcr3a5"),
            Self::dcr3a6 => write!(f, "dcr3a6"),
            Self::dcr3a7 => write!(f, "dcr3a7"),
            Self::dcr3a8 => write!(f, "dcr3a8"),
            Self::dcr3a9 => write!(f, "dcr3a9"),
            Self::dcr3aa => write!(f, "dcr3aa"),
            Self::dcr3ab => write!(f, "dcr3ab"),
            Self::dcr3ac => write!(f, "dcr3ac"),
            Self::dcr3ad => write!(f, "dcr3ad"),
            Self::dcr3ae => write!(f, "dcr3ae"),
            Self::dcr3af => write!(f, "dcr3af"),
            Self::dcr3b0 => write!(f, "dcr3b0"),
            Self::dcr3b1 => write!(f, "dcr3b1"),
            Self::dcr3b2 => write!(f, "dcr3b2"),
            Self::dcr3b3 => write!(f, "dcr3b3"),
            Self::dcr3b4 => write!(f, "dcr3b4"),
            Self::dcr3b5 => write!(f, "dcr3b5"),
            Self::dcr3b6 => write!(f, "dcr3b6"),
            Self::dcr3b7 => write!(f, "dcr3b7"),
            Self::dcr3b8 => write!(f, "dcr3b8"),
            Self::dcr3b9 => write!(f, "dcr3b9"),
            Self::dcr3ba => write!(f, "dcr3ba"),
            Self::dcr3bb => write!(f, "dcr3bb"),
            Self::dcr3bc => write!(f, "dcr3bc"),
            Self::dcr3bd => write!(f, "dcr3bd"),
            Self::dcr3be => write!(f, "dcr3be"),
            Self::dcr3bf => write!(f, "dcr3bf"),
            Self::dcr3c0 => write!(f, "dcr3c0"),
            Self::dcr3c1 => write!(f, "dcr3c1"),
            Self::dcr3c2 => write!(f, "dcr3c2"),
            Self::dcr3c3 => write!(f, "dcr3c3"),
            Self::dcr3c4 => write!(f, "dcr3c4"),
            Self::dcr3c5 => write!(f, "dcr3c5"),
            Self::dcr3c6 => write!(f, "dcr3c6"),
            Self::dcr3c7 => write!(f, "dcr3c7"),
            Self::dcr3c8 => write!(f, "dcr3c8"),
            Self::dcr3c9 => write!(f, "dcr3c9"),
            Self::dcr3ca => write!(f, "dcr3ca"),
            Self::dcr3cb => write!(f, "dcr3cb"),
            Self::dcr3cc => write!(f, "dcr3cc"),
            Self::dcr3cd => write!(f, "dcr3cd"),
            Self::dcr3ce => write!(f, "dcr3ce"),
            Self::dcr3cf => write!(f, "dcr3cf"),
            Self::dcr3d0 => write!(f, "dcr3d0"),
            Self::dcr3d1 => write!(f, "dcr3d1"),
            Self::dcr3d2 => write!(f, "dcr3d2"),
            Self::dcr3d3 => write!(f, "dcr3d3"),
            Self::dcr3d4 => write!(f, "dcr3d4"),
            Self::dcr3d5 => write!(f, "dcr3d5"),
            Self::dcr3d6 => write!(f, "dcr3d6"),
            Self::dcr3d7 => write!(f, "dcr3d7"),
            Self::dcr3d8 => write!(f, "dcr3d8"),
            Self::dcr3d9 => write!(f, "dcr3d9"),
            Self::dcr3da => write!(f, "dcr3da"),
            Self::dcr3db => write!(f, "dcr3db"),
            Self::dcr3dc => write!(f, "dcr3dc"),
            Self::dcr3dd => write!(f, "dcr3dd"),
            Self::dcr3de => write!(f, "dcr3de"),
            Self::dcr3df => write!(f, "dcr3df"),
            Self::dcr3e0 => write!(f, "dcr3e0"),
            Self::dcr3e1 => write!(f, "dcr3e1"),
            Self::dcr3e2 => write!(f, "dcr3e2"),
            Self::dcr3e3 => write!(f, "dcr3e3"),
            Self::dcr3e4 => write!(f, "dcr3e4"),
            Self::dcr3e5 => write!(f, "dcr3e5"),
            Self::dcr3e6 => write!(f, "dcr3e6"),
            Self::dcr3e7 => write!(f, "dcr3e7"),
            Self::dcr3e8 => write!(f, "dcr3e8"),
            Self::dcr3e9 => write!(f, "dcr3e9"),
            Self::dcr3ea => write!(f, "dcr3ea"),
            Self::dcr3eb => write!(f, "dcr3eb"),
            Self::dcr3ec => write!(f, "dcr3ec"),
            Self::dcr3ed => write!(f, "dcr3ed"),
            Self::dcr3ee => write!(f, "dcr3ee"),
            Self::dcr3ef => write!(f, "dcr3ef"),
            Self::dcr3f0 => write!(f, "dcr3f0"),
            Self::dcr3f1 => write!(f, "dcr3f1"),
            Self::dcr3f2 => write!(f, "dcr3f2"),
            Self::dcr3f3 => write!(f, "dcr3f3"),
            Self::dcr3f4 => write!(f, "dcr3f4"),
            Self::dcr3f5 => write!(f, "dcr3f5"),
            Self::dcr3f6 => write!(f, "dcr3f6"),
            Self::dcr3f7 => write!(f, "dcr3f7"),
            Self::dcr3f8 => write!(f, "dcr3f8"),
            Self::dcr3f9 => write!(f, "dcr3f9"),
            Self::dcr3fa => write!(f, "dcr3fa"),
            Self::dcr3fb => write!(f, "dcr3fb"),
            Self::dcr3fc => write!(f, "dcr3fc"),
            Self::dcr3fd => write!(f, "dcr3fd"),
            Self::dcr3fe => write!(f, "dcr3fe"),
            Self::dcr3ff => write!(f, "dcr3ff"),
            Self::ACC => write!(f, "ACC"),
        }
    }
}
#[derive(Clone, Copy, Debug)]
pub enum DisplayElement {
    Literal(&'static str),
    Register(Register),
    Number(bool, i64),
}
impl core::fmt::Display for DisplayElement {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Literal(lit) => lit.fmt(f),
            Self::Register(reg) => reg.fmt(f),
            Self::Number(hex, value) => match (*hex, value.is_negative()) {
                (true, true) => write!(f, "-0x{:x}", value.abs()),
                (true, false) => write!(f, "0x{:x}", value),
                (false, _) => value.fmt(f),
            },
        }
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:332:1"]
#[derive(Clone, Debug)]
struct instructionVar0 {
    REL_ABS: TableREL_ABS,
    addressLI: TableaddressLI,
}
impl instructionVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("bl"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addressLI.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 18i64 {
            return None;
        }
        if token_parser.TokenFieldAA().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldLI().disassembly() != 1i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let REL_ABS = if let Some((len, table)) = TableREL_ABS::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addressLI = if let Some((len, table)) = TableaddressLI::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { REL_ABS, addressLI }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3508:1"]
#[derive(Clone, Debug)]
struct instructionVar1 {}
impl instructionVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("rfid")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_25().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 18i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3706:1"]
#[derive(Clone, Debug)]
struct instructionVar2 {}
impl instructionVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("slbia")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_25().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 498i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4416:1"]
#[derive(Clone, Debug)]
struct instructionVar3 {}
impl instructionVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("tlbia")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_21_25().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 370i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4422:1"]
#[derive(Clone, Debug)]
struct instructionVar4 {}
impl instructionVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("tlbsync")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_21_25().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 566i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4446:1"]
#[derive(Clone, Debug)]
struct instructionVar5 {}
impl instructionVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("trap")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldTO().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldA_BITS().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldB_BITS().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_1_10().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc:55:1"]
#[derive(Clone, Debug)]
struct instructionVar6 {}
impl instructionVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("eieio")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_21_25().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 854i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc:76:1"]
#[derive(Clone, Debug)]
struct instructionVar7 {}
impl instructionVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("isync")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_21_25().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 150i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc:152:1"]
#[derive(Clone, Debug)]
struct instructionVar8 {
    SPRVAL: TokenField_SPRVAL,
    S: TokenField_S,
}
impl instructionVar8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_next),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("mtspr"),
            DisplayElement::Literal(" "),
            self.SPRVAL.display(),
            DisplayElement::Literal(","),
            self.S.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_20().disassembly() != 256i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_21_25().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 467i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let tmp = 1i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let SPRVAL = token_parser.TokenFieldSPRVAL();
        let S = token_parser.TokenFieldS();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SPRVAL, S }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc:158:1"]
#[derive(Clone, Debug)]
struct instructionVar9 {
    SPRVAL: TokenField_SPRVAL,
    S: TokenField_S,
}
impl instructionVar9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("mtspr"),
            DisplayElement::Literal(" "),
            self.SPRVAL.display(),
            DisplayElement::Literal(","),
            self.S.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_linkreg_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_20().disassembly() != 256i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_21_25().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 467i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let SPRVAL = token_parser.TokenFieldSPRVAL();
        let S = token_parser.TokenFieldS();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SPRVAL, S }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc:164:1"]
#[derive(Clone, Debug)]
struct instructionVar10 {}
impl instructionVar10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("rfci")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_21_25().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 51i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc:173:1"]
#[derive(Clone, Debug)]
struct instructionVar11 {}
impl instructionVar11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rfi")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_25().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 50i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4379:1"]
#[derive(Clone, Debug)]
struct instructionVar12 {
    L: TokenField_L,
}
impl instructionVar12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("sync"),
            DisplayElement::Literal(" "),
            self.L.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_23_25().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 598i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let L = token_parser.TokenFieldL();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { L }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:495:1"]
#[derive(Clone, Debug)]
struct instructionVar13 {
    CC: TableCC,
}
impl instructionVar13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
        self.CC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ctr")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBI_CR().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBH().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 528i64 {
            return None;
        }
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CC }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:500:1"]
#[derive(Clone, Debug)]
struct instructionVar14 {
    BH: TokenField_BH,
    CC: TableCC,
}
impl instructionVar14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
        self.CC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("ctr"),
            DisplayElement::Literal(" "),
            self.BH.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBI_CR().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBH_BITS().disassembly() == 0i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 528i64 {
            return None;
        }
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BH = token_parser.TokenFieldBH();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CC, BH }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:507:1"]
#[derive(Clone, Debug)]
struct instructionVar15 {
    CC: TableCC,
}
impl instructionVar15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
        self.CC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ctrl")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBI_CR().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBH().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 528i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CC }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:514:1"]
#[derive(Clone, Debug)]
struct instructionVar16 {
    BH: TokenField_BH,
    CC: TableCC,
}
impl instructionVar16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
        self.CC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("ctrl"),
            DisplayElement::Literal(" "),
            self.BH.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBI_CR().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBH_BITS().disassembly() == 0i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 528i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BH = token_parser.TokenFieldBH();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CC, BH }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:585:1"]
#[derive(Clone, Debug)]
struct instructionVar17 {
    CC: TableCC,
}
impl instructionVar17 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
        self.CC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("lr")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBI_CR().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBH().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 16i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CC }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:591:1"]
#[derive(Clone, Debug)]
struct instructionVar18 {
    BH: TokenField_BH,
    CC: TableCC,
}
impl instructionVar18 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
        self.CC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("lr"),
            DisplayElement::Literal(" "),
            self.BH.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBI_CR().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBH_BITS().disassembly() == 0i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 16i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BH = token_parser.TokenFieldBH();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CC, BH }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:599:1"]
#[derive(Clone, Debug)]
struct instructionVar19 {
    CC: TableCC,
}
impl instructionVar19 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
        self.CC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("lrl")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBI_CR().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBH().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 16i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CC }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:607:1"]
#[derive(Clone, Debug)]
struct instructionVar20 {
    BH: TokenField_BH,
    CC: TableCC,
}
impl instructionVar20 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
        self.CC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("lrl"),
            DisplayElement::Literal(" "),
            self.BH.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBI_CR().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBH_BITS().disassembly() == 0i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 16i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BH = token_parser.TokenFieldBH();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CC, BH }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:461:1"]
#[derive(Clone, Debug)]
struct instructionVar21 {}
impl instructionVar21 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("bctr")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBH().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 528i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:466:1"]
#[derive(Clone, Debug)]
struct instructionVar22 {}
impl instructionVar22 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("bctr")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if context_instance.register().read_linkreg_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBH().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 528i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:481:1"]
#[derive(Clone, Debug)]
struct instructionVar23 {}
impl instructionVar23 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("bctrl")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBH().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 528i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:523:1"]
#[derive(Clone, Debug)]
struct instructionVar24 {
    BI_CR: TokenField_BI_CR,
    CC: TableCC,
}
impl instructionVar24 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
        self.CC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("ctr"),
            DisplayElement::Literal(" "),
            self.BI_CR.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBH().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 528i64 {
            return None;
        }
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BI_CR = token_parser.TokenFieldBI_CR();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CC, BI_CR }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:537:1"]
#[derive(Clone, Debug)]
struct instructionVar25 {
    BI_CR: TokenField_BI_CR,
    CC: TableCC,
}
impl instructionVar25 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
        self.CC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("ctrl"),
            DisplayElement::Literal(" "),
            self.BI_CR.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBH().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 528i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BI_CR = token_parser.TokenFieldBI_CR();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CC, BI_CR }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:559:1"]
#[derive(Clone, Debug)]
struct instructionVar26 {}
impl instructionVar26 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("blr")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBH().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 16i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:569:1"]
#[derive(Clone, Debug)]
struct instructionVar27 {}
impl instructionVar27 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("blrl")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBH().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 16i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:617:1"]
#[derive(Clone, Debug)]
struct instructionVar28 {
    BI_CR: TokenField_BI_CR,
    CC: TableCC,
}
impl instructionVar28 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
        self.CC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("lr"),
            DisplayElement::Literal(" "),
            self.BI_CR.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBH().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 16i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BI_CR = token_parser.TokenFieldBI_CR();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CC, BI_CR }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:625:1"]
#[derive(Clone, Debug)]
struct instructionVar29 {
    BI_CR: TokenField_BI_CR,
    BH: TokenField_BH,
    CC: TableCC,
}
impl instructionVar29 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
        self.CC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("lr"),
            DisplayElement::Literal(" "),
            self.BI_CR.display(),
            DisplayElement::Literal(","),
            self.BH.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBH_BITS().disassembly() == 0i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 16i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BI_CR = token_parser.TokenFieldBI_CR();
        let BH = token_parser.TokenFieldBH();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CC, BI_CR, BH }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:633:1"]
#[derive(Clone, Debug)]
struct instructionVar30 {
    BI_CR: TokenField_BI_CR,
    CC: TableCC,
}
impl instructionVar30 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
        self.CC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("lrl"),
            DisplayElement::Literal(" "),
            self.BI_CR.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBH().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 16i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BI_CR = token_parser.TokenFieldBI_CR();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CC, BI_CR }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:655:1"]
#[derive(Clone, Debug)]
struct instructionVar31 {
    CTR_DEC: TableCTR_DEC,
}
impl instructionVar31 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bd")];
        display.extend_from_slice(&extend);
        self.CTR_DEC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("lr")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBH().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 16i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let CTR_DEC = if let Some((len, table)) = TableCTR_DEC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CTR_DEC }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:669:1"]
#[derive(Clone, Debug)]
struct instructionVar32 {
    CTR_DEC: TableCTR_DEC,
}
impl instructionVar32 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bd")];
        display.extend_from_slice(&extend);
        self.CTR_DEC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("lrl")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBH().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 16i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let CTR_DEC = if let Some((len, table)) = TableCTR_DEC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CTR_DEC }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:688:1"]
#[derive(Clone, Debug)]
struct instructionVar33 {
    CC_TF: TableCC_TF,
    CTR_DEC: TableCTR_DEC,
    CC_OP: TableCC_OP,
}
impl instructionVar33 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bd")];
        display.extend_from_slice(&extend);
        self.CTR_DEC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.CC_TF.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("lr"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CC_OP.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBH().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 16i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let CC_TF = if let Some((len, table)) =
            TableCC_TF::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CTR_DEC = if let Some((len, table)) = TableCTR_DEC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CC_OP = if let Some((len, table)) =
            TableCC_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CC_TF,
                CTR_DEC,
                CC_OP,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:706:1"]
#[derive(Clone, Debug)]
struct instructionVar34 {
    CC_TF: TableCC_TF,
    CTR_DEC: TableCTR_DEC,
    CC_OP: TableCC_OP,
}
impl instructionVar34 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bd")];
        display.extend_from_slice(&extend);
        self.CTR_DEC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.CC_TF.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("lrl"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CC_OP.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBH().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 16i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let CC_TF = if let Some((len, table)) =
            TableCC_TF::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CTR_DEC = if let Some((len, table)) = TableCTR_DEC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CC_OP = if let Some((len, table)) =
            TableCC_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CC_TF,
                CTR_DEC,
                CC_OP,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2960:1"]
#[derive(Clone, Debug)]
struct instructionVar35 {
    CRFD: TokenField_CRFD,
}
impl instructionVar35 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("mcrxr"),
            DisplayElement::Literal(" "),
            self.CRFD.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_22().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 512i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let CRFD = token_parser.TokenFieldCRFD();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CRFD }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2948:1"]
#[derive(Clone, Debug)]
struct instructionVar36 {
    CRFD: TokenField_CRFD,
    CRFS: TokenField_CRFS,
}
impl instructionVar36 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("mcrf"),
            DisplayElement::Literal(" "),
            self.CRFD.display(),
            DisplayElement::Literal(","),
            self.CRFS.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_21_22().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_0_17().disassembly() != 0i64 {
            return None;
        }
        let CRFD = token_parser.TokenFieldCRFD();
        let CRFS = token_parser.TokenFieldCRFS();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CRFD, CRFS }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2954:1"]
#[derive(Clone, Debug)]
struct instructionVar37 {
    CRFD: TokenField_CRFD,
    CRFS: TokenField_CRFS,
    FPSCR_CRFS: TableFPSCR_CRFS,
}
impl instructionVar37 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("mcrfs"),
            DisplayElement::Literal(" "),
            self.CRFD.display(),
            DisplayElement::Literal(","),
            self.CRFS.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_21_22().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_17().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 64i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let FPSCR_CRFS = if let Some((len, table)) = TableFPSCR_CRFS::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CRFD = token_parser.TokenFieldCRFD();
        let CRFS = token_parser.TokenFieldCRFS();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPSCR_CRFS,
                CRFD,
                CRFS,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2969:1"]
#[derive(Clone, Debug)]
struct instructionVar38 {
    D: TokenField_D,
}
impl instructionVar38 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("mfcr"),
            DisplayElement::Literal(" "),
            self.D.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2997:1"]
#[derive(Clone, Debug)]
struct instructionVar39 {
    fD: TokenField_fD,
}
impl instructionVar39 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("mffs"),
            DisplayElement::Literal(" "),
            self.fD.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 583i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3005:1"]
#[derive(Clone, Debug)]
struct instructionVar40 {
    fD: TokenField_fD,
}
impl instructionVar40 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("mffs."),
            DisplayElement::Literal(" "),
            self.fD.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 583i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3063:1"]
#[derive(Clone, Debug)]
struct instructionVar41 {
    CRBD: TokenField_CRBD,
}
impl instructionVar41 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("mtfsb0"),
            DisplayElement::Literal(" "),
            self.CRBD.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 70i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let CRBD = token_parser.TokenFieldCRBD();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CRBD }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3068:1"]
#[derive(Clone, Debug)]
struct instructionVar42 {
    CRBD: TokenField_CRBD,
}
impl instructionVar42 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("mtfsb0."),
            DisplayElement::Literal(" "),
            self.CRBD.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 70i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let CRBD = token_parser.TokenFieldCRBD();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CRBD }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3074:1"]
#[derive(Clone, Debug)]
struct instructionVar43 {
    CRBD: TokenField_CRBD,
}
impl instructionVar43 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("mtfsb1"),
            DisplayElement::Literal(" "),
            self.CRBD.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 38i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let CRBD = token_parser.TokenFieldCRBD();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CRBD }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3079:1"]
#[derive(Clone, Debug)]
struct instructionVar44 {
    CRBD: TokenField_CRBD,
}
impl instructionVar44 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("mtfsb1."),
            DisplayElement::Literal(" "),
            self.CRBD.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 38i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let CRBD = token_parser.TokenFieldCRBD();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CRBD }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc:88:1"]
#[derive(Clone, Debug)]
struct instructionVar45 {
    D: TokenField_D,
}
impl instructionVar45 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("mfmsr"),
            DisplayElement::Literal(" "),
            self.D.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 83i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc:100:1"]
#[derive(Clone, Debug)]
struct instructionVar46 {
    D: TokenField_D,
}
impl instructionVar46 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("mftb"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::TBLr),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldTBR().disassembly() != 392i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 371i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc:105:1"]
#[derive(Clone, Debug)]
struct instructionVar47 {
    D: TokenField_D,
}
impl instructionVar47 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("mftb"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::TBUr),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldTBR().disassembly() != 424i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 371i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc:117:1"]
#[derive(Clone, Debug)]
struct instructionVar48 {
    S: TokenField_S,
}
impl instructionVar48 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("mtmsr"),
            DisplayElement::Literal(" "),
            self.S.display(),
            DisplayElement::Literal(",0"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_17_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldMSR_L().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 146i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc:136:1"]
#[derive(Clone, Debug)]
struct instructionVar49 {
    S: TokenField_S,
}
impl instructionVar49 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("mtmsr"),
            DisplayElement::Literal(" "),
            self.S.display(),
            DisplayElement::Literal(",1"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_17_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldMSR_L().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 146i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3015:1"]
#[derive(Clone, Debug)]
struct instructionVar50 {
    D: TokenField_D,
    B: TokenField_B,
}
impl instructionVar50 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("mfsr"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 595i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let SR = token_parser.TokenFieldSR();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3208:1"]
#[derive(Clone, Debug)]
struct instructionVar51 {
    SR: TokenField_SR,
    S: TokenField_S,
}
impl instructionVar51 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("mtsr"),
            DisplayElement::Literal(" "),
            self.SR.display(),
            DisplayElement::Literal(","),
            self.S.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 210i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        let SR = token_parser.TokenFieldSR();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, SR }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3218:1"]
#[derive(Clone, Debug)]
struct instructionVar52 {
    SR: TokenField_SR,
    S: TokenField_S,
}
impl instructionVar52 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("mtsrd"),
            DisplayElement::Literal(" "),
            self.SR.display(),
            DisplayElement::Literal(","),
            self.S.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 82i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        let SR = token_parser.TokenFieldSR();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, SR }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:181:1"]
#[derive(Clone, Debug)]
struct instructionVar53 {
    D: TokenField_D,
    A: TokenField_A,
}
impl instructionVar53 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("addme"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 234i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:190:1"]
#[derive(Clone, Debug)]
struct instructionVar54 {
    D: TokenField_D,
    A: TokenField_A,
}
impl instructionVar54 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("addme."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 234i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:200:1"]
#[derive(Clone, Debug)]
struct instructionVar55 {
    D: TokenField_D,
    A: TokenField_A,
}
impl instructionVar55 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("addmeo"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 234i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:210:1"]
#[derive(Clone, Debug)]
struct instructionVar56 {
    D: TokenField_D,
    A: TokenField_A,
}
impl instructionVar56 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("addmeo."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 234i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:221:1"]
#[derive(Clone, Debug)]
struct instructionVar57 {
    D: TokenField_D,
    A: TokenField_A,
}
impl instructionVar57 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("addze"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 202i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:229:1"]
#[derive(Clone, Debug)]
struct instructionVar58 {
    D: TokenField_D,
    A: TokenField_A,
}
impl instructionVar58 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("addze."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 202i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:238:1"]
#[derive(Clone, Debug)]
struct instructionVar59 {
    D: TokenField_D,
    A: TokenField_A,
}
impl instructionVar59 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("addzeo"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 202i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:247:1"]
#[derive(Clone, Debug)]
struct instructionVar60 {
    D: TokenField_D,
    A: TokenField_A,
}
impl instructionVar60 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("addzeo."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 202i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:475:1"]
#[derive(Clone, Debug)]
struct instructionVar61 {
    BH: TokenField_BH,
}
impl instructionVar61 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("bctr"),
            DisplayElement::Literal(" "),
            self.BH.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 528i64 {
            return None;
        }
        let BH = token_parser.TokenFieldBH();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BH }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:487:1"]
#[derive(Clone, Debug)]
struct instructionVar62 {
    BH: TokenField_BH,
}
impl instructionVar62 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("bctrl"),
            DisplayElement::Literal(" "),
            self.BH.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 528i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let BH = token_parser.TokenFieldBH();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BH }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:530:1"]
#[derive(Clone, Debug)]
struct instructionVar63 {
    BI_CR: TokenField_BI_CR,
    BH: TokenField_BH,
    CC: TableCC,
}
impl instructionVar63 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
        self.CC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("ctr"),
            DisplayElement::Literal(" "),
            self.BI_CR.display(),
            DisplayElement::Literal(","),
            self.BH.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 528i64 {
            return None;
        }
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BI_CR = token_parser.TokenFieldBI_CR();
        let BH = token_parser.TokenFieldBH();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CC, BI_CR, BH }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:546:1"]
#[derive(Clone, Debug)]
struct instructionVar64 {
    BI_CR: TokenField_BI_CR,
    BH: TokenField_BH,
    CC: TableCC,
}
impl instructionVar64 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
        self.CC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("ctrl"),
            DisplayElement::Literal(" "),
            self.BI_CR.display(),
            DisplayElement::Literal(","),
            self.BH.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 528i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BI_CR = token_parser.TokenFieldBI_CR();
        let BH = token_parser.TokenFieldBH();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CC, BI_CR, BH }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:563:1"]
#[derive(Clone, Debug)]
struct instructionVar65 {
    BH: TokenField_BH,
}
impl instructionVar65 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("blr"),
            DisplayElement::Literal(" "),
            self.BH.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 16i64 {
            return None;
        }
        let BH = token_parser.TokenFieldBH();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BH }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:576:1"]
#[derive(Clone, Debug)]
struct instructionVar66 {
    BH: TokenField_BH,
}
impl instructionVar66 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("blrl"),
            DisplayElement::Literal(" "),
            self.BH.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 16i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let BH = token_parser.TokenFieldBH();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BH }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:643:1"]
#[derive(Clone, Debug)]
struct instructionVar67 {
    BI_CR: TokenField_BI_CR,
    BH: TokenField_BH,
    CC: TableCC,
}
impl instructionVar67 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
        self.CC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("lrl"),
            DisplayElement::Literal(" "),
            self.BI_CR.display(),
            DisplayElement::Literal(","),
            self.BH.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 16i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BI_CR = token_parser.TokenFieldBI_CR();
        let BH = token_parser.TokenFieldBH();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CC, BI_CR, BH }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:661:1"]
#[derive(Clone, Debug)]
struct instructionVar68 {
    BH: TokenField_BH,
    CTR_DEC: TableCTR_DEC,
}
impl instructionVar68 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bd")];
        display.extend_from_slice(&extend);
        self.CTR_DEC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("lr"),
            DisplayElement::Literal(" "),
            self.BH.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 16i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let CTR_DEC = if let Some((len, table)) = TableCTR_DEC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BH = token_parser.TokenFieldBH();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CTR_DEC, BH }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:677:1"]
#[derive(Clone, Debug)]
struct instructionVar69 {
    BH: TokenField_BH,
    CTR_DEC: TableCTR_DEC,
}
impl instructionVar69 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bd")];
        display.extend_from_slice(&extend);
        self.CTR_DEC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("lrl"),
            DisplayElement::Literal(" "),
            self.BH.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 16i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let CTR_DEC = if let Some((len, table)) = TableCTR_DEC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BH = token_parser.TokenFieldBH();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CTR_DEC, BH }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:697:1"]
#[derive(Clone, Debug)]
struct instructionVar70 {
    BH: TokenField_BH,
    CC_TF: TableCC_TF,
    CTR_DEC: TableCTR_DEC,
    CC_OP: TableCC_OP,
}
impl instructionVar70 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bd")];
        display.extend_from_slice(&extend);
        self.CTR_DEC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.CC_TF.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("lr"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CC_OP.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.BH.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 16i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let CC_TF = if let Some((len, table)) =
            TableCC_TF::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CTR_DEC = if let Some((len, table)) = TableCTR_DEC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CC_OP = if let Some((len, table)) =
            TableCC_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BH = token_parser.TokenFieldBH();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CC_TF,
                CTR_DEC,
                CC_OP,
                BH,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:717:1"]
#[derive(Clone, Debug)]
struct instructionVar71 {
    BH: TokenField_BH,
    CC_TF: TableCC_TF,
    CTR_DEC: TableCTR_DEC,
    CC_OP: TableCC_OP,
}
impl instructionVar71 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bd")];
        display.extend_from_slice(&extend);
        self.CTR_DEC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.CC_TF.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("lrl"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CC_OP.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.BH.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 16i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let CC_TF = if let Some((len, table)) =
            TableCC_TF::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CTR_DEC = if let Some((len, table)) = TableCTR_DEC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CC_OP = if let Some((len, table)) =
            TableCC_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BH = token_parser.TokenFieldBH();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CC_TF,
                CTR_DEC,
                CC_OP,
                BH,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4408:1"]
#[derive(Clone, Debug)]
struct instructionVar72 {
    RB_OR_ZERO: TableRB_OR_ZERO,
}
impl instructionVar72 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("tlbiel"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RB_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_21_25().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 274i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RB_OR_ZERO = if let Some((len, table)) = TableRB_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RB_OR_ZERO }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:903:1"]
#[derive(Clone, Debug)]
struct instructionVar73 {
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar73 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("dccci"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_21_25().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 454i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2041:1"]
#[derive(Clone, Debug)]
struct instructionVar74 {
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar74 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("iccci"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_21_25().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 966i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2049:1"]
#[derive(Clone, Debug)]
struct instructionVar75 {
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar75 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("icread"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_21_25().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 998i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc:4:1"]
#[derive(Clone, Debug)]
struct instructionVar76 {
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar76 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("dcba"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_21_25().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 758i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc:11:1"]
#[derive(Clone, Debug)]
struct instructionVar77 {
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar77 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("dcbf"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_21_25().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 86i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc:18:1"]
#[derive(Clone, Debug)]
struct instructionVar78 {
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar78 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("dcbi"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_21_25().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 470i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc:25:1"]
#[derive(Clone, Debug)]
struct instructionVar79 {
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar79 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("dcbst"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_21_25().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 54i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc:32:1"]
#[derive(Clone, Debug)]
struct instructionVar80 {
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar80 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("dcbt"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_21_25().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 278i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc:39:1"]
#[derive(Clone, Debug)]
struct instructionVar81 {
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar81 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("dcbtst"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_21_25().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 246i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc:46:1"]
#[derive(Clone, Debug)]
struct instructionVar82 {
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar82 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("dcbz"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_21_25().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 1014i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc:62:1"]
#[derive(Clone, Debug)]
struct instructionVar83 {
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar83 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("icbi"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_21_25().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 982i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:733:1"]
#[derive(Clone, Debug)]
struct instructionVar84 {
    A: TokenField_A,
    B: TokenField_B,
    DSIZE: TableDSIZE,
    REG_A: TableREG_A,
    REG_B: TableREG_B,
}
impl instructionVar84 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cmp")];
        display.extend_from_slice(&extend);
        self.DSIZE.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(" \t"),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldCRFD().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_22().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let DSIZE = if let Some((len, table)) =
            TableDSIZE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let REG_A = if let Some((len, table)) =
            TableREG_A::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let REG_B = if let Some((len, table)) =
            TableREG_B::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                DSIZE,
                REG_A,
                REG_B,
                A,
                B,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:773:1"]
#[derive(Clone, Debug)]
struct instructionVar85 {
    A: TokenField_A,
    B: TokenField_B,
    DSIZE: TableDSIZE,
    UREG_A: TableUREG_A,
    UREG_B: TableUREG_B,
}
impl instructionVar85 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cmpl")];
        display.extend_from_slice(&extend);
        self.DSIZE.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(" \t"),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldCRFD().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_22().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 32i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let DSIZE = if let Some((len, table)) =
            TableDSIZE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let UREG_A = if let Some((len, table)) = TableUREG_A::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let UREG_B = if let Some((len, table)) = TableUREG_B::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                DSIZE,
                UREG_A,
                UREG_B,
                A,
                B,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3130:1"]
#[derive(Clone, Debug)]
struct instructionVar86 {
    crfD: TokenField_crfD,
    IMM: TokenField_IMM,
}
impl instructionVar86 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("mtfsfi"),
            DisplayElement::Literal(" "),
            self.crfD.display(),
            DisplayElement::Literal(","),
            self.IMM.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_22().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_11().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 134i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let crfD = token_parser.TokenFieldcrfD();
        let IMM = token_parser.TokenFieldIMM();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { crfD, IMM }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3142:1"]
#[derive(Clone, Debug)]
struct instructionVar87 {
    crfD: TokenField_crfD,
    IMM: TokenField_IMM,
}
impl instructionVar87 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("mtfsfi."),
            DisplayElement::Literal(" "),
            self.crfD.display(),
            DisplayElement::Literal(","),
            self.IMM.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_22().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_11().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 134i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let crfD = token_parser.TokenFieldcrfD();
        let IMM = token_parser.TokenFieldIMM();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { crfD, IMM }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1234:1"]
#[derive(Clone, Debug)]
struct instructionVar88 {
    CRFD: TokenField_CRFD,
    fA: TokenField_fA,
    fB: TokenField_fB,
}
impl instructionVar88 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("fcmpo"),
            DisplayElement::Literal(" "),
            self.CRFD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_21_22().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 32i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let CRFD = token_parser.TokenFieldCRFD();
        let fA = token_parser.TokenFieldfA();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CRFD, fA, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1243:1"]
#[derive(Clone, Debug)]
struct instructionVar89 {
    CRFD: TokenField_CRFD,
    fA: TokenField_fA,
    fB: TokenField_fB,
}
impl instructionVar89 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("fcmpu"),
            DisplayElement::Literal(" "),
            self.CRFD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_21_22().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let CRFD = token_parser.TokenFieldCRFD();
        let fA = token_parser.TokenFieldfA();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CRFD, fA, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:743:1"]
#[derive(Clone, Debug)]
struct instructionVar90 {
    CRFD: TokenField_CRFD,
    A: TokenField_A,
    B: TokenField_B,
    DSIZE: TableDSIZE,
    REG_A: TableREG_A,
    REG_B: TableREG_B,
}
impl instructionVar90 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cmp")];
        display.extend_from_slice(&extend);
        self.DSIZE.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(" \t"),
            self.CRFD.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_22().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let DSIZE = if let Some((len, table)) =
            TableDSIZE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let REG_A = if let Some((len, table)) =
            TableREG_A::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let REG_B = if let Some((len, table)) =
            TableREG_B::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CRFD = token_parser.TokenFieldCRFD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                DSIZE,
                REG_A,
                REG_B,
                CRFD,
                A,
                B,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:783:1"]
#[derive(Clone, Debug)]
struct instructionVar91 {
    CRFD: TokenField_CRFD,
    A: TokenField_A,
    B: TokenField_B,
    DSIZE: TableDSIZE,
    UREG_A: TableUREG_A,
    UREG_B: TableUREG_B,
}
impl instructionVar91 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cmpl")];
        display.extend_from_slice(&extend);
        self.DSIZE.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(" \t"),
            self.CRFD.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_22().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 32i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let DSIZE = if let Some((len, table)) =
            TableDSIZE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let UREG_A = if let Some((len, table)) = TableUREG_A::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let UREG_B = if let Some((len, table)) = TableUREG_B::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CRFD = token_parser.TokenFieldCRFD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                DSIZE,
                UREG_A,
                UREG_B,
                CRFD,
                A,
                B,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:829:1"]
#[derive(Clone, Debug)]
struct instructionVar92 {
    A: TokenField_A,
    S: TokenField_S,
}
impl instructionVar92 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("cntlzw"),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 26i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, A }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:835:1"]
#[derive(Clone, Debug)]
struct instructionVar93 {
    A: TokenField_A,
    S: TokenField_S,
}
impl instructionVar93 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("cntlzw."),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 26i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, A }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1110:1"]
#[derive(Clone, Debug)]
struct instructionVar94 {
    A: TokenField_A,
    S: TokenField_S,
}
impl instructionVar94 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("extsb"),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 954i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, A }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1116:1"]
#[derive(Clone, Debug)]
struct instructionVar95 {
    A: TokenField_A,
    S: TokenField_S,
}
impl instructionVar95 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("extsb."),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 954i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, A }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1126:1"]
#[derive(Clone, Debug)]
struct instructionVar96 {
    A: TokenField_A,
    S: TokenField_S,
}
impl instructionVar96 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("extsh"),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 922i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, A }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1132:1"]
#[derive(Clone, Debug)]
struct instructionVar97 {
    A: TokenField_A,
    S: TokenField_S,
}
impl instructionVar97 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("extsh."),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 922i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, A }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1157:1"]
#[derive(Clone, Debug)]
struct instructionVar98 {
    fD: TokenField_fD,
    fB: TokenField_fB,
}
impl instructionVar98 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("fabs"),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 264i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1163:1"]
#[derive(Clone, Debug)]
struct instructionVar99 {
    fD: TokenField_fD,
    fB: TokenField_fB,
}
impl instructionVar99 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("fabs."),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 264i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1213:1"]
#[derive(Clone, Debug)]
struct instructionVar100 {
    fD: TokenField_fD,
    fB: TokenField_fB,
}
impl instructionVar100 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("fcfid"),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 846i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1219:1"]
#[derive(Clone, Debug)]
struct instructionVar101 {
    fD: TokenField_fD,
    fB: TokenField_fB,
}
impl instructionVar101 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("fcfid."),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 846i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1253:1"]
#[derive(Clone, Debug)]
struct instructionVar102 {
    fD: TokenField_fD,
    fB: TokenField_fB,
}
impl instructionVar102 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("fctid"),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 814i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1263:1"]
#[derive(Clone, Debug)]
struct instructionVar103 {
    fD: TokenField_fD,
    fB: TokenField_fB,
}
impl instructionVar103 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("fctid."),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 814i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1275:1"]
#[derive(Clone, Debug)]
struct instructionVar104 {
    fD: TokenField_fD,
    fB: TokenField_fB,
}
impl instructionVar104 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("fctidz"),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 815i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1285:1"]
#[derive(Clone, Debug)]
struct instructionVar105 {
    fD: TokenField_fD,
    fB: TokenField_fB,
}
impl instructionVar105 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("fctidz."),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 815i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1298:1"]
#[derive(Clone, Debug)]
struct instructionVar106 {
    fD: TokenField_fD,
    fB: TokenField_fB,
}
impl instructionVar106 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("fctiw"),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 14i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1310:1"]
#[derive(Clone, Debug)]
struct instructionVar107 {
    fD: TokenField_fD,
    fB: TokenField_fB,
}
impl instructionVar107 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("fctiw."),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 14i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1324:1"]
#[derive(Clone, Debug)]
struct instructionVar108 {
    fD: TokenField_fD,
    fB: TokenField_fB,
}
impl instructionVar108 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("fctiwz"),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 15i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1336:1"]
#[derive(Clone, Debug)]
struct instructionVar109 {
    fD: TokenField_fD,
    fB: TokenField_fB,
}
impl instructionVar109 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("fctiwz."),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 15i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1473:1"]
#[derive(Clone, Debug)]
struct instructionVar110 {
    fD: TokenField_fD,
    fB: TokenField_fB,
}
impl instructionVar110 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("fmr"),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 72i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1478:1"]
#[derive(Clone, Debug)]
struct instructionVar111 {
    fD: TokenField_fD,
    fB: TokenField_fB,
}
impl instructionVar111 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("fmr."),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 72i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1608:1"]
#[derive(Clone, Debug)]
struct instructionVar112 {
    fD: TokenField_fD,
    fB: TokenField_fB,
}
impl instructionVar112 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("fnabs"),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 136i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1614:1"]
#[derive(Clone, Debug)]
struct instructionVar113 {
    fD: TokenField_fD,
    fB: TokenField_fB,
}
impl instructionVar113 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("fnabs."),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 136i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1621:1"]
#[derive(Clone, Debug)]
struct instructionVar114 {
    fD: TokenField_fD,
    fB: TokenField_fB,
}
impl instructionVar114 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("fneg"),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 40i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1627:1"]
#[derive(Clone, Debug)]
struct instructionVar115 {
    fD: TokenField_fD,
    fB: TokenField_fB,
}
impl instructionVar115 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("fneg."),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 40i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1840:1"]
#[derive(Clone, Debug)]
struct instructionVar116 {
    fD: TokenField_fD,
    fB: TokenField_fB,
}
impl instructionVar116 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("frsp"),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1858:1"]
#[derive(Clone, Debug)]
struct instructionVar117 {
    fD: TokenField_fD,
    fB: TokenField_fB,
}
impl instructionVar117 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("frsp."),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1938:1"]
#[derive(Clone, Debug)]
struct instructionVar118 {
    fD: TokenField_fD,
    fB: TokenField_fB,
}
impl instructionVar118 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("fsqrt"),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_6_10().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 22i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1952:1"]
#[derive(Clone, Debug)]
struct instructionVar119 {
    fD: TokenField_fD,
    fB: TokenField_fB,
}
impl instructionVar119 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("fsqrt."),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_6_10().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 22i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1967:1"]
#[derive(Clone, Debug)]
struct instructionVar120 {
    fD: TokenField_fD,
    fB: TokenField_fB,
}
impl instructionVar120 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("fsqrts"),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 59i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_6_10().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 22i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1982:1"]
#[derive(Clone, Debug)]
struct instructionVar121 {
    fD: TokenField_fD,
    fB: TokenField_fB,
}
impl instructionVar121 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("fsqrts."),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 59i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_6_10().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 22i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc:12:1"]
#[derive(Clone, Debug)]
struct instructionVar122 {
    D: TokenField_D,
    NB: TokenField_NB,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_D1: TableDYN_D1,
    DYN_D2: TableDYN_D2,
    DYN_D3: TableDYN_D3,
    DYN_D4: TableDYN_D4,
    DYN_D5: TableDYN_D5,
    DYN_D6: TableDYN_D6,
    DYN_D7: TableDYN_D7,
}
impl instructionVar122 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lswi"),
            DisplayElement::Literal("  "),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.NB.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBH().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 597i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D1 = if let Some((len, table)) = TableDYN_D1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D2 = if let Some((len, table)) = TableDYN_D2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D3 = if let Some((len, table)) = TableDYN_D3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D4 = if let Some((len, table)) = TableDYN_D4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D5 = if let Some((len, table)) = TableDYN_D5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D6 = if let Some((len, table)) = TableDYN_D6::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D7 = if let Some((len, table)) = TableDYN_D7::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        let NB = token_parser.TokenFieldNB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_D1,
                DYN_D2,
                DYN_D3,
                DYN_D4,
                DYN_D5,
                DYN_D6,
                DYN_D7,
                D,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc:33:1"]
#[derive(Clone, Debug)]
struct instructionVar123 {
    D: TokenField_D,
    NB: TokenField_NB,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar123 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lswi"),
            DisplayElement::Literal("  "),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.NB.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBH().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 597i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        let NB = token_parser.TokenFieldNB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, D, NB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc:49:1"]
#[derive(Clone, Debug)]
struct instructionVar124 {
    D: TokenField_D,
    NB: TokenField_NB,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_D1: TableDYN_D1,
}
impl instructionVar124 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lswi"),
            DisplayElement::Literal("  "),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.NB.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldBH().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 597i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D1 = if let Some((len, table)) = TableDYN_D1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        let NB = token_parser.TokenFieldNB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_D1,
                D,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc:67:1"]
#[derive(Clone, Debug)]
struct instructionVar125 {
    D: TokenField_D,
    NB: TokenField_NB,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_D1: TableDYN_D1,
    DYN_D2: TableDYN_D2,
}
impl instructionVar125 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lswi"),
            DisplayElement::Literal("  "),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.NB.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldBH().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 597i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D1 = if let Some((len, table)) = TableDYN_D1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D2 = if let Some((len, table)) = TableDYN_D2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        let NB = token_parser.TokenFieldNB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_D1,
                DYN_D2,
                D,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc:87:1"]
#[derive(Clone, Debug)]
struct instructionVar126 {
    D: TokenField_D,
    NB: TokenField_NB,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_D1: TableDYN_D1,
    DYN_D2: TableDYN_D2,
    DYN_D3: TableDYN_D3,
}
impl instructionVar126 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lswi"),
            DisplayElement::Literal("  "),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.NB.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldBH().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 597i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D1 = if let Some((len, table)) = TableDYN_D1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D2 = if let Some((len, table)) = TableDYN_D2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D3 = if let Some((len, table)) = TableDYN_D3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        let NB = token_parser.TokenFieldNB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_D1,
                DYN_D2,
                DYN_D3,
                D,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc:109:1"]
#[derive(Clone, Debug)]
struct instructionVar127 {
    D: TokenField_D,
    NB: TokenField_NB,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_D1: TableDYN_D1,
    DYN_D2: TableDYN_D2,
    DYN_D3: TableDYN_D3,
    DYN_D4: TableDYN_D4,
}
impl instructionVar127 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lswi"),
            DisplayElement::Literal("  "),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.NB.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 5i64 {
            return None;
        }
        if token_parser.TokenFieldBH().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 597i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D1 = if let Some((len, table)) = TableDYN_D1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D2 = if let Some((len, table)) = TableDYN_D2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D3 = if let Some((len, table)) = TableDYN_D3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D4 = if let Some((len, table)) = TableDYN_D4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        let NB = token_parser.TokenFieldNB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_D1,
                DYN_D2,
                DYN_D3,
                DYN_D4,
                D,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc:133:1"]
#[derive(Clone, Debug)]
struct instructionVar128 {
    D: TokenField_D,
    NB: TokenField_NB,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_D1: TableDYN_D1,
    DYN_D2: TableDYN_D2,
    DYN_D3: TableDYN_D3,
    DYN_D4: TableDYN_D4,
    DYN_D5: TableDYN_D5,
}
impl instructionVar128 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lswi"),
            DisplayElement::Literal("  "),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.NB.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 6i64 {
            return None;
        }
        if token_parser.TokenFieldBH().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 597i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D1 = if let Some((len, table)) = TableDYN_D1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D2 = if let Some((len, table)) = TableDYN_D2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D3 = if let Some((len, table)) = TableDYN_D3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D4 = if let Some((len, table)) = TableDYN_D4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D5 = if let Some((len, table)) = TableDYN_D5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        let NB = token_parser.TokenFieldNB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_D1,
                DYN_D2,
                DYN_D3,
                DYN_D4,
                DYN_D5,
                D,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc:159:1"]
#[derive(Clone, Debug)]
struct instructionVar129 {
    D: TokenField_D,
    NB: TokenField_NB,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_D1: TableDYN_D1,
    DYN_D2: TableDYN_D2,
    DYN_D3: TableDYN_D3,
    DYN_D4: TableDYN_D4,
    DYN_D5: TableDYN_D5,
    DYN_D6: TableDYN_D6,
}
impl instructionVar129 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lswi"),
            DisplayElement::Literal("  "),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.NB.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 7i64 {
            return None;
        }
        if token_parser.TokenFieldBH().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 597i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D1 = if let Some((len, table)) = TableDYN_D1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D2 = if let Some((len, table)) = TableDYN_D2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D3 = if let Some((len, table)) = TableDYN_D3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D4 = if let Some((len, table)) = TableDYN_D4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D5 = if let Some((len, table)) = TableDYN_D5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D6 = if let Some((len, table)) = TableDYN_D6::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        let NB = token_parser.TokenFieldNB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_D1,
                DYN_D2,
                DYN_D3,
                DYN_D4,
                DYN_D5,
                DYN_D6,
                D,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3429:1"]
#[derive(Clone, Debug)]
struct instructionVar130 {
    D: TokenField_D,
    A: TokenField_A,
}
impl instructionVar130 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("neg"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 104i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3435:1"]
#[derive(Clone, Debug)]
struct instructionVar131 {
    D: TokenField_D,
    A: TokenField_A,
}
impl instructionVar131 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("neg."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 104i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3442:1"]
#[derive(Clone, Debug)]
struct instructionVar132 {
    D: TokenField_D,
    A: TokenField_A,
}
impl instructionVar132 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("nego"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 104i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3449:1"]
#[derive(Clone, Debug)]
struct instructionVar133 {
    D: TokenField_D,
    A: TokenField_A,
}
impl instructionVar133 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("nego."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 104i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc:13:1"]
#[derive(Clone, Debug)]
struct instructionVar134 {
    S: TokenField_S,
    NB: TokenField_NB,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_S1: TableDYN_S1,
    DYN_S2: TableDYN_S2,
    DYN_S3: TableDYN_S3,
    DYN_S4: TableDYN_S4,
    DYN_S5: TableDYN_S5,
    DYN_S6: TableDYN_S6,
    DYN_S7: TableDYN_S7,
}
impl instructionVar134 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("stswi"),
            DisplayElement::Literal("  "),
            self.S.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.NB.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBH().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 725i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S1 = if let Some((len, table)) = TableDYN_S1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S2 = if let Some((len, table)) = TableDYN_S2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S3 = if let Some((len, table)) = TableDYN_S3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S4 = if let Some((len, table)) = TableDYN_S4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S5 = if let Some((len, table)) = TableDYN_S5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S6 = if let Some((len, table)) = TableDYN_S6::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S7 = if let Some((len, table)) = TableDYN_S7::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let NB = token_parser.TokenFieldNB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_S1,
                DYN_S2,
                DYN_S3,
                DYN_S4,
                DYN_S5,
                DYN_S6,
                DYN_S7,
                S,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc:34:1"]
#[derive(Clone, Debug)]
struct instructionVar135 {
    S: TokenField_S,
    NB: TokenField_NB,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar135 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("stswi"),
            DisplayElement::Literal("  "),
            self.S.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.NB.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBH().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 725i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let NB = token_parser.TokenFieldNB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, S, NB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc:50:1"]
#[derive(Clone, Debug)]
struct instructionVar136 {
    S: TokenField_S,
    NB: TokenField_NB,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_S1: TableDYN_S1,
}
impl instructionVar136 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("stswi"),
            DisplayElement::Literal("  "),
            self.S.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.NB.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldBH().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 725i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S1 = if let Some((len, table)) = TableDYN_S1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let NB = token_parser.TokenFieldNB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_S1,
                S,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc:68:1"]
#[derive(Clone, Debug)]
struct instructionVar137 {
    S: TokenField_S,
    NB: TokenField_NB,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_S1: TableDYN_S1,
    DYN_S2: TableDYN_S2,
}
impl instructionVar137 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("stswi"),
            DisplayElement::Literal("  "),
            self.S.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.NB.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldBH().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 725i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S1 = if let Some((len, table)) = TableDYN_S1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S2 = if let Some((len, table)) = TableDYN_S2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let NB = token_parser.TokenFieldNB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_S1,
                DYN_S2,
                S,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc:88:1"]
#[derive(Clone, Debug)]
struct instructionVar138 {
    S: TokenField_S,
    NB: TokenField_NB,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_S1: TableDYN_S1,
    DYN_S2: TableDYN_S2,
    DYN_S3: TableDYN_S3,
}
impl instructionVar138 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("stswi"),
            DisplayElement::Literal("  "),
            self.S.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.NB.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldBH().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 725i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S1 = if let Some((len, table)) = TableDYN_S1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S2 = if let Some((len, table)) = TableDYN_S2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S3 = if let Some((len, table)) = TableDYN_S3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let NB = token_parser.TokenFieldNB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_S1,
                DYN_S2,
                DYN_S3,
                S,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc:110:1"]
#[derive(Clone, Debug)]
struct instructionVar139 {
    S: TokenField_S,
    NB: TokenField_NB,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_S1: TableDYN_S1,
    DYN_S2: TableDYN_S2,
    DYN_S3: TableDYN_S3,
    DYN_S4: TableDYN_S4,
}
impl instructionVar139 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("stswi"),
            DisplayElement::Literal("  "),
            self.S.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.NB.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 5i64 {
            return None;
        }
        if token_parser.TokenFieldBH().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 725i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S1 = if let Some((len, table)) = TableDYN_S1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S2 = if let Some((len, table)) = TableDYN_S2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S3 = if let Some((len, table)) = TableDYN_S3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S4 = if let Some((len, table)) = TableDYN_S4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let NB = token_parser.TokenFieldNB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_S1,
                DYN_S2,
                DYN_S3,
                DYN_S4,
                S,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc:134:1"]
#[derive(Clone, Debug)]
struct instructionVar140 {
    S: TokenField_S,
    NB: TokenField_NB,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_S1: TableDYN_S1,
    DYN_S2: TableDYN_S2,
    DYN_S3: TableDYN_S3,
    DYN_S4: TableDYN_S4,
    DYN_S5: TableDYN_S5,
}
impl instructionVar140 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("stswi"),
            DisplayElement::Literal("  "),
            self.S.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.NB.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 6i64 {
            return None;
        }
        if token_parser.TokenFieldBH().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 725i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S1 = if let Some((len, table)) = TableDYN_S1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S2 = if let Some((len, table)) = TableDYN_S2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S3 = if let Some((len, table)) = TableDYN_S3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S4 = if let Some((len, table)) = TableDYN_S4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S5 = if let Some((len, table)) = TableDYN_S5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let NB = token_parser.TokenFieldNB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_S1,
                DYN_S2,
                DYN_S3,
                DYN_S4,
                DYN_S5,
                S,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc:160:1"]
#[derive(Clone, Debug)]
struct instructionVar141 {
    S: TokenField_S,
    NB: TokenField_NB,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_S1: TableDYN_S1,
    DYN_S2: TableDYN_S2,
    DYN_S3: TableDYN_S3,
    DYN_S4: TableDYN_S4,
    DYN_S5: TableDYN_S5,
    DYN_S6: TableDYN_S6,
}
impl instructionVar141 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("stswi"),
            DisplayElement::Literal("  "),
            self.S.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.NB.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 7i64 {
            return None;
        }
        if token_parser.TokenFieldBH().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 725i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S1 = if let Some((len, table)) = TableDYN_S1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S2 = if let Some((len, table)) = TableDYN_S2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S3 = if let Some((len, table)) = TableDYN_S3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S4 = if let Some((len, table)) = TableDYN_S4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S5 = if let Some((len, table)) = TableDYN_S5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S6 = if let Some((len, table)) = TableDYN_S6::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let NB = token_parser.TokenFieldNB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_S1,
                DYN_S2,
                DYN_S3,
                DYN_S4,
                DYN_S5,
                DYN_S6,
                S,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4300:1"]
#[derive(Clone, Debug)]
struct instructionVar142 {
    D: TokenField_D,
    A: TokenField_A,
}
impl instructionVar142 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("subfme"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 232i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4309:1"]
#[derive(Clone, Debug)]
struct instructionVar143 {
    D: TokenField_D,
    A: TokenField_A,
}
impl instructionVar143 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("subfme."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 232i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4318:1"]
#[derive(Clone, Debug)]
struct instructionVar144 {
    D: TokenField_D,
    A: TokenField_A,
}
impl instructionVar144 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("subfmeo"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 232i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4328:1"]
#[derive(Clone, Debug)]
struct instructionVar145 {
    D: TokenField_D,
    A: TokenField_A,
}
impl instructionVar145 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("subfmeo."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 232i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4339:1"]
#[derive(Clone, Debug)]
struct instructionVar146 {
    D: TokenField_D,
    A: TokenField_A,
}
impl instructionVar146 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("subfze"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 200i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4348:1"]
#[derive(Clone, Debug)]
struct instructionVar147 {
    D: TokenField_D,
    A: TokenField_A,
}
impl instructionVar147 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("subfze."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 200i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4358:1"]
#[derive(Clone, Debug)]
struct instructionVar148 {
    D: TokenField_D,
    A: TokenField_A,
}
impl instructionVar148 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("subfzeo"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 200i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4368:1"]
#[derive(Clone, Debug)]
struct instructionVar149 {
    D: TokenField_D,
    A: TokenField_A,
}
impl instructionVar149 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("subfzeo."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 200i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc:26:1"]
#[derive(Clone, Debug)]
struct instructionVar150 {
    D: TokenField_D,
    NB: TokenField_NB,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar150 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lswi"),
            DisplayElement::Literal("  "),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.NB.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 597i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        let NB = token_parser.TokenFieldNB();
        let BH = token_parser.TokenFieldBH();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, D, NB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc:39:1"]
#[derive(Clone, Debug)]
struct instructionVar151 {
    D: TokenField_D,
    NB: TokenField_NB,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_D1: TableDYN_D1,
}
impl instructionVar151 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lswi"),
            DisplayElement::Literal("  "),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.NB.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 597i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D1 = if let Some((len, table)) = TableDYN_D1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        let NB = token_parser.TokenFieldNB();
        let BH = token_parser.TokenFieldBH();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_D1,
                D,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc:57:1"]
#[derive(Clone, Debug)]
struct instructionVar152 {
    D: TokenField_D,
    NB: TokenField_NB,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_D1: TableDYN_D1,
    DYN_D2: TableDYN_D2,
}
impl instructionVar152 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lswi"),
            DisplayElement::Literal("  "),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.NB.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 597i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D1 = if let Some((len, table)) = TableDYN_D1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D2 = if let Some((len, table)) = TableDYN_D2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        let NB = token_parser.TokenFieldNB();
        let BH = token_parser.TokenFieldBH();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_D1,
                DYN_D2,
                D,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc:76:1"]
#[derive(Clone, Debug)]
struct instructionVar153 {
    D: TokenField_D,
    NB: TokenField_NB,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_D1: TableDYN_D1,
    DYN_D2: TableDYN_D2,
    DYN_D3: TableDYN_D3,
}
impl instructionVar153 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lswi"),
            DisplayElement::Literal("  "),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.NB.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 597i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D1 = if let Some((len, table)) = TableDYN_D1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D2 = if let Some((len, table)) = TableDYN_D2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D3 = if let Some((len, table)) = TableDYN_D3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        let NB = token_parser.TokenFieldNB();
        let BH = token_parser.TokenFieldBH();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_D1,
                DYN_D2,
                DYN_D3,
                D,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc:97:1"]
#[derive(Clone, Debug)]
struct instructionVar154 {
    D: TokenField_D,
    NB: TokenField_NB,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_D1: TableDYN_D1,
    DYN_D2: TableDYN_D2,
    DYN_D3: TableDYN_D3,
    DYN_D4: TableDYN_D4,
}
impl instructionVar154 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lswi"),
            DisplayElement::Literal("  "),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.NB.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 597i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D1 = if let Some((len, table)) = TableDYN_D1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D2 = if let Some((len, table)) = TableDYN_D2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D3 = if let Some((len, table)) = TableDYN_D3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D4 = if let Some((len, table)) = TableDYN_D4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        let NB = token_parser.TokenFieldNB();
        let BH = token_parser.TokenFieldBH();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_D1,
                DYN_D2,
                DYN_D3,
                DYN_D4,
                D,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc:120:1"]
#[derive(Clone, Debug)]
struct instructionVar155 {
    D: TokenField_D,
    NB: TokenField_NB,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_D1: TableDYN_D1,
    DYN_D2: TableDYN_D2,
    DYN_D3: TableDYN_D3,
    DYN_D4: TableDYN_D4,
    DYN_D5: TableDYN_D5,
}
impl instructionVar155 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lswi"),
            DisplayElement::Literal("  "),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.NB.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 5i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 597i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D1 = if let Some((len, table)) = TableDYN_D1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D2 = if let Some((len, table)) = TableDYN_D2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D3 = if let Some((len, table)) = TableDYN_D3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D4 = if let Some((len, table)) = TableDYN_D4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D5 = if let Some((len, table)) = TableDYN_D5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        let NB = token_parser.TokenFieldNB();
        let BH = token_parser.TokenFieldBH();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_D1,
                DYN_D2,
                DYN_D3,
                DYN_D4,
                DYN_D5,
                D,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc:145:1"]
#[derive(Clone, Debug)]
struct instructionVar156 {
    D: TokenField_D,
    NB: TokenField_NB,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_D1: TableDYN_D1,
    DYN_D2: TableDYN_D2,
    DYN_D3: TableDYN_D3,
    DYN_D4: TableDYN_D4,
    DYN_D5: TableDYN_D5,
    DYN_D6: TableDYN_D6,
}
impl instructionVar156 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lswi"),
            DisplayElement::Literal("  "),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.NB.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 6i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 597i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D1 = if let Some((len, table)) = TableDYN_D1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D2 = if let Some((len, table)) = TableDYN_D2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D3 = if let Some((len, table)) = TableDYN_D3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D4 = if let Some((len, table)) = TableDYN_D4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D5 = if let Some((len, table)) = TableDYN_D5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D6 = if let Some((len, table)) = TableDYN_D6::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        let NB = token_parser.TokenFieldNB();
        let BH = token_parser.TokenFieldBH();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_D1,
                DYN_D2,
                DYN_D3,
                DYN_D4,
                DYN_D5,
                DYN_D6,
                D,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc:172:1"]
#[derive(Clone, Debug)]
struct instructionVar157 {
    D: TokenField_D,
    NB: TokenField_NB,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_D1: TableDYN_D1,
    DYN_D2: TableDYN_D2,
    DYN_D3: TableDYN_D3,
    DYN_D4: TableDYN_D4,
    DYN_D5: TableDYN_D5,
    DYN_D6: TableDYN_D6,
    DYN_D7: TableDYN_D7,
}
impl instructionVar157 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lswi"),
            DisplayElement::Literal("  "),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.NB.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 7i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 597i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D1 = if let Some((len, table)) = TableDYN_D1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D2 = if let Some((len, table)) = TableDYN_D2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D3 = if let Some((len, table)) = TableDYN_D3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D4 = if let Some((len, table)) = TableDYN_D4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D5 = if let Some((len, table)) = TableDYN_D5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D6 = if let Some((len, table)) = TableDYN_D6::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_D7 = if let Some((len, table)) = TableDYN_D7::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        let NB = token_parser.TokenFieldNB();
        let BH = token_parser.TokenFieldBH();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_D1,
                DYN_D2,
                DYN_D3,
                DYN_D4,
                DYN_D5,
                DYN_D6,
                DYN_D7,
                D,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3024:1"]
#[derive(Clone, Debug)]
struct instructionVar158 {
    D: TokenField_D,
    B: TokenField_B,
}
impl instructionVar158 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("mfsrin"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 659i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3035:1"]
#[derive(Clone, Debug)]
struct instructionVar159 {
    CRM: TokenField_CRM,
    S: TokenField_S,
}
impl instructionVar159 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("mtcrf"),
            DisplayElement::Literal(" "),
            self.CRM.display(),
            DisplayElement::Literal(","),
            self.S.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_11().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 144i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        let CRM = token_parser.TokenFieldCRM();
        let CRM0 = token_parser.TokenFieldCRM0();
        let CRM1 = token_parser.TokenFieldCRM1();
        let CRM2 = token_parser.TokenFieldCRM2();
        let CRM3 = token_parser.TokenFieldCRM3();
        let CRM4 = token_parser.TokenFieldCRM4();
        let CRM5 = token_parser.TokenFieldCRM5();
        let CRM6 = token_parser.TokenFieldCRM6();
        let CRM7 = token_parser.TokenFieldCRM7();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, CRM }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3179:1"]
#[derive(Clone, Debug)]
struct instructionVar160 {
    S: TokenField_S,
    CRM_val: TableCRM_val,
}
impl instructionVar160 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("mtocrf"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.CRM_val.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.S.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_20().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_11().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 144i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let CRM_val = if let Some((len, table)) = TableCRM_val::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let CRM0 = token_parser.TokenFieldCRM0();
        let CRM1 = token_parser.TokenFieldCRM1();
        let CRM2 = token_parser.TokenFieldCRM2();
        let CRM3 = token_parser.TokenFieldCRM3();
        let CRM4 = token_parser.TokenFieldCRM4();
        let CRM5 = token_parser.TokenFieldCRM5();
        let CRM6 = token_parser.TokenFieldCRM6();
        let CRM7 = token_parser.TokenFieldCRM7();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CRM_val, S }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3224:1"]
#[derive(Clone, Debug)]
struct instructionVar161 {
    S: TokenField_S,
    B: TokenField_B,
}
impl instructionVar161 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("mtsrdin"),
            DisplayElement::Literal(" "),
            self.S.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 114i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3232:1"]
#[derive(Clone, Debug)]
struct instructionVar162 {
    S: TokenField_S,
    B: TokenField_B,
}
impl instructionVar162 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("mtsrin"),
            DisplayElement::Literal(" "),
            self.S.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 242i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3712:1"]
#[derive(Clone, Debug)]
struct instructionVar163 {
    B: TokenField_B,
}
impl instructionVar163 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("slbie"),
            DisplayElement::Literal("\t"),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 434i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3718:1"]
#[derive(Clone, Debug)]
struct instructionVar164 {
    D: TokenField_D,
    B: TokenField_B,
}
impl instructionVar164 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("slbmfee"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 915i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3724:1"]
#[derive(Clone, Debug)]
struct instructionVar165 {
    D: TokenField_D,
    B: TokenField_B,
}
impl instructionVar165 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("slbmfev"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 851i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3730:1"]
#[derive(Clone, Debug)]
struct instructionVar166 {
    S: TokenField_S,
    B: TokenField_B,
}
impl instructionVar166 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("slbmte"),
            DisplayElement::Literal(" "),
            self.S.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 402i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4403:1"]
#[derive(Clone, Debug)]
struct instructionVar167 {
    RS_OR_ZERO: TableRS_OR_ZERO,
    RB_OR_ZERO: TableRB_OR_ZERO,
}
impl instructionVar167 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("tlbie"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.RB_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.RS_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_16_20().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 306i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RS_OR_ZERO = if let Some((len, table)) = TableRS_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let RB_OR_ZERO = if let Some((len, table)) = TableRB_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS_OR_ZERO,
                RB_OR_ZERO,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2987:1"]
#[derive(Clone, Debug)]
struct instructionVar168 {
    D: TokenField_D,
    CRM_CR: TableCRM_CR,
}
impl instructionVar168 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("mfocrf"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.CRM_CR.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_20().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let CRM_CR = if let Some((len, table)) = TableCRM_CR::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        let BIT_11 = token_parser.TokenFieldBIT_11();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CRM_CR, D }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3085:1"]
#[derive(Clone, Debug)]
struct instructionVar169 {
    FM: TokenField_FM,
    fB: TokenField_fB,
}
impl instructionVar169 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("mtfsf"),
            DisplayElement::Literal(" "),
            self.FM.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_25().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_16().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 711i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let FM = token_parser.TokenFieldFM();
        let FM0 = token_parser.TokenFieldFM0();
        let FM1 = token_parser.TokenFieldFM1();
        let FM2 = token_parser.TokenFieldFM2();
        let FM3 = token_parser.TokenFieldFM3();
        let FM4 = token_parser.TokenFieldFM4();
        let FM5 = token_parser.TokenFieldFM5();
        let FM6 = token_parser.TokenFieldFM6();
        let FM7 = token_parser.TokenFieldFM7();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FM, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3107:1"]
#[derive(Clone, Debug)]
struct instructionVar170 {
    FM: TokenField_FM,
    fB: TokenField_fB,
}
impl instructionVar170 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("mtfsf."),
            DisplayElement::Literal(" "),
            self.FM.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_25().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_16().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 711i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let FM = token_parser.TokenFieldFM();
        let FM0 = token_parser.TokenFieldFM0();
        let FM1 = token_parser.TokenFieldFM1();
        let FM2 = token_parser.TokenFieldFM2();
        let FM3 = token_parser.TokenFieldFM3();
        let FM4 = token_parser.TokenFieldFM4();
        let FM5 = token_parser.TokenFieldFM5();
        let FM6 = token_parser.TokenFieldFM6();
        let FM7 = token_parser.TokenFieldFM7();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FM, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc:27:1"]
#[derive(Clone, Debug)]
struct instructionVar171 {
    S: TokenField_S,
    NB: TokenField_NB,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar171 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("stswi"),
            DisplayElement::Literal("  "),
            self.S.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.NB.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 725i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let NB = token_parser.TokenFieldNB();
        let BH = token_parser.TokenFieldBH();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, S, NB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc:40:1"]
#[derive(Clone, Debug)]
struct instructionVar172 {
    S: TokenField_S,
    NB: TokenField_NB,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_S1: TableDYN_S1,
}
impl instructionVar172 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("stswi"),
            DisplayElement::Literal("  "),
            self.S.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.NB.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 725i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S1 = if let Some((len, table)) = TableDYN_S1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let NB = token_parser.TokenFieldNB();
        let BH = token_parser.TokenFieldBH();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_S1,
                S,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc:58:1"]
#[derive(Clone, Debug)]
struct instructionVar173 {
    S: TokenField_S,
    NB: TokenField_NB,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_S1: TableDYN_S1,
    DYN_S2: TableDYN_S2,
}
impl instructionVar173 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("stswi"),
            DisplayElement::Literal("  "),
            self.S.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.NB.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 725i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S1 = if let Some((len, table)) = TableDYN_S1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S2 = if let Some((len, table)) = TableDYN_S2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let NB = token_parser.TokenFieldNB();
        let BH = token_parser.TokenFieldBH();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_S1,
                DYN_S2,
                S,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc:77:1"]
#[derive(Clone, Debug)]
struct instructionVar174 {
    S: TokenField_S,
    NB: TokenField_NB,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_S1: TableDYN_S1,
    DYN_S2: TableDYN_S2,
    DYN_S3: TableDYN_S3,
}
impl instructionVar174 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("stswi"),
            DisplayElement::Literal("  "),
            self.S.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.NB.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 725i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S1 = if let Some((len, table)) = TableDYN_S1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S2 = if let Some((len, table)) = TableDYN_S2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S3 = if let Some((len, table)) = TableDYN_S3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let NB = token_parser.TokenFieldNB();
        let BH = token_parser.TokenFieldBH();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_S1,
                DYN_S2,
                DYN_S3,
                S,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc:98:1"]
#[derive(Clone, Debug)]
struct instructionVar175 {
    S: TokenField_S,
    NB: TokenField_NB,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_S1: TableDYN_S1,
    DYN_S2: TableDYN_S2,
    DYN_S3: TableDYN_S3,
    DYN_S4: TableDYN_S4,
}
impl instructionVar175 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("stswi"),
            DisplayElement::Literal("  "),
            self.S.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.NB.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 725i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S1 = if let Some((len, table)) = TableDYN_S1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S2 = if let Some((len, table)) = TableDYN_S2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S3 = if let Some((len, table)) = TableDYN_S3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S4 = if let Some((len, table)) = TableDYN_S4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let NB = token_parser.TokenFieldNB();
        let BH = token_parser.TokenFieldBH();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_S1,
                DYN_S2,
                DYN_S3,
                DYN_S4,
                S,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc:121:1"]
#[derive(Clone, Debug)]
struct instructionVar176 {
    S: TokenField_S,
    NB: TokenField_NB,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_S1: TableDYN_S1,
    DYN_S2: TableDYN_S2,
    DYN_S3: TableDYN_S3,
    DYN_S4: TableDYN_S4,
    DYN_S5: TableDYN_S5,
}
impl instructionVar176 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("stswi"),
            DisplayElement::Literal("  "),
            self.S.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.NB.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 5i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 725i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S1 = if let Some((len, table)) = TableDYN_S1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S2 = if let Some((len, table)) = TableDYN_S2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S3 = if let Some((len, table)) = TableDYN_S3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S4 = if let Some((len, table)) = TableDYN_S4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S5 = if let Some((len, table)) = TableDYN_S5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let NB = token_parser.TokenFieldNB();
        let BH = token_parser.TokenFieldBH();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_S1,
                DYN_S2,
                DYN_S3,
                DYN_S4,
                DYN_S5,
                S,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc:146:1"]
#[derive(Clone, Debug)]
struct instructionVar177 {
    S: TokenField_S,
    NB: TokenField_NB,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_S1: TableDYN_S1,
    DYN_S2: TableDYN_S2,
    DYN_S3: TableDYN_S3,
    DYN_S4: TableDYN_S4,
    DYN_S5: TableDYN_S5,
    DYN_S6: TableDYN_S6,
}
impl instructionVar177 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("stswi"),
            DisplayElement::Literal("  "),
            self.S.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.NB.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 6i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 725i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S1 = if let Some((len, table)) = TableDYN_S1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S2 = if let Some((len, table)) = TableDYN_S2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S3 = if let Some((len, table)) = TableDYN_S3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S4 = if let Some((len, table)) = TableDYN_S4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S5 = if let Some((len, table)) = TableDYN_S5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S6 = if let Some((len, table)) = TableDYN_S6::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let NB = token_parser.TokenFieldNB();
        let BH = token_parser.TokenFieldBH();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_S1,
                DYN_S2,
                DYN_S3,
                DYN_S4,
                DYN_S5,
                DYN_S6,
                S,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc:173:1"]
#[derive(Clone, Debug)]
struct instructionVar178 {
    S: TokenField_S,
    NB: TokenField_NB,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_S1: TableDYN_S1,
    DYN_S2: TableDYN_S2,
    DYN_S3: TableDYN_S3,
    DYN_S4: TableDYN_S4,
    DYN_S5: TableDYN_S5,
    DYN_S6: TableDYN_S6,
    DYN_S7: TableDYN_S7,
}
impl instructionVar178 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("stswi"),
            DisplayElement::Literal("  "),
            self.S.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.NB.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_13_15().disassembly() != 7i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 725i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S1 = if let Some((len, table)) = TableDYN_S1::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S2 = if let Some((len, table)) = TableDYN_S2::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S3 = if let Some((len, table)) = TableDYN_S3::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S4 = if let Some((len, table)) = TableDYN_S4::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S5 = if let Some((len, table)) = TableDYN_S5::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S6 = if let Some((len, table)) = TableDYN_S6::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let DYN_S7 = if let Some((len, table)) = TableDYN_S7::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let NB = token_parser.TokenFieldNB();
        let BH = token_parser.TokenFieldBH();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_S1,
                DYN_S2,
                DYN_S3,
                DYN_S4,
                DYN_S5,
                DYN_S6,
                DYN_S7,
                S,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc:69:1"]
#[derive(Clone, Debug)]
struct instructionVar179 {
    BITS_21_24: TokenField_BITS_21_24,
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar179 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("icbt"),
            DisplayElement::Literal(" "),
            self.BITS_21_24.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_25().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 22i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BITS_21_24 = token_parser.TokenFieldBITS_21_24();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                BITS_21_24,
                B,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:6:1"]
#[derive(Clone, Debug)]
struct instructionVar180 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar180 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("add"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 266i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:12:1"]
#[derive(Clone, Debug)]
struct instructionVar181 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar181 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("add."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 266i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:19:1"]
#[derive(Clone, Debug)]
struct instructionVar182 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar182 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("addo"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 266i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:26:1"]
#[derive(Clone, Debug)]
struct instructionVar183 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar183 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("addo."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 266i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:34:1"]
#[derive(Clone, Debug)]
struct instructionVar184 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar184 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("addc"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 10i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:41:1"]
#[derive(Clone, Debug)]
struct instructionVar185 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar185 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("addc."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 10i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:49:1"]
#[derive(Clone, Debug)]
struct instructionVar186 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar186 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("addco"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 10i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:57:1"]
#[derive(Clone, Debug)]
struct instructionVar187 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar187 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("addco."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 10i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:66:1"]
#[derive(Clone, Debug)]
struct instructionVar188 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar188 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("adde"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 138i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:74:1"]
#[derive(Clone, Debug)]
struct instructionVar189 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar189 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("adde."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 138i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:83:1"]
#[derive(Clone, Debug)]
struct instructionVar190 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar190 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("addeo"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 138i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:92:1"]
#[derive(Clone, Debug)]
struct instructionVar191 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar191 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("addeo."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 138i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3700:1"]
#[derive(Clone, Debug)]
struct instructionVar192 {
    LEV: TokenField_LEV,
}
impl instructionVar192 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("sc"),
            DisplayElement::Literal("\t"),
            self.LEV.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 17i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_12_25().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_2_4().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_1().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let LEV = token_parser.TokenFieldLEV();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LEV }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:109:1"]
#[derive(Clone, Debug)]
struct instructionVar193 {
    D: TokenField_D,
    SIMM: TokenField_SIMM,
}
impl instructionVar193 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("li"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.SIMM.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 14i64 {
            return None;
        }
        if token_parser.TokenFieldA().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldSIMM_SIGN().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let SIMM = token_parser.TokenFieldSIMM();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, SIMM }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:115:1"]
#[derive(Clone, Debug)]
struct instructionVar194 {
    D: TokenField_D,
    SIMM: TokenField_SIMM,
}
impl instructionVar194 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("li"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.SIMM.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 14i64 {
            return None;
        }
        if token_parser.TokenFieldA().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldSIMM_SIGN().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let SIMM = token_parser.TokenFieldSIMM();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, SIMM }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:163:1"]
#[derive(Clone, Debug)]
struct instructionVar195 {
    D: TokenField_D,
    SIMM: TokenField_SIMM,
}
impl instructionVar195 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("lis"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.SIMM.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 15i64 {
            return None;
        }
        if token_parser.TokenFieldA().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldSIMM_SIGN().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let SIMM = token_parser.TokenFieldSIMM();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, SIMM }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:169:1"]
#[derive(Clone, Debug)]
struct instructionVar196 {
    D: TokenField_D,
    SIMM: TokenField_SIMM,
}
impl instructionVar196 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("lis"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.SIMM.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 15i64 {
            return None;
        }
        if token_parser.TokenFieldA().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldSIMM_SIGN().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let SIMM = token_parser.TokenFieldSIMM();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, SIMM }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:370:1"]
#[derive(Clone, Debug)]
struct instructionVar197 {
    addressBD: TableaddressBD,
    REL_ABS: TableREL_ABS,
}
impl instructionVar197 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("bl"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addressBD.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 16i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBD().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 1i64 {
            return None;
        }
        let addressBD = if let Some((len, table)) = TableaddressBD::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let REL_ABS = if let Some((len, table)) = TableREL_ABS::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addressBD, REL_ABS }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1569:1"]
#[derive(Clone, Debug)]
struct instructionVar198 {
    fD: TokenField_fD,
    fA: TokenField_fA,
    fC: TokenField_fC,
}
impl instructionVar198 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("fmul"),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fC.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 25i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fA = token_parser.TokenFieldfA();
        let fC = token_parser.TokenFieldfC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1577:1"]
#[derive(Clone, Debug)]
struct instructionVar199 {
    fD: TokenField_fD,
    fA: TokenField_fA,
    fC: TokenField_fC,
}
impl instructionVar199 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("fmul."),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fC.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 25i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fA = token_parser.TokenFieldfA();
        let fC = token_parser.TokenFieldfC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1587:1"]
#[derive(Clone, Debug)]
struct instructionVar200 {
    fD: TokenField_fD,
    fA: TokenField_fA,
    fC: TokenField_fC,
}
impl instructionVar200 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("fmuls"),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fC.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 59i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 25i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fA = token_parser.TokenFieldfA();
        let fC = token_parser.TokenFieldfC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1597:1"]
#[derive(Clone, Debug)]
struct instructionVar201 {
    fD: TokenField_fD,
    fA: TokenField_fA,
    fC: TokenField_fC,
}
impl instructionVar201 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("fmuls."),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fC.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 59i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_11_15().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 25i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fA = token_parser.TokenFieldfA();
        let fC = token_parser.TokenFieldfC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:103:1"]
#[derive(Clone, Debug)]
struct instructionVar202 {
    D: TokenField_D,
    A: TokenField_A,
    SIMM: TokenField_SIMM,
}
impl instructionVar202 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("addi"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.SIMM.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 14i64 {
            return None;
        }
        if token_parser.TokenFieldSIMM_SIGN().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let SIMM = token_parser.TokenFieldSIMM();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, SIMM }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:121:1"]
#[derive(Clone, Debug)]
struct instructionVar203 {
    D: TokenField_D,
    A: TokenField_A,
    SIMM: TokenField_SIMM,
}
impl instructionVar203 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_tmp: i64 = 0;
        calc_tmp = (-self.SIMM.disassembly());
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("subi"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            DisplayElement::Number(true, calc_tmp),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_tmp: i64 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 14i64 {
            return None;
        }
        if token_parser.TokenFieldSIMM_SIGN().disassembly() != 1i64 {
            return None;
        }
        calc_tmp = (-token_parser.TokenFieldSIMM().disassembly());
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let SIMM = token_parser.TokenFieldSIMM();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, SIMM }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:127:1"]
#[derive(Clone, Debug)]
struct instructionVar204 {
    D: TokenField_D,
    A: TokenField_A,
    SIMM: TokenField_SIMM,
}
impl instructionVar204 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("addic"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.SIMM.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldSIMM_SIGN().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let SIMM = token_parser.TokenFieldSIMM();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, SIMM }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:134:1"]
#[derive(Clone, Debug)]
struct instructionVar205 {
    D: TokenField_D,
    A: TokenField_A,
    SIMM: TokenField_SIMM,
}
impl instructionVar205 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_tmp: i64 = 0;
        calc_tmp = (-self.SIMM.disassembly());
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("subic"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            DisplayElement::Number(true, calc_tmp),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_tmp: i64 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldSIMM_SIGN().disassembly() != 1i64 {
            return None;
        }
        calc_tmp = (-token_parser.TokenFieldSIMM().disassembly());
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let SIMM = token_parser.TokenFieldSIMM();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, SIMM }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:141:1"]
#[derive(Clone, Debug)]
struct instructionVar206 {
    D: TokenField_D,
    A: TokenField_A,
    SIMM: TokenField_SIMM,
}
impl instructionVar206 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("addic."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.SIMM.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 13i64 {
            return None;
        }
        if token_parser.TokenFieldSIMM_SIGN().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let SIMM = token_parser.TokenFieldSIMM();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, SIMM }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:149:1"]
#[derive(Clone, Debug)]
struct instructionVar207 {
    D: TokenField_D,
    A: TokenField_A,
    SIMM: TokenField_SIMM,
}
impl instructionVar207 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_tmp: i64 = 0;
        calc_tmp = (-self.SIMM.disassembly());
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("subic."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            DisplayElement::Number(true, calc_tmp),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_tmp: i64 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 13i64 {
            return None;
        }
        if token_parser.TokenFieldSIMM_SIGN().disassembly() != 1i64 {
            return None;
        }
        calc_tmp = (-token_parser.TokenFieldSIMM().disassembly());
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let SIMM = token_parser.TokenFieldSIMM();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, SIMM }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:157:1"]
#[derive(Clone, Debug)]
struct instructionVar208 {
    D: TokenField_D,
    A: TokenField_A,
    SIMM: TokenField_SIMM,
}
impl instructionVar208 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("addis"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.SIMM.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 15i64 {
            return None;
        }
        if token_parser.TokenFieldSIMM_SIGN().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let SIMM = token_parser.TokenFieldSIMM();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, SIMM }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:175:1"]
#[derive(Clone, Debug)]
struct instructionVar209 {
    D: TokenField_D,
    A: TokenField_A,
    SIMM: TokenField_SIMM,
}
impl instructionVar209 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_tmp: i64 = 0;
        calc_tmp = (-self.SIMM.disassembly());
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("subis"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            DisplayElement::Number(true, calc_tmp),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_tmp: i64 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 15i64 {
            return None;
        }
        if token_parser.TokenFieldSIMM_SIGN().disassembly() != 1i64 {
            return None;
        }
        calc_tmp = (-token_parser.TokenFieldSIMM().disassembly());
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let SIMM = token_parser.TokenFieldSIMM();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, SIMM }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:261:1"]
#[derive(Clone, Debug)]
struct instructionVar210 {
    A: TokenField_A,
    S: TokenField_S,
    B: TokenField_B,
}
impl instructionVar210 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("and"),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 28i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:267:1"]
#[derive(Clone, Debug)]
struct instructionVar211 {
    A: TokenField_A,
    S: TokenField_S,
    B: TokenField_B,
}
impl instructionVar211 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("and."),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 28i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:274:1"]
#[derive(Clone, Debug)]
struct instructionVar212 {
    A: TokenField_A,
    S: TokenField_S,
    B: TokenField_B,
}
impl instructionVar212 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("andc"),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 60i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:280:1"]
#[derive(Clone, Debug)]
struct instructionVar213 {
    A: TokenField_A,
    S: TokenField_S,
    B: TokenField_B,
}
impl instructionVar213 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("andc."),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 60i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:379:1"]
#[derive(Clone, Debug)]
struct instructionVar214 {
    CC: TableCC,
    addressBD: TableaddressBD,
    REL_ABS: TableREL_ABS,
}
impl instructionVar214 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
        self.CC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.REL_ABS.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addressBD.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 16i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBI_CR().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 0i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addressBD = if let Some((len, table)) = TableaddressBD::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let REL_ABS = if let Some((len, table)) = TableREL_ABS::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CC,
                addressBD,
                REL_ABS,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:386:1"]
#[derive(Clone, Debug)]
struct instructionVar215 {
    CC: TableCC,
    addressBD: TableaddressBD,
    REL_ABS: TableREL_ABS,
}
impl instructionVar215 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
        self.CC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.REL_ABS.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addressBD.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_linkreg_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 16i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBI_CR().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 0i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addressBD = if let Some((len, table)) = TableaddressBD::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let REL_ABS = if let Some((len, table)) = TableREL_ABS::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CC,
                addressBD,
                REL_ABS,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:394:1"]
#[derive(Clone, Debug)]
struct instructionVar216 {
    CC: TableCC,
    addressBD: TableaddressBD,
    REL_ABS: TableREL_ABS,
}
impl instructionVar216 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
        self.CC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("l")];
        display.extend_from_slice(&extend);
        self.REL_ABS.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addressBD.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 16i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBI_CR().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 1i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addressBD = if let Some((len, table)) = TableaddressBD::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let REL_ABS = if let Some((len, table)) = TableREL_ABS::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CC,
                addressBD,
                REL_ABS,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:345:1"]
#[derive(Clone, Debug)]
struct instructionVar217 {
    addressBD: TableaddressBD,
    REL_ABS: TableREL_ABS,
}
impl instructionVar217 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
        self.REL_ABS.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addressBD.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 16i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 0i64 {
            return None;
        }
        let addressBD = if let Some((len, table)) = TableaddressBD::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let REL_ABS = if let Some((len, table)) = TableREL_ABS::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addressBD, REL_ABS }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:350:1"]
#[derive(Clone, Debug)]
struct instructionVar218 {
    addressBD: TableaddressBD,
    REL_ABS: TableREL_ABS,
}
impl instructionVar218 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
        self.REL_ABS.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addressBD.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_linkreg_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 16i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 0i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let addressBD = if let Some((len, table)) = TableaddressBD::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let REL_ABS = if let Some((len, table)) = TableREL_ABS::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addressBD, REL_ABS }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:361:1"]
#[derive(Clone, Debug)]
struct instructionVar219 {
    addressBD: TableaddressBD,
    REL_ABS: TableREL_ABS,
}
impl instructionVar219 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bl")];
        display.extend_from_slice(&extend);
        self.REL_ABS.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addressBD.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 16i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 1i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let addressBD = if let Some((len, table)) = TableaddressBD::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let REL_ABS = if let Some((len, table)) = TableREL_ABS::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addressBD, REL_ABS }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:404:1"]
#[derive(Clone, Debug)]
struct instructionVar220 {
    BI_CR: TokenField_BI_CR,
    CC: TableCC,
    addressBD: TableaddressBD,
    REL_ABS: TableREL_ABS,
}
impl instructionVar220 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
        self.CC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.REL_ABS.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.BI_CR.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addressBD.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 16i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 0i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addressBD = if let Some((len, table)) = TableaddressBD::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let REL_ABS = if let Some((len, table)) = TableREL_ABS::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BI_CR = token_parser.TokenFieldBI_CR();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CC,
                addressBD,
                REL_ABS,
                BI_CR,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:412:1"]
#[derive(Clone, Debug)]
struct instructionVar221 {
    BI_CR: TokenField_BI_CR,
    CC: TableCC,
    addressBD: TableaddressBD,
    REL_ABS: TableREL_ABS,
}
impl instructionVar221 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
        self.CC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("l")];
        display.extend_from_slice(&extend);
        self.REL_ABS.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            self.BI_CR.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addressBD.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 16i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 1i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addressBD = if let Some((len, table)) = TableaddressBD::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let REL_ABS = if let Some((len, table)) = TableREL_ABS::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let BI_CR = token_parser.TokenFieldBI_CR();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CC,
                addressBD,
                REL_ABS,
                BI_CR,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:422:1"]
#[derive(Clone, Debug)]
struct instructionVar222 {
    CTR_DEC: TableCTR_DEC,
    REL_ABS: TableREL_ABS,
    addressBD: TableaddressBD,
}
impl instructionVar222 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bd")];
        display.extend_from_slice(&extend);
        self.CTR_DEC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.REL_ABS.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addressBD.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 16i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 0i64 {
            return None;
        }
        let CTR_DEC = if let Some((len, table)) = TableCTR_DEC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let REL_ABS = if let Some((len, table)) = TableREL_ABS::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addressBD = if let Some((len, table)) = TableaddressBD::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CTR_DEC,
                REL_ABS,
                addressBD,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:429:1"]
#[derive(Clone, Debug)]
struct instructionVar223 {
    CTR_DEC: TableCTR_DEC,
    REL_ABS: TableREL_ABS,
    addressBD: TableaddressBD,
}
impl instructionVar223 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bd")];
        display.extend_from_slice(&extend);
        self.CTR_DEC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("l")];
        display.extend_from_slice(&extend);
        self.REL_ABS.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addressBD.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 16i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 1i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let CTR_DEC = if let Some((len, table)) = TableCTR_DEC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let REL_ABS = if let Some((len, table)) = TableREL_ABS::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addressBD = if let Some((len, table)) = TableaddressBD::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CTR_DEC,
                REL_ABS,
                addressBD,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:439:1"]
#[derive(Clone, Debug)]
struct instructionVar224 {
    CC_TF: TableCC_TF,
    REL_ABS: TableREL_ABS,
    CTR_DEC: TableCTR_DEC,
    CC_OP: TableCC_OP,
    addressBD: TableaddressBD,
}
impl instructionVar224 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bd")];
        display.extend_from_slice(&extend);
        self.CTR_DEC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.CC_TF.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.REL_ABS.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CC_OP.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.addressBD.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 16i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 0i64 {
            return None;
        }
        let CC_TF = if let Some((len, table)) =
            TableCC_TF::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let REL_ABS = if let Some((len, table)) = TableREL_ABS::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CTR_DEC = if let Some((len, table)) = TableCTR_DEC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CC_OP = if let Some((len, table)) =
            TableCC_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addressBD = if let Some((len, table)) = TableaddressBD::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CC_TF,
                REL_ABS,
                CTR_DEC,
                CC_OP,
                addressBD,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:446:1"]
#[derive(Clone, Debug)]
struct instructionVar225 {
    CC_TF: TableCC_TF,
    CTR_DEC: TableCTR_DEC,
    REL_ABS: TableREL_ABS,
    CC_OP: TableCC_OP,
    addressBD: TableaddressBD,
}
impl instructionVar225 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bd")];
        display.extend_from_slice(&extend);
        self.CTR_DEC.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        self.CC_TF.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("l")];
        display.extend_from_slice(&extend);
        self.REL_ABS.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CC_OP.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.addressBD.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 16i64 {
            return None;
        }
        if token_parser.TokenFieldBO_0().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBO_2().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 1i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let CC_TF = if let Some((len, table)) =
            TableCC_TF::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CTR_DEC = if let Some((len, table)) = TableCTR_DEC::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let REL_ABS = if let Some((len, table)) = TableREL_ABS::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CC_OP = if let Some((len, table)) =
            TableCC_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addressBD = if let Some((len, table)) = TableaddressBD::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CC_TF,
                CTR_DEC,
                REL_ABS,
                CC_OP,
                addressBD,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:845:1"]
#[derive(Clone, Debug)]
struct instructionVar226 {
    CC_D_OP: TableCC_D_OP,
    CC_OP: TableCC_OP,
    CC_B_OP: TableCC_B_OP,
}
impl instructionVar226 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("crand"),
            DisplayElement::Literal("\t"),
        ];
        display.extend_from_slice(&extend);
        self.CC_D_OP.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.CC_OP.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.CC_B_OP.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 257i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let CC_D_OP = if let Some((len, table)) = TableCC_D_OP::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CC_OP = if let Some((len, table)) =
            TableCC_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CC_B_OP = if let Some((len, table)) = TableCC_B_OP::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CR_D = token_parser.TokenFieldCR_D();
        let CR_D_CC = token_parser.TokenFieldCR_D_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CC_D_OP,
                CC_OP,
                CC_B_OP,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:852:1"]
#[derive(Clone, Debug)]
struct instructionVar227 {
    CC_D_OP: TableCC_D_OP,
    CC_OP: TableCC_OP,
    CC_B_OP: TableCC_B_OP,
}
impl instructionVar227 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("crandc"),
            DisplayElement::Literal("\t"),
        ];
        display.extend_from_slice(&extend);
        self.CC_D_OP.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.CC_OP.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.CC_B_OP.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 129i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let CC_D_OP = if let Some((len, table)) = TableCC_D_OP::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CC_OP = if let Some((len, table)) =
            TableCC_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CC_B_OP = if let Some((len, table)) = TableCC_B_OP::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CR_D = token_parser.TokenFieldCR_D();
        let CR_D_CC = token_parser.TokenFieldCR_D_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CC_D_OP,
                CC_OP,
                CC_B_OP,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:860:1"]
#[derive(Clone, Debug)]
struct instructionVar228 {
    CC_D_OP: TableCC_D_OP,
    CC_OP: TableCC_OP,
    CC_B_OP: TableCC_B_OP,
}
impl instructionVar228 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("creqv"),
            DisplayElement::Literal("\t"),
        ];
        display.extend_from_slice(&extend);
        self.CC_D_OP.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.CC_OP.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.CC_B_OP.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 289i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let CC_D_OP = if let Some((len, table)) = TableCC_D_OP::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CC_OP = if let Some((len, table)) =
            TableCC_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CC_B_OP = if let Some((len, table)) = TableCC_B_OP::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CR_D = token_parser.TokenFieldCR_D();
        let CR_D_CC = token_parser.TokenFieldCR_D_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CC_D_OP,
                CC_OP,
                CC_B_OP,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:867:1"]
#[derive(Clone, Debug)]
struct instructionVar229 {
    CC_D_OP: TableCC_D_OP,
    CC_OP: TableCC_OP,
    CC_B_OP: TableCC_B_OP,
}
impl instructionVar229 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("crnand"),
            DisplayElement::Literal("\t"),
        ];
        display.extend_from_slice(&extend);
        self.CC_D_OP.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.CC_OP.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.CC_B_OP.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 225i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let CC_D_OP = if let Some((len, table)) = TableCC_D_OP::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CC_OP = if let Some((len, table)) =
            TableCC_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CC_B_OP = if let Some((len, table)) = TableCC_B_OP::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CR_D = token_parser.TokenFieldCR_D();
        let CR_D_CC = token_parser.TokenFieldCR_D_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CC_D_OP,
                CC_OP,
                CC_B_OP,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:874:1"]
#[derive(Clone, Debug)]
struct instructionVar230 {
    CC_D_OP: TableCC_D_OP,
    CC_OP: TableCC_OP,
    CC_B_OP: TableCC_B_OP,
}
impl instructionVar230 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("crnor"),
            DisplayElement::Literal("\t"),
        ];
        display.extend_from_slice(&extend);
        self.CC_D_OP.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.CC_OP.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.CC_B_OP.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 33i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let CC_D_OP = if let Some((len, table)) = TableCC_D_OP::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CC_OP = if let Some((len, table)) =
            TableCC_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CC_B_OP = if let Some((len, table)) = TableCC_B_OP::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CR_D = token_parser.TokenFieldCR_D();
        let CR_D_CC = token_parser.TokenFieldCR_D_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CC_D_OP,
                CC_OP,
                CC_B_OP,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:881:1"]
#[derive(Clone, Debug)]
struct instructionVar231 {
    CC_D_OP: TableCC_D_OP,
    CC_OP: TableCC_OP,
    CC_B_OP: TableCC_B_OP,
}
impl instructionVar231 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("cror"),
            DisplayElement::Literal("\t"),
        ];
        display.extend_from_slice(&extend);
        self.CC_D_OP.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.CC_OP.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.CC_B_OP.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 449i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let CC_D_OP = if let Some((len, table)) = TableCC_D_OP::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CC_OP = if let Some((len, table)) =
            TableCC_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CC_B_OP = if let Some((len, table)) = TableCC_B_OP::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CR_D = token_parser.TokenFieldCR_D();
        let CR_D_CC = token_parser.TokenFieldCR_D_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CC_D_OP,
                CC_OP,
                CC_B_OP,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:888:1"]
#[derive(Clone, Debug)]
struct instructionVar232 {
    CC_D_OP: TableCC_D_OP,
    CC_OP: TableCC_OP,
    CC_B_OP: TableCC_B_OP,
}
impl instructionVar232 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("crorc"),
            DisplayElement::Literal("\t"),
        ];
        display.extend_from_slice(&extend);
        self.CC_D_OP.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.CC_OP.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.CC_B_OP.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 417i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let CC_D_OP = if let Some((len, table)) = TableCC_D_OP::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CC_OP = if let Some((len, table)) =
            TableCC_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CC_B_OP = if let Some((len, table)) = TableCC_B_OP::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CR_D = token_parser.TokenFieldCR_D();
        let CR_D_CC = token_parser.TokenFieldCR_D_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CC_D_OP,
                CC_OP,
                CC_B_OP,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:895:1"]
#[derive(Clone, Debug)]
struct instructionVar233 {
    CC_D_OP: TableCC_D_OP,
    CC_OP: TableCC_OP,
    CC_B_OP: TableCC_B_OP,
}
impl instructionVar233 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("crxor"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.CC_D_OP.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.CC_OP.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        self.CC_B_OP.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 19i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 193i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let CC_D_OP = if let Some((len, table)) = TableCC_D_OP::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CC_OP = if let Some((len, table)) =
            TableCC_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CC_B_OP = if let Some((len, table)) = TableCC_B_OP::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CR_D = token_parser.TokenFieldCR_D();
        let CR_D_CC = token_parser.TokenFieldCR_D_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CC_D_OP,
                CC_OP,
                CC_B_OP,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:975:1"]
#[derive(Clone, Debug)]
struct instructionVar234 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar234 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("divw"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 491i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:985:1"]
#[derive(Clone, Debug)]
struct instructionVar235 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar235 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("divw."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 491i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:999:1"]
#[derive(Clone, Debug)]
struct instructionVar236 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar236 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("divwo"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 491i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1011:1"]
#[derive(Clone, Debug)]
struct instructionVar237 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar237 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("divwo."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 491i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1026:1"]
#[derive(Clone, Debug)]
struct instructionVar238 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar238 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("divwu"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 459i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1036:1"]
#[derive(Clone, Debug)]
struct instructionVar239 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar239 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("divwu."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 459i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1048:1"]
#[derive(Clone, Debug)]
struct instructionVar240 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar240 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("divwuo"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 459i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1060:1"]
#[derive(Clone, Debug)]
struct instructionVar241 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar241 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("divwuo."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 459i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1077:1"]
#[derive(Clone, Debug)]
struct instructionVar242 {
    D: TokenField_D,
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar242 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("eciwx"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 310i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, D, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1084:1"]
#[derive(Clone, Debug)]
struct instructionVar243 {
    S: TokenField_S,
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar243 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("ecowx"),
            DisplayElement::Literal(" "),
            self.S.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 438i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, S, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1094:1"]
#[derive(Clone, Debug)]
struct instructionVar244 {
    A: TokenField_A,
    S: TokenField_S,
    B: TokenField_B,
}
impl instructionVar244 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("eqv"),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 284i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1100:1"]
#[derive(Clone, Debug)]
struct instructionVar245 {
    A: TokenField_A,
    S: TokenField_S,
    B: TokenField_B,
}
impl instructionVar245 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("eqv."),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 284i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1169:1"]
#[derive(Clone, Debug)]
struct instructionVar246 {
    fD: TokenField_fD,
    fA: TokenField_fA,
    fB: TokenField_fB,
}
impl instructionVar246 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("fadd"),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_6_10().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 21i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fA = token_parser.TokenFieldfA();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1178:1"]
#[derive(Clone, Debug)]
struct instructionVar247 {
    fD: TokenField_fD,
    fA: TokenField_fA,
    fB: TokenField_fB,
}
impl instructionVar247 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("fadd."),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_6_10().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 21i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fA = token_parser.TokenFieldfA();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1188:1"]
#[derive(Clone, Debug)]
struct instructionVar248 {
    fD: TokenField_fD,
    fA: TokenField_fA,
    fB: TokenField_fB,
}
impl instructionVar248 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("fadds"),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 59i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_6_10().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 21i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fA = token_parser.TokenFieldfA();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1199:1"]
#[derive(Clone, Debug)]
struct instructionVar249 {
    fD: TokenField_fD,
    fA: TokenField_fA,
    fB: TokenField_fB,
}
impl instructionVar249 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("fadds."),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 59i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_6_10().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 21i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fA = token_parser.TokenFieldfA();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1351:1"]
#[derive(Clone, Debug)]
struct instructionVar250 {
    fD: TokenField_fD,
    fA: TokenField_fA,
    fB: TokenField_fB,
}
impl instructionVar250 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("fdiv"),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_6_10().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 18i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fA = token_parser.TokenFieldfA();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1359:1"]
#[derive(Clone, Debug)]
struct instructionVar251 {
    fD: TokenField_fD,
    fA: TokenField_fA,
    fB: TokenField_fB,
}
impl instructionVar251 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("fdiv."),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_6_10().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 18i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fA = token_parser.TokenFieldfA();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1369:1"]
#[derive(Clone, Debug)]
struct instructionVar252 {
    fD: TokenField_fD,
    fA: TokenField_fA,
    fB: TokenField_fB,
}
impl instructionVar252 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("fdivs"),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 59i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_6_10().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 18i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fA = token_parser.TokenFieldfA();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1378:1"]
#[derive(Clone, Debug)]
struct instructionVar253 {
    fD: TokenField_fD,
    fA: TokenField_fA,
    fB: TokenField_fB,
}
impl instructionVar253 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("fdivs."),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 59i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_6_10().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 18i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fA = token_parser.TokenFieldfA();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1803:1"]
#[derive(Clone, Debug)]
struct instructionVar254 {
    fD: TokenField_fD,
    fB: TokenField_fB,
}
impl instructionVar254 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("fres"),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 59i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_6_10().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 24i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let BITS_16_20 = token_parser.TokenFieldBITS_16_20();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1821:1"]
#[derive(Clone, Debug)]
struct instructionVar255 {
    fD: TokenField_fD,
    fB: TokenField_fB,
}
impl instructionVar255 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("fres."),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 59i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_6_10().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 24i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let BITS_16_20 = token_parser.TokenFieldBITS_16_20();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1877:1"]
#[derive(Clone, Debug)]
struct instructionVar256 {
    fD: TokenField_fD,
    fB: TokenField_fB,
}
impl instructionVar256 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("frsqrte"),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_6_10().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 26i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let BITS_16_20 = token_parser.TokenFieldBITS_16_20();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1895:1"]
#[derive(Clone, Debug)]
struct instructionVar257 {
    fD: TokenField_fD,
    fB: TokenField_fB,
}
impl instructionVar257 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("frsqrte."),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_6_10().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 26i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let BITS_16_20 = token_parser.TokenFieldBITS_16_20();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1998:1"]
#[derive(Clone, Debug)]
struct instructionVar258 {
    fD: TokenField_fD,
    fA: TokenField_fA,
    fB: TokenField_fB,
}
impl instructionVar258 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("fsub"),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_6_10().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 20i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fA = token_parser.TokenFieldfA();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2007:1"]
#[derive(Clone, Debug)]
struct instructionVar259 {
    fD: TokenField_fD,
    fA: TokenField_fA,
    fB: TokenField_fB,
}
impl instructionVar259 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("fsub."),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_6_10().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 20i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fA = token_parser.TokenFieldfA();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2017:1"]
#[derive(Clone, Debug)]
struct instructionVar260 {
    fD: TokenField_fD,
    fA: TokenField_fA,
    fB: TokenField_fB,
}
impl instructionVar260 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("fsubs"),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 59i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_6_10().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 20i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fA = token_parser.TokenFieldfA();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2028:1"]
#[derive(Clone, Debug)]
struct instructionVar261 {
    fD: TokenField_fD,
    fA: TokenField_fA,
    fB: TokenField_fB,
}
impl instructionVar261 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("fsubs."),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 59i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_6_10().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 20i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fA = token_parser.TokenFieldfA();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2072:1"]
#[derive(Clone, Debug)]
struct instructionVar262 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar262 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("lbzux"),
            DisplayElement::Literal("\t"),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 119i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2080:1"]
#[derive(Clone, Debug)]
struct instructionVar263 {
    D: TokenField_D,
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar263 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lbzx"),
            DisplayElement::Literal("\t"),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 87i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, D, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2142:1"]
#[derive(Clone, Debug)]
struct instructionVar264 {
    fD: TokenField_fD,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar264 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("lfdux"),
            DisplayElement::Literal("\t"),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 631i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2149:1"]
#[derive(Clone, Debug)]
struct instructionVar265 {
    fD: TokenField_fD,
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar265 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lfdx"),
            DisplayElement::Literal("\t"),
            self.fD.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 599i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fD = token_parser.TokenFieldfD();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, fD, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2168:1"]
#[derive(Clone, Debug)]
struct instructionVar266 {
    fD: TokenField_fD,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar266 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("lfsux"),
            DisplayElement::Literal("\t"),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 567i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2175:1"]
#[derive(Clone, Debug)]
struct instructionVar267 {
    fD: TokenField_fD,
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar267 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lfsx"),
            DisplayElement::Literal("\t"),
            self.fD.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 535i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fD = token_parser.TokenFieldfD();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, fD, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2194:1"]
#[derive(Clone, Debug)]
struct instructionVar268 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar268 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("lhaux"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 375i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2201:1"]
#[derive(Clone, Debug)]
struct instructionVar269 {
    D: TokenField_D,
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar269 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lhax"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 343i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, D, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2207:1"]
#[derive(Clone, Debug)]
struct instructionVar270 {
    D: TokenField_D,
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar270 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lhbrx"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 790i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, D, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2231:1"]
#[derive(Clone, Debug)]
struct instructionVar271 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar271 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("lhzux"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 311i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2238:1"]
#[derive(Clone, Debug)]
struct instructionVar272 {
    D: TokenField_D,
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar272 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lhzx"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 279i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, D, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2251:1"]
#[derive(Clone, Debug)]
struct instructionVar273 {
    D: TokenField_D,
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar273 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lswx"),
            DisplayElement::Literal("\t"),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 533i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        let NB = token_parser.TokenFieldNB();
        let BITS_21_25 = token_parser.TokenFieldBITS_21_25();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, D, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2264:1"]
#[derive(Clone, Debug)]
struct instructionVar274 {
    D: TokenField_D,
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar274 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lwarx"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 20i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, D, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2292:1"]
#[derive(Clone, Debug)]
struct instructionVar275 {
    D: TokenField_D,
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar275 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lwbrx"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 534i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, D, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2324:1"]
#[derive(Clone, Debug)]
struct instructionVar276 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar276 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("lwzux"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 55i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2336:1"]
#[derive(Clone, Debug)]
struct instructionVar277 {
    D: TokenField_D,
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar277 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lwzx"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 23i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, D, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2346:1"]
#[derive(Clone, Debug)]
struct instructionVar278 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar278 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("macchw"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 172i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2352:1"]
#[derive(Clone, Debug)]
struct instructionVar279 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar279 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("macchw."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 172i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2359:1"]
#[derive(Clone, Debug)]
struct instructionVar280 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar280 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("macchwo"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 172i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2367:1"]
#[derive(Clone, Debug)]
struct instructionVar281 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar281 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("macchwo."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 172i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2376:1"]
#[derive(Clone, Debug)]
struct instructionVar282 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar282 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("macchws"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 236i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2382:1"]
#[derive(Clone, Debug)]
struct instructionVar283 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar283 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("macchws."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 236i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2390:1"]
#[derive(Clone, Debug)]
struct instructionVar284 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar284 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("macchwso"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 236i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2399:1"]
#[derive(Clone, Debug)]
struct instructionVar285 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar285 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("macchwso."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 236i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2408:1"]
#[derive(Clone, Debug)]
struct instructionVar286 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar286 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("macchwsu"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 204i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2414:1"]
#[derive(Clone, Debug)]
struct instructionVar287 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar287 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("macchwsu."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 204i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2421:1"]
#[derive(Clone, Debug)]
struct instructionVar288 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar288 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("macchwsuo"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 204i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2428:1"]
#[derive(Clone, Debug)]
struct instructionVar289 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar289 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("macchwsuo."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 204i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2436:1"]
#[derive(Clone, Debug)]
struct instructionVar290 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar290 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("macchwu"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 140i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2442:1"]
#[derive(Clone, Debug)]
struct instructionVar291 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar291 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("macchwu."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 140i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2449:1"]
#[derive(Clone, Debug)]
struct instructionVar292 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar292 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("macchwuo"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 140i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2456:1"]
#[derive(Clone, Debug)]
struct instructionVar293 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar293 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("macchwuo."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 140i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2465:1"]
#[derive(Clone, Debug)]
struct instructionVar294 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar294 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("machhw"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 44i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2471:1"]
#[derive(Clone, Debug)]
struct instructionVar295 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar295 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("machhw."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 44i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2479:1"]
#[derive(Clone, Debug)]
struct instructionVar296 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar296 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("machhwo"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 44i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2488:1"]
#[derive(Clone, Debug)]
struct instructionVar297 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar297 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("machhwo."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 44i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2497:1"]
#[derive(Clone, Debug)]
struct instructionVar298 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar298 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("machhws"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 108i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2503:1"]
#[derive(Clone, Debug)]
struct instructionVar299 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar299 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("machhws."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 108i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2510:1"]
#[derive(Clone, Debug)]
struct instructionVar300 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar300 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("machhwso"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 108i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2517:1"]
#[derive(Clone, Debug)]
struct instructionVar301 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar301 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("machhwso."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 108i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2525:1"]
#[derive(Clone, Debug)]
struct instructionVar302 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar302 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("machhwsu"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 76i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2531:1"]
#[derive(Clone, Debug)]
struct instructionVar303 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar303 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("machhwsu."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 76i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2538:1"]
#[derive(Clone, Debug)]
struct instructionVar304 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar304 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("machhwsuo"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 76i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2545:1"]
#[derive(Clone, Debug)]
struct instructionVar305 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar305 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("machhwsuo."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 76i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2553:1"]
#[derive(Clone, Debug)]
struct instructionVar306 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar306 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("machhwu"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2559:1"]
#[derive(Clone, Debug)]
struct instructionVar307 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar307 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("machhwu."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2566:1"]
#[derive(Clone, Debug)]
struct instructionVar308 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar308 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("machhwuo"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2573:1"]
#[derive(Clone, Debug)]
struct instructionVar309 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar309 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("machhwuo."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 12i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2582:1"]
#[derive(Clone, Debug)]
struct instructionVar310 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar310 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("maclhw"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 428i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2588:1"]
#[derive(Clone, Debug)]
struct instructionVar311 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar311 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("maclhw."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 428i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2595:1"]
#[derive(Clone, Debug)]
struct instructionVar312 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar312 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("maclhwo"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 428i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2602:1"]
#[derive(Clone, Debug)]
struct instructionVar313 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar313 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("maclhwo."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 428i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2610:1"]
#[derive(Clone, Debug)]
struct instructionVar314 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar314 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("maclhws"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 492i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2616:1"]
#[derive(Clone, Debug)]
struct instructionVar315 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar315 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("maclhws."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 492i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2623:1"]
#[derive(Clone, Debug)]
struct instructionVar316 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar316 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("maclhwso"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 492i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2630:1"]
#[derive(Clone, Debug)]
struct instructionVar317 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar317 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("maclhwso."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 492i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2638:1"]
#[derive(Clone, Debug)]
struct instructionVar318 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar318 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("maclhwsu"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 460i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2644:1"]
#[derive(Clone, Debug)]
struct instructionVar319 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar319 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("maclhwsu."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 460i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2651:1"]
#[derive(Clone, Debug)]
struct instructionVar320 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar320 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("maclhwsuo"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 460i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2658:1"]
#[derive(Clone, Debug)]
struct instructionVar321 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar321 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("maclhwsuo."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 460i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2667:1"]
#[derive(Clone, Debug)]
struct instructionVar322 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar322 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("maclhwu"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 396i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2675:1"]
#[derive(Clone, Debug)]
struct instructionVar323 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar323 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("maclhwu."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 396i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2683:1"]
#[derive(Clone, Debug)]
struct instructionVar324 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar324 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("maclhwuo"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 396i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2690:1"]
#[derive(Clone, Debug)]
struct instructionVar325 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar325 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("maclhwuo."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 396i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2698:1"]
#[derive(Clone, Debug)]
struct instructionVar326 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar326 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("mulchw"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 168i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2704:1"]
#[derive(Clone, Debug)]
struct instructionVar327 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar327 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("mulchw."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 168i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2711:1"]
#[derive(Clone, Debug)]
struct instructionVar328 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar328 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("mulchwu"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 136i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2717:1"]
#[derive(Clone, Debug)]
struct instructionVar329 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar329 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("mulchwu."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 136i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2724:1"]
#[derive(Clone, Debug)]
struct instructionVar330 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar330 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("mulhhw"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 40i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2730:1"]
#[derive(Clone, Debug)]
struct instructionVar331 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar331 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("mulhhw."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 40i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2737:1"]
#[derive(Clone, Debug)]
struct instructionVar332 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar332 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("mulhhwu"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 8i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2743:1"]
#[derive(Clone, Debug)]
struct instructionVar333 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar333 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("mulhhwu."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 8i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2750:1"]
#[derive(Clone, Debug)]
struct instructionVar334 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar334 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("mullhw"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 424i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2756:1"]
#[derive(Clone, Debug)]
struct instructionVar335 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar335 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("mullhw."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 424i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2764:1"]
#[derive(Clone, Debug)]
struct instructionVar336 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar336 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("mullhwu"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 392i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2772:1"]
#[derive(Clone, Debug)]
struct instructionVar337 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar337 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("mullhwu."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 392i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2780:1"]
#[derive(Clone, Debug)]
struct instructionVar338 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar338 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("nmacchw"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 174i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2786:1"]
#[derive(Clone, Debug)]
struct instructionVar339 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar339 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("nmacchw."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 174i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2793:1"]
#[derive(Clone, Debug)]
struct instructionVar340 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar340 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("nmacchwo"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 174i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2800:1"]
#[derive(Clone, Debug)]
struct instructionVar341 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar341 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("nmacchwo."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 174i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2808:1"]
#[derive(Clone, Debug)]
struct instructionVar342 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar342 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("nmacchws"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 238i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2814:1"]
#[derive(Clone, Debug)]
struct instructionVar343 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar343 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("nmacchws."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 238i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2821:1"]
#[derive(Clone, Debug)]
struct instructionVar344 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar344 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("nmacchwso"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 238i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2828:1"]
#[derive(Clone, Debug)]
struct instructionVar345 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar345 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("nmacchwso."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 238i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2836:1"]
#[derive(Clone, Debug)]
struct instructionVar346 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar346 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("nmachhw"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 46i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2842:1"]
#[derive(Clone, Debug)]
struct instructionVar347 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar347 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("nmachhw."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 46i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2849:1"]
#[derive(Clone, Debug)]
struct instructionVar348 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar348 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("nmachhwo"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 46i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2856:1"]
#[derive(Clone, Debug)]
struct instructionVar349 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar349 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("nmachhwo."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 46i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2864:1"]
#[derive(Clone, Debug)]
struct instructionVar350 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar350 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("nmachhws"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 110i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2870:1"]
#[derive(Clone, Debug)]
struct instructionVar351 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar351 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("nmachhws."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 110i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2877:1"]
#[derive(Clone, Debug)]
struct instructionVar352 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar352 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("nmachhwso"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 110i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2884:1"]
#[derive(Clone, Debug)]
struct instructionVar353 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar353 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("nmachhwso."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 110i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2892:1"]
#[derive(Clone, Debug)]
struct instructionVar354 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar354 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("nmaclhw"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 430i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2898:1"]
#[derive(Clone, Debug)]
struct instructionVar355 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar355 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("nmaclhw."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 430i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2905:1"]
#[derive(Clone, Debug)]
struct instructionVar356 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar356 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("nmaclhwo"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 430i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2912:1"]
#[derive(Clone, Debug)]
struct instructionVar357 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar357 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("nmaclhwo."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 430i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2920:1"]
#[derive(Clone, Debug)]
struct instructionVar358 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar358 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("nmaclhws"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 494i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2926:1"]
#[derive(Clone, Debug)]
struct instructionVar359 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar359 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("nmaclhws."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 494i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2933:1"]
#[derive(Clone, Debug)]
struct instructionVar360 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar360 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("nmaclhwso"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 494i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2940:1"]
#[derive(Clone, Debug)]
struct instructionVar361 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar361 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("nmaclhwso."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 494i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3274:1"]
#[derive(Clone, Debug)]
struct instructionVar362 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar362 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("mulhw"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_10().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 75i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3287:1"]
#[derive(Clone, Debug)]
struct instructionVar363 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar363 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("mulhw."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_10().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 75i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3301:1"]
#[derive(Clone, Debug)]
struct instructionVar364 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar364 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("mulhwu"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_10().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 11i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3313:1"]
#[derive(Clone, Debug)]
struct instructionVar365 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar365 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("mulhwu."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_10().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 11i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3368:1"]
#[derive(Clone, Debug)]
struct instructionVar366 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar366 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("mullw"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 235i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3378:1"]
#[derive(Clone, Debug)]
struct instructionVar367 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar367 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("mullw."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 235i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3389:1"]
#[derive(Clone, Debug)]
struct instructionVar368 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar368 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("mullwo"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 235i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3402:1"]
#[derive(Clone, Debug)]
struct instructionVar369 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar369 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("mullwo."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 235i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3416:1"]
#[derive(Clone, Debug)]
struct instructionVar370 {
    A: TokenField_A,
    S: TokenField_S,
    B: TokenField_B,
}
impl instructionVar370 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("nand"),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 476i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3422:1"]
#[derive(Clone, Debug)]
struct instructionVar371 {
    A: TokenField_A,
    S: TokenField_S,
    B: TokenField_B,
}
impl instructionVar371 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("nand."),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 476i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3457:1"]
#[derive(Clone, Debug)]
struct instructionVar372 {
    A: TokenField_A,
    S: TokenField_S,
    B: TokenField_B,
}
impl instructionVar372 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("nor"),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 124i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let A = token_parser.TokenFieldA();
        let S = token_parser.TokenFieldS();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3463:1"]
#[derive(Clone, Debug)]
struct instructionVar373 {
    A: TokenField_A,
    S: TokenField_S,
    B: TokenField_B,
}
impl instructionVar373 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("nor."),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 124i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let A = token_parser.TokenFieldA();
        let S = token_parser.TokenFieldS();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3470:1"]
#[derive(Clone, Debug)]
struct instructionVar374 {
    A: TokenField_A,
    S: TokenField_S,
    B: TokenField_B,
}
impl instructionVar374 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("or"),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 444i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let A = token_parser.TokenFieldA();
        let S = token_parser.TokenFieldS();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3476:1"]
#[derive(Clone, Debug)]
struct instructionVar375 {
    A: TokenField_A,
    S: TokenField_S,
    B: TokenField_B,
}
impl instructionVar375 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("or."),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 444i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let A = token_parser.TokenFieldA();
        let S = token_parser.TokenFieldS();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3483:1"]
#[derive(Clone, Debug)]
struct instructionVar376 {
    A: TokenField_A,
    S: TokenField_S,
    B: TokenField_B,
}
impl instructionVar376 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("orc"),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 412i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let A = token_parser.TokenFieldA();
        let S = token_parser.TokenFieldS();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3489:1"]
#[derive(Clone, Debug)]
struct instructionVar377 {
    A: TokenField_A,
    S: TokenField_S,
    B: TokenField_B,
}
impl instructionVar377 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("orc."),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 412i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let A = token_parser.TokenFieldA();
        let S = token_parser.TokenFieldS();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3751:1"]
#[derive(Clone, Debug)]
struct instructionVar378 {
    A: TokenField_A,
    S: TokenField_S,
    B: TokenField_B,
}
impl instructionVar378 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("slw"),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 24i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3765:1"]
#[derive(Clone, Debug)]
struct instructionVar379 {
    A: TokenField_A,
    S: TokenField_S,
    B: TokenField_B,
}
impl instructionVar379 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("slw."),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 24i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3814:1"]
#[derive(Clone, Debug)]
struct instructionVar380 {
    A: TokenField_A,
    S: TokenField_S,
    B: TokenField_B,
}
impl instructionVar380 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("sraw"),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 792i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let A = token_parser.TokenFieldA();
        let S = token_parser.TokenFieldS();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3828:1"]
#[derive(Clone, Debug)]
struct instructionVar381 {
    A: TokenField_A,
    S: TokenField_S,
    B: TokenField_B,
}
impl instructionVar381 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("sraw."),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 792i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let A = token_parser.TokenFieldA();
        let S = token_parser.TokenFieldS();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3844:1"]
#[derive(Clone, Debug)]
struct instructionVar382 {
    A: TokenField_A,
    S: TokenField_S,
    SHL: TokenField_SHL,
}
impl instructionVar382 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("srawi"),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.SHL.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 824i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let A = token_parser.TokenFieldA();
        let S = token_parser.TokenFieldS();
        let SHL = token_parser.TokenFieldSHL();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, SHL }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3857:1"]
#[derive(Clone, Debug)]
struct instructionVar383 {
    A: TokenField_A,
    S: TokenField_S,
    SHL: TokenField_SHL,
}
impl instructionVar383 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("srawi."),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.SHL.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 824i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let A = token_parser.TokenFieldA();
        let S = token_parser.TokenFieldS();
        let SHL = token_parser.TokenFieldSHL();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, SHL }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3887:1"]
#[derive(Clone, Debug)]
struct instructionVar384 {
    A: TokenField_A,
    S: TokenField_S,
    B: TokenField_B,
}
impl instructionVar384 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("srw"),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 536i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3901:1"]
#[derive(Clone, Debug)]
struct instructionVar385 {
    A: TokenField_A,
    S: TokenField_S,
    B: TokenField_B,
}
impl instructionVar385 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("srw."),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 536i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3932:1"]
#[derive(Clone, Debug)]
struct instructionVar386 {
    S: TokenField_S,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar386 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("stbux"),
            DisplayElement::Literal("\t"),
            self.S.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 247i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3940:1"]
#[derive(Clone, Debug)]
struct instructionVar387 {
    S: TokenField_S,
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar387 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("stbx"),
            DisplayElement::Literal("\t"),
            self.S.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 215i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, S, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4013:1"]
#[derive(Clone, Debug)]
struct instructionVar388 {
    fS: TokenField_fS,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar388 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("stfdux"),
            DisplayElement::Literal("\t"),
            self.fS.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 759i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let fS = token_parser.TokenFieldfS();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fS, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4021:1"]
#[derive(Clone, Debug)]
struct instructionVar389 {
    fS: TokenField_fS,
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar389 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("stfdx"),
            DisplayElement::Literal(" "),
            self.fS.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 727i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fS = token_parser.TokenFieldfS();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, fS, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4028:1"]
#[derive(Clone, Debug)]
struct instructionVar390 {
    fS: TokenField_fS,
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar390 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("stfiwx"),
            DisplayElement::Literal(" "),
            self.fS.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 983i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fS = token_parser.TokenFieldfS();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, fS, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4052:1"]
#[derive(Clone, Debug)]
struct instructionVar391 {
    fS: TokenField_fS,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar391 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("stfsux"),
            DisplayElement::Literal(" "),
            self.fS.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 695i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let fS = token_parser.TokenFieldfS();
        let B = token_parser.TokenFieldB();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fS, B, A }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4061:1"]
#[derive(Clone, Debug)]
struct instructionVar392 {
    fS: TokenField_fS,
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar392 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("stfsx"),
            DisplayElement::Literal(" "),
            self.fS.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 663i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fS = token_parser.TokenFieldfS();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, fS, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4075:1"]
#[derive(Clone, Debug)]
struct instructionVar393 {
    S: TokenField_S,
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar393 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("sthbrx"),
            DisplayElement::Literal(" "),
            self.S.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 918i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, S, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4091:1"]
#[derive(Clone, Debug)]
struct instructionVar394 {
    S: TokenField_S,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar394 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("sthux"),
            DisplayElement::Literal(" "),
            self.S.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 439i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4099:1"]
#[derive(Clone, Debug)]
struct instructionVar395 {
    S: TokenField_S,
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar395 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("sthx"),
            DisplayElement::Literal(" "),
            self.S.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 407i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, S, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4119:1"]
#[derive(Clone, Debug)]
struct instructionVar396 {
    S: TokenField_S,
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar396 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("stswx"),
            DisplayElement::Literal(" "),
            self.S.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 661i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, S, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4136:1"]
#[derive(Clone, Debug)]
struct instructionVar397 {
    S: TokenField_S,
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar397 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("stwbrx"),
            DisplayElement::Literal(" "),
            self.S.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 662i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, S, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4152:1"]
#[derive(Clone, Debug)]
struct instructionVar398 {
    S: TokenField_S,
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar398 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("stwcx."),
            DisplayElement::Literal(" "),
            self.S.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 150i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 1i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, S, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4173:1"]
#[derive(Clone, Debug)]
struct instructionVar399 {
    S: TokenField_S,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar399 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("stwux"),
            DisplayElement::Literal(" "),
            self.S.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 183i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4185:1"]
#[derive(Clone, Debug)]
struct instructionVar400 {
    S: TokenField_S,
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar400 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("stwx"),
            DisplayElement::Literal(" "),
            self.S.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 151i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, S, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4197:1"]
#[derive(Clone, Debug)]
struct instructionVar401 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar401 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("subf"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 40i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4203:1"]
#[derive(Clone, Debug)]
struct instructionVar402 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar402 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("subf."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 40i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4210:1"]
#[derive(Clone, Debug)]
struct instructionVar403 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar403 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("subfo"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 40i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4217:1"]
#[derive(Clone, Debug)]
struct instructionVar404 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar404 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("subfo."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 40i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4225:1"]
#[derive(Clone, Debug)]
struct instructionVar405 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar405 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("subfc"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 8i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4232:1"]
#[derive(Clone, Debug)]
struct instructionVar406 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar406 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("subfc."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 8i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4240:1"]
#[derive(Clone, Debug)]
struct instructionVar407 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar407 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("subfco"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 8i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4248:1"]
#[derive(Clone, Debug)]
struct instructionVar408 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar408 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("subfco."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 8i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4257:1"]
#[derive(Clone, Debug)]
struct instructionVar409 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar409 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("subfe"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 136i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4265:1"]
#[derive(Clone, Debug)]
struct instructionVar410 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar410 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("subfe."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 136i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4274:1"]
#[derive(Clone, Debug)]
struct instructionVar411 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar411 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("subfeo"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 136i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4283:1"]
#[derive(Clone, Debug)]
struct instructionVar412 {
    D: TokenField_D,
    A: TokenField_A,
    B: TokenField_B,
}
impl instructionVar412 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("subfeo."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldOE().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_9().disassembly() != 136i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4425:1"]
#[derive(Clone, Debug)]
struct instructionVar413 {
    A: TokenField_A,
    B: TokenField_B,
    TOm: TableTOm,
}
impl instructionVar413 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("tw")];
        display.extend_from_slice(&extend);
        self.TOm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBITS_1_10().disassembly() != 4i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let TOm = if let Some((len, table)) =
            TableTOm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let TO = token_parser.TokenFieldTO();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOm, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4493:1"]
#[derive(Clone, Debug)]
struct instructionVar414 {
    A: TokenField_A,
    S: TokenField_S,
    B: TokenField_B,
}
impl instructionVar414 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("xor"),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 316i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4499:1"]
#[derive(Clone, Debug)]
struct instructionVar415 {
    A: TokenField_A,
    S: TokenField_S,
    B: TokenField_B,
}
impl instructionVar415 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("xor."),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.B.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 316i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, A, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc:82:1"]
#[derive(Clone, Debug)]
struct instructionVar416 {
    D: TokenField_D,
    DCRN: TokenField_DCRN,
}
impl instructionVar416 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("mfdcr"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(", "),
            self.DCRN.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 323i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let DCRN = token_parser.TokenFieldDCRN();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, DCRN }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc:94:1"]
#[derive(Clone, Debug)]
struct instructionVar417 {
    D: TokenField_D,
    SPRVAL: TokenField_SPRVAL,
}
impl instructionVar417 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("mfspr"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.SPRVAL.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 339i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let SPRVAL = token_parser.TokenFieldSPRVAL();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, SPRVAL }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc:111:1"]
#[derive(Clone, Debug)]
struct instructionVar418 {
    DCRN: TokenField_DCRN,
    D: TokenField_D,
}
impl instructionVar418 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("mtdcr"),
            DisplayElement::Literal(" "),
            self.DCRN.display(),
            DisplayElement::Literal(", "),
            self.D.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 451i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let DCRN = token_parser.TokenFieldDCRN();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, DCRN }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc:147:1"]
#[derive(Clone, Debug)]
struct instructionVar419 {
    SPRVAL: TokenField_SPRVAL,
    S: TokenField_S,
}
impl instructionVar419 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("mtspr"),
            DisplayElement::Literal(" "),
            self.SPRVAL.display(),
            DisplayElement::Literal(","),
            self.S.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 467i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let SPRVAL = token_parser.TokenFieldSPRVAL();
        let S = token_parser.TokenFieldS();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SPRVAL, S }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc:188:1"]
#[derive(Clone, Debug)]
struct instructionVar420 {
    D: TokenField_D,
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar420 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("tlbsx"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 914i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, D, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc:195:1"]
#[derive(Clone, Debug)]
struct instructionVar421 {
    D: TokenField_D,
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar421 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("tlbsx."),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 914i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, D, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/4xx.sinc:2:1"]
#[derive(Clone, Debug)]
struct instructionVar422 {
    S: TokenField_S,
    B: TokenField_B,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl instructionVar422 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("dcread"),
            DisplayElement::Literal(" "),
            self.S.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_0().disassembly() != 0i64 {
            return None;
        }
        let mut sub_pattern_c45 = |tokens: &[u8], context_param: &mut T| {
            let mut pattern_len = 0 as u32;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut T| {
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldXOP_1_10().disassembly() == 486i64 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                let token_parser = <TokenParser<4usize>>::new(tokens_param)?;
                if token_parser.TokenFieldXOP_1_10().disassembly() == 326i64 {
                    return Some(((), (), u32::try_from(4u64).unwrap()));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) =
            sub_pattern_c45(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, S, B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1389:1"]
#[derive(Clone, Debug)]
struct instructionVar423 {
    fD: TokenField_fD,
    fA: TokenField_fA,
    fC: TokenField_fC,
    fB: TokenField_fB,
}
impl instructionVar423 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 9usize] = [
            DisplayElement::Literal("fmadd"),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fC.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 29i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fA = token_parser.TokenFieldfA();
        let fC = token_parser.TokenFieldfC();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1409:1"]
#[derive(Clone, Debug)]
struct instructionVar424 {
    fD: TokenField_fD,
    fA: TokenField_fA,
    fC: TokenField_fC,
    fB: TokenField_fB,
}
impl instructionVar424 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 9usize] = [
            DisplayElement::Literal("fmadd."),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fC.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 29i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fA = token_parser.TokenFieldfA();
        let fC = token_parser.TokenFieldfC();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1430:1"]
#[derive(Clone, Debug)]
struct instructionVar425 {
    fD: TokenField_fD,
    fA: TokenField_fA,
    fC: TokenField_fC,
    fB: TokenField_fB,
}
impl instructionVar425 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 9usize] = [
            DisplayElement::Literal("fmadds"),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fC.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 59i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 29i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fA = token_parser.TokenFieldfA();
        let fC = token_parser.TokenFieldfC();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1451:1"]
#[derive(Clone, Debug)]
struct instructionVar426 {
    fD: TokenField_fD,
    fA: TokenField_fA,
    fC: TokenField_fC,
    fB: TokenField_fB,
}
impl instructionVar426 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 9usize] = [
            DisplayElement::Literal("fmadds."),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fC.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 59i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 29i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fA = token_parser.TokenFieldfA();
        let fC = token_parser.TokenFieldfC();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1484:1"]
#[derive(Clone, Debug)]
struct instructionVar427 {
    fD: TokenField_fD,
    fA: TokenField_fA,
    fC: TokenField_fC,
    fB: TokenField_fB,
}
impl instructionVar427 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 9usize] = [
            DisplayElement::Literal("fmsub"),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fC.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 28i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fA = token_parser.TokenFieldfA();
        let fC = token_parser.TokenFieldfC();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1504:1"]
#[derive(Clone, Debug)]
struct instructionVar428 {
    fD: TokenField_fD,
    fA: TokenField_fA,
    fC: TokenField_fC,
    fB: TokenField_fB,
}
impl instructionVar428 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 9usize] = [
            DisplayElement::Literal("fmsub."),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fC.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 28i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fA = token_parser.TokenFieldfA();
        let fC = token_parser.TokenFieldfC();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1526:1"]
#[derive(Clone, Debug)]
struct instructionVar429 {
    fD: TokenField_fD,
    fA: TokenField_fA,
    fC: TokenField_fC,
    fB: TokenField_fB,
}
impl instructionVar429 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 9usize] = [
            DisplayElement::Literal("fmsubs"),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fC.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 59i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 28i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fA = token_parser.TokenFieldfA();
        let fC = token_parser.TokenFieldfC();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1547:1"]
#[derive(Clone, Debug)]
struct instructionVar430 {
    fD: TokenField_fD,
    fA: TokenField_fA,
    fC: TokenField_fC,
    fB: TokenField_fB,
}
impl instructionVar430 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 9usize] = [
            DisplayElement::Literal("fmsubs."),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fC.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 59i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 28i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fA = token_parser.TokenFieldfA();
        let fC = token_parser.TokenFieldfC();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1634:1"]
#[derive(Clone, Debug)]
struct instructionVar431 {
    fD: TokenField_fD,
    fA: TokenField_fA,
    fC: TokenField_fC,
    fB: TokenField_fB,
}
impl instructionVar431 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 9usize] = [
            DisplayElement::Literal("fnmadd"),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fC.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fA = token_parser.TokenFieldfA();
        let fC = token_parser.TokenFieldfC();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1654:1"]
#[derive(Clone, Debug)]
struct instructionVar432 {
    fD: TokenField_fD,
    fA: TokenField_fA,
    fC: TokenField_fC,
    fB: TokenField_fB,
}
impl instructionVar432 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 9usize] = [
            DisplayElement::Literal("fnmadd."),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fC.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fA = token_parser.TokenFieldfA();
        let fC = token_parser.TokenFieldfC();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1675:1"]
#[derive(Clone, Debug)]
struct instructionVar433 {
    fD: TokenField_fD,
    fA: TokenField_fA,
    fC: TokenField_fC,
    fB: TokenField_fB,
}
impl instructionVar433 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 9usize] = [
            DisplayElement::Literal("fnmadds"),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fC.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 59i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fA = token_parser.TokenFieldfA();
        let fC = token_parser.TokenFieldfC();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1696:1"]
#[derive(Clone, Debug)]
struct instructionVar434 {
    fD: TokenField_fD,
    fA: TokenField_fA,
    fC: TokenField_fC,
    fB: TokenField_fB,
}
impl instructionVar434 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 9usize] = [
            DisplayElement::Literal("fnmadds."),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fC.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 59i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fA = token_parser.TokenFieldfA();
        let fC = token_parser.TokenFieldfC();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1718:1"]
#[derive(Clone, Debug)]
struct instructionVar435 {
    fD: TokenField_fD,
    fA: TokenField_fA,
    fC: TokenField_fC,
    fB: TokenField_fB,
}
impl instructionVar435 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 9usize] = [
            DisplayElement::Literal("fnmsub"),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fC.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 30i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fA = token_parser.TokenFieldfA();
        let fC = token_parser.TokenFieldfC();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1738:1"]
#[derive(Clone, Debug)]
struct instructionVar436 {
    fD: TokenField_fD,
    fA: TokenField_fA,
    fC: TokenField_fC,
    fB: TokenField_fB,
}
impl instructionVar436 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 9usize] = [
            DisplayElement::Literal("fnmsub."),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fC.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 30i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fA = token_parser.TokenFieldfA();
        let fC = token_parser.TokenFieldfC();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1760:1"]
#[derive(Clone, Debug)]
struct instructionVar437 {
    fD: TokenField_fD,
    fA: TokenField_fA,
    fC: TokenField_fC,
    fB: TokenField_fB,
}
impl instructionVar437 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 9usize] = [
            DisplayElement::Literal("fnmsubs"),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fC.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 59i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 30i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fA = token_parser.TokenFieldfA();
        let fC = token_parser.TokenFieldfC();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1781:1"]
#[derive(Clone, Debug)]
struct instructionVar438 {
    fD: TokenField_fD,
    fA: TokenField_fA,
    fC: TokenField_fC,
    fB: TokenField_fB,
}
impl instructionVar438 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 9usize] = [
            DisplayElement::Literal("fnmsubs."),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fC.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 59i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 30i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fA = token_parser.TokenFieldfA();
        let fC = token_parser.TokenFieldfC();
        let fB = token_parser.TokenFieldfB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC, fB }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1915:1"]
#[derive(Clone, Debug)]
struct instructionVar439 {
    fD: TokenField_fD,
    fA: TokenField_fA,
    fC: TokenField_fC,
    fB: TokenField_fB,
}
impl instructionVar439 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 9usize] = [
            DisplayElement::Literal("fsel"),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fC.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 23i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fA = token_parser.TokenFieldfA();
        let fB = token_parser.TokenFieldfB();
        let fC = token_parser.TokenFieldfC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fB, fC }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:1926:1"]
#[derive(Clone, Debug)]
struct instructionVar440 {
    fD: TokenField_fD,
    fA: TokenField_fA,
    fC: TokenField_fC,
    fB: TokenField_fB,
}
impl instructionVar440 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 9usize] = [
            DisplayElement::Literal("fsel."),
            DisplayElement::Literal(" "),
            self.fD.display(),
            DisplayElement::Literal(","),
            self.fA.display(),
            DisplayElement::Literal(","),
            self.fC.display(),
            DisplayElement::Literal(","),
            self.fB.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 63i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_5().disassembly() != 23i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let fD = token_parser.TokenFieldfD();
        let fA = token_parser.TokenFieldfA();
        let fB = token_parser.TokenFieldfB();
        let fC = token_parser.TokenFieldfC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fB, fC }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:306:1"]
#[derive(Clone, Debug)]
struct instructionVar441 {
    REL_ABS: TableREL_ABS,
    addressLI: TableaddressLI,
}
impl instructionVar441 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
        self.REL_ABS.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addressLI.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 18i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 0i64 {
            return None;
        }
        let REL_ABS = if let Some((len, table)) = TableREL_ABS::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addressLI = if let Some((len, table)) = TableaddressLI::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { REL_ABS, addressLI }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:311:1"]
#[derive(Clone, Debug)]
struct instructionVar442 {
    REL_ABS: TableREL_ABS,
    addressLI: TableaddressLI,
}
impl instructionVar442 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
        self.REL_ABS.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addressLI.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_linkreg_disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 18i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 0i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let REL_ABS = if let Some((len, table)) = TableREL_ABS::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addressLI = if let Some((len, table)) = TableaddressLI::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { REL_ABS, addressLI }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:322:1"]
#[derive(Clone, Debug)]
struct instructionVar443 {
    REL_ABS: TableREL_ABS,
    addressLI: TableaddressLI,
}
impl instructionVar443 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        global_set.set_linkreg(
            Some(inst_start),
            context.register().read_linkreg_disassembly(),
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bl")];
        display.extend_from_slice(&extend);
        self.REL_ABS.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addressLI.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 18i64 {
            return None;
        }
        if token_parser.TokenFieldLK().disassembly() != 1i64 {
            return None;
        }
        let tmp = 0i64;
        context_instance
            .register_mut()
            .write_linkreg_disassembly(tmp);
        let REL_ABS = if let Some((len, table)) = TableREL_ABS::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let addressLI = if let Some((len, table)) = TableaddressLI::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { REL_ABS, addressLI }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:753:1"]
#[derive(Clone, Debug)]
struct instructionVar444 {
    A: TokenField_A,
    SIMM: TokenField_SIMM,
    DSIZE: TableDSIZE,
    REG_A: TableREG_A,
}
impl instructionVar444 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cmp")];
        display.extend_from_slice(&extend);
        self.DSIZE.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("i"),
            DisplayElement::Literal(" \t"),
            self.A.display(),
            DisplayElement::Literal(","),
            self.SIMM.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 11i64 {
            return None;
        }
        if token_parser.TokenFieldCRFD().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_22().disassembly() != 0i64 {
            return None;
        }
        let DSIZE = if let Some((len, table)) =
            TableDSIZE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let REG_A = if let Some((len, table)) =
            TableREG_A::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let A = token_parser.TokenFieldA();
        let SIMM = token_parser.TokenFieldSIMM();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                DSIZE,
                REG_A,
                A,
                SIMM,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:793:1"]
#[derive(Clone, Debug)]
struct instructionVar445 {
    A: TokenField_A,
    UIMM: TokenField_UIMM,
    DSIZE: TableDSIZE,
    UREG_A: TableUREG_A,
}
impl instructionVar445 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cmpl")];
        display.extend_from_slice(&extend);
        self.DSIZE.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("i"),
            DisplayElement::Literal(" \t"),
            self.A.display(),
            DisplayElement::Literal(","),
            self.UIMM.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 10i64 {
            return None;
        }
        if token_parser.TokenFieldCRFD().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_22().disassembly() != 0i64 {
            return None;
        }
        let DSIZE = if let Some((len, table)) =
            TableDSIZE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let UREG_A = if let Some((len, table)) = TableUREG_A::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let A = token_parser.TokenFieldA();
        let UIMM = token_parser.TokenFieldUIMM();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                DSIZE,
                UREG_A,
                A,
                UIMM,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:763:1"]
#[derive(Clone, Debug)]
struct instructionVar446 {
    CRFD: TokenField_CRFD,
    A: TokenField_A,
    SIMM: TokenField_SIMM,
    DSIZE: TableDSIZE,
    REG_A: TableREG_A,
}
impl instructionVar446 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cmp")];
        display.extend_from_slice(&extend);
        self.DSIZE.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("i"),
            DisplayElement::Literal(" \t"),
            self.CRFD.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.SIMM.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 11i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_22().disassembly() != 0i64 {
            return None;
        }
        let DSIZE = if let Some((len, table)) =
            TableDSIZE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let REG_A = if let Some((len, table)) =
            TableREG_A::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CRFD = token_parser.TokenFieldCRFD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        let SIMM = token_parser.TokenFieldSIMM();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                DSIZE,
                REG_A,
                CRFD,
                A,
                SIMM,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:803:1"]
#[derive(Clone, Debug)]
struct instructionVar447 {
    CRFD: TokenField_CRFD,
    A: TokenField_A,
    UIMM: TokenField_UIMM,
    DSIZE: TableDSIZE,
    UREG_A: TableUREG_A,
}
impl instructionVar447 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cmpl")];
        display.extend_from_slice(&extend);
        self.DSIZE.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("i"),
            DisplayElement::Literal(" \t"),
            self.CRFD.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.UIMM.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 10i64 {
            return None;
        }
        if token_parser.TokenFieldBIT_22().disassembly() != 0i64 {
            return None;
        }
        let DSIZE = if let Some((len, table)) =
            TableDSIZE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let UREG_A = if let Some((len, table)) = TableUREG_A::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let CRFD = token_parser.TokenFieldCRFD();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        let UIMM = token_parser.TokenFieldUIMM();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                DSIZE,
                UREG_A,
                CRFD,
                A,
                UIMM,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3613:1"]
#[derive(Clone, Debug)]
struct instructionVar448 {
    A: TokenField_A,
    S: TokenField_S,
    SHL: TokenField_SHL,
    MBL: TokenField_MBL,
    ME: TokenField_ME,
    rotmask: Tablerotmask,
}
impl instructionVar448 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 11usize] = [
            DisplayElement::Literal("rlwimi"),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.SHL.display(),
            DisplayElement::Literal(","),
            self.MBL.display(),
            DisplayElement::Literal(","),
            self.ME.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 20i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let rotmask = if let Some((len, table)) = Tablerotmask::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        let SHL = token_parser.TokenFieldSHL();
        let MBL = token_parser.TokenFieldMBL();
        let ME = token_parser.TokenFieldME();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rotmask,
                S,
                A,
                SHL,
                MBL,
                ME,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3627:1"]
#[derive(Clone, Debug)]
struct instructionVar449 {
    A: TokenField_A,
    S: TokenField_S,
    SHL: TokenField_SHL,
    MBL: TokenField_MBL,
    ME: TokenField_ME,
    rotmask: Tablerotmask,
}
impl instructionVar449 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 11usize] = [
            DisplayElement::Literal("rlwimi."),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.SHL.display(),
            DisplayElement::Literal(","),
            self.MBL.display(),
            DisplayElement::Literal(","),
            self.ME.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 20i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let rotmask = if let Some((len, table)) = Tablerotmask::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        let SHL = token_parser.TokenFieldSHL();
        let MBL = token_parser.TokenFieldMBL();
        let ME = token_parser.TokenFieldME();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rotmask,
                S,
                A,
                SHL,
                MBL,
                ME,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3642:1"]
#[derive(Clone, Debug)]
struct instructionVar450 {
    A: TokenField_A,
    S: TokenField_S,
    SHL: TokenField_SHL,
    MBL: TokenField_MBL,
    ME: TokenField_ME,
    rotmask: Tablerotmask,
}
impl instructionVar450 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 11usize] = [
            DisplayElement::Literal("rlwinm"),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.SHL.display(),
            DisplayElement::Literal(","),
            self.MBL.display(),
            DisplayElement::Literal(","),
            self.ME.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 21i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let rotmask = if let Some((len, table)) = Tablerotmask::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        let SHL = token_parser.TokenFieldSHL();
        let MBL = token_parser.TokenFieldMBL();
        let ME = token_parser.TokenFieldME();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rotmask,
                S,
                A,
                SHL,
                MBL,
                ME,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3656:1"]
#[derive(Clone, Debug)]
struct instructionVar451 {
    A: TokenField_A,
    S: TokenField_S,
    SHL: TokenField_SHL,
    MBL: TokenField_MBL,
    ME: TokenField_ME,
    rotmask: Tablerotmask,
}
impl instructionVar451 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 11usize] = [
            DisplayElement::Literal("rlwinm."),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.SHL.display(),
            DisplayElement::Literal(","),
            self.MBL.display(),
            DisplayElement::Literal(","),
            self.ME.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 21i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let rotmask = if let Some((len, table)) = Tablerotmask::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        let SHL = token_parser.TokenFieldSHL();
        let MBL = token_parser.TokenFieldMBL();
        let ME = token_parser.TokenFieldME();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rotmask,
                S,
                A,
                SHL,
                MBL,
                ME,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3671:1"]
#[derive(Clone, Debug)]
struct instructionVar452 {
    A: TokenField_A,
    S: TokenField_S,
    B: TokenField_B,
    MBL: TokenField_MBL,
    ME: TokenField_ME,
    rotmask: Tablerotmask,
}
impl instructionVar452 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 11usize] = [
            DisplayElement::Literal("rlwnm"),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.B.display(),
            DisplayElement::Literal(","),
            self.MBL.display(),
            DisplayElement::Literal(","),
            self.ME.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 23i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 0i64 {
            return None;
        }
        let rotmask = if let Some((len, table)) = Tablerotmask::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        let MBL = token_parser.TokenFieldMBL();
        let ME = token_parser.TokenFieldME();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rotmask,
                S,
                A,
                B,
                MBL,
                ME,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3685:1"]
#[derive(Clone, Debug)]
struct instructionVar453 {
    A: TokenField_A,
    S: TokenField_S,
    B: TokenField_B,
    MBL: TokenField_MBL,
    ME: TokenField_ME,
    rotmask: Tablerotmask,
}
impl instructionVar453 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 11usize] = [
            DisplayElement::Literal("rlwnm."),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.B.display(),
            DisplayElement::Literal(","),
            self.MBL.display(),
            DisplayElement::Literal(","),
            self.ME.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 23i64 {
            return None;
        }
        if token_parser.TokenFieldRc().disassembly() != 1i64 {
            return None;
        }
        let rotmask = if let Some((len, table)) = Tablerotmask::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        let B = token_parser.TokenFieldB();
        let MBL = token_parser.TokenFieldMBL();
        let ME = token_parser.TokenFieldME();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rotmask,
                S,
                A,
                B,
                MBL,
                ME,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc:182:1"]
#[derive(Clone, Debug)]
struct instructionVar454 {}
impl instructionVar454 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("tlbre")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 946i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc:203:1"]
#[derive(Clone, Debug)]
struct instructionVar455 {
    D: TokenField_D,
    A: TokenField_A,
    B_BITS: TokenField_B_BITS,
}
impl instructionVar455 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("tlbwe"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.B_BITS.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 978i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let B_BITS = token_parser.TokenFieldB_BITS();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B_BITS }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc:210:1"]
#[derive(Clone, Debug)]
struct instructionVar456 {
    S: TokenField_S,
}
impl instructionVar456 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("wrtee"),
            DisplayElement::Literal(" "),
            self.S.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 131i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc:216:1"]
#[derive(Clone, Debug)]
struct instructionVar457 {
    BIT_15: TokenField_BIT_15,
}
impl instructionVar457 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("wrteei"),
            DisplayElement::Literal(" "),
            self.BIT_15.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldOP().disassembly() != 31i64 {
            return None;
        }
        if token_parser.TokenFieldXOP_1_10().disassembly() != 163i64 {
            return None;
        }
        let BIT_15 = token_parser.TokenFieldBIT_15();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BIT_15 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:287:1"]
#[derive(Clone, Debug)]
struct instructionVar458 {
    A: TokenField_A,
    S: TokenField_S,
    UIMM: TokenField_UIMM,
}
impl instructionVar458 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("andi."),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.UIMM.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 28i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        let UIMM = token_parser.TokenFieldUIMM();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, A, UIMM }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:294:1"]
#[derive(Clone, Debug)]
struct instructionVar459 {
    A: TokenField_A,
    S: TokenField_S,
    UIMM: TokenField_UIMM,
}
impl instructionVar459 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("andis."),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.UIMM.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 29i64 {
            return None;
        }
        let A = token_parser.TokenFieldA();
        let S = token_parser.TokenFieldS();
        let UIMM = token_parser.TokenFieldUIMM();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, UIMM }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2057:1"]
#[derive(Clone, Debug)]
struct instructionVar460 {
    D: TokenField_D,
    dPlusRaOrZeroAddress: TabledPlusRaOrZeroAddress,
}
impl instructionVar460 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lbz"),
            DisplayElement::Literal("\t"),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaOrZeroAddress.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 34i64 {
            return None;
        }
        let dPlusRaOrZeroAddress = if let Some((len, table)) =
            TabledPlusRaOrZeroAddress::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                dPlusRaOrZeroAddress,
                D,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2064:1"]
#[derive(Clone, Debug)]
struct instructionVar461 {
    D: TokenField_D,
    dPlusRaAddress: TabledPlusRaAddress,
}
impl instructionVar461 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lbzu"),
            DisplayElement::Literal("\t"),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaAddress.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 35i64 {
            return None;
        }
        let dPlusRaAddress = if let Some((len, table)) =
            TabledPlusRaAddress::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { dPlusRaAddress, D }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2129:1"]
#[derive(Clone, Debug)]
struct instructionVar462 {
    fD: TokenField_fD,
    dPlusRaOrZeroAddress: TabledPlusRaOrZeroAddress,
}
impl instructionVar462 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lfd"),
            DisplayElement::Literal("\t"),
            self.fD.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaOrZeroAddress.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 50i64 {
            return None;
        }
        let dPlusRaOrZeroAddress = if let Some((len, table)) =
            TabledPlusRaOrZeroAddress::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fD = token_parser.TokenFieldfD();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                dPlusRaOrZeroAddress,
                fD,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2135:1"]
#[derive(Clone, Debug)]
struct instructionVar463 {
    fD: TokenField_fD,
    dPlusRaAddress: TabledPlusRaAddress,
}
impl instructionVar463 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lfdu"),
            DisplayElement::Literal("\t"),
            self.fD.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaAddress.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 51i64 {
            return None;
        }
        let dPlusRaAddress = if let Some((len, table)) =
            TabledPlusRaAddress::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fD = token_parser.TokenFieldfD();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { dPlusRaAddress, fD }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2155:1"]
#[derive(Clone, Debug)]
struct instructionVar464 {
    fD: TokenField_fD,
    dPlusRaOrZeroAddress: TabledPlusRaOrZeroAddress,
}
impl instructionVar464 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lfs"),
            DisplayElement::Literal("\t"),
            self.fD.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaOrZeroAddress.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 48i64 {
            return None;
        }
        let dPlusRaOrZeroAddress = if let Some((len, table)) =
            TabledPlusRaOrZeroAddress::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fD = token_parser.TokenFieldfD();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                dPlusRaOrZeroAddress,
                fD,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2160:1"]
#[derive(Clone, Debug)]
struct instructionVar465 {
    fD: TokenField_fD,
    dPlusRaAddress: TabledPlusRaAddress,
}
impl instructionVar465 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lfsu"),
            DisplayElement::Literal("\t"),
            self.fD.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaAddress.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 49i64 {
            return None;
        }
        let dPlusRaAddress = if let Some((len, table)) =
            TabledPlusRaAddress::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fD = token_parser.TokenFieldfD();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { dPlusRaAddress, fD }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2181:1"]
#[derive(Clone, Debug)]
struct instructionVar466 {
    D: TokenField_D,
    dPlusRaOrZeroAddress: TabledPlusRaOrZeroAddress,
}
impl instructionVar466 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lha"),
            DisplayElement::Literal("\t"),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaOrZeroAddress.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 42i64 {
            return None;
        }
        let dPlusRaOrZeroAddress = if let Some((len, table)) =
            TabledPlusRaOrZeroAddress::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                dPlusRaOrZeroAddress,
                D,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2187:1"]
#[derive(Clone, Debug)]
struct instructionVar467 {
    D: TokenField_D,
    dPlusRaAddress: TabledPlusRaAddress,
}
impl instructionVar467 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lhau"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaAddress.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 43i64 {
            return None;
        }
        let dPlusRaAddress = if let Some((len, table)) =
            TabledPlusRaAddress::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { dPlusRaAddress, D }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2216:1"]
#[derive(Clone, Debug)]
struct instructionVar468 {
    D: TokenField_D,
    dPlusRaOrZeroAddress: TabledPlusRaOrZeroAddress,
}
impl instructionVar468 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lhz"),
            DisplayElement::Literal("\t"),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaOrZeroAddress.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 40i64 {
            return None;
        }
        let dPlusRaOrZeroAddress = if let Some((len, table)) =
            TabledPlusRaOrZeroAddress::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                dPlusRaOrZeroAddress,
                D,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2223:1"]
#[derive(Clone, Debug)]
struct instructionVar469 {
    D: TokenField_D,
    dPlusRaAddress: TabledPlusRaAddress,
}
impl instructionVar469 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lhzu"),
            DisplayElement::Literal("\t"),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaAddress.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 41i64 {
            return None;
        }
        let dPlusRaAddress = if let Some((len, table)) =
            TabledPlusRaAddress::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { dPlusRaAddress, D }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:96:1"]
#[derive(Clone, Debug)]
struct instructionVar470 {
    D: TokenField_D,
    BITS_21_25: TokenField_BITS_21_25,
    dPlusRaOrZeroAddress: TabledPlusRaOrZeroAddress,
    LDMR31: TableLDMR31,
}
impl instructionVar470 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lmw"),
            DisplayElement::Literal("\t"),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaOrZeroAddress.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 46i64 {
            return None;
        }
        let tmp = token_parser.TokenFieldBITS_21_25().disassembly();
        context_instance.register_mut().write_lsmul_disassembly(tmp);
        let dPlusRaOrZeroAddress = if let Some((len, table)) =
            TabledPlusRaOrZeroAddress::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let LDMR31 = if let Some((len, table)) = TableLDMR31::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        let BITS_21_25 = token_parser.TokenFieldBITS_21_25();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                dPlusRaOrZeroAddress,
                LDMR31,
                D,
                BITS_21_25,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2302:1"]
#[derive(Clone, Debug)]
struct instructionVar471 {
    D: TokenField_D,
    dPlusRaOrZeroAddress: TabledPlusRaOrZeroAddress,
}
impl instructionVar471 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lwz"),
            DisplayElement::Literal("\t"),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaOrZeroAddress.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 32i64 {
            return None;
        }
        let dPlusRaOrZeroAddress = if let Some((len, table)) =
            TabledPlusRaOrZeroAddress::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                dPlusRaOrZeroAddress,
                D,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:2312:1"]
#[derive(Clone, Debug)]
struct instructionVar472 {
    D: TokenField_D,
    dPlusRaAddress: TabledPlusRaAddress,
}
impl instructionVar472 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("lwzu"),
            DisplayElement::Literal("\t"),
            self.D.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaAddress.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 33i64 {
            return None;
        }
        let dPlusRaAddress = if let Some((len, table)) =
            TabledPlusRaAddress::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { dPlusRaAddress, D }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3362:1"]
#[derive(Clone, Debug)]
struct instructionVar473 {
    D: TokenField_D,
    A: TokenField_A,
    SIMM: TokenField_SIMM,
}
impl instructionVar473 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("mulli"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.SIMM.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 7i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let SIMM = token_parser.TokenFieldSIMM();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, SIMM }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3496:1"]
#[derive(Clone, Debug)]
struct instructionVar474 {
    A: TokenField_A,
    S: TokenField_S,
    UIMM: TokenField_UIMM,
}
impl instructionVar474 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("ori"),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.UIMM.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 24i64 {
            return None;
        }
        let A = token_parser.TokenFieldA();
        let S = token_parser.TokenFieldS();
        let UIMM = token_parser.TokenFieldUIMM();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, UIMM }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3502:1"]
#[derive(Clone, Debug)]
struct instructionVar475 {
    A: TokenField_A,
    S: TokenField_S,
    UIMM: TokenField_UIMM,
}
impl instructionVar475 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("oris"),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.UIMM.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 25i64 {
            return None;
        }
        let A = token_parser.TokenFieldA();
        let S = token_parser.TokenFieldS();
        let UIMM = token_parser.TokenFieldUIMM();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, UIMM }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3918:1"]
#[derive(Clone, Debug)]
struct instructionVar476 {
    S: TokenField_S,
    dPlusRaOrZeroAddress: TabledPlusRaOrZeroAddress,
}
impl instructionVar476 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("stb"),
            DisplayElement::Literal("\t"),
            self.S.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaOrZeroAddress.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 38i64 {
            return None;
        }
        let dPlusRaOrZeroAddress = if let Some((len, table)) =
            TabledPlusRaOrZeroAddress::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                dPlusRaOrZeroAddress,
                S,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3925:1"]
#[derive(Clone, Debug)]
struct instructionVar477 {
    S: TokenField_S,
    dPlusRaAddress: TabledPlusRaAddress,
}
impl instructionVar477 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("stbu"),
            DisplayElement::Literal("\t"),
            self.S.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaAddress.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 39i64 {
            return None;
        }
        let dPlusRaAddress = if let Some((len, table)) =
            TabledPlusRaAddress::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { dPlusRaAddress, S }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3998:1"]
#[derive(Clone, Debug)]
struct instructionVar478 {
    fS: TokenField_fS,
    dPlusRaOrZeroAddress: TabledPlusRaOrZeroAddress,
}
impl instructionVar478 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("stfd"),
            DisplayElement::Literal(" "),
            self.fS.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaOrZeroAddress.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 54i64 {
            return None;
        }
        let dPlusRaOrZeroAddress = if let Some((len, table)) =
            TabledPlusRaOrZeroAddress::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fS = token_parser.TokenFieldfS();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                dPlusRaOrZeroAddress,
                fS,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4005:1"]
#[derive(Clone, Debug)]
struct instructionVar479 {
    fS: TokenField_fS,
    dPlusRaAddress: TabledPlusRaAddress,
}
impl instructionVar479 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("stfdu"),
            DisplayElement::Literal(" "),
            self.fS.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaAddress.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 55i64 {
            return None;
        }
        let dPlusRaAddress = if let Some((len, table)) =
            TabledPlusRaAddress::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fS = token_parser.TokenFieldfS();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { dPlusRaAddress, fS }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4036:1"]
#[derive(Clone, Debug)]
struct instructionVar480 {
    fS: TokenField_fS,
    dPlusRaOrZeroAddress: TabledPlusRaOrZeroAddress,
}
impl instructionVar480 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("stfs"),
            DisplayElement::Literal(" "),
            self.fS.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaOrZeroAddress.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 52i64 {
            return None;
        }
        let dPlusRaOrZeroAddress = if let Some((len, table)) =
            TabledPlusRaOrZeroAddress::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fS = token_parser.TokenFieldfS();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                dPlusRaOrZeroAddress,
                fS,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4044:1"]
#[derive(Clone, Debug)]
struct instructionVar481 {
    fS: TokenField_fS,
    dPlusRaAddress: TabledPlusRaAddress,
}
impl instructionVar481 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("stfsu"),
            DisplayElement::Literal(" "),
            self.fS.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaAddress.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 53i64 {
            return None;
        }
        let dPlusRaAddress = if let Some((len, table)) =
            TabledPlusRaAddress::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let fS = token_parser.TokenFieldfS();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { dPlusRaAddress, fS }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4069:1"]
#[derive(Clone, Debug)]
struct instructionVar482 {
    S: TokenField_S,
    dPlusRaOrZeroAddress: TabledPlusRaOrZeroAddress,
}
impl instructionVar482 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("sth"),
            DisplayElement::Literal(" "),
            self.S.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaOrZeroAddress.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 44i64 {
            return None;
        }
        let dPlusRaOrZeroAddress = if let Some((len, table)) =
            TabledPlusRaOrZeroAddress::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                dPlusRaOrZeroAddress,
                S,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4084:1"]
#[derive(Clone, Debug)]
struct instructionVar483 {
    S: TokenField_S,
    dPlusRaAddress: TabledPlusRaAddress,
}
impl instructionVar483 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("sthu"),
            DisplayElement::Literal(" "),
            self.S.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaAddress.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 45i64 {
            return None;
        }
        let dPlusRaAddress = if let Some((len, table)) =
            TabledPlusRaAddress::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { dPlusRaAddress, S }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:96:1"]
#[derive(Clone, Debug)]
struct instructionVar484 {
    S: TokenField_S,
    BITS_21_25: TokenField_BITS_21_25,
    dPlusRaOrZeroAddress: TabledPlusRaOrZeroAddress,
    STMR31: TableSTMR31,
}
impl instructionVar484 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("stmw"),
            DisplayElement::Literal("\t"),
            self.S.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaOrZeroAddress.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 47i64 {
            return None;
        }
        let tmp = token_parser.TokenFieldBITS_21_25().disassembly();
        context_instance.register_mut().write_lsmul_disassembly(tmp);
        let dPlusRaOrZeroAddress = if let Some((len, table)) =
            TabledPlusRaOrZeroAddress::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let STMR31 = if let Some((len, table)) = TableSTMR31::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let BITS_21_25 = token_parser.TokenFieldBITS_21_25();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                dPlusRaOrZeroAddress,
                STMR31,
                S,
                BITS_21_25,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4126:1"]
#[derive(Clone, Debug)]
struct instructionVar485 {
    S: TokenField_S,
    dPlusRaOrZeroAddress: TabledPlusRaOrZeroAddress,
}
impl instructionVar485 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("stw"),
            DisplayElement::Literal(" "),
            self.S.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaOrZeroAddress.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 36i64 {
            return None;
        }
        let dPlusRaOrZeroAddress = if let Some((len, table)) =
            TabledPlusRaOrZeroAddress::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                dPlusRaOrZeroAddress,
                S,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4162:1"]
#[derive(Clone, Debug)]
struct instructionVar486 {
    S: TokenField_S,
    dPlusRaAddress: TabledPlusRaAddress,
}
impl instructionVar486 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("stwu"),
            DisplayElement::Literal(" "),
            self.S.display(),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaAddress.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 37i64 {
            return None;
        }
        let dPlusRaAddress = if let Some((len, table)) =
            TabledPlusRaAddress::parse(
                tokens_current,
                &mut context_instance,
                inst_start,
            ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { dPlusRaAddress, S }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4293:1"]
#[derive(Clone, Debug)]
struct instructionVar487 {
    D: TokenField_D,
    A: TokenField_A,
    SIMM: TokenField_SIMM,
}
impl instructionVar487 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("subfic"),
            DisplayElement::Literal(" "),
            self.D.display(),
            DisplayElement::Literal(","),
            self.A.display(),
            DisplayElement::Literal(","),
            self.SIMM.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 8i64 {
            return None;
        }
        let D = token_parser.TokenFieldD();
        let A = token_parser.TokenFieldA();
        let SIMM = token_parser.TokenFieldSIMM();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, SIMM }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4453:1"]
#[derive(Clone, Debug)]
struct instructionVar488 {
    A: TokenField_A,
    SIMM: TokenField_SIMM,
    TOm: TableTOm,
}
impl instructionVar488 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("tw")];
        display.extend_from_slice(&extend);
        self.TOm.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("i"),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.SIMM.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 3i64 {
            return None;
        }
        let TOm = if let Some((len, table)) =
            TableTOm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let TO = token_parser.TokenFieldTO();
        let A = token_parser.TokenFieldA();
        let SIMM = token_parser.TokenFieldSIMM();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOm, A, SIMM }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4506:1"]
#[derive(Clone, Debug)]
struct instructionVar489 {
    A: TokenField_A,
    S: TokenField_S,
    UIMM: TokenField_UIMM,
}
impl instructionVar489 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("xori"),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.UIMM.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 26i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        let UIMM = token_parser.TokenFieldUIMM();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, A, UIMM }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:4512:1"]
#[derive(Clone, Debug)]
struct instructionVar490 {
    A: TokenField_A,
    S: TokenField_S,
    UIMM: TokenField_UIMM,
}
impl instructionVar490 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 7usize] = [
            DisplayElement::Literal("xoris"),
            DisplayElement::Literal(" "),
            self.A.display(),
            DisplayElement::Literal(","),
            self.S.display(),
            DisplayElement::Literal(","),
            self.UIMM.display(),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if context_instance.register().read_vle_disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldOP().disassembly() != 27i64 {
            return None;
        }
        let S = token_parser.TokenFieldS();
        let A = token_parser.TokenFieldA();
        let UIMM = token_parser.TokenFieldUIMM();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, A, UIMM }))
    }
}
#[derive(Clone, Debug)]
enum Tableinstruction {
    Var0(instructionVar0),
    Var1(instructionVar1),
    Var2(instructionVar2),
    Var3(instructionVar3),
    Var4(instructionVar4),
    Var5(instructionVar5),
    Var6(instructionVar6),
    Var7(instructionVar7),
    Var8(instructionVar8),
    Var9(instructionVar9),
    Var10(instructionVar10),
    Var11(instructionVar11),
    Var12(instructionVar12),
    Var13(instructionVar13),
    Var14(instructionVar14),
    Var15(instructionVar15),
    Var16(instructionVar16),
    Var17(instructionVar17),
    Var18(instructionVar18),
    Var19(instructionVar19),
    Var20(instructionVar20),
    Var21(instructionVar21),
    Var22(instructionVar22),
    Var23(instructionVar23),
    Var24(instructionVar24),
    Var25(instructionVar25),
    Var26(instructionVar26),
    Var27(instructionVar27),
    Var28(instructionVar28),
    Var29(instructionVar29),
    Var30(instructionVar30),
    Var31(instructionVar31),
    Var32(instructionVar32),
    Var33(instructionVar33),
    Var34(instructionVar34),
    Var35(instructionVar35),
    Var36(instructionVar36),
    Var37(instructionVar37),
    Var38(instructionVar38),
    Var39(instructionVar39),
    Var40(instructionVar40),
    Var41(instructionVar41),
    Var42(instructionVar42),
    Var43(instructionVar43),
    Var44(instructionVar44),
    Var45(instructionVar45),
    Var46(instructionVar46),
    Var47(instructionVar47),
    Var48(instructionVar48),
    Var49(instructionVar49),
    Var50(instructionVar50),
    Var51(instructionVar51),
    Var52(instructionVar52),
    Var53(instructionVar53),
    Var54(instructionVar54),
    Var55(instructionVar55),
    Var56(instructionVar56),
    Var57(instructionVar57),
    Var58(instructionVar58),
    Var59(instructionVar59),
    Var60(instructionVar60),
    Var61(instructionVar61),
    Var62(instructionVar62),
    Var63(instructionVar63),
    Var64(instructionVar64),
    Var65(instructionVar65),
    Var66(instructionVar66),
    Var67(instructionVar67),
    Var68(instructionVar68),
    Var69(instructionVar69),
    Var70(instructionVar70),
    Var71(instructionVar71),
    Var72(instructionVar72),
    Var73(instructionVar73),
    Var74(instructionVar74),
    Var75(instructionVar75),
    Var76(instructionVar76),
    Var77(instructionVar77),
    Var78(instructionVar78),
    Var79(instructionVar79),
    Var80(instructionVar80),
    Var81(instructionVar81),
    Var82(instructionVar82),
    Var83(instructionVar83),
    Var84(instructionVar84),
    Var85(instructionVar85),
    Var86(instructionVar86),
    Var87(instructionVar87),
    Var88(instructionVar88),
    Var89(instructionVar89),
    Var90(instructionVar90),
    Var91(instructionVar91),
    Var92(instructionVar92),
    Var93(instructionVar93),
    Var94(instructionVar94),
    Var95(instructionVar95),
    Var96(instructionVar96),
    Var97(instructionVar97),
    Var98(instructionVar98),
    Var99(instructionVar99),
    Var100(instructionVar100),
    Var101(instructionVar101),
    Var102(instructionVar102),
    Var103(instructionVar103),
    Var104(instructionVar104),
    Var105(instructionVar105),
    Var106(instructionVar106),
    Var107(instructionVar107),
    Var108(instructionVar108),
    Var109(instructionVar109),
    Var110(instructionVar110),
    Var111(instructionVar111),
    Var112(instructionVar112),
    Var113(instructionVar113),
    Var114(instructionVar114),
    Var115(instructionVar115),
    Var116(instructionVar116),
    Var117(instructionVar117),
    Var118(instructionVar118),
    Var119(instructionVar119),
    Var120(instructionVar120),
    Var121(instructionVar121),
    Var122(instructionVar122),
    Var123(instructionVar123),
    Var124(instructionVar124),
    Var125(instructionVar125),
    Var126(instructionVar126),
    Var127(instructionVar127),
    Var128(instructionVar128),
    Var129(instructionVar129),
    Var130(instructionVar130),
    Var131(instructionVar131),
    Var132(instructionVar132),
    Var133(instructionVar133),
    Var134(instructionVar134),
    Var135(instructionVar135),
    Var136(instructionVar136),
    Var137(instructionVar137),
    Var138(instructionVar138),
    Var139(instructionVar139),
    Var140(instructionVar140),
    Var141(instructionVar141),
    Var142(instructionVar142),
    Var143(instructionVar143),
    Var144(instructionVar144),
    Var145(instructionVar145),
    Var146(instructionVar146),
    Var147(instructionVar147),
    Var148(instructionVar148),
    Var149(instructionVar149),
    Var150(instructionVar150),
    Var151(instructionVar151),
    Var152(instructionVar152),
    Var153(instructionVar153),
    Var154(instructionVar154),
    Var155(instructionVar155),
    Var156(instructionVar156),
    Var157(instructionVar157),
    Var158(instructionVar158),
    Var159(instructionVar159),
    Var160(instructionVar160),
    Var161(instructionVar161),
    Var162(instructionVar162),
    Var163(instructionVar163),
    Var164(instructionVar164),
    Var165(instructionVar165),
    Var166(instructionVar166),
    Var167(instructionVar167),
    Var168(instructionVar168),
    Var169(instructionVar169),
    Var170(instructionVar170),
    Var171(instructionVar171),
    Var172(instructionVar172),
    Var173(instructionVar173),
    Var174(instructionVar174),
    Var175(instructionVar175),
    Var176(instructionVar176),
    Var177(instructionVar177),
    Var178(instructionVar178),
    Var179(instructionVar179),
    Var180(instructionVar180),
    Var181(instructionVar181),
    Var182(instructionVar182),
    Var183(instructionVar183),
    Var184(instructionVar184),
    Var185(instructionVar185),
    Var186(instructionVar186),
    Var187(instructionVar187),
    Var188(instructionVar188),
    Var189(instructionVar189),
    Var190(instructionVar190),
    Var191(instructionVar191),
    Var192(instructionVar192),
    Var193(instructionVar193),
    Var194(instructionVar194),
    Var195(instructionVar195),
    Var196(instructionVar196),
    Var197(instructionVar197),
    Var198(instructionVar198),
    Var199(instructionVar199),
    Var200(instructionVar200),
    Var201(instructionVar201),
    Var202(instructionVar202),
    Var203(instructionVar203),
    Var204(instructionVar204),
    Var205(instructionVar205),
    Var206(instructionVar206),
    Var207(instructionVar207),
    Var208(instructionVar208),
    Var209(instructionVar209),
    Var210(instructionVar210),
    Var211(instructionVar211),
    Var212(instructionVar212),
    Var213(instructionVar213),
    Var214(instructionVar214),
    Var215(instructionVar215),
    Var216(instructionVar216),
    Var217(instructionVar217),
    Var218(instructionVar218),
    Var219(instructionVar219),
    Var220(instructionVar220),
    Var221(instructionVar221),
    Var222(instructionVar222),
    Var223(instructionVar223),
    Var224(instructionVar224),
    Var225(instructionVar225),
    Var226(instructionVar226),
    Var227(instructionVar227),
    Var228(instructionVar228),
    Var229(instructionVar229),
    Var230(instructionVar230),
    Var231(instructionVar231),
    Var232(instructionVar232),
    Var233(instructionVar233),
    Var234(instructionVar234),
    Var235(instructionVar235),
    Var236(instructionVar236),
    Var237(instructionVar237),
    Var238(instructionVar238),
    Var239(instructionVar239),
    Var240(instructionVar240),
    Var241(instructionVar241),
    Var242(instructionVar242),
    Var243(instructionVar243),
    Var244(instructionVar244),
    Var245(instructionVar245),
    Var246(instructionVar246),
    Var247(instructionVar247),
    Var248(instructionVar248),
    Var249(instructionVar249),
    Var250(instructionVar250),
    Var251(instructionVar251),
    Var252(instructionVar252),
    Var253(instructionVar253),
    Var254(instructionVar254),
    Var255(instructionVar255),
    Var256(instructionVar256),
    Var257(instructionVar257),
    Var258(instructionVar258),
    Var259(instructionVar259),
    Var260(instructionVar260),
    Var261(instructionVar261),
    Var262(instructionVar262),
    Var263(instructionVar263),
    Var264(instructionVar264),
    Var265(instructionVar265),
    Var266(instructionVar266),
    Var267(instructionVar267),
    Var268(instructionVar268),
    Var269(instructionVar269),
    Var270(instructionVar270),
    Var271(instructionVar271),
    Var272(instructionVar272),
    Var273(instructionVar273),
    Var274(instructionVar274),
    Var275(instructionVar275),
    Var276(instructionVar276),
    Var277(instructionVar277),
    Var278(instructionVar278),
    Var279(instructionVar279),
    Var280(instructionVar280),
    Var281(instructionVar281),
    Var282(instructionVar282),
    Var283(instructionVar283),
    Var284(instructionVar284),
    Var285(instructionVar285),
    Var286(instructionVar286),
    Var287(instructionVar287),
    Var288(instructionVar288),
    Var289(instructionVar289),
    Var290(instructionVar290),
    Var291(instructionVar291),
    Var292(instructionVar292),
    Var293(instructionVar293),
    Var294(instructionVar294),
    Var295(instructionVar295),
    Var296(instructionVar296),
    Var297(instructionVar297),
    Var298(instructionVar298),
    Var299(instructionVar299),
    Var300(instructionVar300),
    Var301(instructionVar301),
    Var302(instructionVar302),
    Var303(instructionVar303),
    Var304(instructionVar304),
    Var305(instructionVar305),
    Var306(instructionVar306),
    Var307(instructionVar307),
    Var308(instructionVar308),
    Var309(instructionVar309),
    Var310(instructionVar310),
    Var311(instructionVar311),
    Var312(instructionVar312),
    Var313(instructionVar313),
    Var314(instructionVar314),
    Var315(instructionVar315),
    Var316(instructionVar316),
    Var317(instructionVar317),
    Var318(instructionVar318),
    Var319(instructionVar319),
    Var320(instructionVar320),
    Var321(instructionVar321),
    Var322(instructionVar322),
    Var323(instructionVar323),
    Var324(instructionVar324),
    Var325(instructionVar325),
    Var326(instructionVar326),
    Var327(instructionVar327),
    Var328(instructionVar328),
    Var329(instructionVar329),
    Var330(instructionVar330),
    Var331(instructionVar331),
    Var332(instructionVar332),
    Var333(instructionVar333),
    Var334(instructionVar334),
    Var335(instructionVar335),
    Var336(instructionVar336),
    Var337(instructionVar337),
    Var338(instructionVar338),
    Var339(instructionVar339),
    Var340(instructionVar340),
    Var341(instructionVar341),
    Var342(instructionVar342),
    Var343(instructionVar343),
    Var344(instructionVar344),
    Var345(instructionVar345),
    Var346(instructionVar346),
    Var347(instructionVar347),
    Var348(instructionVar348),
    Var349(instructionVar349),
    Var350(instructionVar350),
    Var351(instructionVar351),
    Var352(instructionVar352),
    Var353(instructionVar353),
    Var354(instructionVar354),
    Var355(instructionVar355),
    Var356(instructionVar356),
    Var357(instructionVar357),
    Var358(instructionVar358),
    Var359(instructionVar359),
    Var360(instructionVar360),
    Var361(instructionVar361),
    Var362(instructionVar362),
    Var363(instructionVar363),
    Var364(instructionVar364),
    Var365(instructionVar365),
    Var366(instructionVar366),
    Var367(instructionVar367),
    Var368(instructionVar368),
    Var369(instructionVar369),
    Var370(instructionVar370),
    Var371(instructionVar371),
    Var372(instructionVar372),
    Var373(instructionVar373),
    Var374(instructionVar374),
    Var375(instructionVar375),
    Var376(instructionVar376),
    Var377(instructionVar377),
    Var378(instructionVar378),
    Var379(instructionVar379),
    Var380(instructionVar380),
    Var381(instructionVar381),
    Var382(instructionVar382),
    Var383(instructionVar383),
    Var384(instructionVar384),
    Var385(instructionVar385),
    Var386(instructionVar386),
    Var387(instructionVar387),
    Var388(instructionVar388),
    Var389(instructionVar389),
    Var390(instructionVar390),
    Var391(instructionVar391),
    Var392(instructionVar392),
    Var393(instructionVar393),
    Var394(instructionVar394),
    Var395(instructionVar395),
    Var396(instructionVar396),
    Var397(instructionVar397),
    Var398(instructionVar398),
    Var399(instructionVar399),
    Var400(instructionVar400),
    Var401(instructionVar401),
    Var402(instructionVar402),
    Var403(instructionVar403),
    Var404(instructionVar404),
    Var405(instructionVar405),
    Var406(instructionVar406),
    Var407(instructionVar407),
    Var408(instructionVar408),
    Var409(instructionVar409),
    Var410(instructionVar410),
    Var411(instructionVar411),
    Var412(instructionVar412),
    Var413(instructionVar413),
    Var414(instructionVar414),
    Var415(instructionVar415),
    Var416(instructionVar416),
    Var417(instructionVar417),
    Var418(instructionVar418),
    Var419(instructionVar419),
    Var420(instructionVar420),
    Var421(instructionVar421),
    Var422(instructionVar422),
    Var423(instructionVar423),
    Var424(instructionVar424),
    Var425(instructionVar425),
    Var426(instructionVar426),
    Var427(instructionVar427),
    Var428(instructionVar428),
    Var429(instructionVar429),
    Var430(instructionVar430),
    Var431(instructionVar431),
    Var432(instructionVar432),
    Var433(instructionVar433),
    Var434(instructionVar434),
    Var435(instructionVar435),
    Var436(instructionVar436),
    Var437(instructionVar437),
    Var438(instructionVar438),
    Var439(instructionVar439),
    Var440(instructionVar440),
    Var441(instructionVar441),
    Var442(instructionVar442),
    Var443(instructionVar443),
    Var444(instructionVar444),
    Var445(instructionVar445),
    Var446(instructionVar446),
    Var447(instructionVar447),
    Var448(instructionVar448),
    Var449(instructionVar449),
    Var450(instructionVar450),
    Var451(instructionVar451),
    Var452(instructionVar452),
    Var453(instructionVar453),
    Var454(instructionVar454),
    Var455(instructionVar455),
    Var456(instructionVar456),
    Var457(instructionVar457),
    Var458(instructionVar458),
    Var459(instructionVar459),
    Var460(instructionVar460),
    Var461(instructionVar461),
    Var462(instructionVar462),
    Var463(instructionVar463),
    Var464(instructionVar464),
    Var465(instructionVar465),
    Var466(instructionVar466),
    Var467(instructionVar467),
    Var468(instructionVar468),
    Var469(instructionVar469),
    Var470(instructionVar470),
    Var471(instructionVar471),
    Var472(instructionVar472),
    Var473(instructionVar473),
    Var474(instructionVar474),
    Var475(instructionVar475),
    Var476(instructionVar476),
    Var477(instructionVar477),
    Var478(instructionVar478),
    Var479(instructionVar479),
    Var480(instructionVar480),
    Var481(instructionVar481),
    Var482(instructionVar482),
    Var483(instructionVar483),
    Var484(instructionVar484),
    Var485(instructionVar485),
    Var486(instructionVar486),
    Var487(instructionVar487),
    Var488(instructionVar488),
    Var489(instructionVar489),
    Var490(instructionVar490),
}
impl Tableinstruction {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var14(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var15(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var16(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var17(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var18(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var19(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var20(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var21(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var22(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var23(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var24(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var25(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var26(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var27(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var28(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var29(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var30(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var31(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var32(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var33(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var34(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var35(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var36(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var37(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var38(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var39(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var40(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var41(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var42(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var43(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var44(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var45(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var46(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var47(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var48(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var49(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var50(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var51(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var52(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var53(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var54(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var55(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var56(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var57(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var58(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var59(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var60(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var61(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var62(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var63(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var64(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var65(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var66(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var67(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var68(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var69(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var70(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var71(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var72(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var73(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var74(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var75(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var76(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var77(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var78(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var79(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var80(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var81(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var82(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var83(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var84(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var85(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var86(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var87(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var88(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var89(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var90(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var91(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var92(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var93(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var94(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var95(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var96(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var97(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var98(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var99(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var100(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var101(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var102(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var103(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var104(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var105(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var106(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var107(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var108(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var109(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var110(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var111(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var112(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var113(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var114(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var115(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var116(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var117(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var118(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var119(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var120(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var121(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var122(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var123(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var124(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var125(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var126(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var127(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var128(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var129(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var130(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var131(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var132(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var133(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var134(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var135(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var136(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var137(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var138(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var139(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var140(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var141(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var142(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var143(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var144(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var145(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var146(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var147(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var148(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var149(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var150(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var151(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var152(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var153(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var154(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var155(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var156(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var157(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var158(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var159(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var160(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var161(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var162(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var163(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var164(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var165(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var166(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var167(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var168(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var169(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var170(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var171(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var172(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var173(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var174(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var175(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var176(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var177(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var178(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var179(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var180(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var181(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var182(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var183(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var184(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var185(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var186(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var187(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var188(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var189(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var190(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var191(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var192(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var193(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var194(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var195(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var196(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var197(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var198(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var199(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var200(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var201(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var202(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var203(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var204(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var205(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var206(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var207(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var208(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var209(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var210(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var211(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var212(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var213(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var214(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var215(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var216(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var217(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var218(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var219(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var220(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var221(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var222(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var223(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var224(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var225(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var226(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var227(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var228(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var229(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var230(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var231(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var232(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var233(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var234(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var235(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var236(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var237(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var238(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var239(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var240(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var241(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var242(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var243(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var244(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var245(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var246(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var247(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var248(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var249(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var250(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var251(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var252(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var253(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var254(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var255(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var256(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var257(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var258(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var259(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var260(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var261(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var262(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var263(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var264(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var265(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var266(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var267(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var268(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var269(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var270(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var271(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var272(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var273(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var274(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var275(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var276(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var277(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var278(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var279(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var280(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var281(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var282(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var283(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var284(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var285(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var286(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var287(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var288(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var289(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var290(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var291(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var292(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var293(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var294(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var295(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var296(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var297(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var298(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var299(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var300(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var301(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var302(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var303(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var304(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var305(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var306(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var307(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var308(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var309(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var310(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var311(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var312(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var313(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var314(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var315(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var316(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var317(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var318(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var319(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var320(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var321(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var322(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var323(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var324(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var325(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var326(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var327(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var328(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var329(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var330(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var331(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var332(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var333(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var334(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var335(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var336(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var337(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var338(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var339(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var340(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var341(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var342(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var343(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var344(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var345(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var346(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var347(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var348(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var349(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var350(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var351(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var352(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var353(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var354(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var355(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var356(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var357(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var358(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var359(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var360(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var361(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var362(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var363(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var364(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var365(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var366(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var367(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var368(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var369(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var370(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var371(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var372(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var373(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var374(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var375(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var376(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var377(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var378(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var379(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var380(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var381(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var382(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var383(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var384(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var385(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var386(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var387(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var388(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var389(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var390(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var391(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var392(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var393(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var394(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var395(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var396(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var397(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var398(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var399(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var400(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var401(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var402(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var403(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var404(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var405(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var406(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var407(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var408(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var409(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var410(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var411(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var412(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var413(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var414(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var415(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var416(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var417(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var418(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var419(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var420(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var421(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var422(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var423(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var424(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var425(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var426(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var427(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var428(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var429(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var430(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var431(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var432(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var433(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var434(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var435(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var436(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var437(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var438(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var439(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var440(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var441(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var442(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var443(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var444(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var445(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var446(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var447(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var448(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var449(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var450(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var451(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var452(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var453(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var454(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var455(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var456(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var457(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var458(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var459(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var460(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var461(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var462(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var463(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var464(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var465(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var466(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var467(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var468(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var469(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var470(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var471(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var472(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var473(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var474(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var475(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var476(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var477(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var478(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var479(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var480(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var481(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var482(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var483(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var484(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var485(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var486(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var487(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var488(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var489(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var490(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = instructionVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar8::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar9::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar10::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar11::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var11(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar12::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var12(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar13::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var13(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar14::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var14(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar15::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var15(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar16::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var16(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar17::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var17(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar18::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var18(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar19::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var19(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar20::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var20(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar21::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var21(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar22::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var22(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar23::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var23(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar24::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var24(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar25::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var25(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar26::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var26(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar27::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var27(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar28::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var28(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar29::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var29(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar30::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var30(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar31::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var31(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar32::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var32(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar33::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var33(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar34::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var34(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar35::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var35(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar36::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var36(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar37::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var37(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar38::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var38(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar39::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var39(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar40::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var40(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar41::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var41(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar42::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var42(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar43::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var43(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar44::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var44(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar45::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var45(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar46::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var46(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar47::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var47(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar48::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var48(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar49::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var49(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar50::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var50(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar51::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var51(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar52::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var52(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar53::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var53(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar54::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var54(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar55::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var55(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar56::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var56(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar57::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var57(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar58::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var58(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar59::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var59(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar60::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var60(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar61::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var61(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar62::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var62(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar63::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var63(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar64::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var64(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar65::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var65(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar66::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var66(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar67::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var67(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar68::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var68(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar69::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var69(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar70::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var70(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar71::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var71(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar72::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var72(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar73::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var73(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar74::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var74(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar75::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var75(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar76::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var76(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar77::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var77(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar78::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var78(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar79::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var79(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar80::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var80(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar81::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var81(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar82::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var82(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar83::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var83(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar84::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var84(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar85::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var85(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar86::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var86(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar87::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var87(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar88::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var88(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar89::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var89(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar90::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var90(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar91::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var91(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar92::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var92(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar93::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var93(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar94::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var94(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar95::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var95(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar96::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var96(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar97::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var97(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar98::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var98(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar99::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var99(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar100::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var100(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar101::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var101(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar102::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var102(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar103::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var103(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar104::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var104(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar105::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var105(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar106::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var106(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar107::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var107(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar108::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var108(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar109::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var109(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar110::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var110(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar111::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var111(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar112::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var112(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar113::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var113(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar114::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var114(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar115::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var115(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar116::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var116(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar117::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var117(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar118::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var118(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar119::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var119(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar120::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var120(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar121::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var121(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar122::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var122(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar123::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var123(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar124::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var124(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar125::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var125(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar126::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var126(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar127::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var127(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar128::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var128(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar129::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var129(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar130::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var130(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar131::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var131(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar132::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var132(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar133::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var133(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar134::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var134(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar135::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var135(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar136::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var136(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar137::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var137(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar138::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var138(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar139::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var139(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar140::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var140(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar141::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var141(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar142::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var142(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar143::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var143(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar144::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var144(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar145::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var145(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar146::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var146(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar147::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var147(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar148::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var148(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar149::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var149(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar150::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var150(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar151::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var151(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar152::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var152(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar153::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var153(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar154::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var154(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar155::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var155(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar156::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var156(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar157::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var157(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar158::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var158(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar159::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var159(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar160::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var160(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar161::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var161(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar162::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var162(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar163::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var163(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar164::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var164(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar165::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var165(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar166::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var166(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar167::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var167(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar168::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var168(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar169::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var169(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar170::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var170(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar171::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var171(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar172::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var172(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar173::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var173(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar174::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var174(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar175::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var175(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar176::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var176(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar177::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var177(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar178::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var178(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar179::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var179(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar180::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var180(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar181::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var181(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar182::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var182(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar183::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var183(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar184::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var184(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar185::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var185(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar186::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var186(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar187::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var187(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar188::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var188(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar189::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var189(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar190::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var190(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar191::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var191(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar192::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var192(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar193::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var193(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar194::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var194(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar195::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var195(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar196::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var196(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar197::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var197(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar198::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var198(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar199::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var199(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar200::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var200(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar201::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var201(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar202::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var202(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar203::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var203(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar204::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var204(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar205::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var205(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar206::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var206(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar207::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var207(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar208::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var208(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar209::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var209(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar210::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var210(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar211::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var211(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar212::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var212(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar213::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var213(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar214::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var214(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar215::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var215(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar216::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var216(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar217::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var217(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar218::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var218(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar219::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var219(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar220::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var220(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar221::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var221(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar222::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var222(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar223::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var223(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar224::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var224(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar225::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var225(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar226::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var226(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar227::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var227(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar228::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var228(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar229::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var229(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar230::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var230(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar231::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var231(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar232::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var232(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar233::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var233(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar234::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var234(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar235::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var235(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar236::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var236(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar237::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var237(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar238::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var238(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar239::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var239(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar240::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var240(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar241::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var241(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar242::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var242(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar243::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var243(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar244::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var244(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar245::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var245(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar246::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var246(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar247::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var247(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar248::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var248(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar249::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var249(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar250::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var250(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar251::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var251(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar252::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var252(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar253::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var253(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar254::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var254(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar255::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var255(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar256::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var256(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar257::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var257(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar258::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var258(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar259::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var259(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar260::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var260(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar261::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var261(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar262::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var262(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar263::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var263(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar264::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var264(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar265::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var265(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar266::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var266(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar267::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var267(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar268::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var268(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar269::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var269(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar270::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var270(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar271::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var271(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar272::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var272(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar273::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var273(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar274::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var274(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar275::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var275(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar276::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var276(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar277::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var277(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar278::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var278(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar279::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var279(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar280::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var280(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar281::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var281(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar282::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var282(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar283::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var283(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar284::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var284(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar285::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var285(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar286::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var286(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar287::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var287(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar288::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var288(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar289::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var289(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar290::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var290(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar291::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var291(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar292::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var292(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar293::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var293(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar294::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var294(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar295::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var295(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar296::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var296(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar297::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var297(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar298::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var298(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar299::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var299(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar300::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var300(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar301::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var301(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar302::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var302(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar303::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var303(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar304::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var304(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar305::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var305(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar306::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var306(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar307::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var307(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar308::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var308(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar309::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var309(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar310::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var310(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar311::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var311(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar312::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var312(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar313::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var313(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar314::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var314(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar315::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var315(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar316::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var316(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar317::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var317(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar318::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var318(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar319::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var319(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar320::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var320(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar321::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var321(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar322::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var322(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar323::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var323(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar324::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var324(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar325::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var325(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar326::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var326(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar327::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var327(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar328::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var328(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar329::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var329(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar330::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var330(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar331::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var331(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar332::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var332(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar333::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var333(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar334::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var334(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar335::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var335(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar336::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var336(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar337::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var337(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar338::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var338(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar339::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var339(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar340::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var340(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar341::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var341(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar342::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var342(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar343::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var343(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar344::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var344(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar345::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var345(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar346::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var346(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar347::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var347(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar348::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var348(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar349::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var349(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar350::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var350(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar351::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var351(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar352::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var352(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar353::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var353(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar354::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var354(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar355::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var355(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar356::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var356(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar357::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var357(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar358::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var358(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar359::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var359(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar360::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var360(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar361::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var361(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar362::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var362(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar363::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var363(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar364::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var364(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar365::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var365(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar366::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var366(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar367::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var367(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar368::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var368(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar369::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var369(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar370::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var370(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar371::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var371(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar372::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var372(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar373::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var373(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar374::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var374(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar375::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var375(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar376::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var376(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar377::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var377(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar378::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var378(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar379::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var379(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar380::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var380(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar381::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var381(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar382::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var382(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar383::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var383(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar384::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var384(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar385::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var385(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar386::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var386(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar387::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var387(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar388::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var388(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar389::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var389(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar390::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var390(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar391::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var391(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar392::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var392(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar393::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var393(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar394::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var394(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar395::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var395(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar396::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var396(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar397::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var397(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar398::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var398(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar399::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var399(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar400::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var400(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar401::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var401(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar402::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var402(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar403::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var403(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar404::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var404(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar405::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var405(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar406::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var406(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar407::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var407(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar408::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var408(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar409::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var409(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar410::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var410(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar411::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var411(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar412::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var412(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar413::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var413(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar414::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var414(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar415::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var415(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar416::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var416(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar417::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var417(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar418::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var418(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar419::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var419(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar420::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var420(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar421::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var421(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar422::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var422(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar423::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var423(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar424::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var424(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar425::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var425(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar426::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var426(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar427::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var427(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar428::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var428(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar429::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var429(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar430::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var430(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar431::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var431(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar432::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var432(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar433::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var433(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar434::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var434(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar435::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var435(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar436::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var436(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar437::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var437(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar438::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var438(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar439::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var439(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar440::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var440(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar441::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var441(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar442::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var442(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar443::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var443(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar444::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var444(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar445::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var445(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar446::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var446(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar447::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var447(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar448::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var448(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar449::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var449(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar450::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var450(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar451::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var451(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar452::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var452(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar453::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var453(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar454::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var454(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar455::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var455(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar456::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var456(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar457::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var457(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar458::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var458(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar459::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var459(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar460::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var460(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar461::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var461(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar462::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var462(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar463::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var463(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar464::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var464(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar465::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var465(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar466::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var466(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar467::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var467(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar468::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var468(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar469::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var469(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar470::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var470(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar471::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var471(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar472::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var472(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar473::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var473(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar474::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var474(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar475::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var475(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar476::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var476(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar477::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var477(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar478::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var478(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar479::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var479(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar480::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var480(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar481::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var481(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar482::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var482(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar483::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var483(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar484::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var484(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar485::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var485(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar486::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var486(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar487::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var487(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar488::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var488(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar489::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var489(parsed)));
        }
        if let Some((inst_len, parsed)) = instructionVar490::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var490(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1067:1"]
#[derive(Clone, Debug)]
struct EVUIMM_2_RAtVar0 {
    A: TokenField_A,
    EVUIMM_2: TokenField_EVUIMM_2,
}
impl EVUIMM_2_RAtVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_val: i64 = 0;
        calc_val = self.EVUIMM_2.disassembly().wrapping_mul(2i64);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Number(true, calc_val),
            DisplayElement::Literal("("),
            self.A.display(),
            DisplayElement::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_val: i64 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        calc_val = token_parser
            .TokenFieldEVUIMM_2()
            .disassembly()
            .wrapping_mul(2i64);
        let A = token_parser.TokenFieldA();
        let EVUIMM_2 = token_parser.TokenFieldEVUIMM_2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, EVUIMM_2 }))
    }
}
#[derive(Clone, Debug)]
enum TableEVUIMM_2_RAt {
    Var0(EVUIMM_2_RAtVar0),
}
impl TableEVUIMM_2_RAt {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = EVUIMM_2_RAtVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1068:1"]
#[derive(Clone, Debug)]
struct EVUIMM_4_RAtVar0 {
    A: TokenField_A,
    EVUIMM_4: TokenField_EVUIMM_4,
}
impl EVUIMM_4_RAtVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_val: i64 = 0;
        calc_val = self.EVUIMM_4.disassembly().wrapping_mul(4i64);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Number(true, calc_val),
            DisplayElement::Literal("("),
            self.A.display(),
            DisplayElement::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_val: i64 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        calc_val = token_parser
            .TokenFieldEVUIMM_4()
            .disassembly()
            .wrapping_mul(4i64);
        let A = token_parser.TokenFieldA();
        let EVUIMM_4 = token_parser.TokenFieldEVUIMM_4();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, EVUIMM_4 }))
    }
}
#[derive(Clone, Debug)]
enum TableEVUIMM_4_RAt {
    Var0(EVUIMM_4_RAtVar0),
}
impl TableEVUIMM_4_RAt {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = EVUIMM_4_RAtVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1069:1"]
#[derive(Clone, Debug)]
struct EVUIMM_8_RAtVar0 {
    A: TokenField_A,
    EVUIMM_8: TokenField_EVUIMM_8,
}
impl EVUIMM_8_RAtVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_val: i64 = 0;
        calc_val = self.EVUIMM_8.disassembly().wrapping_mul(8i64);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Number(true, calc_val),
            DisplayElement::Literal("("),
            self.A.display(),
            DisplayElement::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_val: i64 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        calc_val = token_parser
            .TokenFieldEVUIMM_8()
            .disassembly()
            .wrapping_mul(8i64);
        let A = token_parser.TokenFieldA();
        let EVUIMM_8 = token_parser.TokenFieldEVUIMM_8();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, EVUIMM_8 }))
    }
}
#[derive(Clone, Debug)]
enum TableEVUIMM_8_RAt {
    Var0(EVUIMM_8_RAtVar0),
}
impl TableEVUIMM_8_RAt {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = EVUIMM_8_RAtVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1203:1"]
#[derive(Clone, Debug)]
struct vrDVar0 {
    vrDD: TokenField_vrDD,
}
impl vrDVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.vrDD.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let vrDD = token_parser.TokenFieldvrDD();
        let vrDR = token_parser.TokenFieldvrDR();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrDD }))
    }
}
#[derive(Clone, Debug)]
enum TablevrD {
    Var0(vrDVar0),
}
impl TablevrD {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            vrDVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1204:1"]
#[derive(Clone, Debug)]
struct vrAVar0 {
    vrAD: TokenField_vrAD,
}
impl vrAVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.vrAD.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let vrAD = token_parser.TokenFieldvrAD();
        let vrAR = token_parser.TokenFieldvrAR();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrAD }))
    }
}
#[derive(Clone, Debug)]
enum TablevrA {
    Var0(vrAVar0),
}
impl TablevrA {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            vrAVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1205:1"]
#[derive(Clone, Debug)]
struct vrBVar0 {
    vrBD: TokenField_vrBD,
}
impl vrBVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.vrBD.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let vrBD = token_parser.TokenFieldvrBD();
        let vrBR = token_parser.TokenFieldvrBR();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrBD }))
    }
}
#[derive(Clone, Debug)]
enum TablevrB {
    Var0(vrBVar0),
}
impl TablevrB {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            vrBVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1206:1"]
#[derive(Clone, Debug)]
struct vrCVar0 {
    vrCD: TokenField_vrCD,
}
impl vrCVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.vrCD.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let vrCD = token_parser.TokenFieldvrCD();
        let vrCR = token_parser.TokenFieldvrCR();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrCD }))
    }
}
#[derive(Clone, Debug)]
enum TablevrC {
    Var0(vrCVar0),
}
impl TablevrC {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            vrCVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1207:1"]
#[derive(Clone, Debug)]
struct vrSVar0 {
    vrSD: TokenField_vrSD,
}
impl vrSVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.vrSD.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let vrSD = token_parser.TokenFieldvrSD();
        let vrSR = token_parser.TokenFieldvrSR();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrSD }))
    }
}
#[derive(Clone, Debug)]
enum TablevrS {
    Var0(vrSVar0),
}
impl TablevrS {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            vrSVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1825:1"]
#[derive(Clone, Debug)]
struct REL_ABSVar0 {}
impl REL_ABSVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("a")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldAA().disassembly() != 1i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1826:1"]
#[derive(Clone, Debug)]
struct REL_ABSVar1 {}
impl REL_ABSVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldAA().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableREL_ABS {
    Var0(REL_ABSVar0),
    Var1(REL_ABSVar1),
}
impl TableREL_ABS {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            REL_ABSVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            REL_ABSVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1828:1"]
#[derive(Clone, Debug)]
struct addressLIVar0 {
    LI: TokenField_LI,
}
impl addressLIVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_reloc: i64 = 0;
        calc_reloc = i64::try_from(inst_start)
            .unwrap()
            .wrapping_add(self.LI.disassembly().wrapping_mul(4i64));
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_reloc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_reloc: i64 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldAA().disassembly() != 0i64 {
            return None;
        }
        calc_reloc = i64::try_from(inst_start).unwrap().wrapping_add(
            token_parser.TokenFieldLI().disassembly().wrapping_mul(4i64),
        );
        let LI = token_parser.TokenFieldLI();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LI }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1829:1"]
#[derive(Clone, Debug)]
struct addressLIVar1 {
    LI: TokenField_LI,
}
impl addressLIVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_reloc: i64 = 0;
        calc_reloc = self.LI.disassembly().wrapping_mul(4i64);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_reloc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_reloc: i64 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldAA().disassembly() != 1i64 {
            return None;
        }
        calc_reloc =
            token_parser.TokenFieldLI().disassembly().wrapping_mul(4i64);
        let LI = token_parser.TokenFieldLI();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LI }))
    }
}
#[derive(Clone, Debug)]
enum TableaddressLI {
    Var0(addressLIVar0),
    Var1(addressLIVar1),
}
impl TableaddressLI {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            addressLIVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addressLIVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1830:1"]
#[derive(Clone, Debug)]
struct addressBDVar0 {
    BD: TokenField_BD,
}
impl addressBDVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_reloc: i64 = 0;
        calc_reloc = i64::try_from(inst_start)
            .unwrap()
            .wrapping_add(self.BD.disassembly().wrapping_mul(4i64));
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_reloc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_reloc: i64 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldAA().disassembly() != 0i64 {
            return None;
        }
        calc_reloc = i64::try_from(inst_start).unwrap().wrapping_add(
            token_parser.TokenFieldBD().disassembly().wrapping_mul(4i64),
        );
        let BD = token_parser.TokenFieldBD();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BD }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1831:1"]
#[derive(Clone, Debug)]
struct addressBDVar1 {
    BD: TokenField_BD,
}
impl addressBDVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_reloc: i64 = 0;
        calc_reloc = self.BD.disassembly().wrapping_mul(4i64);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_reloc)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_reloc: i64 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldAA().disassembly() != 1i64 {
            return None;
        }
        calc_reloc =
            token_parser.TokenFieldBD().disassembly().wrapping_mul(4i64);
        let BD = token_parser.TokenFieldBD();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BD }))
    }
}
#[derive(Clone, Debug)]
enum TableaddressBD {
    Var0(addressBDVar0),
    Var1(addressBDVar1),
}
impl TableaddressBD {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            addressBDVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            addressBDVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1833:1"]
#[derive(Clone, Debug)]
struct OFF16SHVar0 {
    D0: TokenField_D0,
    D1: TokenField_D1,
    D2: TokenField_D2,
}
impl OFF16SHVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_val: i64 = 0;
        calc_val = ((self
            .D0
            .disassembly()
            .checked_shl(u32::try_from(6i64).unwrap())
            .unwrap_or(0)
            | self
                .D1
                .disassembly()
                .checked_shl(u32::try_from(1i64).unwrap())
                .unwrap_or(0))
            | self.D2.disassembly())
        .checked_shl(u32::try_from(16i64).unwrap())
        .unwrap_or(0);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_val)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_val: i64 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        calc_val = ((token_parser
            .TokenFieldD0()
            .disassembly()
            .checked_shl(u32::try_from(6i64).unwrap())
            .unwrap_or(0)
            | token_parser
                .TokenFieldD1()
                .disassembly()
                .checked_shl(u32::try_from(1i64).unwrap())
                .unwrap_or(0))
            | token_parser.TokenFieldD2().disassembly())
        .checked_shl(u32::try_from(16i64).unwrap())
        .unwrap_or(0);
        let D0 = token_parser.TokenFieldD0();
        let D1 = token_parser.TokenFieldD1();
        let D2 = token_parser.TokenFieldD2();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D0, D1, D2 }))
    }
}
#[derive(Clone, Debug)]
enum TableOFF16SH {
    Var0(OFF16SHVar0),
}
impl TableOFF16SH {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            OFF16SHVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1837:1"]
#[derive(Clone, Debug)]
struct CCVar0 {}
impl CCVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("lt")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldBI_CC().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBO_1().disassembly() != 1i64 {
            return None;
        }
        let BI_CR = token_parser.TokenFieldBI_CR();
        let BI_CC = token_parser.TokenFieldBI_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1838:1"]
#[derive(Clone, Debug)]
struct CCVar1 {}
impl CCVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("le")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldBI_CC().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBO_1().disassembly() != 0i64 {
            return None;
        }
        let BI_CR = token_parser.TokenFieldBI_CR();
        let BI_CC = token_parser.TokenFieldBI_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1839:1"]
#[derive(Clone, Debug)]
struct CCVar2 {}
impl CCVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("eq")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldBI_CC().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldBO_1().disassembly() != 1i64 {
            return None;
        }
        let BI_CR = token_parser.TokenFieldBI_CR();
        let BI_CC = token_parser.TokenFieldBI_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1840:1"]
#[derive(Clone, Debug)]
struct CCVar3 {}
impl CCVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ge")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldBI_CC().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBO_1().disassembly() != 0i64 {
            return None;
        }
        let BI_CR = token_parser.TokenFieldBI_CR();
        let BI_CC = token_parser.TokenFieldBI_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1841:1"]
#[derive(Clone, Debug)]
struct CCVar4 {}
impl CCVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("gt")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldBI_CC().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBO_1().disassembly() != 1i64 {
            return None;
        }
        let BI_CR = token_parser.TokenFieldBI_CR();
        let BI_CC = token_parser.TokenFieldBI_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1842:1"]
#[derive(Clone, Debug)]
struct CCVar5 {}
impl CCVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ne")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldBI_CC().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldBO_1().disassembly() != 0i64 {
            return None;
        }
        let BI_CR = token_parser.TokenFieldBI_CR();
        let BI_CC = token_parser.TokenFieldBI_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1843:1"]
#[derive(Clone, Debug)]
struct CCVar6 {}
impl CCVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("so")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldBI_CC().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldBO_1().disassembly() != 1i64 {
            return None;
        }
        let BI_CR = token_parser.TokenFieldBI_CR();
        let BI_CC = token_parser.TokenFieldBI_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1844:1"]
#[derive(Clone, Debug)]
struct CCVar7 {}
impl CCVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ns")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldBI_CC().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldBO_1().disassembly() != 0i64 {
            return None;
        }
        let BI_CR = token_parser.TokenFieldBI_CR();
        let BI_CC = token_parser.TokenFieldBI_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableCC {
    Var0(CCVar0),
    Var1(CCVar1),
    Var2(CCVar2),
    Var3(CCVar3),
    Var4(CCVar4),
    Var5(CCVar5),
    Var6(CCVar6),
    Var7(CCVar7),
}
impl TableCC {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            CCVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CCVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CCVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CCVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CCVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CCVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CCVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CCVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1846:1"]
#[derive(Clone, Debug)]
struct TOmVar0 {}
impl TOmVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("lt")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldTO().disassembly() != 16i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1847:1"]
#[derive(Clone, Debug)]
struct TOmVar1 {}
impl TOmVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("le")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldTO().disassembly() != 20i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1848:1"]
#[derive(Clone, Debug)]
struct TOmVar2 {}
impl TOmVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("eq")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldTO().disassembly() != 4i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1849:1"]
#[derive(Clone, Debug)]
struct TOmVar3 {}
impl TOmVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ge")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldTO().disassembly() != 12i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1850:1"]
#[derive(Clone, Debug)]
struct TOmVar4 {}
impl TOmVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("gt")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldTO().disassembly() != 8i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1851:1"]
#[derive(Clone, Debug)]
struct TOmVar5 {}
impl TOmVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ne")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldTO().disassembly() != 24i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1852:1"]
#[derive(Clone, Debug)]
struct TOmVar6 {}
impl TOmVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("llt")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldTO().disassembly() != 2i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1853:1"]
#[derive(Clone, Debug)]
struct TOmVar7 {}
impl TOmVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("lle")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldTO().disassembly() != 6i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1854:1"]
#[derive(Clone, Debug)]
struct TOmVar8 {}
impl TOmVar8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("lge")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldTO().disassembly() != 5i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1855:1"]
#[derive(Clone, Debug)]
struct TOmVar9 {}
impl TOmVar9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("lgt")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldTO().disassembly() != 1i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1856:1"]
#[derive(Clone, Debug)]
struct TOmVar10 {}
impl TOmVar10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(""), DisplayElement::Literal("")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let TO = token_parser.TokenFieldTO();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableTOm {
    Var0(TOmVar0),
    Var1(TOmVar1),
    Var2(TOmVar2),
    Var3(TOmVar3),
    Var4(TOmVar4),
    Var5(TOmVar5),
    Var6(TOmVar6),
    Var7(TOmVar7),
    Var8(TOmVar8),
    Var9(TOmVar9),
    Var10(TOmVar10),
}
impl TableTOm {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            TOmVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            TOmVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            TOmVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            TOmVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            TOmVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            TOmVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            TOmVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            TOmVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        if let Some((inst_len, parsed)) =
            TOmVar8::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var8(parsed)));
        }
        if let Some((inst_len, parsed)) =
            TOmVar9::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var9(parsed)));
        }
        if let Some((inst_len, parsed)) =
            TOmVar10::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var10(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1858:1"]
#[derive(Clone, Debug)]
struct CTR_DECVar0 {}
impl CTR_DECVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("z")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldBO_3().disassembly() != 1i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1859:1"]
#[derive(Clone, Debug)]
struct CTR_DECVar1 {}
impl CTR_DECVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("nz")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldBO_3().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableCTR_DEC {
    Var0(CTR_DECVar0),
    Var1(CTR_DECVar1),
}
impl TableCTR_DEC {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            CTR_DECVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CTR_DECVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1861:1"]
#[derive(Clone, Debug)]
struct CC_TFVar0 {}
impl CC_TFVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("t")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldBO_1().disassembly() != 1i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1862:1"]
#[derive(Clone, Debug)]
struct CC_TFVar1 {}
impl CC_TFVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("f")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldBO_1().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableCC_TF {
    Var0(CC_TFVar0),
    Var1(CC_TFVar1),
}
impl TableCC_TF {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            CC_TFVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_TFVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1869:1"]
#[derive(Clone, Debug)]
struct CC_OPVar0 {}
impl CC_OPVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("lt")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldBI_CC().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldBI_CR().disassembly() != 0i64 {
            return None;
        }
        let BI_CC = token_parser.TokenFieldBI_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1870:1"]
#[derive(Clone, Debug)]
struct CC_OPVar1 {}
impl CC_OPVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("eq")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldBI_CC().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldBI_CR().disassembly() != 0i64 {
            return None;
        }
        let BI_CC = token_parser.TokenFieldBI_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1871:1"]
#[derive(Clone, Debug)]
struct CC_OPVar2 {}
impl CC_OPVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("gt")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldBI_CC().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldBI_CR().disassembly() != 0i64 {
            return None;
        }
        let BI_CC = token_parser.TokenFieldBI_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1872:1"]
#[derive(Clone, Debug)]
struct CC_OPVar3 {}
impl CC_OPVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("so")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldBI_CC().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldBI_CR().disassembly() != 0i64 {
            return None;
        }
        let BI_CC = token_parser.TokenFieldBI_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1873:1"]
#[derive(Clone, Debug)]
struct CC_OPVar4 {
    BI_CR: TokenField_BI_CR,
}
impl CC_OPVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("4*"),
            self.BI_CR.display(),
            DisplayElement::Literal("+lt"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldBI_CC().disassembly() != 0i64 {
            return None;
        }
        let BI_CR = token_parser.TokenFieldBI_CR();
        let BI_CC = token_parser.TokenFieldBI_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BI_CR }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1874:1"]
#[derive(Clone, Debug)]
struct CC_OPVar5 {
    BI_CR: TokenField_BI_CR,
}
impl CC_OPVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("4*"),
            self.BI_CR.display(),
            DisplayElement::Literal("+eq"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldBI_CC().disassembly() != 2i64 {
            return None;
        }
        let BI_CR = token_parser.TokenFieldBI_CR();
        let BI_CC = token_parser.TokenFieldBI_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BI_CR }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1875:1"]
#[derive(Clone, Debug)]
struct CC_OPVar6 {
    BI_CR: TokenField_BI_CR,
}
impl CC_OPVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("4*"),
            self.BI_CR.display(),
            DisplayElement::Literal("+gt"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldBI_CC().disassembly() != 1i64 {
            return None;
        }
        let BI_CR = token_parser.TokenFieldBI_CR();
        let BI_CC = token_parser.TokenFieldBI_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BI_CR }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1876:1"]
#[derive(Clone, Debug)]
struct CC_OPVar7 {
    BI_CR: TokenField_BI_CR,
}
impl CC_OPVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("4*"),
            self.BI_CR.display(),
            DisplayElement::Literal("+so"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldBI_CC().disassembly() != 3i64 {
            return None;
        }
        let BI_CR = token_parser.TokenFieldBI_CR();
        let BI_CC = token_parser.TokenFieldBI_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BI_CR }))
    }
}
#[derive(Clone, Debug)]
enum TableCC_OP {
    Var0(CC_OPVar0),
    Var1(CC_OPVar1),
    Var2(CC_OPVar2),
    Var3(CC_OPVar3),
    Var4(CC_OPVar4),
    Var5(CC_OPVar5),
    Var6(CC_OPVar6),
    Var7(CC_OPVar7),
}
impl TableCC_OP {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            CC_OPVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_OPVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_OPVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_OPVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_OPVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_OPVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_OPVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_OPVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1880:1"]
#[derive(Clone, Debug)]
struct CC_B_OPVar0 {}
impl CC_B_OPVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("lt")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCR_B_CC().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldCR_B().disassembly() != 0i64 {
            return None;
        }
        let CR_B_CC = token_parser.TokenFieldCR_B_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1881:1"]
#[derive(Clone, Debug)]
struct CC_B_OPVar1 {}
impl CC_B_OPVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("eq")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCR_B_CC().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldCR_B().disassembly() != 0i64 {
            return None;
        }
        let CR_B_CC = token_parser.TokenFieldCR_B_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1882:1"]
#[derive(Clone, Debug)]
struct CC_B_OPVar2 {}
impl CC_B_OPVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("gt")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCR_B_CC().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldCR_B().disassembly() != 0i64 {
            return None;
        }
        let CR_B_CC = token_parser.TokenFieldCR_B_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1883:1"]
#[derive(Clone, Debug)]
struct CC_B_OPVar3 {}
impl CC_B_OPVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("so")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCR_B_CC().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldCR_B().disassembly() != 0i64 {
            return None;
        }
        let CR_B_CC = token_parser.TokenFieldCR_B_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1884:1"]
#[derive(Clone, Debug)]
struct CC_B_OPVar4 {
    CR_B: TokenField_CR_B,
}
impl CC_B_OPVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("4*"),
            self.CR_B.display(),
            DisplayElement::Literal("+lt"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCR_B_CC().disassembly() != 0i64 {
            return None;
        }
        let CR_B = token_parser.TokenFieldCR_B();
        let CR_B_CC = token_parser.TokenFieldCR_B_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CR_B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1885:1"]
#[derive(Clone, Debug)]
struct CC_B_OPVar5 {
    CR_B: TokenField_CR_B,
}
impl CC_B_OPVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("4*"),
            self.CR_B.display(),
            DisplayElement::Literal("+eq"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCR_B_CC().disassembly() != 2i64 {
            return None;
        }
        let CR_B = token_parser.TokenFieldCR_B();
        let CR_B_CC = token_parser.TokenFieldCR_B_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CR_B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1886:1"]
#[derive(Clone, Debug)]
struct CC_B_OPVar6 {
    CR_B: TokenField_CR_B,
}
impl CC_B_OPVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("4*"),
            self.CR_B.display(),
            DisplayElement::Literal("+gt"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCR_B_CC().disassembly() != 1i64 {
            return None;
        }
        let CR_B = token_parser.TokenFieldCR_B();
        let CR_B_CC = token_parser.TokenFieldCR_B_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CR_B }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1887:1"]
#[derive(Clone, Debug)]
struct CC_B_OPVar7 {
    CR_B: TokenField_CR_B,
}
impl CC_B_OPVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("4*"),
            self.CR_B.display(),
            DisplayElement::Literal("+so"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCR_B_CC().disassembly() != 3i64 {
            return None;
        }
        let CR_B = token_parser.TokenFieldCR_B();
        let CR_B_CC = token_parser.TokenFieldCR_B_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CR_B }))
    }
}
#[derive(Clone, Debug)]
enum TableCC_B_OP {
    Var0(CC_B_OPVar0),
    Var1(CC_B_OPVar1),
    Var2(CC_B_OPVar2),
    Var3(CC_B_OPVar3),
    Var4(CC_B_OPVar4),
    Var5(CC_B_OPVar5),
    Var6(CC_B_OPVar6),
    Var7(CC_B_OPVar7),
}
impl TableCC_B_OP {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            CC_B_OPVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_B_OPVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_B_OPVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_B_OPVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_B_OPVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_B_OPVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_B_OPVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_B_OPVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1891:1"]
#[derive(Clone, Debug)]
struct CC_X_OPVar0 {}
impl CC_X_OPVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::cr0)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCR_X_CC().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldCR_X().disassembly() != 0i64 {
            return None;
        }
        let CR_X_CC = token_parser.TokenFieldCR_X_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1892:1"]
#[derive(Clone, Debug)]
struct CC_X_OPVar1 {}
impl CC_X_OPVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::cr0)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCR_X_CC().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldCR_X().disassembly() != 0i64 {
            return None;
        }
        let CR_X_CC = token_parser.TokenFieldCR_X_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1893:1"]
#[derive(Clone, Debug)]
struct CC_X_OPVar2 {}
impl CC_X_OPVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::cr0)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCR_X_CC().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldCR_X().disassembly() != 0i64 {
            return None;
        }
        let CR_X_CC = token_parser.TokenFieldCR_X_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1894:1"]
#[derive(Clone, Debug)]
struct CC_X_OPVar3 {}
impl CC_X_OPVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::cr0)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCR_X_CC().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldCR_X().disassembly() != 0i64 {
            return None;
        }
        let CR_X_CC = token_parser.TokenFieldCR_X_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1895:1"]
#[derive(Clone, Debug)]
struct CC_X_OPVar4 {
    CR_X: TokenField_CR_X,
}
impl CC_X_OPVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.CR_X.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCR_X_CC().disassembly() != 0i64 {
            return None;
        }
        let CR_X = token_parser.TokenFieldCR_X();
        let CR_X_CC = token_parser.TokenFieldCR_X_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CR_X }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1896:1"]
#[derive(Clone, Debug)]
struct CC_X_OPVar5 {
    CR_X: TokenField_CR_X,
}
impl CC_X_OPVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.CR_X.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCR_X_CC().disassembly() != 1i64 {
            return None;
        }
        let CR_X = token_parser.TokenFieldCR_X();
        let CR_X_CC = token_parser.TokenFieldCR_X_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CR_X }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1897:1"]
#[derive(Clone, Debug)]
struct CC_X_OPVar6 {
    CR_X: TokenField_CR_X,
}
impl CC_X_OPVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.CR_X.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCR_X_CC().disassembly() != 2i64 {
            return None;
        }
        let CR_X = token_parser.TokenFieldCR_X();
        let CR_X_CC = token_parser.TokenFieldCR_X_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CR_X }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1898:1"]
#[derive(Clone, Debug)]
struct CC_X_OPVar7 {
    CR_X: TokenField_CR_X,
}
impl CC_X_OPVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.CR_X.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCR_X_CC().disassembly() != 3i64 {
            return None;
        }
        let CR_X = token_parser.TokenFieldCR_X();
        let CR_X_CC = token_parser.TokenFieldCR_X_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CR_X }))
    }
}
#[derive(Clone, Debug)]
enum TableCC_X_OP {
    Var0(CC_X_OPVar0),
    Var1(CC_X_OPVar1),
    Var2(CC_X_OPVar2),
    Var3(CC_X_OPVar3),
    Var4(CC_X_OPVar4),
    Var5(CC_X_OPVar5),
    Var6(CC_X_OPVar6),
    Var7(CC_X_OPVar7),
}
impl TableCC_X_OP {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            CC_X_OPVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_X_OPVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_X_OPVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_X_OPVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_X_OPVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_X_OPVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_X_OPVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_X_OPVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1900:1"]
#[derive(Clone, Debug)]
struct CC_X_OPmVar0 {}
impl CC_X_OPmVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("lt")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCR_X_CC().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldCR_X().disassembly() != 0i64 {
            return None;
        }
        let CR_X_CC = token_parser.TokenFieldCR_X_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1901:1"]
#[derive(Clone, Debug)]
struct CC_X_OPmVar1 {}
impl CC_X_OPmVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("gt")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCR_X_CC().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldCR_X().disassembly() != 0i64 {
            return None;
        }
        let CR_X_CC = token_parser.TokenFieldCR_X_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1902:1"]
#[derive(Clone, Debug)]
struct CC_X_OPmVar2 {}
impl CC_X_OPmVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("eq")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCR_X_CC().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldCR_X().disassembly() != 0i64 {
            return None;
        }
        let CR_X_CC = token_parser.TokenFieldCR_X_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1903:1"]
#[derive(Clone, Debug)]
struct CC_X_OPmVar3 {}
impl CC_X_OPmVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("so")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCR_X_CC().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldCR_X().disassembly() != 0i64 {
            return None;
        }
        let CR_X_CC = token_parser.TokenFieldCR_X_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1904:1"]
#[derive(Clone, Debug)]
struct CC_X_OPmVar4 {}
impl CC_X_OPmVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("lt")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCR_X_CC().disassembly() != 0i64 {
            return None;
        }
        let CR_X = token_parser.TokenFieldCR_X();
        let CR_X_CC = token_parser.TokenFieldCR_X_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1905:1"]
#[derive(Clone, Debug)]
struct CC_X_OPmVar5 {}
impl CC_X_OPmVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("gt")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCR_X_CC().disassembly() != 1i64 {
            return None;
        }
        let CR_X = token_parser.TokenFieldCR_X();
        let CR_X_CC = token_parser.TokenFieldCR_X_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1906:1"]
#[derive(Clone, Debug)]
struct CC_X_OPmVar6 {}
impl CC_X_OPmVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("eq")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCR_X_CC().disassembly() != 2i64 {
            return None;
        }
        let CR_X = token_parser.TokenFieldCR_X();
        let CR_X_CC = token_parser.TokenFieldCR_X_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1907:1"]
#[derive(Clone, Debug)]
struct CC_X_OPmVar7 {}
impl CC_X_OPmVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("so")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCR_X_CC().disassembly() != 3i64 {
            return None;
        }
        let CR_X = token_parser.TokenFieldCR_X();
        let CR_X_CC = token_parser.TokenFieldCR_X_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableCC_X_OPm {
    Var0(CC_X_OPmVar0),
    Var1(CC_X_OPmVar1),
    Var2(CC_X_OPmVar2),
    Var3(CC_X_OPmVar3),
    Var4(CC_X_OPmVar4),
    Var5(CC_X_OPmVar5),
    Var6(CC_X_OPmVar6),
    Var7(CC_X_OPmVar7),
}
impl TableCC_X_OPm {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            CC_X_OPmVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_X_OPmVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_X_OPmVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_X_OPmVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_X_OPmVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_X_OPmVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_X_OPmVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_X_OPmVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1911:1"]
#[derive(Clone, Debug)]
struct CC_D_OPVar0 {}
impl CC_D_OPVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("lt")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCR_D_CC().disassembly() != 0i64 {
            return None;
        }
        if token_parser.TokenFieldCR_D().disassembly() != 0i64 {
            return None;
        }
        let CR_D_CC = token_parser.TokenFieldCR_D_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1912:1"]
#[derive(Clone, Debug)]
struct CC_D_OPVar1 {}
impl CC_D_OPVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("eq")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCR_D_CC().disassembly() != 2i64 {
            return None;
        }
        if token_parser.TokenFieldCR_D().disassembly() != 0i64 {
            return None;
        }
        let CR_D_CC = token_parser.TokenFieldCR_D_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1913:1"]
#[derive(Clone, Debug)]
struct CC_D_OPVar2 {}
impl CC_D_OPVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("gt")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCR_D_CC().disassembly() != 1i64 {
            return None;
        }
        if token_parser.TokenFieldCR_D().disassembly() != 0i64 {
            return None;
        }
        let CR_D_CC = token_parser.TokenFieldCR_D_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1914:1"]
#[derive(Clone, Debug)]
struct CC_D_OPVar3 {}
impl CC_D_OPVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("so")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCR_D_CC().disassembly() != 3i64 {
            return None;
        }
        if token_parser.TokenFieldCR_D().disassembly() != 0i64 {
            return None;
        }
        let CR_D_CC = token_parser.TokenFieldCR_D_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1915:1"]
#[derive(Clone, Debug)]
struct CC_D_OPVar4 {
    CR_D: TokenField_CR_D,
}
impl CC_D_OPVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("4*"),
            self.CR_D.display(),
            DisplayElement::Literal("+lt"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCR_D_CC().disassembly() != 0i64 {
            return None;
        }
        let CR_D = token_parser.TokenFieldCR_D();
        let CR_D_CC = token_parser.TokenFieldCR_D_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CR_D }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1916:1"]
#[derive(Clone, Debug)]
struct CC_D_OPVar5 {
    CR_D: TokenField_CR_D,
}
impl CC_D_OPVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("4*"),
            self.CR_D.display(),
            DisplayElement::Literal("+eq"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCR_D_CC().disassembly() != 2i64 {
            return None;
        }
        let CR_D = token_parser.TokenFieldCR_D();
        let CR_D_CC = token_parser.TokenFieldCR_D_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CR_D }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1917:1"]
#[derive(Clone, Debug)]
struct CC_D_OPVar6 {
    CR_D: TokenField_CR_D,
}
impl CC_D_OPVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("4*"),
            self.CR_D.display(),
            DisplayElement::Literal("+gt"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCR_D_CC().disassembly() != 1i64 {
            return None;
        }
        let CR_D = token_parser.TokenFieldCR_D();
        let CR_D_CC = token_parser.TokenFieldCR_D_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CR_D }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1918:1"]
#[derive(Clone, Debug)]
struct CC_D_OPVar7 {
    CR_D: TokenField_CR_D,
}
impl CC_D_OPVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("4*"),
            self.CR_D.display(),
            DisplayElement::Literal("+so"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCR_D_CC().disassembly() != 3i64 {
            return None;
        }
        let CR_D = token_parser.TokenFieldCR_D();
        let CR_D_CC = token_parser.TokenFieldCR_D_CC();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CR_D }))
    }
}
#[derive(Clone, Debug)]
enum TableCC_D_OP {
    Var0(CC_D_OPVar0),
    Var1(CC_D_OPVar1),
    Var2(CC_D_OPVar2),
    Var3(CC_D_OPVar3),
    Var4(CC_D_OPVar4),
    Var5(CC_D_OPVar5),
    Var6(CC_D_OPVar6),
    Var7(CC_D_OPVar7),
}
impl TableCC_D_OP {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            CC_D_OPVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_D_OPVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_D_OPVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_D_OPVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_D_OPVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_D_OPVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_D_OPVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CC_D_OPVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1921:1"]
#[derive(Clone, Debug)]
struct RA_OR_ZEROVar0 {}
impl RA_OR_ZEROVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("0")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldA().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1920:1"]
#[derive(Clone, Debug)]
struct RA_OR_ZEROVar1 {
    A: TokenField_A,
}
impl RA_OR_ZEROVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.A.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A }))
    }
}
#[derive(Clone, Debug)]
enum TableRA_OR_ZERO {
    Var0(RA_OR_ZEROVar0),
    Var1(RA_OR_ZEROVar1),
}
impl TableRA_OR_ZERO {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = RA_OR_ZEROVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = RA_OR_ZEROVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1924:1"]
#[derive(Clone, Debug)]
struct RB_OR_ZEROVar0 {}
impl RB_OR_ZEROVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("0")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldB().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1923:1"]
#[derive(Clone, Debug)]
struct RB_OR_ZEROVar1 {
    B: TokenField_B,
}
impl RB_OR_ZEROVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.B.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { B }))
    }
}
#[derive(Clone, Debug)]
enum TableRB_OR_ZERO {
    Var0(RB_OR_ZEROVar0),
    Var1(RB_OR_ZEROVar1),
}
impl TableRB_OR_ZERO {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = RB_OR_ZEROVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = RB_OR_ZEROVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1927:1"]
#[derive(Clone, Debug)]
struct RS_OR_ZEROVar0 {}
impl RS_OR_ZEROVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("0")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldS().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1926:1"]
#[derive(Clone, Debug)]
struct RS_OR_ZEROVar1 {
    S: TokenField_S,
}
impl RS_OR_ZEROVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [self.S.display()];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let S = token_parser.TokenFieldS();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S }))
    }
}
#[derive(Clone, Debug)]
enum TableRS_OR_ZERO {
    Var0(RS_OR_ZEROVar0),
    Var1(RS_OR_ZEROVar1),
}
impl TableRS_OR_ZERO {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = RS_OR_ZEROVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = RS_OR_ZEROVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1951:1"]
#[derive(Clone, Debug)]
struct rotmaskVar0 {
    ME: TokenField_ME,
    MBL: TokenField_MBL,
}
impl rotmaskVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_mask: i64 = 0;
        calc_mask = (((self
            .ME
            .disassembly()
            .wrapping_sub(self.MBL.disassembly())
            .checked_shr(u32::try_from(8i64).unwrap())
            .unwrap_or(0)
            & 1i64)
            .wrapping_mul(4294967295i64)
            ^ 2147483647i64
                .checked_shr(u32::try_from(self.ME.disassembly()).unwrap())
                .unwrap_or(0))
            ^ 4294967295i64
                .checked_shr(u32::try_from(self.MBL.disassembly()).unwrap())
                .unwrap_or(0));
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_mask)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_mask: i64 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        calc_mask = (((token_parser
            .TokenFieldME()
            .disassembly()
            .wrapping_sub(token_parser.TokenFieldMBL().disassembly())
            .checked_shr(u32::try_from(8i64).unwrap())
            .unwrap_or(0)
            & 1i64)
            .wrapping_mul(4294967295i64)
            ^ 2147483647i64
                .checked_shr(
                    u32::try_from(token_parser.TokenFieldME().disassembly())
                        .unwrap(),
                )
                .unwrap_or(0))
            ^ 4294967295i64
                .checked_shr(
                    u32::try_from(token_parser.TokenFieldMBL().disassembly())
                        .unwrap(),
                )
                .unwrap_or(0));
        let MBL = token_parser.TokenFieldMBL();
        let ME = token_parser.TokenFieldME();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { MBL, ME }))
    }
}
#[derive(Clone, Debug)]
enum Tablerotmask {
    Var0(rotmaskVar0),
}
impl Tablerotmask {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            rotmaskVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1954:1"]
#[derive(Clone, Debug)]
struct DSIZEVar0 {}
impl DSIZEVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("w")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let L = token_parser.TokenFieldL();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableDSIZE {
    Var0(DSIZEVar0),
}
impl TableDSIZE {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            DSIZEVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1965:1"]
#[derive(Clone, Debug)]
struct REG_AVar0 {}
impl REG_AVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableREG_A {
    Var0(REG_AVar0),
}
impl TableREG_A {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            REG_AVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1966:1"]
#[derive(Clone, Debug)]
struct REG_BVar0 {}
impl REG_BVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableREG_B {
    Var0(REG_BVar0),
}
impl TableREG_B {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            REG_BVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1975:1"]
#[derive(Clone, Debug)]
struct UREG_AVar0 {}
impl UREG_AVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableUREG_A {
    Var0(UREG_AVar0),
}
impl TableUREG_A {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            UREG_AVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1976:1"]
#[derive(Clone, Debug)]
struct UREG_BVar0 {}
impl UREG_BVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let B = token_parser.TokenFieldB();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableUREG_B {
    Var0(UREG_BVar0),
}
impl TableUREG_B {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            UREG_BVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1979:1"]
#[derive(Clone, Debug)]
struct dPlusRaOrZeroAddressVar0 {
    SIMM: TokenField_SIMM,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl dPlusRaOrZeroAddressVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 2usize] =
            [self.SIMM.display(), DisplayElement::Literal("(")];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let SIMM = token_parser.TokenFieldSIMM();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, SIMM }))
    }
}
#[derive(Clone, Debug)]
enum TabledPlusRaOrZeroAddress {
    Var0(dPlusRaOrZeroAddressVar0),
}
impl TabledPlusRaOrZeroAddress {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = dPlusRaOrZeroAddressVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1980:1"]
#[derive(Clone, Debug)]
struct dPlusRaAddressVar0 {
    SIMM: TokenField_SIMM,
    A: TokenField_A,
}
impl dPlusRaAddressVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 4usize] = [
            self.SIMM.display(),
            DisplayElement::Literal("("),
            self.A.display(),
            DisplayElement::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        let SIMM = token_parser.TokenFieldSIMM();
        let A = token_parser.TokenFieldA();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SIMM, A }))
    }
}
#[derive(Clone, Debug)]
enum TabledPlusRaAddress {
    Var0(dPlusRaAddressVar0),
}
impl TabledPlusRaAddress {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = dPlusRaAddressVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1982:1"]
#[derive(Clone, Debug)]
struct dUI16PlusRAOrZeroAddressVar0 {
    UI_16_s8: TokenField_UI_16_s8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl dUI16PlusRAOrZeroAddressVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_val: i64 = 0;
        calc_val = self
            .UI_16_s8
            .disassembly()
            .checked_shl(u32::try_from(3i64).unwrap())
            .unwrap_or(0);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Number(true, calc_val),
            DisplayElement::Literal("("),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO.display_extend(
            display, context, inst_start, inst_next, global_set,
        );
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_val: i64 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        calc_val = token_parser
            .TokenFieldUI_16_s8()
            .disassembly()
            .checked_shl(u32::try_from(3i64).unwrap())
            .unwrap_or(0);
        let RA_OR_ZERO = if let Some((len, table)) = TableRA_OR_ZERO::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        let UI_16_s8 = token_parser.TokenFieldUI_16_s8();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                UI_16_s8,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum TabledUI16PlusRAOrZeroAddress {
    Var0(dUI16PlusRAOrZeroAddressVar0),
}
impl TabledUI16PlusRAOrZeroAddress {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = dUI16PlusRAOrZeroAddressVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1990:1"]
#[derive(Clone, Debug)]
struct FPSCR_CRFSVar0 {}
impl FPSCR_CRFSVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCRFS().disassembly() != 0i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1991:1"]
#[derive(Clone, Debug)]
struct FPSCR_CRFSVar1 {}
impl FPSCR_CRFSVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCRFS().disassembly() != 1i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1992:1"]
#[derive(Clone, Debug)]
struct FPSCR_CRFSVar2 {}
impl FPSCR_CRFSVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCRFS().disassembly() != 2i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1993:1"]
#[derive(Clone, Debug)]
struct FPSCR_CRFSVar3 {}
impl FPSCR_CRFSVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCRFS().disassembly() != 3i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1994:1"]
#[derive(Clone, Debug)]
struct FPSCR_CRFSVar4 {}
impl FPSCR_CRFSVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCRFS().disassembly() != 4i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1995:1"]
#[derive(Clone, Debug)]
struct FPSCR_CRFSVar5 {}
impl FPSCR_CRFSVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCRFS().disassembly() != 5i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1996:1"]
#[derive(Clone, Debug)]
struct FPSCR_CRFSVar6 {}
impl FPSCR_CRFSVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCRFS().disassembly() != 6i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1997:1"]
#[derive(Clone, Debug)]
struct FPSCR_CRFSVar7 {}
impl FPSCR_CRFSVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCRFS().disassembly() != 7i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableFPSCR_CRFS {
    Var0(FPSCR_CRFSVar0),
    Var1(FPSCR_CRFSVar1),
    Var2(FPSCR_CRFSVar2),
    Var3(FPSCR_CRFSVar3),
    Var4(FPSCR_CRFSVar4),
    Var5(FPSCR_CRFSVar5),
    Var6(FPSCR_CRFSVar6),
    Var7(FPSCR_CRFSVar7),
}
impl TableFPSCR_CRFS {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) = FPSCR_CRFSVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) = FPSCR_CRFSVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) = FPSCR_CRFSVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) = FPSCR_CRFSVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) = FPSCR_CRFSVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) = FPSCR_CRFSVar5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) = FPSCR_CRFSVar6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) = FPSCR_CRFSVar7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
        ) {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:1999:1"]
#[derive(Clone, Debug)]
struct CRM_CRVar0 {}
impl CRM_CRVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::cr7)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCRM().disassembly() != 1i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:2000:1"]
#[derive(Clone, Debug)]
struct CRM_CRVar1 {}
impl CRM_CRVar1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::cr6)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCRM().disassembly() != 2i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:2001:1"]
#[derive(Clone, Debug)]
struct CRM_CRVar2 {}
impl CRM_CRVar2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::cr5)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCRM().disassembly() != 4i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:2002:1"]
#[derive(Clone, Debug)]
struct CRM_CRVar3 {}
impl CRM_CRVar3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::cr4)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCRM().disassembly() != 8i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:2003:1"]
#[derive(Clone, Debug)]
struct CRM_CRVar4 {}
impl CRM_CRVar4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::cr3)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCRM().disassembly() != 16i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:2004:1"]
#[derive(Clone, Debug)]
struct CRM_CRVar5 {}
impl CRM_CRVar5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::cr2)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCRM().disassembly() != 32i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:2005:1"]
#[derive(Clone, Debug)]
struct CRM_CRVar6 {}
impl CRM_CRVar6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::cr1)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCRM().disassembly() != 64i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc:2006:1"]
#[derive(Clone, Debug)]
struct CRM_CRVar7 {}
impl CRM_CRVar7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::cr0)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        if token_parser.TokenFieldCRM().disassembly() != 128i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableCRM_CR {
    Var0(CRM_CRVar0),
    Var1(CRM_CRVar1),
    Var2(CRM_CRVar2),
    Var3(CRM_CRVar3),
    Var4(CRM_CRVar4),
    Var5(CRM_CRVar5),
    Var6(CRM_CRVar6),
    Var7(CRM_CRVar7),
}
impl TableCRM_CR {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            CRM_CRVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CRM_CRVar1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CRM_CRVar2::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var2(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CRM_CRVar3::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var3(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CRM_CRVar4::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var4(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CRM_CRVar5::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var5(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CRM_CRVar6::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var6(parsed)));
        }
        if let Some((inst_len, parsed)) =
            CRM_CRVar7::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:1:1"]
#[derive(Clone, Debug)]
struct LDMR0Var0 {}
impl LDMR0Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 1i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:2:1"]
#[derive(Clone, Debug)]
struct LDMR0Var1 {}
impl LDMR0Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR0 {
    Var0(LDMR0Var0),
    Var1(LDMR0Var1),
}
impl TableLDMR0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LDMR0Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LDMR0Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:4:1"]
#[derive(Clone, Debug)]
struct LDMR1Var0 {}
impl LDMR1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 2i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:5:1"]
#[derive(Clone, Debug)]
struct LDMR1Var1 {
    LDMR0: TableLDMR0,
}
impl LDMR1Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let LDMR0 = if let Some((len, table)) =
            TableLDMR0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR0 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR1 {
    Var0(LDMR1Var0),
    Var1(LDMR1Var1),
}
impl TableLDMR1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LDMR1Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LDMR1Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:7:1"]
#[derive(Clone, Debug)]
struct LDMR2Var0 {}
impl LDMR2Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 3i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:8:1"]
#[derive(Clone, Debug)]
struct LDMR2Var1 {
    LDMR1: TableLDMR1,
}
impl LDMR2Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let LDMR1 = if let Some((len, table)) =
            TableLDMR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR1 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR2 {
    Var0(LDMR2Var0),
    Var1(LDMR2Var1),
}
impl TableLDMR2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LDMR2Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LDMR2Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:10:1"]
#[derive(Clone, Debug)]
struct LDMR3Var0 {}
impl LDMR3Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 4i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:11:1"]
#[derive(Clone, Debug)]
struct LDMR3Var1 {
    LDMR2: TableLDMR2,
}
impl LDMR3Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let LDMR2 = if let Some((len, table)) =
            TableLDMR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR2 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR3 {
    Var0(LDMR3Var0),
    Var1(LDMR3Var1),
}
impl TableLDMR3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LDMR3Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LDMR3Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:13:1"]
#[derive(Clone, Debug)]
struct LDMR4Var0 {}
impl LDMR4Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 5i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:14:1"]
#[derive(Clone, Debug)]
struct LDMR4Var1 {
    LDMR3: TableLDMR3,
}
impl LDMR4Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let LDMR3 = if let Some((len, table)) =
            TableLDMR3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR3 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR4 {
    Var0(LDMR4Var0),
    Var1(LDMR4Var1),
}
impl TableLDMR4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LDMR4Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LDMR4Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:16:1"]
#[derive(Clone, Debug)]
struct LDMR5Var0 {}
impl LDMR5Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 6i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:17:1"]
#[derive(Clone, Debug)]
struct LDMR5Var1 {
    LDMR4: TableLDMR4,
}
impl LDMR5Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let LDMR4 = if let Some((len, table)) =
            TableLDMR4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR4 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR5 {
    Var0(LDMR5Var0),
    Var1(LDMR5Var1),
}
impl TableLDMR5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LDMR5Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LDMR5Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:19:1"]
#[derive(Clone, Debug)]
struct LDMR6Var0 {}
impl LDMR6Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 7i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:20:1"]
#[derive(Clone, Debug)]
struct LDMR6Var1 {
    LDMR5: TableLDMR5,
}
impl LDMR6Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let LDMR5 = if let Some((len, table)) =
            TableLDMR5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR5 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR6 {
    Var0(LDMR6Var0),
    Var1(LDMR6Var1),
}
impl TableLDMR6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LDMR6Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LDMR6Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:22:1"]
#[derive(Clone, Debug)]
struct LDMR7Var0 {}
impl LDMR7Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 8i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:23:1"]
#[derive(Clone, Debug)]
struct LDMR7Var1 {
    LDMR6: TableLDMR6,
}
impl LDMR7Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let LDMR6 = if let Some((len, table)) =
            TableLDMR6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR6 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR7 {
    Var0(LDMR7Var0),
    Var1(LDMR7Var1),
}
impl TableLDMR7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LDMR7Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LDMR7Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:25:1"]
#[derive(Clone, Debug)]
struct LDMR8Var0 {}
impl LDMR8Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 9i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:26:1"]
#[derive(Clone, Debug)]
struct LDMR8Var1 {
    LDMR7: TableLDMR7,
}
impl LDMR8Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let LDMR7 = if let Some((len, table)) =
            TableLDMR7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR7 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR8 {
    Var0(LDMR8Var0),
    Var1(LDMR8Var1),
}
impl TableLDMR8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LDMR8Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LDMR8Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:28:1"]
#[derive(Clone, Debug)]
struct LDMR9Var0 {}
impl LDMR9Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 10i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:29:1"]
#[derive(Clone, Debug)]
struct LDMR9Var1 {
    LDMR8: TableLDMR8,
}
impl LDMR9Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let LDMR8 = if let Some((len, table)) =
            TableLDMR8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR8 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR9 {
    Var0(LDMR9Var0),
    Var1(LDMR9Var1),
}
impl TableLDMR9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LDMR9Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LDMR9Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:31:1"]
#[derive(Clone, Debug)]
struct LDMR10Var0 {}
impl LDMR10Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 11i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:32:1"]
#[derive(Clone, Debug)]
struct LDMR10Var1 {
    LDMR9: TableLDMR9,
}
impl LDMR10Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let LDMR9 = if let Some((len, table)) =
            TableLDMR9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR9 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR10 {
    Var0(LDMR10Var0),
    Var1(LDMR10Var1),
}
impl TableLDMR10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LDMR10Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LDMR10Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:34:1"]
#[derive(Clone, Debug)]
struct LDMR11Var0 {}
impl LDMR11Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 12i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:35:1"]
#[derive(Clone, Debug)]
struct LDMR11Var1 {
    LDMR10: TableLDMR10,
}
impl LDMR11Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let LDMR10 = if let Some((len, table)) = TableLDMR10::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR10 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR11 {
    Var0(LDMR11Var0),
    Var1(LDMR11Var1),
}
impl TableLDMR11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LDMR11Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LDMR11Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:37:1"]
#[derive(Clone, Debug)]
struct LDMR12Var0 {}
impl LDMR12Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 13i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:38:1"]
#[derive(Clone, Debug)]
struct LDMR12Var1 {
    LDMR11: TableLDMR11,
}
impl LDMR12Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let LDMR11 = if let Some((len, table)) = TableLDMR11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR11 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR12 {
    Var0(LDMR12Var0),
    Var1(LDMR12Var1),
}
impl TableLDMR12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LDMR12Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LDMR12Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:40:1"]
#[derive(Clone, Debug)]
struct LDMR13Var0 {}
impl LDMR13Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 14i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:41:1"]
#[derive(Clone, Debug)]
struct LDMR13Var1 {
    LDMR12: TableLDMR12,
}
impl LDMR13Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let LDMR12 = if let Some((len, table)) = TableLDMR12::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR12 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR13 {
    Var0(LDMR13Var0),
    Var1(LDMR13Var1),
}
impl TableLDMR13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LDMR13Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LDMR13Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:43:1"]
#[derive(Clone, Debug)]
struct LDMR14Var0 {}
impl LDMR14Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 15i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:44:1"]
#[derive(Clone, Debug)]
struct LDMR14Var1 {
    LDMR13: TableLDMR13,
}
impl LDMR14Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let LDMR13 = if let Some((len, table)) = TableLDMR13::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR13 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR14 {
    Var0(LDMR14Var0),
    Var1(LDMR14Var1),
}
impl TableLDMR14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LDMR14Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LDMR14Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:46:1"]
#[derive(Clone, Debug)]
struct LDMR15Var0 {}
impl LDMR15Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 16i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:47:1"]
#[derive(Clone, Debug)]
struct LDMR15Var1 {
    LDMR14: TableLDMR14,
}
impl LDMR15Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let LDMR14 = if let Some((len, table)) = TableLDMR14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR14 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR15 {
    Var0(LDMR15Var0),
    Var1(LDMR15Var1),
}
impl TableLDMR15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LDMR15Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LDMR15Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:49:1"]
#[derive(Clone, Debug)]
struct LDMR16Var0 {}
impl LDMR16Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 17i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:50:1"]
#[derive(Clone, Debug)]
struct LDMR16Var1 {
    LDMR15: TableLDMR15,
}
impl LDMR16Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let LDMR15 = if let Some((len, table)) = TableLDMR15::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR15 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR16 {
    Var0(LDMR16Var0),
    Var1(LDMR16Var1),
}
impl TableLDMR16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LDMR16Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LDMR16Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:52:1"]
#[derive(Clone, Debug)]
struct LDMR17Var0 {}
impl LDMR17Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 18i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:53:1"]
#[derive(Clone, Debug)]
struct LDMR17Var1 {
    LDMR16: TableLDMR16,
}
impl LDMR17Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let LDMR16 = if let Some((len, table)) = TableLDMR16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR16 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR17 {
    Var0(LDMR17Var0),
    Var1(LDMR17Var1),
}
impl TableLDMR17 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LDMR17Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LDMR17Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:55:1"]
#[derive(Clone, Debug)]
struct LDMR18Var0 {}
impl LDMR18Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 19i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:56:1"]
#[derive(Clone, Debug)]
struct LDMR18Var1 {
    LDMR17: TableLDMR17,
}
impl LDMR18Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let LDMR17 = if let Some((len, table)) = TableLDMR17::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR17 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR18 {
    Var0(LDMR18Var0),
    Var1(LDMR18Var1),
}
impl TableLDMR18 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LDMR18Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LDMR18Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:58:1"]
#[derive(Clone, Debug)]
struct LDMR19Var0 {}
impl LDMR19Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 20i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:59:1"]
#[derive(Clone, Debug)]
struct LDMR19Var1 {
    LDMR18: TableLDMR18,
}
impl LDMR19Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let LDMR18 = if let Some((len, table)) = TableLDMR18::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR18 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR19 {
    Var0(LDMR19Var0),
    Var1(LDMR19Var1),
}
impl TableLDMR19 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LDMR19Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LDMR19Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:61:1"]
#[derive(Clone, Debug)]
struct LDMR20Var0 {}
impl LDMR20Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 21i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:62:1"]
#[derive(Clone, Debug)]
struct LDMR20Var1 {
    LDMR19: TableLDMR19,
}
impl LDMR20Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let LDMR19 = if let Some((len, table)) = TableLDMR19::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR19 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR20 {
    Var0(LDMR20Var0),
    Var1(LDMR20Var1),
}
impl TableLDMR20 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LDMR20Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LDMR20Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:64:1"]
#[derive(Clone, Debug)]
struct LDMR21Var0 {}
impl LDMR21Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 22i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:65:1"]
#[derive(Clone, Debug)]
struct LDMR21Var1 {
    LDMR20: TableLDMR20,
}
impl LDMR21Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let LDMR20 = if let Some((len, table)) = TableLDMR20::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR20 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR21 {
    Var0(LDMR21Var0),
    Var1(LDMR21Var1),
}
impl TableLDMR21 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LDMR21Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LDMR21Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:67:1"]
#[derive(Clone, Debug)]
struct LDMR22Var0 {}
impl LDMR22Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 23i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:68:1"]
#[derive(Clone, Debug)]
struct LDMR22Var1 {
    LDMR21: TableLDMR21,
}
impl LDMR22Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let LDMR21 = if let Some((len, table)) = TableLDMR21::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR21 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR22 {
    Var0(LDMR22Var0),
    Var1(LDMR22Var1),
}
impl TableLDMR22 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LDMR22Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LDMR22Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:70:1"]
#[derive(Clone, Debug)]
struct LDMR23Var0 {}
impl LDMR23Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 24i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:71:1"]
#[derive(Clone, Debug)]
struct LDMR23Var1 {
    LDMR22: TableLDMR22,
}
impl LDMR23Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let LDMR22 = if let Some((len, table)) = TableLDMR22::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR22 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR23 {
    Var0(LDMR23Var0),
    Var1(LDMR23Var1),
}
impl TableLDMR23 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LDMR23Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LDMR23Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:73:1"]
#[derive(Clone, Debug)]
struct LDMR24Var0 {}
impl LDMR24Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 25i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:74:1"]
#[derive(Clone, Debug)]
struct LDMR24Var1 {
    LDMR23: TableLDMR23,
}
impl LDMR24Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let LDMR23 = if let Some((len, table)) = TableLDMR23::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR23 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR24 {
    Var0(LDMR24Var0),
    Var1(LDMR24Var1),
}
impl TableLDMR24 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LDMR24Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LDMR24Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:76:1"]
#[derive(Clone, Debug)]
struct LDMR25Var0 {}
impl LDMR25Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 26i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:77:1"]
#[derive(Clone, Debug)]
struct LDMR25Var1 {
    LDMR24: TableLDMR24,
}
impl LDMR25Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let LDMR24 = if let Some((len, table)) = TableLDMR24::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR24 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR25 {
    Var0(LDMR25Var0),
    Var1(LDMR25Var1),
}
impl TableLDMR25 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LDMR25Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LDMR25Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:79:1"]
#[derive(Clone, Debug)]
struct LDMR26Var0 {}
impl LDMR26Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 27i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:80:1"]
#[derive(Clone, Debug)]
struct LDMR26Var1 {
    LDMR25: TableLDMR25,
}
impl LDMR26Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let LDMR25 = if let Some((len, table)) = TableLDMR25::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR25 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR26 {
    Var0(LDMR26Var0),
    Var1(LDMR26Var1),
}
impl TableLDMR26 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LDMR26Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LDMR26Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:82:1"]
#[derive(Clone, Debug)]
struct LDMR27Var0 {}
impl LDMR27Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 28i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:83:1"]
#[derive(Clone, Debug)]
struct LDMR27Var1 {
    LDMR26: TableLDMR26,
}
impl LDMR27Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let LDMR26 = if let Some((len, table)) = TableLDMR26::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR26 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR27 {
    Var0(LDMR27Var0),
    Var1(LDMR27Var1),
}
impl TableLDMR27 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LDMR27Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LDMR27Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:85:1"]
#[derive(Clone, Debug)]
struct LDMR28Var0 {}
impl LDMR28Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 29i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:86:1"]
#[derive(Clone, Debug)]
struct LDMR28Var1 {
    LDMR27: TableLDMR27,
}
impl LDMR28Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let LDMR27 = if let Some((len, table)) = TableLDMR27::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR27 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR28 {
    Var0(LDMR28Var0),
    Var1(LDMR28Var1),
}
impl TableLDMR28 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LDMR28Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LDMR28Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:88:1"]
#[derive(Clone, Debug)]
struct LDMR29Var0 {}
impl LDMR29Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 30i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:89:1"]
#[derive(Clone, Debug)]
struct LDMR29Var1 {
    LDMR28: TableLDMR28,
}
impl LDMR29Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let LDMR28 = if let Some((len, table)) = TableLDMR28::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR28 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR29 {
    Var0(LDMR29Var0),
    Var1(LDMR29Var1),
}
impl TableLDMR29 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LDMR29Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LDMR29Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:91:1"]
#[derive(Clone, Debug)]
struct LDMR30Var0 {}
impl LDMR30Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 31i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:92:1"]
#[derive(Clone, Debug)]
struct LDMR30Var1 {
    LDMR29: TableLDMR29,
}
impl LDMR30Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let LDMR29 = if let Some((len, table)) = TableLDMR29::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR29 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR30 {
    Var0(LDMR30Var0),
    Var1(LDMR30Var1),
}
impl TableLDMR30 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LDMR30Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            LDMR30Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc:94:1"]
#[derive(Clone, Debug)]
struct LDMR31Var0 {
    LDMR30: TableLDMR30,
}
impl LDMR31Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let LDMR30 = if let Some((len, table)) = TableLDMR30::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR30 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR31 {
    Var0(LDMR31Var0),
}
impl TableLDMR31 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            LDMR31Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc:4:1"]
#[derive(Clone, Debug)]
struct DYN_D1Var0 {
    BITS_21_25: TokenField_BITS_21_25,
}
impl DYN_D1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_regaddr: i64 = 0;
        calc_regaddr = (self.BITS_21_25.disassembly().wrapping_add(1i64)
            & 31i64)
            .wrapping_mul(4i64);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_regaddr)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_regaddr: i64 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        calc_regaddr = (token_parser
            .TokenFieldBITS_21_25()
            .disassembly()
            .wrapping_add(1i64)
            & 31i64)
            .wrapping_mul(4i64);
        let BITS_21_25 = token_parser.TokenFieldBITS_21_25();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BITS_21_25 }))
    }
}
#[derive(Clone, Debug)]
enum TableDYN_D1 {
    Var0(DYN_D1Var0),
}
impl TableDYN_D1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            DYN_D1Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc:5:1"]
#[derive(Clone, Debug)]
struct DYN_D2Var0 {
    BITS_21_25: TokenField_BITS_21_25,
}
impl DYN_D2Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_regaddr: i64 = 0;
        calc_regaddr = (self.BITS_21_25.disassembly().wrapping_add(2i64)
            & 31i64)
            .wrapping_mul(4i64);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_regaddr)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_regaddr: i64 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        calc_regaddr = (token_parser
            .TokenFieldBITS_21_25()
            .disassembly()
            .wrapping_add(2i64)
            & 31i64)
            .wrapping_mul(4i64);
        let BITS_21_25 = token_parser.TokenFieldBITS_21_25();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BITS_21_25 }))
    }
}
#[derive(Clone, Debug)]
enum TableDYN_D2 {
    Var0(DYN_D2Var0),
}
impl TableDYN_D2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            DYN_D2Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc:6:1"]
#[derive(Clone, Debug)]
struct DYN_D3Var0 {
    BITS_21_25: TokenField_BITS_21_25,
}
impl DYN_D3Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_regaddr: i64 = 0;
        calc_regaddr = (self.BITS_21_25.disassembly().wrapping_add(3i64)
            & 31i64)
            .wrapping_mul(4i64);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_regaddr)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_regaddr: i64 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        calc_regaddr = (token_parser
            .TokenFieldBITS_21_25()
            .disassembly()
            .wrapping_add(3i64)
            & 31i64)
            .wrapping_mul(4i64);
        let BITS_21_25 = token_parser.TokenFieldBITS_21_25();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BITS_21_25 }))
    }
}
#[derive(Clone, Debug)]
enum TableDYN_D3 {
    Var0(DYN_D3Var0),
}
impl TableDYN_D3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            DYN_D3Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc:7:1"]
#[derive(Clone, Debug)]
struct DYN_D4Var0 {
    BITS_21_25: TokenField_BITS_21_25,
}
impl DYN_D4Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_regaddr: i64 = 0;
        calc_regaddr = (self.BITS_21_25.disassembly().wrapping_add(4i64)
            & 31i64)
            .wrapping_mul(4i64);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_regaddr)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_regaddr: i64 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        calc_regaddr = (token_parser
            .TokenFieldBITS_21_25()
            .disassembly()
            .wrapping_add(4i64)
            & 31i64)
            .wrapping_mul(4i64);
        let BITS_21_25 = token_parser.TokenFieldBITS_21_25();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BITS_21_25 }))
    }
}
#[derive(Clone, Debug)]
enum TableDYN_D4 {
    Var0(DYN_D4Var0),
}
impl TableDYN_D4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            DYN_D4Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc:8:1"]
#[derive(Clone, Debug)]
struct DYN_D5Var0 {
    BITS_21_25: TokenField_BITS_21_25,
}
impl DYN_D5Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_regaddr: i64 = 0;
        calc_regaddr = (self.BITS_21_25.disassembly().wrapping_add(5i64)
            & 31i64)
            .wrapping_mul(4i64);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_regaddr)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_regaddr: i64 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        calc_regaddr = (token_parser
            .TokenFieldBITS_21_25()
            .disassembly()
            .wrapping_add(5i64)
            & 31i64)
            .wrapping_mul(4i64);
        let BITS_21_25 = token_parser.TokenFieldBITS_21_25();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BITS_21_25 }))
    }
}
#[derive(Clone, Debug)]
enum TableDYN_D5 {
    Var0(DYN_D5Var0),
}
impl TableDYN_D5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            DYN_D5Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc:9:1"]
#[derive(Clone, Debug)]
struct DYN_D6Var0 {
    BITS_21_25: TokenField_BITS_21_25,
}
impl DYN_D6Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_regaddr: i64 = 0;
        calc_regaddr = (self.BITS_21_25.disassembly().wrapping_add(6i64)
            & 31i64)
            .wrapping_mul(4i64);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_regaddr)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_regaddr: i64 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        calc_regaddr = (token_parser
            .TokenFieldBITS_21_25()
            .disassembly()
            .wrapping_add(6i64)
            & 31i64)
            .wrapping_mul(4i64);
        let BITS_21_25 = token_parser.TokenFieldBITS_21_25();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BITS_21_25 }))
    }
}
#[derive(Clone, Debug)]
enum TableDYN_D6 {
    Var0(DYN_D6Var0),
}
impl TableDYN_D6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            DYN_D6Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc:10:1"]
#[derive(Clone, Debug)]
struct DYN_D7Var0 {
    BITS_21_25: TokenField_BITS_21_25,
}
impl DYN_D7Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_regaddr: i64 = 0;
        calc_regaddr = (self.BITS_21_25.disassembly().wrapping_add(7i64)
            & 31i64)
            .wrapping_mul(4i64);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_regaddr)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_regaddr: i64 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        calc_regaddr = (token_parser
            .TokenFieldBITS_21_25()
            .disassembly()
            .wrapping_add(7i64)
            & 31i64)
            .wrapping_mul(4i64);
        let BITS_21_25 = token_parser.TokenFieldBITS_21_25();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BITS_21_25 }))
    }
}
#[derive(Clone, Debug)]
enum TableDYN_D7 {
    Var0(DYN_D7Var0),
}
impl TableDYN_D7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            DYN_D7Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc:3177:1"]
#[derive(Clone, Debug)]
struct CRM_valVar0 {
    CRM: TokenField_CRM,
}
impl CRM_valVar0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_crmval: i64 = 0;
        calc_crmval = self.CRM.disassembly().wrapping_add(0i64);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_crmval)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_crmval: i64 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        calc_crmval = token_parser
            .TokenFieldCRM()
            .disassembly()
            .wrapping_add(0i64);
        let CRM = token_parser.TokenFieldCRM();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CRM }))
    }
}
#[derive(Clone, Debug)]
enum TableCRM_val {
    Var0(CRM_valVar0),
}
impl TableCRM_val {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            CRM_valVar0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:1:1"]
#[derive(Clone, Debug)]
struct STMR0Var0 {}
impl STMR0Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 1i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:2:1"]
#[derive(Clone, Debug)]
struct STMR0Var1 {}
impl STMR0Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR0 {
    Var0(STMR0Var0),
    Var1(STMR0Var1),
}
impl TableSTMR0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            STMR0Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            STMR0Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:4:1"]
#[derive(Clone, Debug)]
struct STMR1Var0 {}
impl STMR1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 2i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:5:1"]
#[derive(Clone, Debug)]
struct STMR1Var1 {
    STMR0: TableSTMR0,
}
impl STMR1Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let STMR0 = if let Some((len, table)) =
            TableSTMR0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR0 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR1 {
    Var0(STMR1Var0),
    Var1(STMR1Var1),
}
impl TableSTMR1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            STMR1Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            STMR1Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:7:1"]
#[derive(Clone, Debug)]
struct STMR2Var0 {}
impl STMR2Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 3i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:8:1"]
#[derive(Clone, Debug)]
struct STMR2Var1 {
    STMR1: TableSTMR1,
}
impl STMR2Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let STMR1 = if let Some((len, table)) =
            TableSTMR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR1 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR2 {
    Var0(STMR2Var0),
    Var1(STMR2Var1),
}
impl TableSTMR2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            STMR2Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            STMR2Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:10:1"]
#[derive(Clone, Debug)]
struct STMR3Var0 {}
impl STMR3Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 4i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:11:1"]
#[derive(Clone, Debug)]
struct STMR3Var1 {
    STMR2: TableSTMR2,
}
impl STMR3Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let STMR2 = if let Some((len, table)) =
            TableSTMR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR2 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR3 {
    Var0(STMR3Var0),
    Var1(STMR3Var1),
}
impl TableSTMR3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            STMR3Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            STMR3Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:13:1"]
#[derive(Clone, Debug)]
struct STMR4Var0 {}
impl STMR4Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 5i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:14:1"]
#[derive(Clone, Debug)]
struct STMR4Var1 {
    STMR3: TableSTMR3,
}
impl STMR4Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let STMR3 = if let Some((len, table)) =
            TableSTMR3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR3 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR4 {
    Var0(STMR4Var0),
    Var1(STMR4Var1),
}
impl TableSTMR4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            STMR4Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            STMR4Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:16:1"]
#[derive(Clone, Debug)]
struct STMR5Var0 {}
impl STMR5Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 6i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:17:1"]
#[derive(Clone, Debug)]
struct STMR5Var1 {
    STMR4: TableSTMR4,
}
impl STMR5Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let STMR4 = if let Some((len, table)) =
            TableSTMR4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR4 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR5 {
    Var0(STMR5Var0),
    Var1(STMR5Var1),
}
impl TableSTMR5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            STMR5Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            STMR5Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:19:1"]
#[derive(Clone, Debug)]
struct STMR6Var0 {}
impl STMR6Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 7i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:20:1"]
#[derive(Clone, Debug)]
struct STMR6Var1 {
    STMR5: TableSTMR5,
}
impl STMR6Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let STMR5 = if let Some((len, table)) =
            TableSTMR5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR5 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR6 {
    Var0(STMR6Var0),
    Var1(STMR6Var1),
}
impl TableSTMR6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            STMR6Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            STMR6Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:22:1"]
#[derive(Clone, Debug)]
struct STMR7Var0 {}
impl STMR7Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 8i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:23:1"]
#[derive(Clone, Debug)]
struct STMR7Var1 {
    STMR6: TableSTMR6,
}
impl STMR7Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let STMR6 = if let Some((len, table)) =
            TableSTMR6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR6 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR7 {
    Var0(STMR7Var0),
    Var1(STMR7Var1),
}
impl TableSTMR7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            STMR7Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            STMR7Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:25:1"]
#[derive(Clone, Debug)]
struct STMR8Var0 {}
impl STMR8Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 9i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:26:1"]
#[derive(Clone, Debug)]
struct STMR8Var1 {
    STMR7: TableSTMR7,
}
impl STMR8Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let STMR7 = if let Some((len, table)) =
            TableSTMR7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR7 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR8 {
    Var0(STMR8Var0),
    Var1(STMR8Var1),
}
impl TableSTMR8 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            STMR8Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            STMR8Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:28:1"]
#[derive(Clone, Debug)]
struct STMR9Var0 {}
impl STMR9Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 10i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:29:1"]
#[derive(Clone, Debug)]
struct STMR9Var1 {
    STMR8: TableSTMR8,
}
impl STMR9Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let STMR8 = if let Some((len, table)) =
            TableSTMR8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR8 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR9 {
    Var0(STMR9Var0),
    Var1(STMR9Var1),
}
impl TableSTMR9 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            STMR9Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            STMR9Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:31:1"]
#[derive(Clone, Debug)]
struct STMR10Var0 {}
impl STMR10Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 11i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:32:1"]
#[derive(Clone, Debug)]
struct STMR10Var1 {
    STMR9: TableSTMR9,
}
impl STMR10Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let STMR9 = if let Some((len, table)) =
            TableSTMR9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR9 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR10 {
    Var0(STMR10Var0),
    Var1(STMR10Var1),
}
impl TableSTMR10 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            STMR10Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            STMR10Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:34:1"]
#[derive(Clone, Debug)]
struct STMR11Var0 {}
impl STMR11Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 12i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:35:1"]
#[derive(Clone, Debug)]
struct STMR11Var1 {
    STMR10: TableSTMR10,
}
impl STMR11Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let STMR10 = if let Some((len, table)) = TableSTMR10::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR10 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR11 {
    Var0(STMR11Var0),
    Var1(STMR11Var1),
}
impl TableSTMR11 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            STMR11Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            STMR11Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:37:1"]
#[derive(Clone, Debug)]
struct STMR12Var0 {}
impl STMR12Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 13i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:38:1"]
#[derive(Clone, Debug)]
struct STMR12Var1 {
    STMR11: TableSTMR11,
}
impl STMR12Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let STMR11 = if let Some((len, table)) = TableSTMR11::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR11 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR12 {
    Var0(STMR12Var0),
    Var1(STMR12Var1),
}
impl TableSTMR12 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            STMR12Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            STMR12Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:40:1"]
#[derive(Clone, Debug)]
struct STMR13Var0 {}
impl STMR13Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 14i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:41:1"]
#[derive(Clone, Debug)]
struct STMR13Var1 {
    STMR12: TableSTMR12,
}
impl STMR13Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let STMR12 = if let Some((len, table)) = TableSTMR12::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR12 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR13 {
    Var0(STMR13Var0),
    Var1(STMR13Var1),
}
impl TableSTMR13 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            STMR13Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            STMR13Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:43:1"]
#[derive(Clone, Debug)]
struct STMR14Var0 {}
impl STMR14Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 15i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:44:1"]
#[derive(Clone, Debug)]
struct STMR14Var1 {
    STMR13: TableSTMR13,
}
impl STMR14Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let STMR13 = if let Some((len, table)) = TableSTMR13::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR13 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR14 {
    Var0(STMR14Var0),
    Var1(STMR14Var1),
}
impl TableSTMR14 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            STMR14Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            STMR14Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:46:1"]
#[derive(Clone, Debug)]
struct STMR15Var0 {}
impl STMR15Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 16i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:47:1"]
#[derive(Clone, Debug)]
struct STMR15Var1 {
    STMR14: TableSTMR14,
}
impl STMR15Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let STMR14 = if let Some((len, table)) = TableSTMR14::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR14 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR15 {
    Var0(STMR15Var0),
    Var1(STMR15Var1),
}
impl TableSTMR15 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            STMR15Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            STMR15Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:49:1"]
#[derive(Clone, Debug)]
struct STMR16Var0 {}
impl STMR16Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 17i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:50:1"]
#[derive(Clone, Debug)]
struct STMR16Var1 {
    STMR15: TableSTMR15,
}
impl STMR16Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let STMR15 = if let Some((len, table)) = TableSTMR15::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR15 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR16 {
    Var0(STMR16Var0),
    Var1(STMR16Var1),
}
impl TableSTMR16 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            STMR16Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            STMR16Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:52:1"]
#[derive(Clone, Debug)]
struct STMR17Var0 {}
impl STMR17Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 18i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:53:1"]
#[derive(Clone, Debug)]
struct STMR17Var1 {
    STMR16: TableSTMR16,
}
impl STMR17Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let STMR16 = if let Some((len, table)) = TableSTMR16::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR16 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR17 {
    Var0(STMR17Var0),
    Var1(STMR17Var1),
}
impl TableSTMR17 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            STMR17Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            STMR17Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:55:1"]
#[derive(Clone, Debug)]
struct STMR18Var0 {}
impl STMR18Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 19i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:56:1"]
#[derive(Clone, Debug)]
struct STMR18Var1 {
    STMR17: TableSTMR17,
}
impl STMR18Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let STMR17 = if let Some((len, table)) = TableSTMR17::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR17 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR18 {
    Var0(STMR18Var0),
    Var1(STMR18Var1),
}
impl TableSTMR18 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            STMR18Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            STMR18Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:58:1"]
#[derive(Clone, Debug)]
struct STMR19Var0 {}
impl STMR19Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 20i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:59:1"]
#[derive(Clone, Debug)]
struct STMR19Var1 {
    STMR18: TableSTMR18,
}
impl STMR19Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let STMR18 = if let Some((len, table)) = TableSTMR18::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR18 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR19 {
    Var0(STMR19Var0),
    Var1(STMR19Var1),
}
impl TableSTMR19 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            STMR19Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            STMR19Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:61:1"]
#[derive(Clone, Debug)]
struct STMR20Var0 {}
impl STMR20Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 21i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:62:1"]
#[derive(Clone, Debug)]
struct STMR20Var1 {
    STMR19: TableSTMR19,
}
impl STMR20Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let STMR19 = if let Some((len, table)) = TableSTMR19::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR19 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR20 {
    Var0(STMR20Var0),
    Var1(STMR20Var1),
}
impl TableSTMR20 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            STMR20Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            STMR20Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:64:1"]
#[derive(Clone, Debug)]
struct STMR21Var0 {}
impl STMR21Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 22i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:65:1"]
#[derive(Clone, Debug)]
struct STMR21Var1 {
    STMR20: TableSTMR20,
}
impl STMR21Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let STMR20 = if let Some((len, table)) = TableSTMR20::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR20 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR21 {
    Var0(STMR21Var0),
    Var1(STMR21Var1),
}
impl TableSTMR21 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            STMR21Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            STMR21Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:67:1"]
#[derive(Clone, Debug)]
struct STMR22Var0 {}
impl STMR22Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 23i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:68:1"]
#[derive(Clone, Debug)]
struct STMR22Var1 {
    STMR21: TableSTMR21,
}
impl STMR22Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let STMR21 = if let Some((len, table)) = TableSTMR21::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR21 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR22 {
    Var0(STMR22Var0),
    Var1(STMR22Var1),
}
impl TableSTMR22 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            STMR22Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            STMR22Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:70:1"]
#[derive(Clone, Debug)]
struct STMR23Var0 {}
impl STMR23Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 24i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:71:1"]
#[derive(Clone, Debug)]
struct STMR23Var1 {
    STMR22: TableSTMR22,
}
impl STMR23Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let STMR22 = if let Some((len, table)) = TableSTMR22::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR22 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR23 {
    Var0(STMR23Var0),
    Var1(STMR23Var1),
}
impl TableSTMR23 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            STMR23Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            STMR23Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:73:1"]
#[derive(Clone, Debug)]
struct STMR24Var0 {}
impl STMR24Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 25i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:74:1"]
#[derive(Clone, Debug)]
struct STMR24Var1 {
    STMR23: TableSTMR23,
}
impl STMR24Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let STMR23 = if let Some((len, table)) = TableSTMR23::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR23 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR24 {
    Var0(STMR24Var0),
    Var1(STMR24Var1),
}
impl TableSTMR24 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            STMR24Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            STMR24Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:76:1"]
#[derive(Clone, Debug)]
struct STMR25Var0 {}
impl STMR25Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 26i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:77:1"]
#[derive(Clone, Debug)]
struct STMR25Var1 {
    STMR24: TableSTMR24,
}
impl STMR25Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let STMR24 = if let Some((len, table)) = TableSTMR24::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR24 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR25 {
    Var0(STMR25Var0),
    Var1(STMR25Var1),
}
impl TableSTMR25 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            STMR25Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            STMR25Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:79:1"]
#[derive(Clone, Debug)]
struct STMR26Var0 {}
impl STMR26Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 27i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:80:1"]
#[derive(Clone, Debug)]
struct STMR26Var1 {
    STMR25: TableSTMR25,
}
impl STMR26Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let STMR25 = if let Some((len, table)) = TableSTMR25::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR25 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR26 {
    Var0(STMR26Var0),
    Var1(STMR26Var1),
}
impl TableSTMR26 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            STMR26Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            STMR26Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:82:1"]
#[derive(Clone, Debug)]
struct STMR27Var0 {}
impl STMR27Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 28i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:83:1"]
#[derive(Clone, Debug)]
struct STMR27Var1 {
    STMR26: TableSTMR26,
}
impl STMR27Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let STMR26 = if let Some((len, table)) = TableSTMR26::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR26 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR27 {
    Var0(STMR27Var0),
    Var1(STMR27Var1),
}
impl TableSTMR27 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            STMR27Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            STMR27Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:85:1"]
#[derive(Clone, Debug)]
struct STMR28Var0 {}
impl STMR28Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 29i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:86:1"]
#[derive(Clone, Debug)]
struct STMR28Var1 {
    STMR27: TableSTMR27,
}
impl STMR28Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let STMR27 = if let Some((len, table)) = TableSTMR27::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR27 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR28 {
    Var0(STMR28Var0),
    Var1(STMR28Var1),
}
impl TableSTMR28 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            STMR28Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            STMR28Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:88:1"]
#[derive(Clone, Debug)]
struct STMR29Var0 {}
impl STMR29Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 30i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:89:1"]
#[derive(Clone, Debug)]
struct STMR29Var1 {
    STMR28: TableSTMR28,
}
impl STMR29Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let STMR28 = if let Some((len, table)) = TableSTMR28::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR28 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR29 {
    Var0(STMR29Var0),
    Var1(STMR29Var1),
}
impl TableSTMR29 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            STMR29Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            STMR29Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:91:1"]
#[derive(Clone, Debug)]
struct STMR30Var0 {}
impl STMR30Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        if context_instance.register().read_lsmul_disassembly() != 31i64 {
            return None;
        }
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:92:1"]
#[derive(Clone, Debug)]
struct STMR30Var1 {
    STMR29: TableSTMR29,
}
impl STMR30Var1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let STMR29 = if let Some((len, table)) = TableSTMR29::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR29 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR30 {
    Var0(STMR30Var0),
    Var1(STMR30Var1),
}
impl TableSTMR30 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            STMR30Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        if let Some((inst_len, parsed)) =
            STMR30Var1::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc:94:1"]
#[derive(Clone, Debug)]
struct STMR31Var0 {
    STMR30: TableSTMR30,
}
impl STMR31Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut block_0_len = 0u64 as u32;
        let STMR30 = if let Some((len, table)) = TableSTMR30::parse(
            tokens_current,
            &mut context_instance,
            inst_start,
        ) {
            block_0_len = block_0_len.max(len as u32);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR30 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR31 {
    Var0(STMR31Var0),
}
impl TableSTMR31 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            STMR31Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc:5:1"]
#[derive(Clone, Debug)]
struct DYN_S1Var0 {
    BITS_21_25: TokenField_BITS_21_25,
}
impl DYN_S1Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_regaddr: i64 = 0;
        calc_regaddr = (self.BITS_21_25.disassembly().wrapping_add(1i64)
            & 31i64)
            .wrapping_mul(4i64);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_regaddr)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_regaddr: i64 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        calc_regaddr = (token_parser
            .TokenFieldBITS_21_25()
            .disassembly()
            .wrapping_add(1i64)
            & 31i64)
            .wrapping_mul(4i64);
        let BITS_21_25 = token_parser.TokenFieldBITS_21_25();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BITS_21_25 }))
    }
}
#[derive(Clone, Debug)]
enum TableDYN_S1 {
    Var0(DYN_S1Var0),
}
impl TableDYN_S1 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            DYN_S1Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc:6:1"]
#[derive(Clone, Debug)]
struct DYN_S2Var0 {
    BITS_21_25: TokenField_BITS_21_25,
}
impl DYN_S2Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_regaddr: i64 = 0;
        calc_regaddr = (self.BITS_21_25.disassembly().wrapping_add(2i64)
            & 31i64)
            .wrapping_mul(4i64);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_regaddr)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_regaddr: i64 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        calc_regaddr = (token_parser
            .TokenFieldBITS_21_25()
            .disassembly()
            .wrapping_add(2i64)
            & 31i64)
            .wrapping_mul(4i64);
        let BITS_21_25 = token_parser.TokenFieldBITS_21_25();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BITS_21_25 }))
    }
}
#[derive(Clone, Debug)]
enum TableDYN_S2 {
    Var0(DYN_S2Var0),
}
impl TableDYN_S2 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            DYN_S2Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc:7:1"]
#[derive(Clone, Debug)]
struct DYN_S3Var0 {
    BITS_21_25: TokenField_BITS_21_25,
}
impl DYN_S3Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_regaddr: i64 = 0;
        calc_regaddr = (self.BITS_21_25.disassembly().wrapping_add(3i64)
            & 31i64)
            .wrapping_mul(4i64);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_regaddr)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_regaddr: i64 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        calc_regaddr = (token_parser
            .TokenFieldBITS_21_25()
            .disassembly()
            .wrapping_add(3i64)
            & 31i64)
            .wrapping_mul(4i64);
        let BITS_21_25 = token_parser.TokenFieldBITS_21_25();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BITS_21_25 }))
    }
}
#[derive(Clone, Debug)]
enum TableDYN_S3 {
    Var0(DYN_S3Var0),
}
impl TableDYN_S3 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            DYN_S3Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc:8:1"]
#[derive(Clone, Debug)]
struct DYN_S4Var0 {
    BITS_21_25: TokenField_BITS_21_25,
}
impl DYN_S4Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_regaddr: i64 = 0;
        calc_regaddr = (self.BITS_21_25.disassembly().wrapping_add(4i64)
            & 31i64)
            .wrapping_mul(4i64);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_regaddr)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_regaddr: i64 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        calc_regaddr = (token_parser
            .TokenFieldBITS_21_25()
            .disassembly()
            .wrapping_add(4i64)
            & 31i64)
            .wrapping_mul(4i64);
        let BITS_21_25 = token_parser.TokenFieldBITS_21_25();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BITS_21_25 }))
    }
}
#[derive(Clone, Debug)]
enum TableDYN_S4 {
    Var0(DYN_S4Var0),
}
impl TableDYN_S4 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            DYN_S4Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc:9:1"]
#[derive(Clone, Debug)]
struct DYN_S5Var0 {
    BITS_21_25: TokenField_BITS_21_25,
}
impl DYN_S5Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_regaddr: i64 = 0;
        calc_regaddr = (self.BITS_21_25.disassembly().wrapping_add(5i64)
            & 31i64)
            .wrapping_mul(4i64);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_regaddr)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_regaddr: i64 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        calc_regaddr = (token_parser
            .TokenFieldBITS_21_25()
            .disassembly()
            .wrapping_add(5i64)
            & 31i64)
            .wrapping_mul(4i64);
        let BITS_21_25 = token_parser.TokenFieldBITS_21_25();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BITS_21_25 }))
    }
}
#[derive(Clone, Debug)]
enum TableDYN_S5 {
    Var0(DYN_S5Var0),
}
impl TableDYN_S5 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            DYN_S5Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc:10:1"]
#[derive(Clone, Debug)]
struct DYN_S6Var0 {
    BITS_21_25: TokenField_BITS_21_25,
}
impl DYN_S6Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_regaddr: i64 = 0;
        calc_regaddr = (self.BITS_21_25.disassembly().wrapping_add(6i64)
            & 31i64)
            .wrapping_mul(4i64);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_regaddr)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_regaddr: i64 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        calc_regaddr = (token_parser
            .TokenFieldBITS_21_25()
            .disassembly()
            .wrapping_add(6i64)
            & 31i64)
            .wrapping_mul(4i64);
        let BITS_21_25 = token_parser.TokenFieldBITS_21_25();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BITS_21_25 }))
    }
}
#[derive(Clone, Debug)]
enum TableDYN_S6 {
    Var0(DYN_S6Var0),
}
impl TableDYN_S6 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            DYN_S6Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc:11:1"]
#[derive(Clone, Debug)]
struct DYN_S7Var0 {
    BITS_21_25: TokenField_BITS_21_25,
}
impl DYN_S7Var0 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let mut calc_regaddr: i64 = 0;
        calc_regaddr = (self.BITS_21_25.disassembly().wrapping_add(7i64)
            & 31i64)
            .wrapping_mul(4i64);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, calc_regaddr)];
        display.extend_from_slice(&extend);
    }
    fn parse<T>(
        mut tokens_current: &[u8],
        context: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut pattern_len = 0 as u32;
        let mut context_instance = context.clone();
        let mut calc_regaddr: i64 = 0;
        let mut block_0_len = 4u64 as u32;
        let token_parser = <TokenParser<4usize>>::new(tokens_current)?;
        calc_regaddr = (token_parser
            .TokenFieldBITS_21_25()
            .disassembly()
            .wrapping_add(7i64)
            & 31i64)
            .wrapping_mul(4i64);
        let BITS_21_25 = token_parser.TokenFieldBITS_21_25();
        pattern_len += block_0_len;
        tokens_current =
            &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BITS_21_25 }))
    }
}
#[derive(Clone, Debug)]
enum TableDYN_S7 {
    Var0(DYN_S7Var0),
}
impl TableDYN_S7 {
    fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(
                display,
                context,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    fn parse<T>(
        tokens_param: &[u8],
        context_param: &mut T,
        inst_start: u32,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_len, parsed)) =
            DYN_S7Var0::parse(tokens_param, &mut context_current, inst_start)
        {
            *context_param = context_current;
            return Some((inst_len, Self::Var0(parsed)));
        }
        None
    }
}
pub fn parse_instruction<T>(
    tokens: &[u8],
    context: &mut T,
    inst_start: u32,
    global_set: &mut impl GlobalSetTrait,
) -> Option<(u32, Vec<DisplayElement>)>
where
    T: ContextTrait + Clone,
{
    let (inst_len, instruction) =
        Tableinstruction::parse(tokens, context, inst_start)?;
    let inst_next = inst_start + inst_len;
    let mut display = vec![];
    instruction.display_extend(
        &mut display,
        context,
        inst_start,
        inst_next,
        global_set,
    );
    Some((inst_next, display))
}
