pub fn meaning_94047764607728(value: usize) -> DisplayElement {
    match value {
        0usize => DisplayElement::Register(Register::r8),
        1usize => DisplayElement::Register(Register::r9),
        2usize => DisplayElement::Register(Register::r10),
        3usize => DisplayElement::Register(Register::r11),
        4usize => DisplayElement::Register(Register::r12),
        5usize => DisplayElement::Register(Register::sp),
        6usize => DisplayElement::Register(Register::lr),
        7usize => DisplayElement::Register(Register::pc),
        _ => unreachable!("Invalid Attach Value"),
    }
}
pub fn meaning_94047783056016(value: usize) -> DisplayElement {
    match value {
        0usize => DisplayElement::Register(Register::r0),
        1usize => DisplayElement::Register(Register::r1),
        2usize => DisplayElement::Register(Register::r2),
        3usize => DisplayElement::Register(Register::r3),
        4usize => DisplayElement::Register(Register::r4),
        5usize => DisplayElement::Register(Register::r5),
        6usize => DisplayElement::Register(Register::r6),
        7usize => DisplayElement::Register(Register::r7),
        _ => unreachable!("Invalid Attach Value"),
    }
}
pub fn meaning_94047761878256(value: usize) -> DisplayElement {
    match value {
        0usize => DisplayElement::Register(Register::r0),
        1usize => DisplayElement::Register(Register::r1),
        2usize => DisplayElement::Register(Register::r2),
        3usize => DisplayElement::Register(Register::r3),
        4usize => DisplayElement::Register(Register::r4),
        5usize => DisplayElement::Register(Register::r5),
        6usize => DisplayElement::Register(Register::r6),
        7usize => DisplayElement::Register(Register::r7),
        8usize => DisplayElement::Register(Register::r8),
        9usize => DisplayElement::Register(Register::r9),
        10usize => DisplayElement::Register(Register::r10),
        11usize => DisplayElement::Register(Register::r11),
        12usize => DisplayElement::Register(Register::r12),
        13usize => DisplayElement::Register(Register::sp),
        14usize => DisplayElement::Register(Register::lr),
        15usize => DisplayElement::Register(Register::pc),
        _ => unreachable!("Invalid Attach Value"),
    }
}
pub fn meaning_94047763728944(value: usize) -> DisplayElement {
    match value {
        0usize => DisplayElement::Register(Register::r0),
        1usize => DisplayElement::Register(Register::r1),
        2usize => DisplayElement::Register(Register::r2),
        3usize => DisplayElement::Register(Register::r3),
        4usize => DisplayElement::Register(Register::r4),
        5usize => DisplayElement::Register(Register::r5),
        6usize => DisplayElement::Register(Register::r6),
        7usize => DisplayElement::Register(Register::r7),
        8usize => DisplayElement::Register(Register::r8),
        9usize => DisplayElement::Register(Register::r9),
        10usize => DisplayElement::Register(Register::r10),
        11usize => DisplayElement::Register(Register::r11),
        12usize => DisplayElement::Register(Register::r12),
        13usize => DisplayElement::Register(Register::sp),
        14usize => DisplayElement::Register(Register::lr),
        15usize => DisplayElement::Register(Register::pc),
        _ => unreachable!("Invalid Attach Value"),
    }
}
pub fn meaning_94047824017376(value: usize) -> DisplayElement {
    match value {
        0usize => DisplayElement::Literal("opt0"),
        1usize => DisplayElement::Literal("opt1"),
        2usize => DisplayElement::Literal("OSHST"),
        3usize => DisplayElement::Literal("OSH"),
        4usize => DisplayElement::Literal("opt4"),
        5usize => DisplayElement::Literal("opt5"),
        6usize => DisplayElement::Literal("NSHST"),
        7usize => DisplayElement::Literal("NSH"),
        8usize => DisplayElement::Literal("opt8"),
        9usize => DisplayElement::Literal("opt9"),
        10usize => DisplayElement::Literal("ISHST"),
        11usize => DisplayElement::Literal("ISH"),
        12usize => DisplayElement::Literal("opt12"),
        13usize => DisplayElement::Literal("opt13"),
        14usize => DisplayElement::Literal("ST"),
        15usize => DisplayElement::Literal("SY"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
pub fn meaning_94047773010576(value: usize) -> DisplayElement {
    match value {
        0usize => DisplayElement::Literal("p0"),
        1usize => DisplayElement::Literal("p1"),
        2usize => DisplayElement::Literal("p2"),
        3usize => DisplayElement::Literal("p3"),
        4usize => DisplayElement::Literal("p4"),
        5usize => DisplayElement::Literal("p5"),
        6usize => DisplayElement::Literal("p6"),
        7usize => DisplayElement::Literal("p7"),
        8usize => DisplayElement::Literal("p8"),
        9usize => DisplayElement::Literal("p9"),
        10usize => DisplayElement::Literal("p10"),
        11usize => DisplayElement::Literal("p11"),
        12usize => DisplayElement::Literal("p12"),
        13usize => DisplayElement::Literal("p13"),
        14usize => DisplayElement::Literal("p14"),
        15usize => DisplayElement::Literal("p15"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
pub fn meaning_94047766867488(value: usize) -> DisplayElement {
    match value {
        0usize => DisplayElement::Register(Register::r1),
        2usize => DisplayElement::Register(Register::r3),
        4usize => DisplayElement::Register(Register::r5),
        6usize => DisplayElement::Register(Register::r7),
        8usize => DisplayElement::Register(Register::r9),
        10usize => DisplayElement::Register(Register::r11),
        12usize => DisplayElement::Register(Register::sp),
        _ => unreachable!("Invalid Attach Value"),
    }
}
pub fn meaning_94047773007344(value: usize) -> DisplayElement {
    match value {
        0usize => DisplayElement::Literal("opt0"),
        1usize => DisplayElement::Literal("opt1"),
        2usize => DisplayElement::Literal("opt2"),
        3usize => DisplayElement::Literal("opt3"),
        4usize => DisplayElement::Literal("opt4"),
        5usize => DisplayElement::Literal("opt5"),
        6usize => DisplayElement::Literal("opt6"),
        7usize => DisplayElement::Literal("opt7"),
        8usize => DisplayElement::Literal("opt8"),
        9usize => DisplayElement::Literal("opt9"),
        10usize => DisplayElement::Literal("opt10"),
        11usize => DisplayElement::Literal("opt11"),
        12usize => DisplayElement::Literal("opt12"),
        13usize => DisplayElement::Literal("opt13"),
        14usize => DisplayElement::Literal("opt14"),
        15usize => DisplayElement::Literal("SY"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
pub fn meaning_94047764607584(value: usize) -> DisplayElement {
    match value {
        0usize => DisplayElement::Literal("p0"),
        1usize => DisplayElement::Literal("p1"),
        2usize => DisplayElement::Literal("p2"),
        3usize => DisplayElement::Literal("p3"),
        4usize => DisplayElement::Literal("p4"),
        5usize => DisplayElement::Literal("p5"),
        6usize => DisplayElement::Literal("p6"),
        7usize => DisplayElement::Literal("p7"),
        8usize => DisplayElement::Literal("p8"),
        9usize => DisplayElement::Literal("p9"),
        10usize => DisplayElement::Literal("p10"),
        11usize => DisplayElement::Literal("p11"),
        12usize => DisplayElement::Literal("p12"),
        13usize => DisplayElement::Literal("p13"),
        14usize => DisplayElement::Literal("p14"),
        15usize => DisplayElement::Literal("p15"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
pub fn meaning_94047768585360(value: usize) -> DisplayElement {
    match value {
        0usize => DisplayElement::Register(Register::cr0),
        1usize => DisplayElement::Register(Register::cr1),
        2usize => DisplayElement::Register(Register::cr2),
        3usize => DisplayElement::Register(Register::cr3),
        4usize => DisplayElement::Register(Register::cr4),
        5usize => DisplayElement::Register(Register::cr5),
        6usize => DisplayElement::Register(Register::cr6),
        7usize => DisplayElement::Register(Register::cr7),
        8usize => DisplayElement::Register(Register::cr8),
        9usize => DisplayElement::Register(Register::cr9),
        10usize => DisplayElement::Register(Register::cr10),
        11usize => DisplayElement::Register(Register::cr11),
        12usize => DisplayElement::Register(Register::cr12),
        13usize => DisplayElement::Register(Register::cr13),
        14usize => DisplayElement::Register(Register::cr14),
        15usize => DisplayElement::Register(Register::cr15),
        _ => unreachable!("Invalid Attach Value"),
    }
}
pub fn meaning_94047764607520(value: usize) -> DisplayElement {
    match value {
        0usize => DisplayElement::Register(Register::cr0),
        1usize => DisplayElement::Register(Register::cr1),
        2usize => DisplayElement::Register(Register::cr2),
        3usize => DisplayElement::Register(Register::cr3),
        4usize => DisplayElement::Register(Register::cr4),
        5usize => DisplayElement::Register(Register::cr5),
        6usize => DisplayElement::Register(Register::cr6),
        7usize => DisplayElement::Register(Register::cr7),
        8usize => DisplayElement::Register(Register::cr8),
        9usize => DisplayElement::Register(Register::cr9),
        10usize => DisplayElement::Register(Register::cr10),
        11usize => DisplayElement::Register(Register::cr11),
        12usize => DisplayElement::Register(Register::cr12),
        13usize => DisplayElement::Register(Register::cr13),
        14usize => DisplayElement::Register(Register::cr14),
        15usize => DisplayElement::Register(Register::cr15),
        _ => unreachable!("Invalid Attach Value"),
    }
}
pub fn meaning_94047766862464(value: usize) -> DisplayElement {
    match value {
        0usize => DisplayElement::Register(Register::r0),
        1usize => DisplayElement::Register(Register::r1),
        2usize => DisplayElement::Register(Register::r2),
        3usize => DisplayElement::Register(Register::r3),
        4usize => DisplayElement::Register(Register::r4),
        5usize => DisplayElement::Register(Register::r5),
        6usize => DisplayElement::Register(Register::r6),
        7usize => DisplayElement::Register(Register::r7),
        8usize => DisplayElement::Register(Register::r8),
        9usize => DisplayElement::Register(Register::r9),
        10usize => DisplayElement::Register(Register::r10),
        11usize => DisplayElement::Register(Register::r11),
        12usize => DisplayElement::Register(Register::r12),
        13usize => DisplayElement::Register(Register::sp),
        14usize => DisplayElement::Register(Register::lr),
        15usize => DisplayElement::Register(Register::pc),
        _ => unreachable!("Invalid Attach Value"),
    }
}
pub struct TokenParser32([u8; 4usize]);
impl TokenParser32 {
    pub fn new(data: &[u8]) -> Option<Self> {
        <[u8; 4usize]>::try_from(data).ok().map(Self)
    }
    pub fn dbOption(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_c2021(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 4u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn c2222(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 22u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn addr_puw(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 8u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn Rd0811(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 8u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn c2027(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 20u64 as u32;
        raw_value &= 255u128 as u32;
        raw_value as u8
    }
    pub fn Dn0(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn c2327(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 23u64 as u32;
        raw_value &= 31u128 as u32;
        raw_value as u8
    }
    pub fn thv_bit30(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 14u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn c0002(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn c0808(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 8u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn srsMode(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 31u128 as u32;
        raw_value as u8
    }
    pub fn immed24(&self) -> u32 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 16777215u128 as u32;
        raw_value as u32
    }
    pub fn L7(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 7u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn RdHi(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_c1818(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 2u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn opcode1(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 20u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0505(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 21u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_c2828(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 12u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thc0005(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 63u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0708(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 23u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn Dm0(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn c0010(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 2047u128 as u32;
        raw_value as u16
    }
    pub fn c0711(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 7u64 as u32;
        raw_value &= 31u128 as u32;
        raw_value as u8
    }
    pub fn CRd(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 12u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_Q6(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 22u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_c2424(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 8u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn c1215(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 12u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn c1718(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 17u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn thc0815(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 8u64 as u32;
        raw_value &= 255u128 as u32;
        raw_value as u8
    }
    pub fn Qd0(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 12u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn c0607(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 6u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn ibOption(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0409(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 20u64 as u32;
        raw_value &= 63u128 as u32;
        raw_value as u8
    }
    pub fn thv_cmode(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 24u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thc0606(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 6u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn Rt1215(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 12u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn c1415(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 14u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn c2627(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 26u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn thv_Dd_5(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 28u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_c1718(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 1u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn Dm1(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn imm5(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 3u64 as u32;
        raw_value &= 31u128 as u32;
        raw_value as u8
    }
    pub fn thc0405(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 4u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn Sm0(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn pref(&self) -> u32 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 4294967295u128 as u32;
        raw_value as u32
    }
    pub fn thv_Sm1next(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn part2imm6(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 63u128 as u32;
        raw_value as u8
    }
    pub fn thv_c2122(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 5u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn thv_Rm(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn immed3(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 6u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn thv_Dd_15(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 28u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0015(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 65535u128 as u32;
        raw_value as u16
    }
    pub fn c0507(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 5u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn opcode2(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 5u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn thc0615(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 6u64 as u32;
        raw_value &= 1023u128 as u32;
        raw_value as u16
    }
    pub fn thc0715(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 7u64 as u32;
        raw_value &= 511u128 as u32;
        raw_value as u16
    }
    pub fn thv_c2531(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 9u64 as u32;
        raw_value &= 127u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0405(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 20u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn c0515(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 5u64 as u32;
        raw_value &= 2047u128 as u32;
        raw_value as u16
    }
    pub fn c0012(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 8191u128 as u32;
        raw_value as u16
    }
    pub fn thv_bit00(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_c1719(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 1u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn h1(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 7u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn op12(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 12u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn sftimm(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 7u64 as u32;
        raw_value &= 31u128 as u32;
        raw_value as u8
    }
    pub fn thv_c1010(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 26u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thL8(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 8u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn Rd0810(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 8u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn op9(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 9u64 as u32;
        raw_value &= 127u128 as u32;
        raw_value as u8
    }
    pub fn thv_c2327(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 7u64 as u32;
        raw_value &= 31u128 as u32;
        raw_value as u8
    }
    pub fn thv_c1620(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 31u128 as u32;
        raw_value as u8
    }
    pub fn thc0808(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 8u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thc0505(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 5u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_Dd_7(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 28u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_Dd_16(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 28u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thc1414(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 14u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_Dd_9(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 28u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn Dd1(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 12u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn Rm2(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn c2121(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 21u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0711(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 23u64 as u32;
        raw_value &= 31u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0010(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 2047u128 as u32;
        raw_value as u16
    }
    pub fn thv_Rd(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 28u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thc0507(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 5u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn sop0508(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 5u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thc1515(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 15u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_c1618(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0406(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 20u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn thc0915(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 9u64 as u32;
        raw_value &= 127u128 as u32;
        raw_value as u8
    }
    pub fn Dm_4(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn c2424(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 24u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_Dd_10(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 28u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn Rm0305(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 3u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn c0707(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 7u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn offset11(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 2047u128 as u32;
        raw_value as u16
    }
    pub fn part2Rt(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 12u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thcond(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 8u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thc0707(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 7u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn c0031(&self) -> u32 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 4294967295u128 as u32;
        raw_value as u32
    }
    pub fn c1620(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 31u128 as u32;
        raw_value as u8
    }
    pub fn thv_bit07(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 23u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn immedL(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_Sn0(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn th_psrmask(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 8u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_c1212(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 28u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn Rm0003(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn rotate(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 8u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thc0811(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 8u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn part2Rd0003(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn Rn0003(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thc0001(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn thv_L7(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 23u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn immed8(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 255u128 as u32;
        raw_value as u8
    }
    pub fn Rd(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 12u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn c0406(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 4u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn c0001(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn op8(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 8u64 as u32;
        raw_value &= 255u128 as u32;
        raw_value as u8
    }
    pub fn thwbit(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 5u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn Rs(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 8u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn Dm_3(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn c1111(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 11u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_c1011(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 26u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn thc0002(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn c2122(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 21u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn hrd0002(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn thB6(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 6u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn Rn0810(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 8u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn c1315(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 13u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn c0004(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 31u128 as u32;
        raw_value as u8
    }
    pub fn c1515(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 15u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn c1818(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 18u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn N7(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 7u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn throt(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 4u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn c2127(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 21u64 as u32;
        raw_value &= 127u128 as u32;
        raw_value as u8
    }
    pub fn c1414(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 14u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_Sn1(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_Dd_13(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 28u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn part2c0505(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 5u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn sop0407(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 4u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn RmHi(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 8u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_c1717(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 1u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn offset10(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 1023u128 as u32;
        raw_value as u16
    }
    pub fn Rm(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0911(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 25u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn thv_c2031(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 4u64 as u32;
        raw_value &= 4095u128 as u32;
        raw_value as u16
    }
    pub fn thc0506(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 5u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn Qm1(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_c1616(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn immed12_imm8(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 255u128 as u32;
        raw_value as u8
    }
    pub fn thv_Dd_8(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 28u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn op0(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 65535u128 as u32;
        raw_value as u16
    }
    pub fn c0811(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 8u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn c0007(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 255u128 as u32;
        raw_value as u8
    }
    pub fn thv_c1621(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 63u128 as u32;
        raw_value as u8
    }
    pub fn c0404(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 4u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn c2124(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 21u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_Dn0(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn part2off_10(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 1u64 as u32;
        raw_value &= 1023u128 as u32;
        raw_value as u16
    }
    pub fn thv_c2127(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 5u64 as u32;
        raw_value &= 127u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0607(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 22u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn thv_c2027(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 4u64 as u32;
        raw_value &= 255u128 as u32;
        raw_value as u8
    }
    pub fn opc1(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 21u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn thv_Dd_6(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 28u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_c2121(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 5u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_c2331(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 7u64 as u32;
        raw_value &= 511u128 as u32;
        raw_value as u16
    }
    pub fn N22(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 22u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn immed4(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thc0006(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 127u128 as u32;
        raw_value as u8
    }
    pub fn c1619(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn lsb(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 7u64 as u32;
        raw_value &= 31u128 as u32;
        raw_value as u8
    }
    pub fn Qm0(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn op(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 21u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thW5(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 5u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0404(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 20u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0001(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn thL4(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 4u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn imm2_shft(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 6u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0809(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 24u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn M5(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 5u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thc1015(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 10u64 as u32;
        raw_value &= 63u128 as u32;
        raw_value as u8
    }
    pub fn c0027(&self) -> u32 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 268435455u128 as u32;
        raw_value as u32
    }
    pub fn thc0909(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 9u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0004(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 31u128 as u32;
        raw_value as u8
    }
    pub fn CRm(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn c0303(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 3u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thc1115(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 11u64 as u32;
        raw_value &= 31u128 as u32;
        raw_value as u8
    }
    pub fn c1015(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 10u64 as u32;
        raw_value &= 63u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0427(&self) -> u32 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 4u64 as u32;
        raw_value &= 16777215u128 as u32;
        raw_value as u32
    }
    pub fn thv_Dm1(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thU7(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 7u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_c2324(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 7u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn c0215(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 2u64 as u32;
        raw_value &= 16383u128 as u32;
        raw_value as u16
    }
    pub fn thv_Dd_12(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 28u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn c0709(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 7u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn thv_Dd0(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 28u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn smRd(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn sopit(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 255u128 as u32;
        raw_value as u8
    }
    pub fn opcode3(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 4u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thc1215(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 12u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn Sd0(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 12u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_c2427(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 8u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn part2op(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 11u64 as u32;
        raw_value &= 31u128 as u32;
        raw_value as u8
    }
    pub fn smRn(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_bit29(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 13u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn c1627(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 4095u128 as u32;
        raw_value as u16
    }
    pub fn thv_Qd1(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 28u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thI9(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 9u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn shft(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 5u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn c2021(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 20u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn c0916(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 9u64 as u32;
        raw_value &= 255u128 as u32;
        raw_value as u8
    }
    pub fn RnLo(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn c0409(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 4u64 as u32;
        raw_value &= 63u128 as u32;
        raw_value as u8
    }
    pub fn I25(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 25u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn addr24(&self) -> i32 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 16777215u128 as u32;
        let unsigned = raw_value & 8388607u128 as u32;
        if raw_value & 8388608u128 as u32 != 0 {
            (!8388607u128 as u32 | unsigned) as i32
        } else {
            unsigned as i32
        }
    }
    pub fn c0606(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 6u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thc0307(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 3u64 as u32;
        raw_value &= 31u128 as u32;
        raw_value as u8
    }
    pub fn thc0107(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 1u64 as u32;
        raw_value &= 127u128 as u32;
        raw_value as u8
    }
    pub fn c0708(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 7u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn c1313(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 13u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn part2c0615(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 6u64 as u32;
        raw_value &= 1023u128 as u32;
        raw_value as u16
    }
    pub fn part2c0404(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 4u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn Sm0next(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn op6(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 6u64 as u32;
        raw_value &= 1023u128 as u32;
        raw_value as u16
    }
    pub fn thv_c1415(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 30u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn c1819(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 18u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn thc0415(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 4u64 as u32;
        raw_value &= 4095u128 as u32;
        raw_value as u16
    }
    pub fn thv_c1921(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 3u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn Qn0(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0215(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 18u64 as u32;
        raw_value &= 16383u128 as u32;
        raw_value as u16
    }
    pub fn immedH(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 8u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thc0101(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 1u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn c0915(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 9u64 as u32;
        raw_value &= 127u128 as u32;
        raw_value as u8
    }
    pub fn c0101(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 1u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn Rs0305(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 3u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn c0611(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 6u64 as u32;
        raw_value &= 63u128 as u32;
        raw_value as u8
    }
    pub fn thv_c1821(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 2u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_c2124(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 5u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn bit28(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 28u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0011(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 4095u128 as u32;
        raw_value as u16
    }
    pub fn offset10S(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 10u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_Dm_3(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn Rn0002(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn thv_c1919(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 3u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn c2024(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 20u64 as u32;
        raw_value &= 31u128 as u32;
        raw_value as u8
    }
    pub fn c2831(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 28u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn y(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 6u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn part2cond(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 6u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn W21(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 21u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thc0910(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 9u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn thc0810(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 8u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn c0427(&self) -> u32 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 4u64 as u32;
        raw_value &= 16777215u128 as u32;
        raw_value as u32
    }
    pub fn thv_c2323(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 7u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn Q6(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 6u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn offset12(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 4095u128 as u32;
        raw_value as u16
    }
    pub fn thc1212(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 12u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thc0004(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 31u128 as u32;
        raw_value as u8
    }
    pub fn c1919(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 19u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn c0014(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 32767u128 as u32;
        raw_value as u16
    }
    pub fn c2531(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 25u64 as u32;
        raw_value &= 127u128 as u32;
        raw_value as u8
    }
    pub fn P24(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 24u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_c1414(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 30u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn sop0507(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 5u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn thv_D22(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 6u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn addr_ubit(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 9u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn c0809(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 8u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn thv_c2525(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 9u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0909(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 25u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn offset_12(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 4095u128 as u32;
        raw_value as u16
    }
    pub fn thv_Dd_3(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 28u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn c0407(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 4u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn fcond(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 4u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn Rt0811(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 8u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn R(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 8u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn immed12(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 8u64 as u32;
        raw_value &= 4095u128 as u32;
        raw_value as u16
    }
    pub fn sop0608(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 6u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn thv_c2222(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 6u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn L24(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 24u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0431(&self) -> u32 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 4u64 as u32;
        raw_value &= 268435455u128 as u32;
        raw_value as u32
    }
    pub fn sysm(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 255u128 as u32;
        raw_value as u8
    }
    pub fn thv_c1313(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 29u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn bit30(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 30u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thsrsMode(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 31u128 as u32;
        raw_value as u8
    }
    pub fn thv_bit28(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 12u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn imm3_shft(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 12u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn immed5(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 6u64 as u32;
        raw_value &= 31u128 as u32;
        raw_value as u8
    }
    pub fn c0431(&self) -> u32 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 4u64 as u32;
        raw_value &= 268435455u128 as u32;
        raw_value as u32
    }
    pub fn thv_c1819(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 2u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn satimm5(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 31u128 as u32;
        raw_value as u8
    }
    pub fn thc1111(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 11u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn part2J2(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 11u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn c2131(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 21u64 as u32;
        raw_value &= 2047u128 as u32;
        raw_value as u16
    }
    pub fn c1821(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 18u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_Rt(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 28u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn sop0003(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_c1627(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 4095u128 as u32;
        raw_value as u16
    }
    pub fn part2S(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 10u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn part2c1415(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 14u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn thv_c1631(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 65535u128 as u32;
        raw_value as u16
    }
    pub fn thN6(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 6u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thc0202(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 2u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thS6(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 6u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_Qm0(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn part2c0909(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 9u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn S20(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 20u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn part2imm10(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 1023u128 as u32;
        raw_value as u16
    }
    pub fn c2020(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 20u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thc0409(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 4u64 as u32;
        raw_value &= 63u128 as u32;
        raw_value as u8
    }
    pub fn thc0003(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thc0407(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 4u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0202(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 18u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn c2427(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 24u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thCRm(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn addr_puw1(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 5u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn c0013(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 16383u128 as u32;
        raw_value as u16
    }
    pub fn thc0607(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 6u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn c0415(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 4u64 as u32;
        raw_value &= 4095u128 as u32;
        raw_value as u16
    }
    pub fn thv_Dd1(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 28u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn Sm1next(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn Qd1(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 12u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thcpn(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 8u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn part2J1(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 13u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn c2022(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 20u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn thCRn(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn c1212(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 12u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0101(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 17u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_Qd0(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 28u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0006(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 127u128 as u32;
        raw_value as u8
    }
    pub fn c0315(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 3u64 as u32;
        raw_value &= 8191u128 as u32;
        raw_value as u16
    }
    pub fn H24(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 24u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn c0506(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 5u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn op4(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 4u64 as u32;
        raw_value &= 4095u128 as u32;
        raw_value as u16
    }
    pub fn c0815(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 8u64 as u32;
        raw_value &= 255u128 as u32;
        raw_value as u8
    }
    pub fn thc1214(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 12u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn immed(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 255u128 as u32;
        raw_value as u8
    }
    pub fn thv_Sm0next(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn c0006(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 127u128 as u32;
        raw_value as u8
    }
    pub fn part2c0011(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 4095u128 as u32;
        raw_value as u16
    }
    pub fn bit29(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 29u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thc0315(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 3u64 as u32;
        raw_value &= 8191u128 as u32;
        raw_value as u16
    }
    pub fn thv_Sm0(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn RdLo(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 12u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn op7(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 7u64 as u32;
        raw_value &= 511u128 as u32;
        raw_value as u16
    }
    pub fn c2525(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 25u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn c0408(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 4u64 as u32;
        raw_value &= 31u128 as u32;
        raw_value as u8
    }
    pub fn thv_c1721(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 1u64 as u32;
        raw_value &= 31u128 as u32;
        raw_value as u8
    }
    pub fn Rm0306(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 3u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn soffset8(&self) -> i8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 255u128 as u32;
        let unsigned = raw_value & 127u128 as u32;
        if raw_value & 128u128 as u32 != 0 {
            (!127u128 as u32 | unsigned) as i8
        } else {
            unsigned as i8
        }
    }
    pub fn thv_Dm0(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thopcode2(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 5u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn mask(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_Qm1(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn U23(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 23u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn r(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 5u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0707(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 23u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_Dd_2(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 28u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn part2off(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 2047u128 as u32;
        raw_value as u16
    }
    pub fn thc1010(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 10u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn sop0610(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 6u64 as u32;
        raw_value &= 31u128 as u32;
        raw_value as u8
    }
    pub fn c0009(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 1023u128 as u32;
        raw_value as u16
    }
    pub fn thv_c0000(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn c0505(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 5u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn c1616(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_Rn(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_c2024(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 4u64 as u32;
        raw_value &= 31u128 as u32;
        raw_value as u8
    }
    pub fn c0405(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 4u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn part2c0707(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 7u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0003(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn c0008(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 511u128 as u32;
        raw_value as u16
    }
    pub fn thv_bit23(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 7u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_Sd1(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 28u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn c0005(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 63u128 as u32;
        raw_value as u8
    }
    pub fn Sd1(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 12u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_c2020(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 4u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn cmode(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 8u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0709(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 23u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn thv_Sm1(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_Dd_4(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 28u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0303(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 19u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn c0615(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 6u64 as u32;
        raw_value &= 1023u128 as u32;
        raw_value as u16
    }
    pub fn D22(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 22u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_Dd_11(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 28u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_bit06(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 22u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn hrn0002(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn sysm02(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn c1717(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 17u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn c0003(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn Rd0003(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn Ra1215(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 12u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thc0207(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 2u64 as u32;
        raw_value &= 63u128 as u32;
        raw_value as u8
    }
    pub fn c0508(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 5u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn l07(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 7u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thCRd(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 12u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn Sn1(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thc1315(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 13u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0508(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 21u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn cond(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 28u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn addr_pbit(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 10u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn part2imm11(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 2047u128 as u32;
        raw_value as u16
    }
    pub fn immed12_i(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 10u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thc0215(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 2u64 as u32;
        raw_value &= 16383u128 as u32;
        raw_value as u16
    }
    pub fn thv_Qn1(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn L20(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 20u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn sbz(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn c0715(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 7u64 as u32;
        raw_value &= 511u128 as u32;
        raw_value as u16
    }
    pub fn thc0115(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 1u64 as u32;
        raw_value &= 32767u128 as u32;
        raw_value as u16
    }
    pub fn thv_c0507(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 21u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn thv_c1619(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn c1631(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 65535u128 as u32;
        raw_value as u16
    }
    pub fn c0411(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 4u64 as u32;
        raw_value &= 255u128 as u32;
        raw_value as u8
    }
    pub fn hrm0305(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 3u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn thv_c2831(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 12u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn sh(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 6u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn c2331(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 23u64 as u32;
        raw_value &= 511u128 as u32;
        raw_value as u16
    }
    pub fn thv_c0008(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 511u128 as u32;
        raw_value as u16
    }
    pub fn c0000(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn smRa(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 12u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_c2131(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 5u64 as u32;
        raw_value &= 2047u128 as u32;
        raw_value as u16
    }
    pub fn thv_c0104(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 17u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_bit21(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 5u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thc1112(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 11u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn immed6(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 63u128 as u32;
        raw_value as u8
    }
    pub fn Sm1(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0007(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 255u128 as u32;
        raw_value as u8
    }
    pub fn CRn(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn part2c1212(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 12u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn Qn1(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_N7(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 23u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_c1111(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 27u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thP8(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 8u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_Sd0(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 28u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn immed12_imm3(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 12u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn thc1313(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 13u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn msb(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 31u128 as u32;
        raw_value as u8
    }
    pub fn addr_wbit(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 8u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn immed7(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 127u128 as u32;
        raw_value as u8
    }
    pub fn soffset11(&self) -> i16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 2047u128 as u32;
        let unsigned = raw_value & 1023u128 as u32;
        if raw_value & 1024u128 as u32 != 0 {
            (!1023u128 as u32 | unsigned) as i16
        } else {
            unsigned as i16
        }
    }
    pub fn thv_c1515(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 31u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_c1215(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 28u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_c1617(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn thH8(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 8u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thc0404(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 4u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thc0007(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 255u128 as u32;
        raw_value as u8
    }
    pub fn c0011(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 4095u128 as u32;
        raw_value as u16
    }
    pub fn thv_c2022(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 4u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn sysm37(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 3u64 as u32;
        raw_value &= 31u128 as u32;
        raw_value as u8
    }
    pub fn c1011(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 10u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn cpn(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 8u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn c0911(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 9u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn thv_Dm_4(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn c1621(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 63u128 as u32;
        raw_value as u8
    }
    pub fn l11(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 11u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn opc2(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 5u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn Rd0002(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn x(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 5u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0506(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 21u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn thv_bit31(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 15u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn c1719(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 17u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn Dn1(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn Rm0608(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 6u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0407(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 20u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn rm0306(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 3u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thc0515(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 5u64 as u32;
        raw_value &= 2047u128 as u32;
        raw_value as u16
    }
    pub fn thv_c0411(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 20u64 as u32;
        raw_value &= 255u128 as u32;
        raw_value as u8
    }
    pub fn thv_M5(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 21u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0606(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 22u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_Rt2(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 24u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0027(&self) -> u32 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 268435455u128 as u32;
        raw_value as u32
    }
    pub fn satimm4(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_Qn0(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thc0000(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_immed(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 255u128 as u32;
        raw_value as u8
    }
    pub fn c0115(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 1u64 as u32;
        raw_value &= 32767u128 as u32;
        raw_value as u16
    }
    pub fn c2123(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 21u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn thv_Dn1(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn c1921(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 19u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn c1617(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn c1010(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 10u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn h2(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 6u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn Rn(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0808(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 24u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn Dd0(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 12u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_option(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_Dd_1(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 28u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thc1415(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 14u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn thopcode1(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 4u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn S22(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 22u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn bit31(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 31u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn smRm(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 8u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_Dd_14(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 28u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn c1618(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn c1115(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 11u64 as u32;
        raw_value &= 31u128 as u32;
        raw_value as u8
    }
    pub fn B22(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 22u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0611(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 22u64 as u32;
        raw_value &= 63u128 as u32;
        raw_value as u8
    }
    pub fn Rn0305(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 3u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn Sn0(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 16u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn thv_c2627(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 10u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn c1721(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 17u64 as u32;
        raw_value &= 31u128 as u32;
        raw_value as u8
    }
    pub fn thv_bit20(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 4u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn c2323(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 23u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thv_c2123(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 5u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0811(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 24u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn c2527(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 25u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn thv_c0031(&self) -> u32 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 4294967295u128 as u32;
        raw_value as u32
    }
    pub fn thv_c2931(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 13u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn thc0011(&self) -> u16 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 0u64 as u32;
        raw_value &= 4095u128 as u32;
        raw_value as u16
    }
    pub fn c2324(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 23u64 as u32;
        raw_value &= 3u128 as u32;
        raw_value as u8
    }
    pub fn thv_c2527(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 9u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn part2c0808(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 8u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn Rd2(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 12u64 as u32;
        raw_value &= 15u128 as u32;
        raw_value as u8
    }
    pub fn op11(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 11u64 as u32;
        raw_value &= 31u128 as u32;
        raw_value as u8
    }
    pub fn imm3_12(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 12u64 as u32;
        raw_value &= 7u128 as u32;
        raw_value as u8
    }
    pub fn c0202(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 2u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn c0909(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 9u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
    pub fn thc0303(&self) -> u8 {
        let mut raw_value = u32::from_le_bytes(self.0);
        raw_value >>= 3u64 as u32;
        raw_value &= 1u128 as u32;
        raw_value as u8
    }
}
pub struct TokenParser16([u8; 2usize]);
impl TokenParser16 {
    pub fn new(data: &[u8]) -> Option<Self> {
        <[u8; 2usize]>::try_from(data).ok().map(Self)
    }
    pub fn sop0407(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 4u64 as u16;
        raw_value &= 15u128 as u16;
        raw_value as u8
    }
    pub fn thc1515(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 15u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn thsrsMode(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 31u128 as u16;
        raw_value as u8
    }
    pub fn Rd0002(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 7u128 as u16;
        raw_value as u8
    }
    pub fn thU7(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 7u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn addr_ubit(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 9u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn op12(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 12u64 as u16;
        raw_value &= 15u128 as u16;
        raw_value as u8
    }
    pub fn part2cond(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 6u64 as u16;
        raw_value &= 15u128 as u16;
        raw_value as u8
    }
    pub fn thc0409(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 4u64 as u16;
        raw_value &= 63u128 as u16;
        raw_value as u8
    }
    pub fn thc1010(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 10u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn part2c1212(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 12u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn thc0405(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 4u64 as u16;
        raw_value &= 3u128 as u16;
        raw_value as u8
    }
    pub fn thc0606(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 6u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn Rd0003(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 15u128 as u16;
        raw_value as u8
    }
    pub fn part2imm11(&self) -> u16 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 2047u128 as u16;
        raw_value as u16
    }
    pub fn thc1115(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 11u64 as u16;
        raw_value &= 31u128 as u16;
        raw_value as u8
    }
    pub fn h2(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 6u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn soffset11(&self) -> i16 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 2047u128 as u16;
        let unsigned = raw_value & 1023u128 as u16;
        if raw_value & 1024u128 as u16 != 0 {
            (!1023u128 as u16 | unsigned) as i16
        } else {
            unsigned as i16
        }
    }
    pub fn part2S(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 10u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn thc0001(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 3u128 as u16;
        raw_value as u8
    }
    pub fn throt(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 4u64 as u16;
        raw_value &= 7u128 as u16;
        raw_value as u8
    }
    pub fn Rt0811(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 8u64 as u16;
        raw_value &= 15u128 as u16;
        raw_value as u8
    }
    pub fn Rn0002(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 7u128 as u16;
        raw_value as u8
    }
    pub fn immed12_imm3(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 12u64 as u16;
        raw_value &= 7u128 as u16;
        raw_value as u8
    }
    pub fn immed5(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 6u64 as u16;
        raw_value &= 31u128 as u16;
        raw_value as u8
    }
    pub fn thc0115(&self) -> u16 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 1u64 as u16;
        raw_value &= 32767u128 as u16;
        raw_value as u16
    }
    pub fn part2imm10(&self) -> u16 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 1023u128 as u16;
        raw_value as u16
    }
    pub fn thc1313(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 13u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn thN6(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 6u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn sop0610(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 6u64 as u16;
        raw_value &= 31u128 as u16;
        raw_value as u8
    }
    pub fn Ra1215(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 12u64 as u16;
        raw_value &= 15u128 as u16;
        raw_value as u8
    }
    pub fn thc1415(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 14u64 as u16;
        raw_value &= 3u128 as u16;
        raw_value as u8
    }
    pub fn Rn0305(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 3u64 as u16;
        raw_value &= 7u128 as u16;
        raw_value as u8
    }
    pub fn part2Rd0003(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 15u128 as u16;
        raw_value as u8
    }
    pub fn sop0508(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 5u64 as u16;
        raw_value &= 15u128 as u16;
        raw_value as u8
    }
    pub fn th_psrmask(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 8u64 as u16;
        raw_value &= 15u128 as u16;
        raw_value as u8
    }
    pub fn hrn0002(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 7u128 as u16;
        raw_value as u8
    }
    pub fn rm0306(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 3u64 as u16;
        raw_value &= 15u128 as u16;
        raw_value as u8
    }
    pub fn part2c0011(&self) -> u16 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 4095u128 as u16;
        raw_value as u16
    }
    pub fn thc1015(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 10u64 as u16;
        raw_value &= 63u128 as u16;
        raw_value as u8
    }
    pub fn h1(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 7u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn op11(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 11u64 as u16;
        raw_value &= 31u128 as u16;
        raw_value as u8
    }
    pub fn fcond(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 4u64 as u16;
        raw_value &= 15u128 as u16;
        raw_value as u8
    }
    pub fn soffset8(&self) -> i8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 255u128 as u16;
        let unsigned = raw_value & 127u128 as u16;
        if raw_value & 128u128 as u16 != 0 {
            (!127u128 as u16 | unsigned) as i8
        } else {
            unsigned as i8
        }
    }
    pub fn part2c0808(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 8u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn part2c1415(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 14u64 as u16;
        raw_value &= 3u128 as u16;
        raw_value as u8
    }
    pub fn part2J1(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 13u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn thc0004(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 31u128 as u16;
        raw_value as u8
    }
    pub fn thCRm(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 15u128 as u16;
        raw_value as u8
    }
    pub fn hrd0002(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 7u128 as u16;
        raw_value as u8
    }
    pub fn thopcode2(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 5u64 as u16;
        raw_value &= 7u128 as u16;
        raw_value as u8
    }
    pub fn immed12_imm8(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 255u128 as u16;
        raw_value as u8
    }
    pub fn offset10S(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 10u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn thc0007(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 255u128 as u16;
        raw_value as u8
    }
    pub fn thc0615(&self) -> u16 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 6u64 as u16;
        raw_value &= 1023u128 as u16;
        raw_value as u16
    }
    pub fn op8(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 8u64 as u16;
        raw_value &= 255u128 as u16;
        raw_value as u8
    }
    pub fn Rm0003(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 15u128 as u16;
        raw_value as u8
    }
    pub fn thc0215(&self) -> u16 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 2u64 as u16;
        raw_value &= 16383u128 as u16;
        raw_value as u16
    }
    pub fn thc1112(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 11u64 as u16;
        raw_value &= 3u128 as u16;
        raw_value as u8
    }
    pub fn immed8(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 255u128 as u16;
        raw_value as u8
    }
    pub fn part2c0707(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 7u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn thc0815(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 8u64 as u16;
        raw_value &= 255u128 as u16;
        raw_value as u8
    }
    pub fn thc0715(&self) -> u16 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 7u64 as u16;
        raw_value &= 511u128 as u16;
        raw_value as u16
    }
    pub fn thc0505(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 5u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn imm3_shft(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 12u64 as u16;
        raw_value &= 7u128 as u16;
        raw_value as u8
    }
    pub fn immed6(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 63u128 as u16;
        raw_value as u8
    }
    pub fn part2off_10(&self) -> u16 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 1u64 as u16;
        raw_value &= 1023u128 as u16;
        raw_value as u16
    }
    pub fn thc0303(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 3u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn Rn0810(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 8u64 as u16;
        raw_value &= 7u128 as u16;
        raw_value as u8
    }
    pub fn hrm0305(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 3u64 as u16;
        raw_value &= 7u128 as u16;
        raw_value as u8
    }
    pub fn thc0909(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 9u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn part2c0909(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 9u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn offset10(&self) -> u16 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 1023u128 as u16;
        raw_value as u16
    }
    pub fn sbz(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 7u128 as u16;
        raw_value as u8
    }
    pub fn immed12_i(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 10u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn thc0810(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 8u64 as u16;
        raw_value &= 7u128 as u16;
        raw_value as u8
    }
    pub fn imm2_shft(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 6u64 as u16;
        raw_value &= 3u128 as u16;
        raw_value as u8
    }
    pub fn addr_puw(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 8u64 as u16;
        raw_value &= 7u128 as u16;
        raw_value as u8
    }
    pub fn op7(&self) -> u16 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 7u64 as u16;
        raw_value &= 511u128 as u16;
        raw_value as u16
    }
    pub fn thwbit(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 5u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn thc1212(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 12u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn imm5(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 3u64 as u16;
        raw_value &= 31u128 as u16;
        raw_value as u8
    }
    pub fn thc0415(&self) -> u16 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 4u64 as u16;
        raw_value &= 4095u128 as u16;
        raw_value as u16
    }
    pub fn sop0608(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 6u64 as u16;
        raw_value &= 7u128 as u16;
        raw_value as u8
    }
    pub fn addr_wbit(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 8u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn Rm0305(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 3u64 as u16;
        raw_value &= 7u128 as u16;
        raw_value as u8
    }
    pub fn thc0808(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 8u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn sysm(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 255u128 as u16;
        raw_value as u8
    }
    pub fn thc0507(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 5u64 as u16;
        raw_value &= 7u128 as u16;
        raw_value as u8
    }
    pub fn addr_puw1(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 5u64 as u16;
        raw_value &= 15u128 as u16;
        raw_value as u8
    }
    pub fn part2c0505(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 5u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn op4(&self) -> u16 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 4u64 as u16;
        raw_value &= 4095u128 as u16;
        raw_value as u16
    }
    pub fn thc0915(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 9u64 as u16;
        raw_value &= 127u128 as u16;
        raw_value as u8
    }
    pub fn thc0002(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 7u128 as u16;
        raw_value as u8
    }
    pub fn thc1215(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 12u64 as u16;
        raw_value &= 15u128 as u16;
        raw_value as u8
    }
    pub fn thS6(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 6u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn thc1111(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 11u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn thc0207(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 2u64 as u16;
        raw_value &= 63u128 as u16;
        raw_value as u8
    }
    pub fn sopit(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 255u128 as u16;
        raw_value as u8
    }
    pub fn thc0407(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 4u64 as u16;
        raw_value &= 15u128 as u16;
        raw_value as u8
    }
    pub fn offset11(&self) -> u16 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 2047u128 as u16;
        raw_value as u16
    }
    pub fn thcond(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 8u64 as u16;
        raw_value &= 15u128 as u16;
        raw_value as u8
    }
    pub fn thCRd(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 12u64 as u16;
        raw_value &= 15u128 as u16;
        raw_value as u8
    }
    pub fn thc0910(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 9u64 as u16;
        raw_value &= 3u128 as u16;
        raw_value as u8
    }
    pub fn Rm0608(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 6u64 as u16;
        raw_value &= 7u128 as u16;
        raw_value as u8
    }
    pub fn sysm02(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 7u128 as u16;
        raw_value as u8
    }
    pub fn thc0404(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 4u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn thc0005(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 63u128 as u16;
        raw_value as u8
    }
    pub fn addr_pbit(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 10u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn part2Rt(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 12u64 as u16;
        raw_value &= 15u128 as u16;
        raw_value as u8
    }
    pub fn thc0707(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 7u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn op0(&self) -> u16 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 65535u128 as u16;
        raw_value as u16
    }
    pub fn thCRn(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 15u128 as u16;
        raw_value as u8
    }
    pub fn part2imm6(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 63u128 as u16;
        raw_value as u8
    }
    pub fn thP8(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 8u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn immed7(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 127u128 as u16;
        raw_value as u8
    }
    pub fn thc0315(&self) -> u16 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 3u64 as u16;
        raw_value &= 8191u128 as u16;
        raw_value as u16
    }
    pub fn thcpn(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 8u64 as u16;
        raw_value &= 15u128 as u16;
        raw_value as u8
    }
    pub fn thc1414(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 14u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn sop0507(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 5u64 as u16;
        raw_value &= 7u128 as u16;
        raw_value as u8
    }
    pub fn thc0607(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 6u64 as u16;
        raw_value &= 3u128 as u16;
        raw_value as u8
    }
    pub fn sop0003(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 15u128 as u16;
        raw_value as u8
    }
    pub fn R(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 8u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn Rs0305(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 3u64 as u16;
        raw_value &= 7u128 as u16;
        raw_value as u8
    }
    pub fn l11(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 11u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn thI9(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 9u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn part2op(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 11u64 as u16;
        raw_value &= 31u128 as u16;
        raw_value as u8
    }
    pub fn thc0202(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 2u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn thc0011(&self) -> u16 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 4095u128 as u16;
        raw_value as u16
    }
    pub fn thc0000(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn imm3_12(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 12u64 as u16;
        raw_value &= 7u128 as u16;
        raw_value as u8
    }
    pub fn Rt1215(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 12u64 as u16;
        raw_value &= 15u128 as u16;
        raw_value as u8
    }
    pub fn thc0307(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 3u64 as u16;
        raw_value &= 31u128 as u16;
        raw_value as u8
    }
    pub fn part2off(&self) -> u16 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 2047u128 as u16;
        raw_value as u16
    }
    pub fn Rd0811(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 8u64 as u16;
        raw_value &= 15u128 as u16;
        raw_value as u8
    }
    pub fn op6(&self) -> u16 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 6u64 as u16;
        raw_value &= 1023u128 as u16;
        raw_value as u16
    }
    pub fn thL8(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 8u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn Rm0306(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 3u64 as u16;
        raw_value &= 15u128 as u16;
        raw_value as u8
    }
    pub fn thc0003(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 15u128 as u16;
        raw_value as u8
    }
    pub fn thc0101(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 1u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn offset12(&self) -> u16 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 4095u128 as u16;
        raw_value as u16
    }
    pub fn thc0107(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 1u64 as u16;
        raw_value &= 127u128 as u16;
        raw_value as u8
    }
    pub fn l07(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 7u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn immed3(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 6u64 as u16;
        raw_value &= 7u128 as u16;
        raw_value as u8
    }
    pub fn thB6(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 6u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn thc0515(&self) -> u16 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 5u64 as u16;
        raw_value &= 2047u128 as u16;
        raw_value as u16
    }
    pub fn op9(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 9u64 as u16;
        raw_value &= 127u128 as u16;
        raw_value as u8
    }
    pub fn part2J2(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 11u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn sysm37(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 3u64 as u16;
        raw_value &= 31u128 as u16;
        raw_value as u8
    }
    pub fn thL4(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 4u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn thH8(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 8u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn thc0506(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 5u64 as u16;
        raw_value &= 3u128 as u16;
        raw_value as u8
    }
    pub fn thopcode1(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 4u64 as u16;
        raw_value &= 15u128 as u16;
        raw_value as u8
    }
    pub fn part2c0404(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 4u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
    pub fn Rn0003(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 15u128 as u16;
        raw_value as u8
    }
    pub fn thc0811(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 8u64 as u16;
        raw_value &= 15u128 as u16;
        raw_value as u8
    }
    pub fn Rd0810(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 8u64 as u16;
        raw_value &= 7u128 as u16;
        raw_value as u8
    }
    pub fn thc1315(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 13u64 as u16;
        raw_value &= 7u128 as u16;
        raw_value as u8
    }
    pub fn part2c0615(&self) -> u16 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 6u64 as u16;
        raw_value &= 1023u128 as u16;
        raw_value as u16
    }
    pub fn thc1214(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 12u64 as u16;
        raw_value &= 7u128 as u16;
        raw_value as u8
    }
    pub fn thc0006(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 0u64 as u16;
        raw_value &= 127u128 as u16;
        raw_value as u8
    }
    pub fn thW5(&self) -> u8 {
        let mut raw_value = u16::from_le_bytes(self.0);
        raw_value >>= 5u64 as u16;
        raw_value &= 1u128 as u16;
        raw_value as u8
    }
}
pub trait GlobalSetTrait {
    fn set_reg2Num(&mut self, address: Option<u32>, value: u8);
    fn set_counter(&mut self, address: Option<u32>, value: u8);
    fn set_TMode(&mut self, address: Option<u32>, value: u8);
    fn set_CALLoverride(&mut self, address: Option<u32>, value: u8);
    fn set_ISA_MODE(&mut self, address: Option<u32>, value: u8);
    fn set_counter2(&mut self, address: Option<u32>, value: u8);
    fn set_LRset(&mut self, address: Option<u32>, value: u8);
    fn set_T(&mut self, address: Option<u32>, value: u8);
    fn set_LowBitCodeMode(&mut self, address: Option<u32>, value: u8);
    fn set_ARMcond(&mut self, address: Option<u32>, value: u8);
    fn set_regInc(&mut self, address: Option<u32>, value: u8);
    fn set_ARMcondCk(&mut self, address: Option<u32>, value: u8);
    fn set_REToverride(&mut self, address: Option<u32>, value: u8);
    fn set_regNum(&mut self, address: Option<u32>, value: u8);
}
pub trait ContextTrait {
    fn read_LRset(&self) -> u8;
    fn write_LRset(&mut self, value: u8);
    fn read_T(&self) -> u8;
    fn write_T(&mut self, value: u8);
    fn read_CALLoverride(&self) -> u8;
    fn write_CALLoverride(&mut self, value: u8);
    fn read_TMode(&self) -> u8;
    fn write_TMode(&mut self, value: u8);
    fn read_counter(&self) -> u8;
    fn write_counter(&mut self, value: u8);
    fn read_regInc(&self) -> u8;
    fn write_regInc(&mut self, value: u8);
    fn read_LowBitCodeMode(&self) -> u8;
    fn write_LowBitCodeMode(&mut self, value: u8);
    fn read_counter2(&self) -> u8;
    fn write_counter2(&mut self, value: u8);
    fn read_ISA_MODE(&self) -> u8;
    fn write_ISA_MODE(&mut self, value: u8);
    fn read_reg2Num(&self) -> u8;
    fn write_reg2Num(&mut self, value: u8);
    fn read_ARMcond(&self) -> u8;
    fn write_ARMcond(&mut self, value: u8);
    fn read_ARMcondCk(&self) -> u8;
    fn write_ARMcondCk(&mut self, value: u8);
    fn read_regNum(&self) -> u8;
    fn write_regNum(&mut self, value: u8);
    fn read_REToverride(&self) -> u8;
    fn write_REToverride(&mut self, value: u8);
}
#[derive(Debug, Clone, Copy)]
pub struct ContextSpaceregister {
    pub chunk_0x0: [u8; 8usize],
}
impl ContextSpaceregister {
    pub fn read(&self, addr: usize, buf: &mut [u8]) {
        let addr_end = addr + buf.len();
        match (addr, addr_end) {
            (0usize..=7usize, 0usize..=8usize) => {
                let start = addr - 0usize;
                let end = start + buf.len();
                buf.copy_from_slice(&self.chunk_0x0[start..end]);
            }
            _ => panic!("undefined mem {}:{}", addr, buf.len()),
        }
    }
    pub fn write(&mut self, addr: usize, buf: &[u8]) {
        let addr_end = addr + buf.len();
        match (addr, addr_end) {
            (0usize..=7usize, 0usize..=8usize) => {
                let start = addr - 0usize;
                let end = start + buf.len();
                self.chunk_0x0[start..end].copy_from_slice(buf);
            }
            _ => panic!("undefined mem {}:{}", addr, buf.len()),
        }
    }
}
#[derive(Debug, Clone, Copy)]
pub struct Context {
    pub register: ContextSpaceregister,
}
impl ContextTrait for Context {
    fn read_LRset(&self) -> u8 {
        let mut mem = [0u8; 1usize];
        self.register.read(0usize, &mut mem[0usize..]);
        let mut work = u8::from_be_bytes(mem);
        work >>= 1usize;
        work &= 1usize as u8;
        work as u8
    }
    fn write_LRset(&mut self, value: u8) {
        let mut mem = [0u8; 1usize];
        self.register.read(0usize, &mut mem[0usize..]);
        let mut mem = u8::from_be_bytes(mem);
        mem &= !((1usize as u8) << 1usize);
        let mut param = value as u8;
        param &= 1usize as u8;
        param <<= 1usize;
        let result = (mem | param).to_be_bytes();
        self.register.write(0usize, &result[0usize..]);
    }
    fn read_T(&self) -> u8 {
        let mut mem = [0u8; 1usize];
        self.register.read(0usize, &mut mem[0usize..]);
        let mut work = u8::from_be_bytes(mem);
        work >>= 1usize;
        work &= 1usize as u8;
        work as u8
    }
    fn write_T(&mut self, value: u8) {
        let mut mem = [0u8; 1usize];
        self.register.read(0usize, &mut mem[0usize..]);
        let mut mem = u8::from_be_bytes(mem);
        mem &= !((1usize as u8) << 1usize);
        let mut param = value as u8;
        param &= 1usize as u8;
        param <<= 1usize;
        let result = (mem | param).to_be_bytes();
        self.register.write(0usize, &result[0usize..]);
    }
    fn read_CALLoverride(&self) -> u8 {
        let mut mem = [0u8; 1usize];
        self.register.read(0usize, &mut mem[0usize..]);
        let mut work = u8::from_be_bytes(mem);
        work >>= 1usize;
        work &= 1usize as u8;
        work as u8
    }
    fn write_CALLoverride(&mut self, value: u8) {
        let mut mem = [0u8; 1usize];
        self.register.read(0usize, &mut mem[0usize..]);
        let mut mem = u8::from_be_bytes(mem);
        mem &= !((1usize as u8) << 1usize);
        let mut param = value as u8;
        param &= 1usize as u8;
        param <<= 1usize;
        let result = (mem | param).to_be_bytes();
        self.register.write(0usize, &result[0usize..]);
    }
    fn read_TMode(&self) -> u8 {
        let mut mem = [0u8; 1usize];
        self.register.read(0usize, &mut mem[0usize..]);
        let mut work = u8::from_be_bytes(mem);
        work >>= 1usize;
        work &= 1usize as u8;
        work as u8
    }
    fn write_TMode(&mut self, value: u8) {
        let mut mem = [0u8; 1usize];
        self.register.read(0usize, &mut mem[0usize..]);
        let mut mem = u8::from_be_bytes(mem);
        mem &= !((1usize as u8) << 1usize);
        let mut param = value as u8;
        param &= 1usize as u8;
        param <<= 1usize;
        let result = (mem | param).to_be_bytes();
        self.register.write(0usize, &result[0usize..]);
    }
    fn read_counter(&self) -> u8 {
        let mut mem = [0u8; 2usize];
        self.register.read(1usize, &mut mem[0usize..]);
        let mut work = u16::from_be_bytes(mem);
        work >>= 5usize;
        work &= 31usize as u16;
        work as u8
    }
    fn write_counter(&mut self, value: u8) {
        let mut mem = [0u8; 2usize];
        self.register.read(1usize, &mut mem[0usize..]);
        let mut mem = u16::from_be_bytes(mem);
        mem &= !((31usize as u16) << 5usize);
        let mut param = value as u16;
        param &= 31usize as u16;
        param <<= 5usize;
        let result = (mem | param).to_be_bytes();
        self.register.write(1usize, &result[0usize..]);
    }
    fn read_regInc(&self) -> u8 {
        let mut mem = [0u8; 1usize];
        self.register.read(4usize, &mut mem[0usize..]);
        let mut work = u8::from_be_bytes(mem);
        work >>= 2usize;
        work &= 3usize as u8;
        work as u8
    }
    fn write_regInc(&mut self, value: u8) {
        let mut mem = [0u8; 1usize];
        self.register.read(4usize, &mut mem[0usize..]);
        let mut mem = u8::from_be_bytes(mem);
        mem &= !((3usize as u8) << 2usize);
        let mut param = value as u8;
        param &= 3usize as u8;
        param <<= 2usize;
        let result = (mem | param).to_be_bytes();
        self.register.write(4usize, &result[0usize..]);
    }
    fn read_LowBitCodeMode(&self) -> u8 {
        let mut mem = [0u8; 1usize];
        self.register.read(0usize, &mut mem[0usize..]);
        let mut work = u8::from_be_bytes(mem);
        work >>= 1usize;
        work &= 1usize as u8;
        work as u8
    }
    fn write_LowBitCodeMode(&mut self, value: u8) {
        let mut mem = [0u8; 1usize];
        self.register.read(0usize, &mut mem[0usize..]);
        let mut mem = u8::from_be_bytes(mem);
        mem &= !((1usize as u8) << 1usize);
        let mut param = value as u8;
        param &= 1usize as u8;
        param <<= 1usize;
        let result = (mem | param).to_be_bytes();
        self.register.write(0usize, &result[0usize..]);
    }
    fn read_counter2(&self) -> u8 {
        let mut mem = [0u8; 1usize];
        self.register.read(3usize, &mut mem[0usize..]);
        let mut work = u8::from_be_bytes(mem);
        work >>= 3usize;
        work &= 7usize as u8;
        work as u8
    }
    fn write_counter2(&mut self, value: u8) {
        let mut mem = [0u8; 1usize];
        self.register.read(3usize, &mut mem[0usize..]);
        let mut mem = u8::from_be_bytes(mem);
        mem &= !((7usize as u8) << 3usize);
        let mut param = value as u8;
        param &= 7usize as u8;
        param <<= 3usize;
        let result = (mem | param).to_be_bytes();
        self.register.write(3usize, &result[0usize..]);
    }
    fn read_ISA_MODE(&self) -> u8 {
        let mut mem = [0u8; 1usize];
        self.register.read(0usize, &mut mem[0usize..]);
        let mut work = u8::from_be_bytes(mem);
        work >>= 1usize;
        work &= 1usize as u8;
        work as u8
    }
    fn write_ISA_MODE(&mut self, value: u8) {
        let mut mem = [0u8; 1usize];
        self.register.read(0usize, &mut mem[0usize..]);
        let mut mem = u8::from_be_bytes(mem);
        mem &= !((1usize as u8) << 1usize);
        let mut param = value as u8;
        param &= 1usize as u8;
        param <<= 1usize;
        let result = (mem | param).to_be_bytes();
        self.register.write(0usize, &result[0usize..]);
    }
    fn read_reg2Num(&self) -> u8 {
        let mut mem = [0u8; 1usize];
        self.register.read(3usize, &mut mem[0usize..]);
        let mut work = u8::from_be_bytes(mem);
        work >>= 5usize;
        work &= 31usize as u8;
        work as u8
    }
    fn write_reg2Num(&mut self, value: u8) {
        let mut mem = [0u8; 1usize];
        self.register.read(3usize, &mut mem[0usize..]);
        let mut mem = u8::from_be_bytes(mem);
        mem &= !((31usize as u8) << 5usize);
        let mut param = value as u8;
        param &= 31usize as u8;
        param <<= 5usize;
        let result = (mem | param).to_be_bytes();
        self.register.write(3usize, &result[0usize..]);
    }
    fn read_ARMcond(&self) -> u8 {
        let mut mem = [0u8; 1usize];
        self.register.read(4usize, &mut mem[0usize..]);
        let mut work = u8::from_be_bytes(mem);
        work >>= 1usize;
        work &= 1usize as u8;
        work as u8
    }
    fn write_ARMcond(&mut self, value: u8) {
        let mut mem = [0u8; 1usize];
        self.register.read(4usize, &mut mem[0usize..]);
        let mut mem = u8::from_be_bytes(mem);
        mem &= !((1usize as u8) << 1usize);
        let mut param = value as u8;
        param &= 1usize as u8;
        param <<= 1usize;
        let result = (mem | param).to_be_bytes();
        self.register.write(4usize, &result[0usize..]);
    }
    fn read_ARMcondCk(&self) -> u8 {
        let mut mem = [0u8; 1usize];
        self.register.read(4usize, &mut mem[0usize..]);
        let mut work = u8::from_be_bytes(mem);
        work >>= 1usize;
        work &= 1usize as u8;
        work as u8
    }
    fn write_ARMcondCk(&mut self, value: u8) {
        let mut mem = [0u8; 1usize];
        self.register.read(4usize, &mut mem[0usize..]);
        let mut mem = u8::from_be_bytes(mem);
        mem &= !((1usize as u8) << 1usize);
        let mut param = value as u8;
        param &= 1usize as u8;
        param <<= 1usize;
        let result = (mem | param).to_be_bytes();
        self.register.write(4usize, &result[0usize..]);
    }
    fn read_regNum(&self) -> u8 {
        let mut mem = [0u8; 1usize];
        self.register.read(2usize, &mut mem[0usize..]);
        let mut work = u8::from_be_bytes(mem);
        work >>= 5usize;
        work &= 31usize as u8;
        work as u8
    }
    fn write_regNum(&mut self, value: u8) {
        let mut mem = [0u8; 1usize];
        self.register.read(2usize, &mut mem[0usize..]);
        let mut mem = u8::from_be_bytes(mem);
        mem &= !((31usize as u8) << 5usize);
        let mut param = value as u8;
        param &= 31usize as u8;
        param <<= 5usize;
        let result = (mem | param).to_be_bytes();
        self.register.write(2usize, &result[0usize..]);
    }
    fn read_REToverride(&self) -> u8 {
        let mut mem = [0u8; 1usize];
        self.register.read(0usize, &mut mem[0usize..]);
        let mut work = u8::from_be_bytes(mem);
        work >>= 1usize;
        work &= 1usize as u8;
        work as u8
    }
    fn write_REToverride(&mut self, value: u8) {
        let mut mem = [0u8; 1usize];
        self.register.read(0usize, &mut mem[0usize..]);
        let mut mem = u8::from_be_bytes(mem);
        mem &= !((1usize as u8) << 1usize);
        let mut param = value as u8;
        param &= 1usize as u8;
        param <<= 1usize;
        let result = (mem | param).to_be_bytes();
        self.register.write(0usize, &result[0usize..]);
    }
}
#[derive(Clone, Copy, Debug)]
pub enum Register {
    cr11,
    spsr_svc,
    r3,
    sp,
    r0,
    CALLoverride,
    contextreg,
    TMode,
    ARMcondCk,
    r13_svc,
    counter2,
    cr5,
    r14_svc,
    cr4,
    mult_addr,
    fp0,
    GE2,
    ISA_MODE,
    tmpZR,
    cr3,
    OV,
    cr15,
    NG,
    GE4,
    counter,
    regInc,
    LRset,
    cr14,
    tmpOV,
    fp1,
    fp5,
    r4,
    tmpNG,
    spsr,
    fpsr,
    TB,
    tmpCY,
    CY,
    cr13,
    mult_dat16,
    r12,
    T,
    Q,
    LowBitCodeMode,
    cr1,
    mult_dat8,
    ISAModeSwitch,
    shift_carry,
    r9,
    r7,
    r5,
    reg2Num,
    r1,
    ARMcond,
    ZR,
    r11,
    regNum,
    fp2,
    cr6,
    cr10,
    pc,
    cr9,
    fp6,
    r2,
    fp7,
    cr7,
    r8,
    r6,
    cpsr,
    r10,
    fp3,
    REToverride,
    GE1,
    cr0,
    lr,
    cr12,
    GE3,
    fp4,
    cr2,
    cr8,
}
impl core::fmt::Display for Register {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::cr11 => write!(f, "cr11"),
            Self::spsr_svc => write!(f, "spsr_svc"),
            Self::r3 => write!(f, "r3"),
            Self::sp => write!(f, "sp"),
            Self::r0 => write!(f, "r0"),
            Self::CALLoverride => write!(f, "CALLoverride"),
            Self::contextreg => write!(f, "contextreg"),
            Self::TMode => write!(f, "TMode"),
            Self::ARMcondCk => write!(f, "ARMcondCk"),
            Self::r13_svc => write!(f, "r13_svc"),
            Self::counter2 => write!(f, "counter2"),
            Self::cr5 => write!(f, "cr5"),
            Self::r14_svc => write!(f, "r14_svc"),
            Self::cr4 => write!(f, "cr4"),
            Self::mult_addr => write!(f, "mult_addr"),
            Self::fp0 => write!(f, "fp0"),
            Self::GE2 => write!(f, "GE2"),
            Self::ISA_MODE => write!(f, "ISA_MODE"),
            Self::tmpZR => write!(f, "tmpZR"),
            Self::cr3 => write!(f, "cr3"),
            Self::OV => write!(f, "OV"),
            Self::cr15 => write!(f, "cr15"),
            Self::NG => write!(f, "NG"),
            Self::GE4 => write!(f, "GE4"),
            Self::counter => write!(f, "counter"),
            Self::regInc => write!(f, "regInc"),
            Self::LRset => write!(f, "LRset"),
            Self::cr14 => write!(f, "cr14"),
            Self::tmpOV => write!(f, "tmpOV"),
            Self::fp1 => write!(f, "fp1"),
            Self::fp5 => write!(f, "fp5"),
            Self::r4 => write!(f, "r4"),
            Self::tmpNG => write!(f, "tmpNG"),
            Self::spsr => write!(f, "spsr"),
            Self::fpsr => write!(f, "fpsr"),
            Self::TB => write!(f, "TB"),
            Self::tmpCY => write!(f, "tmpCY"),
            Self::CY => write!(f, "CY"),
            Self::cr13 => write!(f, "cr13"),
            Self::mult_dat16 => write!(f, "mult_dat16"),
            Self::r12 => write!(f, "r12"),
            Self::T => write!(f, "T"),
            Self::Q => write!(f, "Q"),
            Self::LowBitCodeMode => write!(f, "LowBitCodeMode"),
            Self::cr1 => write!(f, "cr1"),
            Self::mult_dat8 => write!(f, "mult_dat8"),
            Self::ISAModeSwitch => write!(f, "ISAModeSwitch"),
            Self::shift_carry => write!(f, "shift_carry"),
            Self::r9 => write!(f, "r9"),
            Self::r7 => write!(f, "r7"),
            Self::r5 => write!(f, "r5"),
            Self::reg2Num => write!(f, "reg2Num"),
            Self::r1 => write!(f, "r1"),
            Self::ARMcond => write!(f, "ARMcond"),
            Self::ZR => write!(f, "ZR"),
            Self::r11 => write!(f, "r11"),
            Self::regNum => write!(f, "regNum"),
            Self::fp2 => write!(f, "fp2"),
            Self::cr6 => write!(f, "cr6"),
            Self::cr10 => write!(f, "cr10"),
            Self::pc => write!(f, "pc"),
            Self::cr9 => write!(f, "cr9"),
            Self::fp6 => write!(f, "fp6"),
            Self::r2 => write!(f, "r2"),
            Self::fp7 => write!(f, "fp7"),
            Self::cr7 => write!(f, "cr7"),
            Self::r8 => write!(f, "r8"),
            Self::r6 => write!(f, "r6"),
            Self::cpsr => write!(f, "cpsr"),
            Self::r10 => write!(f, "r10"),
            Self::fp3 => write!(f, "fp3"),
            Self::REToverride => write!(f, "REToverride"),
            Self::GE1 => write!(f, "GE1"),
            Self::cr0 => write!(f, "cr0"),
            Self::lr => write!(f, "lr"),
            Self::cr12 => write!(f, "cr12"),
            Self::GE3 => write!(f, "GE3"),
            Self::fp4 => write!(f, "fp4"),
            Self::cr2 => write!(f, "cr2"),
            Self::cr8 => write!(f, "cr8"),
        }
    }
}
#[derive(Clone, Copy, Debug)]
pub enum DisplayElement {
    Literal(&'static str),
    Register(Register),
    Signed(bool, i64),
    Unsigned(bool, u64),
}
impl core::fmt::Display for DisplayElement {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Literal(lit) => lit.fmt(f),
            Self::Register(reg) => reg.fmt(f),
            Self::Signed(hex, value) => {
                if *hex {
                    write!(f, "0x{:x}", value)
                } else {
                    value.fmt(f)
                }
            }
            Self::Unsigned(hex, value) => {
                if *hex {
                    write!(f, "0x{:x}", value)
                } else {
                    value.fmt(f)
                }
            }
        }
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:727:1"]
#[derive(Clone, Debug)]
pub struct thrlist5Var0 {
    thrlist6: thrlist6,
}
impl thrlist5Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist6 } = self;
        thrlist6.display_extend(display, context);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r10)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc1010() != (1u64 as i64) as u8 {
                return None;
            }
            let thrlist6 = if let Some((len, table)) = thrlist6::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc1115() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((thrlist6), (), block_len))
        };
        let ((mut thrlist6), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist6 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:729:1"]
#[derive(Clone, Debug)]
pub struct thrlist5Var1 {
    thrlist6: thrlist6,
}
impl thrlist5Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist6 } = self;
        thrlist6.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc1010() != (0u64 as i64) as u8 {
                return None;
            }
            let thrlist6 = if let Some((len, table)) = thrlist6::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thrlist6), (), block_len))
        };
        let ((mut thrlist6), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist6 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:728:1"]
#[derive(Clone, Debug)]
pub struct thrlist5Var2 {
    thrlist6: thrlist6,
}
impl thrlist5Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist6 } = self;
        thrlist6.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r10),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc1010() != (1u64 as i64) as u8 {
                return None;
            }
            let thrlist6 = if let Some((len, table)) = thrlist6::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thrlist6), (), block_len))
        };
        let ((mut thrlist6), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist6 }))
    }
}
#[doc = "Table thrlist5"]
#[derive(Clone, Debug)]
pub enum thrlist5 {
    Var0(thrlist5Var0),
    Var1(thrlist5Var1),
    Var2(thrlist5Var2),
}
impl thrlist5 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thrlist5Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thrlist5Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = thrlist5Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:618:1"]
#[derive(Clone, Debug)]
pub struct LdRtype0Var0 {}
impl LdRtype0Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r0)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0000() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0107() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:620:1"]
#[derive(Clone, Debug)]
pub struct LdRtype0Var1 {}
impl LdRtype0Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0000() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:619:1"]
#[derive(Clone, Debug)]
pub struct LdRtype0Var2 {}
impl LdRtype0Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r0),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0000() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table LdRtype0"]
#[derive(Clone, Debug)]
pub enum LdRtype0 {
    Var0(LdRtype0Var0),
    Var1(LdRtype0Var1),
    Var2(LdRtype0Var2),
}
impl LdRtype0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = LdRtype0Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = LdRtype0Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = LdRtype0Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:389:1"]
#[derive(Clone, Debug)]
pub struct Immed7_4Var0 {
    immval: i64,
}
impl Immed7_4Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { immval } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("#"),
            DisplayElement::Signed(true, *immval),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut immval = 0i64;
        immval = (i64::try_from(immed7).unwrap() * (4u64 as i64));
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let immed7 = token_parser.immed7();
            *context = context_current;
            Some(((), (immed7), block_len))
        };
        let ((), (immed7), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let immval = 0i64;
        *context = context_current;
        Some((inst_len, Self { immval }))
    }
}
#[doc = "Table Immed7_4"]
#[derive(Clone, Debug)]
pub enum Immed7_4 {
    Var0(Immed7_4Var0),
}
impl Immed7_4 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = Immed7_4Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:666:1"]
#[derive(Clone, Debug)]
pub struct strlistVar0 {
    StrType7: StrType7,
}
impl strlistVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { StrType7 } = self;
        StrType7.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let StrType7 = if let Some((len, table)) = StrType7::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((StrType7), (), block_len))
        };
        let ((mut StrType7), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { StrType7 }))
    }
}
#[doc = "Table strlist"]
#[derive(Clone, Debug)]
pub enum strlist {
    Var0(strlistVar0),
}
impl strlist {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = strlistVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1053:1"]
#[derive(Clone, Debug)]
pub struct linc15Var0 {}
impl linc15Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0000() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1052:1"]
#[derive(Clone, Debug)]
pub struct linc15Var1 {}
impl linc15Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r0)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0000() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table linc15"]
#[derive(Clone, Debug)]
pub enum linc15 {
    Var0(linc15Var0),
    Var1(linc15Var1),
}
impl linc15 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = linc15Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = linc15Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1193:1"]
#[derive(Clone, Debug)]
pub struct ldec2Var0 {
    ldec3: ldec3,
}
impl ldec2Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldec3 } = self;
        ldec3.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0202() != (0u64 as i64) as u8 {
                return None;
            }
            let ldec3 = if let Some((len, table)) = ldec3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldec3), (), block_len))
        };
        let ((mut ldec3), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldec3 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1191:1"]
#[derive(Clone, Debug)]
pub struct ldec2Var1 {
    ldec3: ldec3,
}
impl ldec2Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldec3 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r2),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        ldec3.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0202() != (1u64 as i64) as u8 {
                return None;
            }
            let ldec3 = if let Some((len, table)) = ldec3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldec3), (), block_len))
        };
        let ((mut ldec3), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldec3 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1192:1"]
#[derive(Clone, Debug)]
pub struct ldec2Var2 {}
impl ldec2Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0202() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0315() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table ldec2"]
#[derive(Clone, Debug)]
pub enum ldec2 {
    Var0(ldec2Var0),
    Var1(ldec2Var1),
    Var2(ldec2Var2),
}
impl ldec2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = ldec2Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = ldec2Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = ldec2Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:781:1"]
#[derive(Clone, Debug)]
pub struct mcrOperandsVar0 {
    opc1: u8,
    opc2: u8,
    cpn: u8,
    Rd: u8,
    CRn: u8,
    CRm: u8,
}
impl mcrOperandsVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            opc1,
            opc2,
            cpn,
            Rd,
            CRn,
            CRm,
        } = self;
        let extend: [DisplayElement; 11usize] = [
            meaning_94047773010576(usize::try_from(*cpn).unwrap()),
            DisplayElement::Literal(","),
            DisplayElement::Unsigned(true, u64::try_from(*opc1).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047768585360(usize::try_from(*CRn).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047768585360(usize::try_from(*CRm).unwrap()),
            DisplayElement::Literal(","),
            DisplayElement::Unsigned(true, u64::try_from(*opc2).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let CRm = token_parser.CRm();
            let opc2 = token_parser.opc2();
            let cpn = token_parser.cpn();
            let CRn = token_parser.CRn();
            let opc1 = token_parser.opc1();
            let Rd = token_parser.Rd();
            *context = context_current;
            Some(((), (CRn, CRm, cpn, opc2, opc1, Rd), block_len))
        };
        let ((), (CRn, CRm, cpn, opc2, opc1, Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((
            inst_len,
            Self {
                opc1,
                opc2,
                cpn,
                Rd,
                CRn,
                CRm,
            },
        ))
    }
}
#[doc = "Table mcrOperands"]
#[derive(Clone, Debug)]
pub enum mcrOperands {
    Var0(mcrOperandsVar0),
}
impl mcrOperands {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = mcrOperandsVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1554:1"]
#[derive(Clone, Debug)]
pub struct immed12_4Var0 {
    tmp: i64,
}
impl immed12_4Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { tmp } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("#"),
            DisplayElement::Signed(true, *tmp),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut tmp = 0i64;
        tmp = ((i64::try_from(immed12).unwrap() << (4u64 as i64))
            | i64::try_from(immed4).unwrap());
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let immed12 = token_parser.immed12();
            let immed4 = token_parser.immed4();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (immed12, immed4), block_len))
        };
        let ((), (immed12, immed4), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let tmp = 0i64;
        *context = context_current;
        Some((inst_len, Self { tmp }))
    }
}
#[doc = "Table immed12_4"]
#[derive(Clone, Debug)]
pub enum immed12_4 {
    Var0(immed12_4Var0),
}
impl immed12_4 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = immed12_4Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1243:1"]
#[derive(Clone, Debug)]
pub struct sdec2Var0 {
    sdec3: sdec3,
}
impl sdec2Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sdec3 } = self;
        sdec3.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0202() != (0u64 as i64) as u8 {
                return None;
            }
            let sdec3 = if let Some((len, table)) = sdec3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sdec3), (), block_len))
        };
        let ((mut sdec3), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sdec3 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1241:1"]
#[derive(Clone, Debug)]
pub struct sdec2Var1 {
    sdec3: sdec3,
}
impl sdec2Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sdec3 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r2),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        sdec3.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0202() != (1u64 as i64) as u8 {
                return None;
            }
            let sdec3 = if let Some((len, table)) = sdec3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sdec3), (), block_len))
        };
        let ((mut sdec3), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sdec3 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1242:1"]
#[derive(Clone, Debug)]
pub struct sdec2Var2 {}
impl sdec2Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0202() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0315() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table sdec2"]
#[derive(Clone, Debug)]
pub enum sdec2 {
    Var0(sdec2Var0),
    Var1(sdec2Var1),
    Var2(sdec2Var2),
}
impl sdec2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = sdec2Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = sdec2Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = sdec2Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:597:1"]
#[derive(Clone, Debug)]
pub struct Rn_exclaimVar0 {
    Rn0810: u8,
}
impl Rn_exclaimVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { Rn0810 } = self;
        let extend: [DisplayElement; 1usize] =
            [meaning_94047783056016(usize::try_from(*Rn0810).unwrap())];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0810 = token_parser.Rn0810();
            if token_parser.thc0810() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0000() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rn0810), block_len))
        };
        let ((), (Rn0810), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { Rn0810 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:598:1"]
#[derive(Clone, Debug)]
pub struct Rn_exclaimVar1 {
    Rn0810: u8,
}
impl Rn_exclaimVar1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { Rn0810 } = self;
        let extend: [DisplayElement; 1usize] =
            [meaning_94047783056016(usize::try_from(*Rn0810).unwrap())];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0810 = token_parser.Rn0810();
            if token_parser.thc0810() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0101() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rn0810), block_len))
        };
        let ((), (Rn0810), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { Rn0810 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:599:1"]
#[derive(Clone, Debug)]
pub struct Rn_exclaimVar2 {
    Rn0810: u8,
}
impl Rn_exclaimVar2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { Rn0810 } = self;
        let extend: [DisplayElement; 1usize] =
            [meaning_94047783056016(usize::try_from(*Rn0810).unwrap())];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0810 = token_parser.Rn0810();
            if token_parser.thc0810() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0202() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rn0810), block_len))
        };
        let ((), (Rn0810), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { Rn0810 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:600:1"]
#[derive(Clone, Debug)]
pub struct Rn_exclaimVar3 {
    Rn0810: u8,
}
impl Rn_exclaimVar3 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { Rn0810 } = self;
        let extend: [DisplayElement; 1usize] =
            [meaning_94047783056016(usize::try_from(*Rn0810).unwrap())];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0810 = token_parser.Rn0810();
            if token_parser.thc0810() != (3u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0303() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rn0810), block_len))
        };
        let ((), (Rn0810), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { Rn0810 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:601:1"]
#[derive(Clone, Debug)]
pub struct Rn_exclaimVar4 {
    Rn0810: u8,
}
impl Rn_exclaimVar4 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { Rn0810 } = self;
        let extend: [DisplayElement; 1usize] =
            [meaning_94047783056016(usize::try_from(*Rn0810).unwrap())];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0810 = token_parser.Rn0810();
            if token_parser.thc0810() != (4u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0404() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rn0810), block_len))
        };
        let ((), (Rn0810), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { Rn0810 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:602:1"]
#[derive(Clone, Debug)]
pub struct Rn_exclaimVar5 {
    Rn0810: u8,
}
impl Rn_exclaimVar5 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { Rn0810 } = self;
        let extend: [DisplayElement; 1usize] =
            [meaning_94047783056016(usize::try_from(*Rn0810).unwrap())];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0810 = token_parser.Rn0810();
            if token_parser.thc0810() != (5u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0505() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rn0810), block_len))
        };
        let ((), (Rn0810), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { Rn0810 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:603:1"]
#[derive(Clone, Debug)]
pub struct Rn_exclaimVar6 {
    Rn0810: u8,
}
impl Rn_exclaimVar6 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { Rn0810 } = self;
        let extend: [DisplayElement; 1usize] =
            [meaning_94047783056016(usize::try_from(*Rn0810).unwrap())];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0810 = token_parser.Rn0810();
            if token_parser.thc0810() != (6u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0606() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rn0810), block_len))
        };
        let ((), (Rn0810), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { Rn0810 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:604:1"]
#[derive(Clone, Debug)]
pub struct Rn_exclaimVar7 {
    Rn0810: u8,
}
impl Rn_exclaimVar7 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { Rn0810 } = self;
        let extend: [DisplayElement; 1usize] =
            [meaning_94047783056016(usize::try_from(*Rn0810).unwrap())];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0810 = token_parser.Rn0810();
            if token_parser.thc0810() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0707() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rn0810), block_len))
        };
        let ((), (Rn0810), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { Rn0810 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:605:1"]
#[derive(Clone, Debug)]
pub struct Rn_exclaimVar8 {
    Rn0810: u8,
}
impl Rn_exclaimVar8 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { Rn0810 } = self;
        let extend: [DisplayElement; 2usize] = [
            meaning_94047783056016(usize::try_from(*Rn0810).unwrap()),
            DisplayElement::Literal("!"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0810 = token_parser.Rn0810();
            let thc0810 = token_parser.thc0810();
            *context = context_current;
            Some(((), (thc0810, Rn0810), block_len))
        };
        let ((), (thc0810, Rn0810), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { Rn0810 }))
    }
}
#[doc = "Table Rn_exclaim"]
#[derive(Clone, Debug)]
pub enum Rn_exclaim {
    Var0(Rn_exclaimVar0),
    Var1(Rn_exclaimVar1),
    Var2(Rn_exclaimVar2),
    Var3(Rn_exclaimVar3),
    Var4(Rn_exclaimVar4),
    Var5(Rn_exclaimVar5),
    Var6(Rn_exclaimVar6),
    Var7(Rn_exclaimVar7),
    Var8(Rn_exclaimVar8),
}
impl Rn_exclaim {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
            Self::Var3(x) => x.display_extend(display, context),
            Self::Var4(x) => x.display_extend(display, context),
            Self::Var5(x) => x.display_extend(display, context),
            Self::Var6(x) => x.display_extend(display, context),
            Self::Var7(x) => x.display_extend(display, context),
            Self::Var8(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = Rn_exclaimVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = Rn_exclaimVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = Rn_exclaimVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        if let Some((inst_next, parsed)) = Rn_exclaimVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var3(parsed)));
        }
        if let Some((inst_next, parsed)) = Rn_exclaimVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var4(parsed)));
        }
        if let Some((inst_next, parsed)) = Rn_exclaimVar5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var5(parsed)));
        }
        if let Some((inst_next, parsed)) = Rn_exclaimVar6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var6(parsed)));
        }
        if let Some((inst_next, parsed)) = Rn_exclaimVar7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var7(parsed)));
        }
        if let Some((inst_next, parsed)) = Rn_exclaimVar8::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var8(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:369:1"]
#[derive(Clone, Debug)]
pub struct Immed3Var0 {
    immed3: u8,
}
impl Immed3Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { immed3 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("#"),
            DisplayElement::Unsigned(true, u64::try_from(*immed3).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let immed3 = token_parser.immed3();
            *context = context_current;
            Some(((), (immed3), block_len))
        };
        let ((), (immed3), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { immed3 }))
    }
}
#[doc = "Table Immed3"]
#[derive(Clone, Debug)]
pub enum Immed3 {
    Var0(Immed3Var0),
}
impl Immed3 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = Immed3Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1222:1"]
#[derive(Clone, Debug)]
pub struct sdec9Var0 {
    sdec10: sdec10,
}
impl sdec9Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sdec10 } = self;
        sdec10.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0909() != (0u64 as i64) as u8 {
                return None;
            }
            let sdec10 = if let Some((len, table)) = sdec10::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sdec10), (), block_len))
        };
        let ((mut sdec10), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sdec10 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1220:1"]
#[derive(Clone, Debug)]
pub struct sdec9Var1 {
    sdec10: sdec10,
}
impl sdec9Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sdec10 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r9),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        sdec10.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0909() != (1u64 as i64) as u8 {
                return None;
            }
            let sdec10 = if let Some((len, table)) = sdec10::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sdec10), (), block_len))
        };
        let ((mut sdec10), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sdec10 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1221:1"]
#[derive(Clone, Debug)]
pub struct sdec9Var2 {}
impl sdec9Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r9)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0909() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1015() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table sdec9"]
#[derive(Clone, Debug)]
pub enum sdec9 {
    Var0(sdec9Var0),
    Var1(sdec9Var1),
    Var2(sdec9Var2),
}
impl sdec9 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = sdec9Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = sdec9Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = sdec9Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:655:1"]
#[derive(Clone, Debug)]
pub struct XBITVar0 {}
impl XBITVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("t")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let smRn = token_parser.smRn();
            if token_parser.x() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (smRn), block_len))
        };
        let ((), (smRn), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:654:1"]
#[derive(Clone, Debug)]
pub struct XBITVar1 {}
impl XBITVar1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let smRn = token_parser.smRn();
            if token_parser.x() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (smRn), block_len))
        };
        let ((), (smRn), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table XBIT"]
#[derive(Clone, Debug)]
pub enum XBIT {
    Var0(XBITVar0),
    Var1(XBITVar1),
}
impl XBIT {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = XBITVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = XBITVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1099:1"]
#[derive(Clone, Debug)]
pub struct ldlist_incVar0 {
    linc0: linc0,
}
impl ldlist_incVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { linc0 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("{")];
        display.extend_from_slice(&extend);
        linc0.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let linc0 = if let Some((len, table)) = linc0::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((linc0), (), block_len))
        };
        let ((mut linc0), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { linc0 }))
    }
}
#[doc = "Table ldlist_inc"]
#[derive(Clone, Debug)]
pub enum ldlist_inc {
    Var0(ldlist_incVar0),
}
impl ldlist_inc {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = ldlist_incVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1154:1"]
#[derive(Clone, Debug)]
pub struct ldec15Var0 {}
impl ldec15Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1515() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1153:1"]
#[derive(Clone, Debug)]
pub struct ldec15Var1 {}
impl ldec15Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1515() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table ldec15"]
#[derive(Clone, Debug)]
pub enum ldec15 {
    Var0(ldec15Var0),
    Var1(ldec15Var1),
}
impl ldec15 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = ldec15Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = ldec15Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1207:1"]
#[derive(Clone, Debug)]
pub struct sdec14Var0 {
    sdec15: sdec15,
}
impl sdec14Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sdec15 } = self;
        sdec15.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1414() != (0u64 as i64) as u8 {
                return None;
            }
            let sdec15 = if let Some((len, table)) = sdec15::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sdec15), (), block_len))
        };
        let ((mut sdec15), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sdec15 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1205:1"]
#[derive(Clone, Debug)]
pub struct sdec14Var1 {
    sdec15: sdec15,
}
impl sdec14Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sdec15 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::lr),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        sdec15.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1414() != (1u64 as i64) as u8 {
                return None;
            }
            let sdec15 = if let Some((len, table)) = sdec15::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sdec15), (), block_len))
        };
        let ((mut sdec15), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sdec15 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1206:1"]
#[derive(Clone, Debug)]
pub struct sdec14Var2 {}
impl sdec14Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::lr)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1414() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1515() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table sdec14"]
#[derive(Clone, Debug)]
pub enum sdec14 {
    Var0(sdec14Var0),
    Var1(sdec14Var1),
    Var2(sdec14Var2),
}
impl sdec14 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = sdec14Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = sdec14Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = sdec14Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:676:1"]
#[derive(Clone, Debug)]
pub struct PshType6Var0 {
    PshType7: PshType7,
}
impl PshType6Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { PshType7 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r6),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        PshType7.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let PshType7 = if let Some((len, table)) = PshType7::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0606() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((PshType7), (), block_len))
        };
        let ((mut PshType7), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { PshType7 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:674:1"]
#[derive(Clone, Debug)]
pub struct PshType6Var1 {
    PshType7: PshType7,
}
impl PshType6Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { PshType7 } = self;
        PshType7.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let PshType7 = if let Some((len, table)) = PshType7::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0606() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((PshType7), (), block_len))
        };
        let ((mut PshType7), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { PshType7 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:675:1"]
#[derive(Clone, Debug)]
pub struct PshType6Var2 {}
impl PshType6Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0606() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0707() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table PshType6"]
#[derive(Clone, Debug)]
pub enum PshType6 {
    Var0(PshType6Var0),
    Var1(PshType6Var1),
    Var2(PshType6Var2),
}
impl PshType6 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = PshType6Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = PshType6Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = PshType6Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1056:1"]
#[derive(Clone, Debug)]
pub struct linc14Var0 {
    linc15: linc15,
}
impl linc14Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { linc15 } = self;
        linc15.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0101() != (0u64 as i64) as u8 {
                return None;
            }
            let linc15 = if let Some((len, table)) = linc15::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((linc15), (), block_len))
        };
        let ((mut linc15), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { linc15 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1054:1"]
#[derive(Clone, Debug)]
pub struct linc14Var1 {
    linc15: linc15,
}
impl linc14Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { linc15 } = self;
        linc15.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r1),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0101() != (1u64 as i64) as u8 {
                return None;
            }
            let linc15 = if let Some((len, table)) = linc15::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((linc15), (), block_len))
        };
        let ((mut linc15), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { linc15 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1055:1"]
#[derive(Clone, Debug)]
pub struct linc14Var2 {}
impl linc14Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0101() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0000() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table linc14"]
#[derive(Clone, Debug)]
pub enum linc14 {
    Var0(linc14Var0),
    Var1(linc14Var1),
    Var2(linc14Var2),
}
impl linc14 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = linc14Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = linc14Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = linc14Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:540:1"]
#[derive(Clone, Debug)]
pub struct Addr8Var0 {
    reloc: i64,
}
impl Addr8Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { reloc } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Signed(true, *reloc)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut reloc = 0i64;
        reloc = (((i64::try_from(inst_start).unwrap() + (4u64 as i64))
            + (2u64 as i64))
            * i64::try_from(soffset8).unwrap());
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let soffset8 = token_parser.soffset8();
            *context = context_current;
            Some(((), (soffset8), block_len))
        };
        let ((), (soffset8), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let reloc = 0i64;
        *context = context_current;
        Some((inst_len, Self { reloc }))
    }
}
#[doc = "Table Addr8"]
#[derive(Clone, Debug)]
pub enum Addr8 {
    Var0(Addr8Var0),
}
impl Addr8 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = Addr8Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1074:1"]
#[derive(Clone, Debug)]
pub struct linc8Var0 {
    linc9: linc9,
}
impl linc8Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { linc9 } = self;
        linc9.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0707() != (0u64 as i64) as u8 {
                return None;
            }
            let linc9 = if let Some((len, table)) = linc9::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((linc9), (), block_len))
        };
        let ((mut linc9), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { linc9 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1072:1"]
#[derive(Clone, Debug)]
pub struct linc8Var1 {
    linc9: linc9,
}
impl linc8Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { linc9 } = self;
        linc9.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r7),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0707() != (1u64 as i64) as u8 {
                return None;
            }
            let linc9 = if let Some((len, table)) = linc9::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((linc9), (), block_len))
        };
        let ((mut linc9), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { linc9 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1073:1"]
#[derive(Clone, Debug)]
pub struct linc8Var2 {}
impl linc8Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0707() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0006() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table linc8"]
#[derive(Clone, Debug)]
pub enum linc8 {
    Var0(linc8Var0),
    Var1(linc8Var1),
    Var2(linc8Var2),
}
impl linc8 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = linc8Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = linc8Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = linc8Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:940:1"]
#[derive(Clone, Debug)]
pub struct Sprel8IndirectVar0 {
    immval: i64,
}
impl Sprel8IndirectVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { immval } = self;
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("["),
            DisplayElement::Register(Register::sp),
            DisplayElement::Literal(","),
            DisplayElement::Literal("#"),
            DisplayElement::Signed(true, *immval),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut immval = 0i64;
        immval = (i64::try_from(immed8).unwrap() * (4u64 as i64));
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let immed8 = token_parser.immed8();
            *context = context_current;
            Some(((), (immed8), block_len))
        };
        let ((), (immed8), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let immval = 0i64;
        *context = context_current;
        Some((inst_len, Self { immval }))
    }
}
#[doc = "Table Sprel8Indirect"]
#[derive(Clone, Debug)]
pub enum Sprel8Indirect {
    Var0(Sprel8IndirectVar0),
}
impl Sprel8Indirect {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = Sprel8IndirectVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:898:1"]
#[derive(Clone, Debug)]
pub struct psbraceVar0 {
    pshlist: pshlist,
}
impl psbraceVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { pshlist } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("{")];
        display.extend_from_slice(&extend);
        pshlist.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let pshlist = if let Some((len, table)) = pshlist::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((pshlist), (), block_len))
        };
        let ((mut pshlist), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { pshlist }))
    }
}
#[doc = "Table psbrace"]
#[derive(Clone, Debug)]
pub enum psbrace {
    Var0(psbraceVar0),
}
impl psbrace {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = psbraceVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1483:1"]
#[derive(Clone, Debug)]
pub struct bxnsVar0 {}
impl bxnsVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ns")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0002() != (4u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1482:1"]
#[derive(Clone, Debug)]
pub struct bxnsVar1 {}
impl bxnsVar1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(""), DisplayElement::Literal("")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let thc0003 = token_parser.thc0003();
            *context = context_current;
            Some(((), (thc0003), block_len))
        };
        let ((), (thc0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table bxns"]
#[derive(Clone, Debug)]
pub enum bxns {
    Var0(bxnsVar0),
    Var1(bxnsVar1),
}
impl bxns {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = bxnsVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = bxnsVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:652:1"]
#[derive(Clone, Debug)]
pub struct StrType3Var0 {
    StrType2: StrType2,
}
impl StrType3Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { StrType2 } = self;
        StrType2.display_extend(display, context);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let StrType2 = if let Some((len, table)) = StrType2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0303() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0407() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((StrType2), (), block_len))
        };
        let ((mut StrType2), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { StrType2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:654:1"]
#[derive(Clone, Debug)]
pub struct StrType3Var1 {
    StrType2: StrType2,
}
impl StrType3Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { StrType2 } = self;
        StrType2.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let StrType2 = if let Some((len, table)) = StrType2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0303() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((StrType2), (), block_len))
        };
        let ((mut StrType2), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { StrType2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:653:1"]
#[derive(Clone, Debug)]
pub struct StrType3Var2 {
    StrType2: StrType2,
}
impl StrType3Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { StrType2 } = self;
        StrType2.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r3),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let StrType2 = if let Some((len, table)) = StrType2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0303() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((StrType2), (), block_len))
        };
        let ((mut StrType2), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { StrType2 }))
    }
}
#[doc = "Table StrType3"]
#[derive(Clone, Debug)]
pub enum StrType3 {
    Var0(StrType3Var0),
    Var1(StrType3Var1),
    Var2(StrType3Var2),
}
impl StrType3 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = StrType3Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = StrType3Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = StrType3Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:721:1"]
#[derive(Clone, Debug)]
pub struct thrlist7Var0 {
    thrlist8: thrlist8,
}
impl thrlist7Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist8 } = self;
        thrlist8.display_extend(display, context);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r8)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0808() != (1u64 as i64) as u8 {
                return None;
            }
            let thrlist8 = if let Some((len, table)) = thrlist8::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0915() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((thrlist8), (), block_len))
        };
        let ((mut thrlist8), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:723:1"]
#[derive(Clone, Debug)]
pub struct thrlist7Var1 {
    thrlist8: thrlist8,
}
impl thrlist7Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist8 } = self;
        thrlist8.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0808() != (0u64 as i64) as u8 {
                return None;
            }
            let thrlist8 = if let Some((len, table)) = thrlist8::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thrlist8), (), block_len))
        };
        let ((mut thrlist8), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:722:1"]
#[derive(Clone, Debug)]
pub struct thrlist7Var2 {
    thrlist8: thrlist8,
}
impl thrlist7Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist8 } = self;
        thrlist8.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r8),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0808() != (1u64 as i64) as u8 {
                return None;
            }
            let thrlist8 = if let Some((len, table)) = thrlist8::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thrlist8), (), block_len))
        };
        let ((mut thrlist8), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist8 }))
    }
}
#[doc = "Table thrlist7"]
#[derive(Clone, Debug)]
pub enum thrlist7 {
    Var0(thrlist7Var0),
    Var1(thrlist7Var1),
    Var2(thrlist7Var2),
}
impl thrlist7 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thrlist7Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thrlist7Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = thrlist7Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:353:1"]
#[derive(Clone, Debug)]
pub struct Hrd0002Var0 {}
impl Hrd0002Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.hrd0002() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.h1() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:352:1"]
#[derive(Clone, Debug)]
pub struct Hrd0002Var1 {
    hrd0002: u8,
}
impl Hrd0002Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { hrd0002 } = self;
        let extend: [DisplayElement; 1usize] =
            [meaning_94047764607728(usize::try_from(*hrd0002).unwrap())];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let hrd0002 = token_parser.hrd0002();
            if token_parser.h1() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (hrd0002), block_len))
        };
        let ((), (hrd0002), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { hrd0002 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:351:1"]
#[derive(Clone, Debug)]
pub struct Hrd0002Var2 {
    Rd0002: u8,
}
impl Hrd0002Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { Rd0002 } = self;
        let extend: [DisplayElement; 1usize] =
            [meaning_94047783056016(usize::try_from(*Rd0002).unwrap())];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0002 = token_parser.Rd0002();
            if token_parser.h1() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rd0002), block_len))
        };
        let ((), (Rd0002), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { Rd0002 }))
    }
}
#[doc = "Table Hrd0002"]
#[derive(Clone, Debug)]
pub enum Hrd0002 {
    Var0(Hrd0002Var0),
    Var1(Hrd0002Var1),
    Var2(Hrd0002Var2),
}
impl Hrd0002 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = Hrd0002Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = Hrd0002Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = Hrd0002Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1442:1"]
#[derive(Clone, Debug)]
pub struct cpsrmaskVar0 {}
impl cpsrmaskVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_cxsf")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.mask() != (15u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1441:1"]
#[derive(Clone, Debug)]
pub struct cpsrmaskVar1 {}
impl cpsrmaskVar1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_xsf")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.mask() != (14u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1440:1"]
#[derive(Clone, Debug)]
pub struct cpsrmaskVar2 {}
impl cpsrmaskVar2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_csf")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.mask() != (13u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1439:1"]
#[derive(Clone, Debug)]
pub struct cpsrmaskVar3 {}
impl cpsrmaskVar3 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_sf")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.mask() != (12u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1438:1"]
#[derive(Clone, Debug)]
pub struct cpsrmaskVar4 {}
impl cpsrmaskVar4 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_cxf")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.mask() != (11u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1437:1"]
#[derive(Clone, Debug)]
pub struct cpsrmaskVar5 {}
impl cpsrmaskVar5 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_xf")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.mask() != (10u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1436:1"]
#[derive(Clone, Debug)]
pub struct cpsrmaskVar6 {}
impl cpsrmaskVar6 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_cf")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.mask() != (9u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1435:1"]
#[derive(Clone, Debug)]
pub struct cpsrmaskVar7 {}
impl cpsrmaskVar7 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_f")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.mask() != (8u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1434:1"]
#[derive(Clone, Debug)]
pub struct cpsrmaskVar8 {}
impl cpsrmaskVar8 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_cxs")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.mask() != (7u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1433:1"]
#[derive(Clone, Debug)]
pub struct cpsrmaskVar9 {}
impl cpsrmaskVar9 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_xs")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.mask() != (6u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1432:1"]
#[derive(Clone, Debug)]
pub struct cpsrmaskVar10 {}
impl cpsrmaskVar10 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_cs")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.mask() != (5u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1431:1"]
#[derive(Clone, Debug)]
pub struct cpsrmaskVar11 {}
impl cpsrmaskVar11 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_s")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.mask() != (4u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1430:1"]
#[derive(Clone, Debug)]
pub struct cpsrmaskVar12 {}
impl cpsrmaskVar12 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_cx")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.mask() != (3u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1429:1"]
#[derive(Clone, Debug)]
pub struct cpsrmaskVar13 {}
impl cpsrmaskVar13 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_x")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.mask() != (2u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1428:1"]
#[derive(Clone, Debug)]
pub struct cpsrmaskVar14 {}
impl cpsrmaskVar14 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cpsr_c")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.mask() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1427:1"]
#[derive(Clone, Debug)]
pub struct cpsrmaskVar15 {}
impl cpsrmaskVar15 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.mask() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table cpsrmask"]
#[derive(Clone, Debug)]
pub enum cpsrmask {
    Var0(cpsrmaskVar0),
    Var1(cpsrmaskVar1),
    Var2(cpsrmaskVar2),
    Var3(cpsrmaskVar3),
    Var4(cpsrmaskVar4),
    Var5(cpsrmaskVar5),
    Var6(cpsrmaskVar6),
    Var7(cpsrmaskVar7),
    Var8(cpsrmaskVar8),
    Var9(cpsrmaskVar9),
    Var10(cpsrmaskVar10),
    Var11(cpsrmaskVar11),
    Var12(cpsrmaskVar12),
    Var13(cpsrmaskVar13),
    Var14(cpsrmaskVar14),
    Var15(cpsrmaskVar15),
}
impl cpsrmask {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
            Self::Var3(x) => x.display_extend(display, context),
            Self::Var4(x) => x.display_extend(display, context),
            Self::Var5(x) => x.display_extend(display, context),
            Self::Var6(x) => x.display_extend(display, context),
            Self::Var7(x) => x.display_extend(display, context),
            Self::Var8(x) => x.display_extend(display, context),
            Self::Var9(x) => x.display_extend(display, context),
            Self::Var10(x) => x.display_extend(display, context),
            Self::Var11(x) => x.display_extend(display, context),
            Self::Var12(x) => x.display_extend(display, context),
            Self::Var13(x) => x.display_extend(display, context),
            Self::Var14(x) => x.display_extend(display, context),
            Self::Var15(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var14(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var15(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = cpsrmaskVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = cpsrmaskVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = cpsrmaskVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        if let Some((inst_next, parsed)) = cpsrmaskVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var3(parsed)));
        }
        if let Some((inst_next, parsed)) = cpsrmaskVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var4(parsed)));
        }
        if let Some((inst_next, parsed)) = cpsrmaskVar5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var5(parsed)));
        }
        if let Some((inst_next, parsed)) = cpsrmaskVar6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var6(parsed)));
        }
        if let Some((inst_next, parsed)) = cpsrmaskVar7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var7(parsed)));
        }
        if let Some((inst_next, parsed)) = cpsrmaskVar8::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var8(parsed)));
        }
        if let Some((inst_next, parsed)) = cpsrmaskVar9::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var9(parsed)));
        }
        if let Some((inst_next, parsed)) = cpsrmaskVar10::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var10(parsed)));
        }
        if let Some((inst_next, parsed)) = cpsrmaskVar11::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var11(parsed)));
        }
        if let Some((inst_next, parsed)) = cpsrmaskVar12::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var12(parsed)));
        }
        if let Some((inst_next, parsed)) = cpsrmaskVar13::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var13(parsed)));
        }
        if let Some((inst_next, parsed)) = cpsrmaskVar14::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var14(parsed)));
        }
        if let Some((inst_next, parsed)) = cpsrmaskVar15::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var15(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1065:1"]
#[derive(Clone, Debug)]
pub struct linc11Var0 {
    linc12: linc12,
}
impl linc11Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { linc12 } = self;
        linc12.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0404() != (0u64 as i64) as u8 {
                return None;
            }
            let linc12 = if let Some((len, table)) = linc12::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((linc12), (), block_len))
        };
        let ((mut linc12), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { linc12 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1063:1"]
#[derive(Clone, Debug)]
pub struct linc11Var1 {
    linc12: linc12,
}
impl linc11Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { linc12 } = self;
        linc12.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r4),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            let linc12 = if let Some((len, table)) = linc12::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((linc12), (), block_len))
        };
        let ((mut linc12), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { linc12 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1064:1"]
#[derive(Clone, Debug)]
pub struct linc11Var2 {}
impl linc11Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0003() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table linc11"]
#[derive(Clone, Debug)]
pub enum linc11 {
    Var0(linc11Var0),
    Var1(linc11Var1),
    Var2(linc11Var2),
}
impl linc11 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = linc11Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = linc11Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = linc11Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1136:1"]
#[derive(Clone, Debug)]
pub struct sinc4Var0 {
    sinc5: sinc5,
}
impl sinc4Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sinc5 } = self;
        sinc5.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1111() != (0u64 as i64) as u8 {
                return None;
            }
            let sinc5 = if let Some((len, table)) = sinc5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sinc5), (), block_len))
        };
        let ((mut sinc5), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sinc5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1134:1"]
#[derive(Clone, Debug)]
pub struct sinc4Var1 {
    sinc5: sinc5,
}
impl sinc4Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sinc5 } = self;
        sinc5.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r11),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1111() != (1u64 as i64) as u8 {
                return None;
            }
            let sinc5 = if let Some((len, table)) = sinc5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sinc5), (), block_len))
        };
        let ((mut sinc5), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sinc5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1135:1"]
#[derive(Clone, Debug)]
pub struct sinc4Var2 {}
impl sinc4Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r11)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1111() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0010() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table sinc4"]
#[derive(Clone, Debug)]
pub enum sinc4 {
    Var0(sinc4Var0),
    Var1(sinc4Var1),
    Var2(sinc4Var2),
}
impl sinc4 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = sinc4Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = sinc4Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = sinc4Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:638:1"]
#[derive(Clone, Debug)]
pub struct SBIT_CZNOVar0 {}
impl SBIT_CZNOVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("s")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.S20() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:637:1"]
#[derive(Clone, Debug)]
pub struct SBIT_CZNOVar1 {}
impl SBIT_CZNOVar1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.S20() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table SBIT_CZNO"]
#[derive(Clone, Debug)]
pub enum SBIT_CZNO {
    Var0(SBIT_CZNOVar0),
    Var1(SBIT_CZNOVar1),
}
impl SBIT_CZNO {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = SBIT_CZNOVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = SBIT_CZNOVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:661:1"]
#[derive(Clone, Debug)]
pub struct StrType6Var0 {
    StrType5: StrType5,
}
impl StrType6Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { StrType5 } = self;
        StrType5.display_extend(display, context);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let StrType5 = if let Some((len, table)) = StrType5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0606() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0707() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((StrType5), (), block_len))
        };
        let ((mut StrType5), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { StrType5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:663:1"]
#[derive(Clone, Debug)]
pub struct StrType6Var1 {
    StrType5: StrType5,
}
impl StrType6Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { StrType5 } = self;
        StrType5.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let StrType5 = if let Some((len, table)) = StrType5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0606() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((StrType5), (), block_len))
        };
        let ((mut StrType5), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { StrType5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:662:1"]
#[derive(Clone, Debug)]
pub struct StrType6Var2 {
    StrType5: StrType5,
}
impl StrType6Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { StrType5 } = self;
        StrType5.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r6),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let StrType5 = if let Some((len, table)) = StrType5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0606() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((StrType5), (), block_len))
        };
        let ((mut StrType5), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { StrType5 }))
    }
}
#[doc = "Table StrType6"]
#[derive(Clone, Debug)]
pub enum StrType6 {
    Var0(StrType6Var0),
    Var1(StrType6Var1),
    Var2(StrType6Var2),
}
impl StrType6 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = StrType6Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = StrType6Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = StrType6Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1412:1"]
#[derive(Clone, Debug)]
pub struct mdirVar0 {}
impl mdirVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("db")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1411:1"]
#[derive(Clone, Debug)]
pub struct mdirVar1 {}
impl mdirVar1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("da")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1410:1"]
#[derive(Clone, Debug)]
pub struct mdirVar2 {}
impl mdirVar2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ib")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1409:1"]
#[derive(Clone, Debug)]
pub struct mdirVar3 {}
impl mdirVar3 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ia")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table mdir"]
#[derive(Clone, Debug)]
pub enum mdir {
    Var0(mdirVar0),
    Var1(mdirVar1),
    Var2(mdirVar2),
    Var3(mdirVar3),
}
impl mdir {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
            Self::Var3(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = mdirVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = mdirVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = mdirVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        if let Some((inst_next, parsed)) = mdirVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var3(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:889:1"]
#[derive(Clone, Debug)]
pub struct thsdec1Var0 {}
impl thsdec1Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0101() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0215() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:891:1"]
#[derive(Clone, Debug)]
pub struct thsdec1Var1 {
    thsdec2: thsdec2,
}
impl thsdec1Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thsdec2 } = self;
        thsdec2.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0101() != (0u64 as i64) as u8 {
                return None;
            }
            let thsdec2 = if let Some((len, table)) = thsdec2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thsdec2), (), block_len))
        };
        let ((mut thsdec2), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thsdec2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:890:1"]
#[derive(Clone, Debug)]
pub struct thsdec1Var2 {
    thsdec2: thsdec2,
}
impl thsdec1Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thsdec2 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r1),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        thsdec2.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0101() != (1u64 as i64) as u8 {
                return None;
            }
            let thsdec2 = if let Some((len, table)) = thsdec2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thsdec2), (), block_len))
        };
        let ((mut thsdec2), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thsdec2 }))
    }
}
#[doc = "Table thsdec1"]
#[derive(Clone, Debug)]
pub enum thsdec1 {
    Var0(thsdec1Var0),
    Var1(thsdec1Var1),
    Var2(thsdec1Var2),
}
impl thsdec1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thsdec1Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thsdec1Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = thsdec1Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1071:1"]
#[derive(Clone, Debug)]
pub struct linc9Var0 {
    linc10: linc10,
}
impl linc9Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { linc10 } = self;
        linc10.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0606() != (0u64 as i64) as u8 {
                return None;
            }
            let linc10 = if let Some((len, table)) = linc10::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((linc10), (), block_len))
        };
        let ((mut linc10), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { linc10 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1069:1"]
#[derive(Clone, Debug)]
pub struct linc9Var1 {
    linc10: linc10,
}
impl linc9Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { linc10 } = self;
        linc10.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r6),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0606() != (1u64 as i64) as u8 {
                return None;
            }
            let linc10 = if let Some((len, table)) = linc10::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((linc10), (), block_len))
        };
        let ((mut linc10), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { linc10 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1070:1"]
#[derive(Clone, Debug)]
pub struct linc9Var2 {}
impl linc9Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0606() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0005() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table linc9"]
#[derive(Clone, Debug)]
pub enum linc9 {
    Var0(linc9Var0),
    Var1(linc9Var1),
    Var2(linc9Var2),
}
impl linc9 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = linc9Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = linc9Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = linc9Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:700:1"]
#[derive(Clone, Debug)]
pub struct thrlist14Var0 {
    thrlist15: thrlist15,
}
impl thrlist14Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist15 } = self;
        thrlist15.display_extend(display, context);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0101() != (1u64 as i64) as u8 {
                return None;
            }
            let thrlist15 = if let Some((len, table)) = thrlist15::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0215() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((thrlist15), (), block_len))
        };
        let ((mut thrlist15), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist15 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:702:1"]
#[derive(Clone, Debug)]
pub struct thrlist14Var1 {
    thrlist15: thrlist15,
}
impl thrlist14Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist15 } = self;
        thrlist15.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0101() != (0u64 as i64) as u8 {
                return None;
            }
            let thrlist15 = if let Some((len, table)) = thrlist15::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thrlist15), (), block_len))
        };
        let ((mut thrlist15), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist15 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:701:1"]
#[derive(Clone, Debug)]
pub struct thrlist14Var2 {
    thrlist15: thrlist15,
}
impl thrlist14Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist15 } = self;
        thrlist15.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r1),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0101() != (1u64 as i64) as u8 {
                return None;
            }
            let thrlist15 = if let Some((len, table)) = thrlist15::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thrlist15), (), block_len))
        };
        let ((mut thrlist15), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist15 }))
    }
}
#[doc = "Table thrlist14"]
#[derive(Clone, Debug)]
pub enum thrlist14 {
    Var0(thrlist14Var0),
    Var1(thrlist14Var1),
    Var2(thrlist14Var2),
}
impl thrlist14 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thrlist14Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thrlist14Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = thrlist14Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1139:1"]
#[derive(Clone, Debug)]
pub struct sinc3Var0 {
    sinc4: sinc4,
}
impl sinc3Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sinc4 } = self;
        sinc4.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1212() != (0u64 as i64) as u8 {
                return None;
            }
            let sinc4 = if let Some((len, table)) = sinc4::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sinc4), (), block_len))
        };
        let ((mut sinc4), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sinc4 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1137:1"]
#[derive(Clone, Debug)]
pub struct sinc3Var1 {
    sinc4: sinc4,
}
impl sinc3Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sinc4 } = self;
        sinc4.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r12),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1212() != (1u64 as i64) as u8 {
                return None;
            }
            let sinc4 = if let Some((len, table)) = sinc4::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sinc4), (), block_len))
        };
        let ((mut sinc4), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sinc4 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1138:1"]
#[derive(Clone, Debug)]
pub struct sinc3Var2 {}
impl sinc3Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r12)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1212() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0011() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table sinc3"]
#[derive(Clone, Debug)]
pub enum sinc3 {
    Var0(sinc3Var0),
    Var1(sinc3Var1),
    Var2(sinc3Var2),
}
impl sinc3 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = sinc3Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = sinc3Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = sinc3Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:877:1"]
#[derive(Clone, Debug)]
pub struct thsdec5Var0 {}
impl thsdec5Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0505() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0615() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:879:1"]
#[derive(Clone, Debug)]
pub struct thsdec5Var1 {
    thsdec6: thsdec6,
}
impl thsdec5Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thsdec6 } = self;
        thsdec6.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0505() != (0u64 as i64) as u8 {
                return None;
            }
            let thsdec6 = if let Some((len, table)) = thsdec6::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thsdec6), (), block_len))
        };
        let ((mut thsdec6), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thsdec6 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:878:1"]
#[derive(Clone, Debug)]
pub struct thsdec5Var2 {
    thsdec6: thsdec6,
}
impl thsdec5Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thsdec6 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r5),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        thsdec6.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0505() != (1u64 as i64) as u8 {
                return None;
            }
            let thsdec6 = if let Some((len, table)) = thsdec6::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thsdec6), (), block_len))
        };
        let ((mut thsdec6), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thsdec6 }))
    }
}
#[doc = "Table thsdec5"]
#[derive(Clone, Debug)]
pub enum thsdec5 {
    Var0(thsdec5Var0),
    Var1(thsdec5Var1),
    Var2(thsdec5Var2),
}
impl thsdec5 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thsdec5Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thsdec5Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = thsdec5Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:607:1"]
#[derive(Clone, Debug)]
pub struct rmVar0 {}
impl rmVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.Rm() != (15u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:608:1"]
#[derive(Clone, Debug)]
pub struct rmVar1 {
    Rm: u8,
}
impl rmVar1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { Rm } = self;
        let extend: [DisplayElement; 1usize] =
            [meaning_94047766862464(usize::try_from(*Rm).unwrap())];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rm = token_parser.Rm();
            *context = context_current;
            Some(((), (Rm), block_len))
        };
        let ((), (Rm), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { Rm }))
    }
}
#[doc = "Table rm"]
#[derive(Clone, Debug)]
pub enum rm {
    Var0(rmVar0),
    Var1(rmVar1),
}
impl rm {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = rmVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = rmVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:390:1"]
#[derive(Clone, Debug)]
pub struct Immed5Var0 {
    immed5: u8,
}
impl Immed5Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { immed5 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("#"),
            DisplayElement::Unsigned(true, u64::try_from(*immed5).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let immed5 = token_parser.immed5();
            *context = context_current;
            Some(((), (immed5), block_len))
        };
        let ((), (immed5), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { immed5 }))
    }
}
#[doc = "Table Immed5"]
#[derive(Clone, Debug)]
pub enum Immed5 {
    Var0(Immed5Var0),
}
impl Immed5 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = Immed5Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARM.sinc:243:1"]
#[derive(Clone, Debug)]
pub struct CheckInIT_CZNVar0 {}
impl CheckInIT_CZNVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table CheckInIT_CZN"]
#[derive(Clone, Debug)]
pub enum CheckInIT_CZN {
    Var0(CheckInIT_CZNVar0),
}
impl CheckInIT_CZN {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = CheckInIT_CZNVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:733:1"]
#[derive(Clone, Debug)]
pub struct thrlist3Var0 {
    thrlist4: thrlist4,
}
impl thrlist3Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist4 } = self;
        thrlist4.display_extend(display, context);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r12)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc1212() != (1u64 as i64) as u8 {
                return None;
            }
            let thrlist4 = if let Some((len, table)) = thrlist4::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc1315() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((thrlist4), (), block_len))
        };
        let ((mut thrlist4), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist4 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:735:1"]
#[derive(Clone, Debug)]
pub struct thrlist3Var1 {
    thrlist4: thrlist4,
}
impl thrlist3Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist4 } = self;
        thrlist4.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc1212() != (0u64 as i64) as u8 {
                return None;
            }
            let thrlist4 = if let Some((len, table)) = thrlist4::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thrlist4), (), block_len))
        };
        let ((mut thrlist4), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist4 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:734:1"]
#[derive(Clone, Debug)]
pub struct thrlist3Var2 {
    thrlist4: thrlist4,
}
impl thrlist3Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist4 } = self;
        thrlist4.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r12),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc1212() != (1u64 as i64) as u8 {
                return None;
            }
            let thrlist4 = if let Some((len, table)) = thrlist4::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thrlist4), (), block_len))
        };
        let ((mut thrlist4), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist4 }))
    }
}
#[doc = "Table thrlist3"]
#[derive(Clone, Debug)]
pub enum thrlist3 {
    Var0(thrlist3Var0),
    Var1(thrlist3Var1),
    Var2(thrlist3Var2),
}
impl thrlist3 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thrlist3Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thrlist3Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = thrlist3Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1169:1"]
#[derive(Clone, Debug)]
pub struct ldec10Var0 {
    ldec11: ldec11,
}
impl ldec10Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldec11 } = self;
        ldec11.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1010() != (0u64 as i64) as u8 {
                return None;
            }
            let ldec11 = if let Some((len, table)) = ldec11::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldec11), (), block_len))
        };
        let ((mut ldec11), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldec11 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1167:1"]
#[derive(Clone, Debug)]
pub struct ldec10Var1 {
    ldec11: ldec11,
}
impl ldec10Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldec11 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r10),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        ldec11.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1010() != (1u64 as i64) as u8 {
                return None;
            }
            let ldec11 = if let Some((len, table)) = ldec11::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldec11), (), block_len))
        };
        let ((mut ldec11), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldec11 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1168:1"]
#[derive(Clone, Debug)]
pub struct ldec10Var2 {}
impl ldec10Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r10)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1010() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1115() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table ldec10"]
#[derive(Clone, Debug)]
pub enum ldec10 {
    Var0(ldec10Var0),
    Var1(ldec10Var1),
    Var2(ldec10Var2),
}
impl ldec10 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = ldec10Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = ldec10Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = ldec10Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:624:1"]
#[derive(Clone, Debug)]
pub struct LdRtype2Var0 {
    LdRtype1: LdRtype1,
}
impl LdRtype2Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { LdRtype1 } = self;
        LdRtype1.display_extend(display, context);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let LdRtype1 = if let Some((len, table)) = LdRtype1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0202() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0307() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((LdRtype1), (), block_len))
        };
        let ((mut LdRtype1), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { LdRtype1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:626:1"]
#[derive(Clone, Debug)]
pub struct LdRtype2Var1 {
    LdRtype1: LdRtype1,
}
impl LdRtype2Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { LdRtype1 } = self;
        LdRtype1.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let LdRtype1 = if let Some((len, table)) = LdRtype1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0202() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((LdRtype1), (), block_len))
        };
        let ((mut LdRtype1), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { LdRtype1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:625:1"]
#[derive(Clone, Debug)]
pub struct LdRtype2Var2 {
    LdRtype1: LdRtype1,
}
impl LdRtype2Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { LdRtype1 } = self;
        LdRtype1.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r2),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let LdRtype1 = if let Some((len, table)) = LdRtype1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0202() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((LdRtype1), (), block_len))
        };
        let ((mut LdRtype1), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { LdRtype1 }))
    }
}
#[doc = "Table LdRtype2"]
#[derive(Clone, Debug)]
pub enum LdRtype2 {
    Var0(LdRtype2Var0),
    Var1(LdRtype2Var1),
    Var2(LdRtype2Var2),
}
impl LdRtype2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = LdRtype2Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = LdRtype2Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = LdRtype2Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:673:1"]
#[derive(Clone, Debug)]
pub struct PshType7Var0 {}
impl PshType7Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0707() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:672:1"]
#[derive(Clone, Debug)]
pub struct PshType7Var1 {}
impl PshType7Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(""), DisplayElement::Literal("")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0707() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table PshType7"]
#[derive(Clone, Debug)]
pub enum PshType7 {
    Var0(PshType7Var0),
    Var1(PshType7Var1),
}
impl PshType7 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = PshType7Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = PshType7Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:743:1"]
#[derive(Clone, Debug)]
pub struct thldrlist_incVar0 {
    thrlist1: thrlist1,
}
impl thldrlist_incVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist1 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("{")];
        display.extend_from_slice(&extend);
        thrlist1.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc1515() != (0u64 as i64) as u8 {
                return None;
            }
            let thrlist1 = if let Some((len, table)) = thrlist1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thrlist1), (), block_len))
        };
        let ((mut thrlist1), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:742:1"]
#[derive(Clone, Debug)]
pub struct thldrlist_incVar1 {
    thrlist1: thrlist1,
}
impl thldrlist_incVar1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist1 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("{")];
        display.extend_from_slice(&extend);
        thrlist1.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc1515() != (1u64 as i64) as u8 {
                return None;
            }
            let thrlist1 = if let Some((len, table)) = thrlist1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thrlist1), (), block_len))
        };
        let ((mut thrlist1), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist1 }))
    }
}
#[doc = "Table thldrlist_inc"]
#[derive(Clone, Debug)]
pub enum thldrlist_inc {
    Var0(thldrlist_incVar0),
    Var1(thldrlist_incVar1),
}
impl thldrlist_inc {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thldrlist_incVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thldrlist_incVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:647:1"]
#[derive(Clone, Debug)]
pub struct HAddr24Var0 {
    reloc: i64,
    addr24: i32,
    H24: u8,
}
impl HAddr24Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { reloc, addr24, H24 } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Signed(true, *reloc)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { reloc, addr24, H24 } = self;
        let mut TMode = context_param.read_TMode();
        *reloc = ((((i64::try_from(inst_next).unwrap() + (4u64 as i64))
            + ((4u64 as i64) * i64::try_from(*addr24).unwrap()))
            + ((2u64 as i64) * i64::try_from(*H24).unwrap()))
            & (4294967295u64 as i64));
        TMode = u8::try_from((1u64 as i64)).unwrap();
        global_set.set_TMode(
            Some(u32::try_from(*reloc).unwrap()),
            u8::try_into(TMode).unwrap(),
        );
        context_param.write_TMode(TMode);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let addr24 = token_parser.addr24();
            let H24 = token_parser.H24();
            *context = context_current;
            Some(((), (addr24, H24), block_len))
        };
        let ((), (addr24, H24), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let reloc = 0i64;
        *context = context_current;
        Some((inst_len, Self { reloc, addr24, H24 }))
    }
}
#[doc = "Table HAddr24"]
#[derive(Clone, Debug)]
pub enum HAddr24 {
    Var0(HAddr24Var0),
}
impl HAddr24 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = HAddr24Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:682:1"]
#[derive(Clone, Debug)]
pub struct PshType4Var0 {
    PshType5: PshType5,
}
impl PshType4Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { PshType5 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r4),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        PshType5.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let PshType5 = if let Some((len, table)) = PshType5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0404() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((PshType5), (), block_len))
        };
        let ((mut PshType5), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { PshType5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:680:1"]
#[derive(Clone, Debug)]
pub struct PshType4Var1 {
    PshType5: PshType5,
}
impl PshType4Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { PshType5 } = self;
        PshType5.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let PshType5 = if let Some((len, table)) = PshType5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0404() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((PshType5), (), block_len))
        };
        let ((mut PshType5), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { PshType5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:681:1"]
#[derive(Clone, Debug)]
pub struct PshType4Var2 {}
impl PshType4Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0507() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table PshType4"]
#[derive(Clone, Debug)]
pub enum PshType4 {
    Var0(PshType4Var0),
    Var1(PshType4Var1),
    Var2(PshType4Var2),
}
impl PshType4 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = PshType4Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = PshType4Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = PshType4Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:807:1"]
#[derive(Clone, Debug)]
pub struct shift2Var0 {
    rm: rm,
}
impl shift2Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rm } = self;
        rm.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(", "),
            DisplayElement::Literal("asr #32"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.I25() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.sftimm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0406() != (4u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rm), (), block_len))
        };
        let ((mut rm), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rm }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:797:1"]
#[derive(Clone, Debug)]
pub struct shift2Var1 {
    rm: rm,
}
impl shift2Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rm } = self;
        rm.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(", "),
            DisplayElement::Literal("lsr #32"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.I25() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.sftimm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0406() != (2u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rm), (), block_len))
        };
        let ((mut rm), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rm }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:787:1"]
#[derive(Clone, Debug)]
pub struct shift2Var2 {
    rm: rm,
}
impl shift2Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rm } = self;
        rm.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.I25() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.sftimm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0406() != (0u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rm), (), block_len))
        };
        let ((mut rm), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rm }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:822:1"]
#[derive(Clone, Debug)]
pub struct shift2Var3 {
    rm: rm,
    sftimm: u8,
}
impl shift2Var3 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rm, sftimm } = self;
        rm.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(", "),
            DisplayElement::Literal("ror #"),
            DisplayElement::Unsigned(true, u64::try_from(*sftimm).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let sftimm = token_parser.sftimm();
            if token_parser.I25() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0406() != (6u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rm), (sftimm), block_len))
        };
        let ((mut rm), (sftimm), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rm, sftimm }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:812:1"]
#[derive(Clone, Debug)]
pub struct shift2Var4 {
    rm: rm,
    sftimm: u8,
}
impl shift2Var4 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rm, sftimm } = self;
        rm.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(", "),
            DisplayElement::Literal("asr #"),
            DisplayElement::Unsigned(true, u64::try_from(*sftimm).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let sftimm = token_parser.sftimm();
            if token_parser.I25() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0406() != (4u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rm), (sftimm), block_len))
        };
        let ((mut rm), (sftimm), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rm, sftimm }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:802:1"]
#[derive(Clone, Debug)]
pub struct shift2Var5 {
    rm: rm,
    sftimm: u8,
}
impl shift2Var5 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rm, sftimm } = self;
        rm.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(", "),
            DisplayElement::Literal("lsr #"),
            DisplayElement::Unsigned(true, u64::try_from(*sftimm).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let sftimm = token_parser.sftimm();
            if token_parser.I25() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0406() != (2u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rm), (sftimm), block_len))
        };
        let ((mut rm), (sftimm), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rm, sftimm }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:792:1"]
#[derive(Clone, Debug)]
pub struct shift2Var6 {
    rm: rm,
    sftimm: u8,
}
impl shift2Var6 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rm, sftimm } = self;
        rm.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(", "),
            DisplayElement::Literal("lsl #"),
            DisplayElement::Unsigned(true, u64::try_from(*sftimm).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let sftimm = token_parser.sftimm();
            if token_parser.I25() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0406() != (0u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rm), (sftimm), block_len))
        };
        let ((mut rm), (sftimm), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rm, sftimm }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:817:1"]
#[derive(Clone, Debug)]
pub struct shift2Var7 {
    rm: rm,
}
impl shift2Var7 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rm } = self;
        rm.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(", "),
            DisplayElement::Literal("rrx"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.I25() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0411() != (6u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rm), (), block_len))
        };
        let ((mut rm), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rm }))
    }
}
#[doc = "Table shift2"]
#[derive(Clone, Debug)]
pub enum shift2 {
    Var0(shift2Var0),
    Var1(shift2Var1),
    Var2(shift2Var2),
    Var3(shift2Var3),
    Var4(shift2Var4),
    Var5(shift2Var5),
    Var6(shift2Var6),
    Var7(shift2Var7),
}
impl shift2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
            Self::Var3(x) => x.display_extend(display, context),
            Self::Var4(x) => x.display_extend(display, context),
            Self::Var5(x) => x.display_extend(display, context),
            Self::Var6(x) => x.display_extend(display, context),
            Self::Var7(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = shift2Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = shift2Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = shift2Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        if let Some((inst_next, parsed)) = shift2Var3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var3(parsed)));
        }
        if let Some((inst_next, parsed)) = shift2Var4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var4(parsed)));
        }
        if let Some((inst_next, parsed)) = shift2Var5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var5(parsed)));
        }
        if let Some((inst_next, parsed)) = shift2Var6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var6(parsed)));
        }
        if let Some((inst_next, parsed)) = shift2Var7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1145:1"]
#[derive(Clone, Debug)]
pub struct sinc1Var0 {
    sinc2: sinc2,
}
impl sinc1Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sinc2 } = self;
        sinc2.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1414() != (0u64 as i64) as u8 {
                return None;
            }
            let sinc2 = if let Some((len, table)) = sinc2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sinc2), (), block_len))
        };
        let ((mut sinc2), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sinc2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1143:1"]
#[derive(Clone, Debug)]
pub struct sinc1Var1 {
    sinc2: sinc2,
}
impl sinc1Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sinc2 } = self;
        sinc2.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::lr),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1414() != (1u64 as i64) as u8 {
                return None;
            }
            let sinc2 = if let Some((len, table)) = sinc2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sinc2), (), block_len))
        };
        let ((mut sinc2), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sinc2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1144:1"]
#[derive(Clone, Debug)]
pub struct sinc1Var2 {}
impl sinc1Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::lr)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1414() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0013() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table sinc1"]
#[derive(Clone, Debug)]
pub enum sinc1 {
    Var0(sinc1Var0),
    Var1(sinc1Var1),
    Var2(sinc1Var2),
}
impl sinc1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = sinc1Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = sinc1Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = sinc1Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:621:1"]
#[derive(Clone, Debug)]
pub struct LdRtype1Var0 {
    LdRtype0: LdRtype0,
}
impl LdRtype1Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { LdRtype0 } = self;
        LdRtype0.display_extend(display, context);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let LdRtype0 = if let Some((len, table)) = LdRtype0::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0101() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0207() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((LdRtype0), (), block_len))
        };
        let ((mut LdRtype0), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { LdRtype0 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:623:1"]
#[derive(Clone, Debug)]
pub struct LdRtype1Var1 {
    LdRtype0: LdRtype0,
}
impl LdRtype1Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { LdRtype0 } = self;
        LdRtype0.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let LdRtype0 = if let Some((len, table)) = LdRtype0::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0101() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((LdRtype0), (), block_len))
        };
        let ((mut LdRtype0), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { LdRtype0 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:622:1"]
#[derive(Clone, Debug)]
pub struct LdRtype1Var2 {
    LdRtype0: LdRtype0,
}
impl LdRtype1Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { LdRtype0 } = self;
        LdRtype0.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r1),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let LdRtype0 = if let Some((len, table)) = LdRtype0::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0101() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((LdRtype0), (), block_len))
        };
        let ((mut LdRtype0), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { LdRtype0 }))
    }
}
#[doc = "Table LdRtype1"]
#[derive(Clone, Debug)]
pub enum LdRtype1 {
    Var0(LdRtype1Var0),
    Var1(LdRtype1Var1),
    Var2(LdRtype1Var2),
}
impl LdRtype1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = LdRtype1Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = LdRtype1Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = LdRtype1Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1118:1"]
#[derive(Clone, Debug)]
pub struct sinc10Var0 {
    sinc11: sinc11,
}
impl sinc10Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sinc11 } = self;
        sinc11.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0505() != (0u64 as i64) as u8 {
                return None;
            }
            let sinc11 = if let Some((len, table)) = sinc11::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sinc11), (), block_len))
        };
        let ((mut sinc11), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sinc11 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1116:1"]
#[derive(Clone, Debug)]
pub struct sinc10Var1 {
    sinc11: sinc11,
}
impl sinc10Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sinc11 } = self;
        sinc11.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r5),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0505() != (1u64 as i64) as u8 {
                return None;
            }
            let sinc11 = if let Some((len, table)) = sinc11::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sinc11), (), block_len))
        };
        let ((mut sinc11), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sinc11 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1117:1"]
#[derive(Clone, Debug)]
pub struct sinc10Var2 {}
impl sinc10Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0505() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0004() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table sinc10"]
#[derive(Clone, Debug)]
pub enum sinc10 {
    Var0(sinc10Var0),
    Var1(sinc10Var1),
    Var2(sinc10Var2),
}
impl sinc10 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = sinc10Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = sinc10Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = sinc10Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1200:1"]
#[derive(Clone, Debug)]
pub struct ldlist_decVar0 {
    ldec0: ldec0,
}
impl ldlist_decVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldec0 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("{")];
        display.extend_from_slice(&extend);
        ldec0.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let ldec0 = if let Some((len, table)) = ldec0::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldec0), (), block_len))
        };
        let ((mut ldec0), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldec0 }))
    }
}
#[doc = "Table ldlist_dec"]
#[derive(Clone, Debug)]
pub enum ldlist_dec {
    Var0(ldlist_decVar0),
}
impl ldlist_dec {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = ldlist_decVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:897:1"]
#[derive(Clone, Debug)]
pub struct stbraceVar0 {
    strlist: strlist,
}
impl stbraceVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { strlist } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("{")];
        display.extend_from_slice(&extend);
        strlist.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let strlist = if let Some((len, table)) = strlist::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((strlist), (), block_len))
        };
        let ((mut strlist), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { strlist }))
    }
}
#[doc = "Table stbrace"]
#[derive(Clone, Debug)]
pub enum stbrace {
    Var0(stbraceVar0),
}
impl stbrace {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = stbraceVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1240:1"]
#[derive(Clone, Debug)]
pub struct sdec3Var0 {
    sdec4: sdec4,
}
impl sdec3Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sdec4 } = self;
        sdec4.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0303() != (0u64 as i64) as u8 {
                return None;
            }
            let sdec4 = if let Some((len, table)) = sdec4::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sdec4), (), block_len))
        };
        let ((mut sdec4), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sdec4 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1238:1"]
#[derive(Clone, Debug)]
pub struct sdec3Var1 {
    sdec4: sdec4,
}
impl sdec3Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sdec4 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r3),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        sdec4.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0303() != (1u64 as i64) as u8 {
                return None;
            }
            let sdec4 = if let Some((len, table)) = sdec4::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sdec4), (), block_len))
        };
        let ((mut sdec4), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sdec4 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1239:1"]
#[derive(Clone, Debug)]
pub struct sdec3Var2 {}
impl sdec3Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0303() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0415() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table sdec3"]
#[derive(Clone, Debug)]
pub enum sdec3 {
    Var0(sdec3Var0),
    Var1(sdec3Var1),
    Var2(sdec3Var2),
}
impl sdec3 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = sdec3Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = sdec3Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = sdec3Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1157:1"]
#[derive(Clone, Debug)]
pub struct ldec14Var0 {
    ldec15: ldec15,
}
impl ldec14Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldec15 } = self;
        ldec15.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1414() != (0u64 as i64) as u8 {
                return None;
            }
            let ldec15 = if let Some((len, table)) = ldec15::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldec15), (), block_len))
        };
        let ((mut ldec15), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldec15 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1155:1"]
#[derive(Clone, Debug)]
pub struct ldec14Var1 {
    ldec15: ldec15,
}
impl ldec14Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldec15 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::lr),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        ldec15.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1414() != (1u64 as i64) as u8 {
                return None;
            }
            let ldec15 = if let Some((len, table)) = ldec15::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldec15), (), block_len))
        };
        let ((mut ldec15), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldec15 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1156:1"]
#[derive(Clone, Debug)]
pub struct ldec14Var2 {}
impl ldec14Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::lr)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1414() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1515() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table ldec14"]
#[derive(Clone, Debug)]
pub enum ldec14 {
    Var0(ldec14Var0),
    Var1(ldec14Var1),
    Var2(ldec14Var2),
}
impl ldec14 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = ldec14Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = ldec14Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = ldec14Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:886:1"]
#[derive(Clone, Debug)]
pub struct thsdec2Var0 {}
impl thsdec2Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0202() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0415() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:888:1"]
#[derive(Clone, Debug)]
pub struct thsdec2Var1 {
    thsdec3: thsdec3,
}
impl thsdec2Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thsdec3 } = self;
        thsdec3.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0202() != (0u64 as i64) as u8 {
                return None;
            }
            let thsdec3 = if let Some((len, table)) = thsdec3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thsdec3), (), block_len))
        };
        let ((mut thsdec3), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thsdec3 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:887:1"]
#[derive(Clone, Debug)]
pub struct thsdec2Var2 {
    thsdec3: thsdec3,
}
impl thsdec2Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thsdec3 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r2),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        thsdec3.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0202() != (1u64 as i64) as u8 {
                return None;
            }
            let thsdec3 = if let Some((len, table)) = thsdec3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thsdec3), (), block_len))
        };
        let ((mut thsdec3), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thsdec3 }))
    }
}
#[doc = "Table thsdec2"]
#[derive(Clone, Debug)]
pub enum thsdec2 {
    Var0(thsdec2Var0),
    Var1(thsdec2Var1),
    Var2(thsdec2Var2),
}
impl thsdec2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thsdec2Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thsdec2Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = thsdec2Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:655:1"]
#[derive(Clone, Debug)]
pub struct StrType4Var0 {
    StrType3: StrType3,
}
impl StrType4Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { StrType3 } = self;
        StrType3.display_extend(display, context);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let StrType3 = if let Some((len, table)) = StrType3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0507() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((StrType3), (), block_len))
        };
        let ((mut StrType3), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { StrType3 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:657:1"]
#[derive(Clone, Debug)]
pub struct StrType4Var1 {
    StrType3: StrType3,
}
impl StrType4Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { StrType3 } = self;
        StrType3.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let StrType3 = if let Some((len, table)) = StrType3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0404() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((StrType3), (), block_len))
        };
        let ((mut StrType3), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { StrType3 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:656:1"]
#[derive(Clone, Debug)]
pub struct StrType4Var2 {
    StrType3: StrType3,
}
impl StrType4Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { StrType3 } = self;
        StrType3.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r4),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let StrType3 = if let Some((len, table)) = StrType3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0404() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((StrType3), (), block_len))
        };
        let ((mut StrType3), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { StrType3 }))
    }
}
#[doc = "Table StrType4"]
#[derive(Clone, Debug)]
pub enum StrType4 {
    Var0(StrType4Var0),
    Var1(StrType4Var1),
    Var2(StrType4Var2),
}
impl StrType4 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = StrType4Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = StrType4Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = StrType4Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:964:1"]
#[derive(Clone, Debug)]
pub struct thSRSModeVar0 {}
impl thSRSModeVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sys")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let thc0004 = token_parser.thc0004();
            if token_parser.thsrsMode() != (23u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (thc0004), block_len))
        };
        let ((), (thc0004), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:963:1"]
#[derive(Clone, Debug)]
pub struct thSRSModeVar1 {}
impl thSRSModeVar1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("und")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let thc0004 = token_parser.thc0004();
            if token_parser.thsrsMode() != (19u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (thc0004), block_len))
        };
        let ((), (thc0004), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:962:1"]
#[derive(Clone, Debug)]
pub struct thSRSModeVar2 {}
impl thSRSModeVar2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("abt")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let thc0004 = token_parser.thc0004();
            if token_parser.thsrsMode() != (15u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (thc0004), block_len))
        };
        let ((), (thc0004), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:961:1"]
#[derive(Clone, Debug)]
pub struct thSRSModeVar3 {}
impl thSRSModeVar3 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mon")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let thc0004 = token_parser.thc0004();
            if token_parser.thsrsMode() != (14u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (thc0004), block_len))
        };
        let ((), (thc0004), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:960:1"]
#[derive(Clone, Debug)]
pub struct thSRSModeVar4 {}
impl thSRSModeVar4 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("svc")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let thc0004 = token_parser.thc0004();
            if token_parser.thsrsMode() != (11u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (thc0004), block_len))
        };
        let ((), (thc0004), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:959:1"]
#[derive(Clone, Debug)]
pub struct thSRSModeVar5 {}
impl thSRSModeVar5 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("irq")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let thc0004 = token_parser.thc0004();
            if token_parser.thsrsMode() != (10u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (thc0004), block_len))
        };
        let ((), (thc0004), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:958:1"]
#[derive(Clone, Debug)]
pub struct thSRSModeVar6 {}
impl thSRSModeVar6 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("fiq")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let thc0004 = token_parser.thc0004();
            if token_parser.thsrsMode() != (9u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (thc0004), block_len))
        };
        let ((), (thc0004), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:957:1"]
#[derive(Clone, Debug)]
pub struct thSRSModeVar7 {}
impl thSRSModeVar7 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("usr")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let thc0004 = token_parser.thc0004();
            if token_parser.thsrsMode() != (8u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (thc0004), block_len))
        };
        let ((), (thc0004), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:965:1"]
#[derive(Clone, Debug)]
pub struct thSRSModeVar8 {
    thsrsMode: u8,
}
impl thSRSModeVar8 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thsrsMode } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("#"),
            DisplayElement::Unsigned(true, u64::try_from(*thsrsMode).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let thsrsMode = token_parser.thsrsMode();
            *context = context_current;
            Some(((), (thsrsMode), block_len))
        };
        let ((), (thsrsMode), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thsrsMode }))
    }
}
#[doc = "Table thSRSMode"]
#[derive(Clone, Debug)]
pub enum thSRSMode {
    Var0(thSRSModeVar0),
    Var1(thSRSModeVar1),
    Var2(thSRSModeVar2),
    Var3(thSRSModeVar3),
    Var4(thSRSModeVar4),
    Var5(thSRSModeVar5),
    Var6(thSRSModeVar6),
    Var7(thSRSModeVar7),
    Var8(thSRSModeVar8),
}
impl thSRSMode {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
            Self::Var3(x) => x.display_extend(display, context),
            Self::Var4(x) => x.display_extend(display, context),
            Self::Var5(x) => x.display_extend(display, context),
            Self::Var6(x) => x.display_extend(display, context),
            Self::Var7(x) => x.display_extend(display, context),
            Self::Var8(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thSRSModeVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thSRSModeVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = thSRSModeVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        if let Some((inst_next, parsed)) = thSRSModeVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var3(parsed)));
        }
        if let Some((inst_next, parsed)) = thSRSModeVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var4(parsed)));
        }
        if let Some((inst_next, parsed)) = thSRSModeVar5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var5(parsed)));
        }
        if let Some((inst_next, parsed)) = thSRSModeVar6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var6(parsed)));
        }
        if let Some((inst_next, parsed)) = thSRSModeVar7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var7(parsed)));
        }
        if let Some((inst_next, parsed)) = thSRSModeVar8::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var8(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1423:1"]
#[derive(Clone, Debug)]
pub struct addrmode5Var0 {
    rn: rn,
    immed: u8,
}
impl addrmode5Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, immed } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("],{"),
            DisplayElement::Unsigned(true, u64::try_from(*immed).unwrap()),
            DisplayElement::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let immed = token_parser.immed();
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (0u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn), (immed), block_len))
        };
        let ((mut rn), (immed), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rn, immed }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1422:1"]
#[derive(Clone, Debug)]
pub struct addrmode5Var1 {
    rn: rn,
    noff8: i64,
}
impl addrmode5Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, noff8 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("],"),
            DisplayElement::Literal("#"),
            DisplayElement::Signed(true, *noff8),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut noff8 = 0i64;
        noff8 = (-(i64::try_from(immed).unwrap() * (4u64 as i64)));
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let immed = token_parser.immed();
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (1u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn), (immed), block_len))
        };
        let ((mut rn), (immed), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let noff8 = 0i64;
        *context = context_current;
        Some((inst_len, Self { rn, noff8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1421:1"]
#[derive(Clone, Debug)]
pub struct addrmode5Var2 {
    rn: rn,
    off8: i64,
}
impl addrmode5Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, off8 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("],"),
            DisplayElement::Literal("#"),
            DisplayElement::Signed(true, *off8),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut off8 = 0i64;
        off8 = (i64::try_from(immed).unwrap() * (4u64 as i64));
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let immed = token_parser.immed();
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (1u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn), (immed), block_len))
        };
        let ((mut rn), (immed), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let off8 = 0i64;
        *context = context_current;
        Some((inst_len, Self { rn, off8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1420:1"]
#[derive(Clone, Debug)]
pub struct addrmode5Var3 {
    rn: rn,
    noff8: i64,
}
impl addrmode5Var3 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, noff8 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal("#"),
            DisplayElement::Signed(true, *noff8),
            DisplayElement::Literal("]!"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut noff8 = 0i64;
        noff8 = (-(i64::try_from(immed).unwrap() * (4u64 as i64)));
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let immed = token_parser.immed();
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (1u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn), (immed), block_len))
        };
        let ((mut rn), (immed), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let noff8 = 0i64;
        *context = context_current;
        Some((inst_len, Self { rn, noff8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1419:1"]
#[derive(Clone, Debug)]
pub struct addrmode5Var4 {
    rn: rn,
    off8: i64,
}
impl addrmode5Var4 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, off8 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal("#"),
            DisplayElement::Signed(true, *off8),
            DisplayElement::Literal("]!"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut off8 = 0i64;
        off8 = (i64::try_from(immed).unwrap() * (4u64 as i64));
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let immed = token_parser.immed();
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (1u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn), (immed), block_len))
        };
        let ((mut rn), (immed), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let off8 = 0i64;
        *context = context_current;
        Some((inst_len, Self { rn, off8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1418:1"]
#[derive(Clone, Debug)]
pub struct addrmode5Var5 {
    rn: rn,
    noff8: i64,
}
impl addrmode5Var5 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, noff8 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal("#"),
            DisplayElement::Signed(true, *noff8),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut noff8 = 0i64;
        noff8 = (-(i64::try_from(immed).unwrap() * (4u64 as i64)));
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let immed = token_parser.immed();
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (0u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn), (immed), block_len))
        };
        let ((mut rn), (immed), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let noff8 = 0i64;
        *context = context_current;
        Some((inst_len, Self { rn, noff8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1417:1"]
#[derive(Clone, Debug)]
pub struct addrmode5Var6 {
    rn: rn,
    off8: i64,
}
impl addrmode5Var6 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, off8 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal("#"),
            DisplayElement::Signed(true, *off8),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut off8 = 0i64;
        off8 = (i64::try_from(immed).unwrap() * (4u64 as i64));
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let immed = token_parser.immed();
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (0u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn), (immed), block_len))
        };
        let ((mut rn), (immed), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let off8 = 0i64;
        *context = context_current;
        Some((inst_len, Self { rn, off8 }))
    }
}
#[doc = "Table addrmode5"]
#[derive(Clone, Debug)]
pub enum addrmode5 {
    Var0(addrmode5Var0),
    Var1(addrmode5Var1),
    Var2(addrmode5Var2),
    Var3(addrmode5Var3),
    Var4(addrmode5Var4),
    Var5(addrmode5Var5),
    Var6(addrmode5Var6),
}
impl addrmode5 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
            Self::Var3(x) => x.display_extend(display, context),
            Self::Var4(x) => x.display_extend(display, context),
            Self::Var5(x) => x.display_extend(display, context),
            Self::Var6(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = addrmode5Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode5Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode5Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode5Var3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var3(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode5Var4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var4(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode5Var5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var5(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode5Var6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var6(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1112:1"]
#[derive(Clone, Debug)]
pub struct sinc12Var0 {
    sinc13: sinc13,
}
impl sinc12Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sinc13 } = self;
        sinc13.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0303() != (0u64 as i64) as u8 {
                return None;
            }
            let sinc13 = if let Some((len, table)) = sinc13::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sinc13), (), block_len))
        };
        let ((mut sinc13), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sinc13 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1110:1"]
#[derive(Clone, Debug)]
pub struct sinc12Var1 {
    sinc13: sinc13,
}
impl sinc12Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sinc13 } = self;
        sinc13.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r3),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0303() != (1u64 as i64) as u8 {
                return None;
            }
            let sinc13 = if let Some((len, table)) = sinc13::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sinc13), (), block_len))
        };
        let ((mut sinc13), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sinc13 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1111:1"]
#[derive(Clone, Debug)]
pub struct sinc12Var2 {}
impl sinc12Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0303() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0002() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table sinc12"]
#[derive(Clone, Debug)]
pub enum sinc12 {
    Var0(sinc12Var0),
    Var1(sinc12Var1),
    Var2(sinc12Var2),
}
impl sinc12 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = sinc12Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = sinc12Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = sinc12Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARM.sinc:241:1"]
#[derive(Clone, Debug)]
pub struct ItCondVar0 {}
impl ItCondVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table ItCond"]
#[derive(Clone, Debug)]
pub enum ItCond {
    Var0(ItCondVar0),
}
impl ItCond {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = ItCondVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1190:1"]
#[derive(Clone, Debug)]
pub struct ldec3Var0 {
    ldec4: ldec4,
}
impl ldec3Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldec4 } = self;
        ldec4.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0303() != (0u64 as i64) as u8 {
                return None;
            }
            let ldec4 = if let Some((len, table)) = ldec4::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldec4), (), block_len))
        };
        let ((mut ldec4), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldec4 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1188:1"]
#[derive(Clone, Debug)]
pub struct ldec3Var1 {
    ldec4: ldec4,
}
impl ldec3Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldec4 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r3),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        ldec4.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0303() != (1u64 as i64) as u8 {
                return None;
            }
            let ldec4 = if let Some((len, table)) = ldec4::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldec4), (), block_len))
        };
        let ((mut ldec4), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldec4 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1189:1"]
#[derive(Clone, Debug)]
pub struct ldec3Var2 {}
impl ldec3Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0303() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0415() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table ldec3"]
#[derive(Clone, Debug)]
pub enum ldec3 {
    Var0(ldec3Var0),
    Var1(ldec3Var1),
    Var2(ldec3Var2),
}
impl ldec3 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = ldec3Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = ldec3Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = ldec3Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1181:1"]
#[derive(Clone, Debug)]
pub struct ldec6Var0 {
    ldec7: ldec7,
}
impl ldec6Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldec7 } = self;
        ldec7.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0606() != (0u64 as i64) as u8 {
                return None;
            }
            let ldec7 = if let Some((len, table)) = ldec7::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldec7), (), block_len))
        };
        let ((mut ldec7), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldec7 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1179:1"]
#[derive(Clone, Debug)]
pub struct ldec6Var1 {
    ldec7: ldec7,
}
impl ldec6Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldec7 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r6),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        ldec7.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0606() != (1u64 as i64) as u8 {
                return None;
            }
            let ldec7 = if let Some((len, table)) = ldec7::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldec7), (), block_len))
        };
        let ((mut ldec7), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldec7 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1180:1"]
#[derive(Clone, Debug)]
pub struct ldec6Var2 {}
impl ldec6Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0606() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0715() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table ldec6"]
#[derive(Clone, Debug)]
pub enum ldec6 {
    Var0(ldec6Var0),
    Var1(ldec6Var1),
    Var2(ldec6Var2),
}
impl ldec6 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = ldec6Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = ldec6Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = ldec6Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:709:1"]
#[derive(Clone, Debug)]
pub struct thrlist11Var0 {
    thrlist12: thrlist12,
}
impl thrlist11Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist12 } = self;
        thrlist12.display_extend(display, context);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0404() != (1u64 as i64) as u8 {
                return None;
            }
            let thrlist12 = if let Some((len, table)) = thrlist12::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0515() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((thrlist12), (), block_len))
        };
        let ((mut thrlist12), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist12 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:711:1"]
#[derive(Clone, Debug)]
pub struct thrlist11Var1 {
    thrlist12: thrlist12,
}
impl thrlist11Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist12 } = self;
        thrlist12.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0404() != (0u64 as i64) as u8 {
                return None;
            }
            let thrlist12 = if let Some((len, table)) = thrlist12::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thrlist12), (), block_len))
        };
        let ((mut thrlist12), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist12 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:710:1"]
#[derive(Clone, Debug)]
pub struct thrlist11Var2 {
    thrlist12: thrlist12,
}
impl thrlist11Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist12 } = self;
        thrlist12.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r4),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0404() != (1u64 as i64) as u8 {
                return None;
            }
            let thrlist12 = if let Some((len, table)) = thrlist12::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thrlist12), (), block_len))
        };
        let ((mut thrlist12), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist12 }))
    }
}
#[doc = "Table thrlist11"]
#[derive(Clone, Debug)]
pub enum thrlist11 {
    Var0(thrlist11Var0),
    Var1(thrlist11Var1),
    Var2(thrlist11Var2),
}
impl thrlist11 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thrlist11Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thrlist11Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = thrlist11Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:282:1"]
#[derive(Clone, Debug)]
pub struct thccVar0 {}
impl thccVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("le")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thcond() != (13u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:281:1"]
#[derive(Clone, Debug)]
pub struct thccVar1 {}
impl thccVar1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("gt")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thcond() != (12u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:280:1"]
#[derive(Clone, Debug)]
pub struct thccVar2 {}
impl thccVar2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("lt")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thcond() != (11u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:279:1"]
#[derive(Clone, Debug)]
pub struct thccVar3 {}
impl thccVar3 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ge")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thcond() != (10u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:278:1"]
#[derive(Clone, Debug)]
pub struct thccVar4 {}
impl thccVar4 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ls")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thcond() != (9u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:277:1"]
#[derive(Clone, Debug)]
pub struct thccVar5 {}
impl thccVar5 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("hi")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thcond() != (8u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:276:1"]
#[derive(Clone, Debug)]
pub struct thccVar6 {}
impl thccVar6 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("vc")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thcond() != (7u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:275:1"]
#[derive(Clone, Debug)]
pub struct thccVar7 {}
impl thccVar7 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("vs")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thcond() != (6u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:274:1"]
#[derive(Clone, Debug)]
pub struct thccVar8 {}
impl thccVar8 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("pl")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thcond() != (5u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:273:1"]
#[derive(Clone, Debug)]
pub struct thccVar9 {}
impl thccVar9 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mi")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thcond() != (4u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:272:1"]
#[derive(Clone, Debug)]
pub struct thccVar10 {}
impl thccVar10 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cc")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thcond() != (3u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:271:1"]
#[derive(Clone, Debug)]
pub struct thccVar11 {}
impl thccVar11 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cs")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thcond() != (2u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:270:1"]
#[derive(Clone, Debug)]
pub struct thccVar12 {}
impl thccVar12 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ne")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thcond() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:269:1"]
#[derive(Clone, Debug)]
pub struct thccVar13 {}
impl thccVar13 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("eq")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thcond() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table thcc"]
#[derive(Clone, Debug)]
pub enum thcc {
    Var0(thccVar0),
    Var1(thccVar1),
    Var2(thccVar2),
    Var3(thccVar3),
    Var4(thccVar4),
    Var5(thccVar5),
    Var6(thccVar6),
    Var7(thccVar7),
    Var8(thccVar8),
    Var9(thccVar9),
    Var10(thccVar10),
    Var11(thccVar11),
    Var12(thccVar12),
    Var13(thccVar13),
}
impl thcc {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
            Self::Var3(x) => x.display_extend(display, context),
            Self::Var4(x) => x.display_extend(display, context),
            Self::Var5(x) => x.display_extend(display, context),
            Self::Var6(x) => x.display_extend(display, context),
            Self::Var7(x) => x.display_extend(display, context),
            Self::Var8(x) => x.display_extend(display, context),
            Self::Var9(x) => x.display_extend(display, context),
            Self::Var10(x) => x.display_extend(display, context),
            Self::Var11(x) => x.display_extend(display, context),
            Self::Var12(x) => x.display_extend(display, context),
            Self::Var13(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thccVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thccVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = thccVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        if let Some((inst_next, parsed)) = thccVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var3(parsed)));
        }
        if let Some((inst_next, parsed)) = thccVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var4(parsed)));
        }
        if let Some((inst_next, parsed)) = thccVar5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var5(parsed)));
        }
        if let Some((inst_next, parsed)) = thccVar6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var6(parsed)));
        }
        if let Some((inst_next, parsed)) = thccVar7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var7(parsed)));
        }
        if let Some((inst_next, parsed)) = thccVar8::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var8(parsed)));
        }
        if let Some((inst_next, parsed)) = thccVar9::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var9(parsed)));
        }
        if let Some((inst_next, parsed)) = thccVar10::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var10(parsed)));
        }
        if let Some((inst_next, parsed)) = thccVar11::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var11(parsed)));
        }
        if let Some((inst_next, parsed)) = thccVar12::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var12(parsed)));
        }
        if let Some((inst_next, parsed)) = thccVar13::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var13(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1083:1"]
#[derive(Clone, Debug)]
pub struct linc5Var0 {
    linc6: linc6,
}
impl linc5Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { linc6 } = self;
        linc6.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1010() != (0u64 as i64) as u8 {
                return None;
            }
            let linc6 = if let Some((len, table)) = linc6::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((linc6), (), block_len))
        };
        let ((mut linc6), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { linc6 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1081:1"]
#[derive(Clone, Debug)]
pub struct linc5Var1 {
    linc6: linc6,
}
impl linc5Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { linc6 } = self;
        linc6.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r10),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1010() != (1u64 as i64) as u8 {
                return None;
            }
            let linc6 = if let Some((len, table)) = linc6::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((linc6), (), block_len))
        };
        let ((mut linc6), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { linc6 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1082:1"]
#[derive(Clone, Debug)]
pub struct linc5Var2 {}
impl linc5Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r10)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1010() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0009() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table linc5"]
#[derive(Clone, Debug)]
pub enum linc5 {
    Var0(linc5Var0),
    Var1(linc5Var1),
    Var2(linc5Var2),
}
impl linc5 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = linc5Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = linc5Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = linc5Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:724:1"]
#[derive(Clone, Debug)]
pub struct thrlist6Var0 {
    thrlist7: thrlist7,
}
impl thrlist6Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist7 } = self;
        thrlist7.display_extend(display, context);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r9)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0909() != (1u64 as i64) as u8 {
                return None;
            }
            let thrlist7 = if let Some((len, table)) = thrlist7::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc1015() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((thrlist7), (), block_len))
        };
        let ((mut thrlist7), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist7 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:726:1"]
#[derive(Clone, Debug)]
pub struct thrlist6Var1 {
    thrlist7: thrlist7,
}
impl thrlist6Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist7 } = self;
        thrlist7.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0909() != (0u64 as i64) as u8 {
                return None;
            }
            let thrlist7 = if let Some((len, table)) = thrlist7::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thrlist7), (), block_len))
        };
        let ((mut thrlist7), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist7 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:725:1"]
#[derive(Clone, Debug)]
pub struct thrlist6Var2 {
    thrlist7: thrlist7,
}
impl thrlist6Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist7 } = self;
        thrlist7.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r9),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0909() != (1u64 as i64) as u8 {
                return None;
            }
            let thrlist7 = if let Some((len, table)) = thrlist7::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thrlist7), (), block_len))
        };
        let ((mut thrlist7), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist7 }))
    }
}
#[doc = "Table thrlist6"]
#[derive(Clone, Debug)]
pub enum thrlist6 {
    Var0(thrlist6Var0),
    Var1(thrlist6Var1),
    Var2(thrlist6Var2),
}
impl thrlist6 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thrlist6Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thrlist6Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = thrlist6Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:688:1"]
#[derive(Clone, Debug)]
pub struct PshType2Var0 {
    PshType3: PshType3,
}
impl PshType2Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { PshType3 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r2),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        PshType3.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let PshType3 = if let Some((len, table)) = PshType3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0202() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((PshType3), (), block_len))
        };
        let ((mut PshType3), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { PshType3 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:686:1"]
#[derive(Clone, Debug)]
pub struct PshType2Var1 {
    PshType3: PshType3,
}
impl PshType2Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { PshType3 } = self;
        PshType3.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let PshType3 = if let Some((len, table)) = PshType3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0202() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((PshType3), (), block_len))
        };
        let ((mut PshType3), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { PshType3 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:687:1"]
#[derive(Clone, Debug)]
pub struct PshType2Var2 {}
impl PshType2Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0202() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0307() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table PshType2"]
#[derive(Clone, Debug)]
pub enum PshType2 {
    Var0(PshType2Var0),
    Var1(PshType2Var1),
    Var2(PshType2Var2),
}
impl PshType2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = PshType2Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = PshType2Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = PshType2Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1130:1"]
#[derive(Clone, Debug)]
pub struct sinc6Var0 {
    sinc7: sinc7,
}
impl sinc6Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sinc7 } = self;
        sinc7.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0909() != (0u64 as i64) as u8 {
                return None;
            }
            let sinc7 = if let Some((len, table)) = sinc7::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sinc7), (), block_len))
        };
        let ((mut sinc7), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sinc7 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1128:1"]
#[derive(Clone, Debug)]
pub struct sinc6Var1 {
    sinc7: sinc7,
}
impl sinc6Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sinc7 } = self;
        sinc7.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r9),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0909() != (1u64 as i64) as u8 {
                return None;
            }
            let sinc7 = if let Some((len, table)) = sinc7::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sinc7), (), block_len))
        };
        let ((mut sinc7), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sinc7 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1129:1"]
#[derive(Clone, Debug)]
pub struct sinc6Var2 {}
impl sinc6Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r9)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0909() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0008() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table sinc6"]
#[derive(Clone, Debug)]
pub enum sinc6 {
    Var0(sinc6Var0),
    Var1(sinc6Var1),
    Var2(sinc6Var2),
}
impl sinc6 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = sinc6Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = sinc6Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = sinc6Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:643:1"]
#[derive(Clone, Debug)]
pub struct StrType0Var0 {}
impl StrType0Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r0)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0000() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0107() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:645:1"]
#[derive(Clone, Debug)]
pub struct StrType0Var1 {}
impl StrType0Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0000() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:644:1"]
#[derive(Clone, Debug)]
pub struct StrType0Var2 {}
impl StrType0Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r0),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0000() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table StrType0"]
#[derive(Clone, Debug)]
pub enum StrType0 {
    Var0(StrType0Var0),
    Var1(StrType0Var1),
    Var2(StrType0Var2),
}
impl StrType0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = StrType0Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = StrType0Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = StrType0Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:628:1"]
#[derive(Clone, Debug)]
pub struct CONDVar0 {
    cc: cc,
}
impl CONDVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { cc } = self;
        cc.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let cc = if let Some((len, table)) =
                cc::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((cc), (), block_len))
        };
        let ((mut cc), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { cc }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:629:1"]
#[derive(Clone, Debug)]
pub struct CONDVar1 {}
impl CONDVar1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cond() != (14u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table COND"]
#[derive(Clone, Debug)]
pub enum COND {
    Var0(CONDVar0),
    Var1(CONDVar1),
}
impl COND {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = CONDVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = CONDVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:856:1"]
#[derive(Clone, Debug)]
pub struct thsdec12Var0 {}
impl thsdec12Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r12)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc1212() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc1315() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:858:1"]
#[derive(Clone, Debug)]
pub struct thsdec12Var1 {
    thsdec13: thsdec13,
}
impl thsdec12Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thsdec13 } = self;
        thsdec13.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc1212() != (0u64 as i64) as u8 {
                return None;
            }
            let thsdec13 = if let Some((len, table)) = thsdec13::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thsdec13), (), block_len))
        };
        let ((mut thsdec13), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thsdec13 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:857:1"]
#[derive(Clone, Debug)]
pub struct thsdec12Var2 {
    thsdec13: thsdec13,
}
impl thsdec12Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thsdec13 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r12),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        thsdec13.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc1212() != (1u64 as i64) as u8 {
                return None;
            }
            let thsdec13 = if let Some((len, table)) = thsdec13::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thsdec13), (), block_len))
        };
        let ((mut thsdec13), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thsdec13 }))
    }
}
#[doc = "Table thsdec12"]
#[derive(Clone, Debug)]
pub enum thsdec12 {
    Var0(thsdec12Var0),
    Var1(thsdec12Var1),
    Var2(thsdec12Var2),
}
impl thsdec12 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thsdec12Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thsdec12Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = thsdec12Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:665:1"]
#[derive(Clone, Debug)]
pub struct StrType7Var0 {
    StrType6: StrType6,
}
impl StrType7Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { StrType6 } = self;
        StrType6.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let StrType6 = if let Some((len, table)) = StrType6::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0707() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((StrType6), (), block_len))
        };
        let ((mut StrType6), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { StrType6 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:664:1"]
#[derive(Clone, Debug)]
pub struct StrType7Var1 {
    StrType6: StrType6,
}
impl StrType7Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { StrType6 } = self;
        StrType6.display_extend(display, context);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let StrType6 = if let Some((len, table)) = StrType6::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0707() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((StrType6), (), block_len))
        };
        let ((mut StrType6), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { StrType6 }))
    }
}
#[doc = "Table StrType7"]
#[derive(Clone, Debug)]
pub enum StrType7 {
    Var0(StrType7Var0),
    Var1(StrType7Var1),
}
impl StrType7 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = StrType7Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = StrType7Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1068:1"]
#[derive(Clone, Debug)]
pub struct linc10Var0 {
    linc11: linc11,
}
impl linc10Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { linc11 } = self;
        linc11.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0505() != (0u64 as i64) as u8 {
                return None;
            }
            let linc11 = if let Some((len, table)) = linc11::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((linc11), (), block_len))
        };
        let ((mut linc11), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { linc11 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1066:1"]
#[derive(Clone, Debug)]
pub struct linc10Var1 {
    linc11: linc11,
}
impl linc10Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { linc11 } = self;
        linc11.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r5),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0505() != (1u64 as i64) as u8 {
                return None;
            }
            let linc11 = if let Some((len, table)) = linc11::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((linc11), (), block_len))
        };
        let ((mut linc11), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { linc11 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1067:1"]
#[derive(Clone, Debug)]
pub struct linc10Var2 {}
impl linc10Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0505() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0004() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table linc10"]
#[derive(Clone, Debug)]
pub enum linc10 {
    Var0(linc10Var0),
    Var1(linc10Var1),
    Var2(linc10Var2),
}
impl linc10 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = linc10Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = linc10Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = linc10Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:640:1"]
#[derive(Clone, Debug)]
pub struct ldlistVar0 {
    LdRtype6: LdRtype6,
}
impl ldlistVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { LdRtype6 } = self;
        LdRtype6.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let LdRtype6 = if let Some((len, table)) = LdRtype6::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0707() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((LdRtype6), (), block_len))
        };
        let ((mut LdRtype6), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { LdRtype6 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:639:1"]
#[derive(Clone, Debug)]
pub struct ldlistVar1 {
    LdRtype6: LdRtype6,
}
impl ldlistVar1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { LdRtype6 } = self;
        LdRtype6.display_extend(display, context);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let LdRtype6 = if let Some((len, table)) = LdRtype6::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0707() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((LdRtype6), (), block_len))
        };
        let ((mut LdRtype6), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { LdRtype6 }))
    }
}
#[doc = "Table ldlist"]
#[derive(Clone, Debug)]
pub enum ldlist {
    Var0(ldlistVar0),
    Var1(ldlistVar1),
}
impl ldlist {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = ldlistVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = ldlistVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:892:1"]
#[derive(Clone, Debug)]
pub struct thstrlist_decVar0 {}
impl thstrlist_decVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("{"),
            DisplayElement::Register(Register::r0),
            DisplayElement::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0000() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0115() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:894:1"]
#[derive(Clone, Debug)]
pub struct thstrlist_decVar1 {
    thsdec1: thsdec1,
}
impl thstrlist_decVar1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thsdec1 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("{")];
        display.extend_from_slice(&extend);
        thsdec1.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0000() != (0u64 as i64) as u8 {
                return None;
            }
            let thsdec1 = if let Some((len, table)) = thsdec1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thsdec1), (), block_len))
        };
        let ((mut thsdec1), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thsdec1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:893:1"]
#[derive(Clone, Debug)]
pub struct thstrlist_decVar2 {
    thsdec1: thsdec1,
}
impl thstrlist_decVar2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thsdec1 } = self;
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("{"),
            DisplayElement::Register(Register::r0),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        thsdec1.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0000() != (1u64 as i64) as u8 {
                return None;
            }
            let thsdec1 = if let Some((len, table)) = thsdec1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thsdec1), (), block_len))
        };
        let ((mut thsdec1), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thsdec1 }))
    }
}
#[doc = "Table thstrlist_dec"]
#[derive(Clone, Debug)]
pub enum thstrlist_dec {
    Var0(thstrlist_decVar0),
    Var1(thstrlist_decVar1),
    Var2(thstrlist_decVar2),
}
impl thstrlist_dec {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thstrlist_decVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thstrlist_decVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = thstrlist_decVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:694:1"]
#[derive(Clone, Debug)]
pub struct pshlistVar0 {
    PshType1: PshType1,
}
impl pshlistVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { PshType1 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r0),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        PshType1.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let PshType1 = if let Some((len, table)) = PshType1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0000() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((PshType1), (), block_len))
        };
        let ((mut PshType1), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { PshType1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:692:1"]
#[derive(Clone, Debug)]
pub struct pshlistVar1 {
    PshType1: PshType1,
}
impl pshlistVar1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { PshType1 } = self;
        PshType1.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let PshType1 = if let Some((len, table)) = PshType1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0000() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((PshType1), (), block_len))
        };
        let ((mut PshType1), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { PshType1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:693:1"]
#[derive(Clone, Debug)]
pub struct pshlistVar2 {}
impl pshlistVar2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r0)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0000() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0107() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table pshlist"]
#[derive(Clone, Debug)]
pub enum pshlist {
    Var0(pshlistVar0),
    Var1(pshlistVar1),
    Var2(pshlistVar2),
}
impl pshlist {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = pshlistVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = pshlistVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = pshlistVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:658:1"]
#[derive(Clone, Debug)]
pub struct StrType5Var0 {
    StrType4: StrType4,
}
impl StrType5Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { StrType4 } = self;
        StrType4.display_extend(display, context);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let StrType4 = if let Some((len, table)) = StrType4::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0505() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0607() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((StrType4), (), block_len))
        };
        let ((mut StrType4), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { StrType4 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:660:1"]
#[derive(Clone, Debug)]
pub struct StrType5Var1 {
    StrType4: StrType4,
}
impl StrType5Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { StrType4 } = self;
        StrType4.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let StrType4 = if let Some((len, table)) = StrType4::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0505() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((StrType4), (), block_len))
        };
        let ((mut StrType4), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { StrType4 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:659:1"]
#[derive(Clone, Debug)]
pub struct StrType5Var2 {
    StrType4: StrType4,
}
impl StrType5Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { StrType4 } = self;
        StrType4.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r5),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let StrType4 = if let Some((len, table)) = StrType4::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0505() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((StrType4), (), block_len))
        };
        let ((mut StrType4), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { StrType4 }))
    }
}
#[doc = "Table StrType5"]
#[derive(Clone, Debug)]
pub enum StrType5 {
    Var0(StrType5Var0),
    Var1(StrType5Var1),
    Var2(StrType5Var2),
}
impl StrType5 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = StrType5Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = StrType5Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = StrType5Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3834:1"]
#[derive(Clone, Debug)]
pub struct thdXbotVar0 {}
impl thdXbotVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("X")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rm0003 = token_parser.Rm0003();
            if token_parser.thc0404() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rm0003), block_len))
        };
        let ((), (Rm0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3833:1"]
#[derive(Clone, Debug)]
pub struct thdXbotVar1 {}
impl thdXbotVar1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(""), DisplayElement::Literal("")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rm0003 = token_parser.Rm0003();
            if token_parser.thc0404() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rm0003), block_len))
        };
        let ((), (Rm0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table thdXbot"]
#[derive(Clone, Debug)]
pub enum thdXbot {
    Var0(thdXbotVar0),
    Var1(thdXbotVar1),
}
impl thdXbot {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thdXbotVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thdXbotVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:859:1"]
#[derive(Clone, Debug)]
pub struct thsdec11Var0 {}
impl thsdec11Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r11)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc1111() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc1215() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:861:1"]
#[derive(Clone, Debug)]
pub struct thsdec11Var1 {
    thsdec12: thsdec12,
}
impl thsdec11Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thsdec12 } = self;
        thsdec12.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc1111() != (0u64 as i64) as u8 {
                return None;
            }
            let thsdec12 = if let Some((len, table)) = thsdec12::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thsdec12), (), block_len))
        };
        let ((mut thsdec12), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thsdec12 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:860:1"]
#[derive(Clone, Debug)]
pub struct thsdec11Var2 {
    thsdec12: thsdec12,
}
impl thsdec11Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thsdec12 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r11),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        thsdec12.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc1111() != (1u64 as i64) as u8 {
                return None;
            }
            let thsdec12 = if let Some((len, table)) = thsdec12::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thsdec12), (), block_len))
        };
        let ((mut thsdec12), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thsdec12 }))
    }
}
#[doc = "Table thsdec11"]
#[derive(Clone, Debug)]
pub enum thsdec11 {
    Var0(thsdec11Var0),
    Var1(thsdec11Var1),
    Var2(thsdec11Var2),
}
impl thsdec11 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thsdec11Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thsdec11Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = thsdec11Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:903:1"]
#[derive(Clone, Debug)]
pub struct pcpbraceVar0 {
    pshlist: pshlist,
}
impl pcpbraceVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { pshlist } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("{")];
        display.extend_from_slice(&extend);
        pshlist.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::lr),
            DisplayElement::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let pshlist = if let Some((len, table)) = pshlist::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((pshlist), (), block_len))
        };
        let ((mut pshlist), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { pshlist }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:904:1"]
#[derive(Clone, Debug)]
pub struct pcpbraceVar1 {}
impl pcpbraceVar1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("{"),
            DisplayElement::Register(Register::lr),
            DisplayElement::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0007() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table pcpbrace"]
#[derive(Clone, Debug)]
pub enum pcpbrace {
    Var0(pcpbraceVar0),
    Var1(pcpbraceVar1),
}
impl pcpbrace {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = pcpbraceVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = pcpbraceVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:588:1"]
#[derive(Clone, Debug)]
pub struct ThArmAddr23Var0 {
    reloc: i64,
}
impl ThArmAddr23Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { reloc } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Signed(true, *reloc)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut reloc = 0i64;
        reloc = (((i64::try_from(inst_start).unwrap() + (4u64 as i64))
            & (4294967292u64 as i64))
            + ((((((-(1u64 as i64)) << (24u64 as i64))
                | (i64::try_from(part2J1).unwrap() << (23u64 as i64)))
                | (i64::try_from(part2J2).unwrap() << (22u64 as i64)))
                | (i64::try_from(offset10).unwrap() << (12u64 as i64)))
                | (i64::try_from(part2off_10).unwrap() << (2u64 as i64))));
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let offset10 = token_parser.offset10();
            if token_parser.offset10S() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (offset10), block_len))
        };
        let ((), (offset10), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let part2J1 = token_parser.part2J1();
            let part2J2 = token_parser.part2J2();
            let part2off_10 = token_parser.part2off_10();
            *context = context_current;
            Some(((), (part2J2, part2off_10, part2J1), block_len))
        };
        let ((), (part2J2, part2off_10, part2J1), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let reloc = 0i64;
        *context = context_current;
        Some((inst_len, Self { reloc }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:582:1"]
#[derive(Clone, Debug)]
pub struct ThArmAddr23Var1 {
    reloc: i64,
}
impl ThArmAddr23Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { reloc } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Signed(true, *reloc)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut reloc = 0i64;
        reloc = (((i64::try_from(inst_start).unwrap() + (4u64 as i64))
            & (4294967292u64 as i64))
            + (((((i64::try_from(part2J1).unwrap() ^ (1u64 as i64))
                << (23u64 as i64))
                | ((i64::try_from(part2J2).unwrap() ^ (1u64 as i64))
                    << (22u64 as i64)))
                | (i64::try_from(offset10).unwrap() << (12u64 as i64)))
                | (i64::try_from(part2off_10).unwrap() << (2u64 as i64))));
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let offset10 = token_parser.offset10();
            if token_parser.offset10S() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (offset10), block_len))
        };
        let ((), (offset10), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let part2J1 = token_parser.part2J1();
            let part2J2 = token_parser.part2J2();
            let part2off_10 = token_parser.part2off_10();
            *context = context_current;
            Some(((), (part2J2, part2off_10, part2J1), block_len))
        };
        let ((), (part2J2, part2off_10, part2J1), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let reloc = 0i64;
        *context = context_current;
        Some((inst_len, Self { reloc }))
    }
}
#[doc = "Table ThArmAddr23"]
#[derive(Clone, Debug)]
pub enum ThArmAddr23 {
    Var0(ThArmAddr23Var0),
    Var1(ThArmAddr23Var1),
}
impl ThArmAddr23 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = ThArmAddr23Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = ThArmAddr23Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:868:1"]
#[derive(Clone, Debug)]
pub struct thsdec8Var0 {}
impl thsdec8Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r8)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0808() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0915() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:870:1"]
#[derive(Clone, Debug)]
pub struct thsdec8Var1 {
    thsdec9: thsdec9,
}
impl thsdec8Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thsdec9 } = self;
        thsdec9.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0808() != (0u64 as i64) as u8 {
                return None;
            }
            let thsdec9 = if let Some((len, table)) = thsdec9::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thsdec9), (), block_len))
        };
        let ((mut thsdec9), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thsdec9 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:869:1"]
#[derive(Clone, Debug)]
pub struct thsdec8Var2 {
    thsdec9: thsdec9,
}
impl thsdec8Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thsdec9 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r8),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        thsdec9.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0808() != (1u64 as i64) as u8 {
                return None;
            }
            let thsdec9 = if let Some((len, table)) = thsdec9::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thsdec9), (), block_len))
        };
        let ((mut thsdec9), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thsdec9 }))
    }
}
#[doc = "Table thsdec8"]
#[derive(Clone, Debug)]
pub enum thsdec8 {
    Var0(thsdec8Var0),
    Var1(thsdec8Var1),
    Var2(thsdec8Var2),
}
impl thsdec8 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thsdec8Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thsdec8Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = thsdec8Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:739:1"]
#[derive(Clone, Debug)]
pub struct thrlist1Var0 {
    thrlist2: thrlist2,
}
impl thrlist1Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist2 } = self;
        thrlist2.display_extend(display, context);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::lr)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc1414() != (1u64 as i64) as u8 {
                return None;
            }
            let thrlist2 = if let Some((len, table)) = thrlist2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc1515() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((thrlist2), (), block_len))
        };
        let ((mut thrlist2), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:741:1"]
#[derive(Clone, Debug)]
pub struct thrlist1Var1 {
    thrlist2: thrlist2,
}
impl thrlist1Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist2 } = self;
        thrlist2.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc1414() != (0u64 as i64) as u8 {
                return None;
            }
            let thrlist2 = if let Some((len, table)) = thrlist2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thrlist2), (), block_len))
        };
        let ((mut thrlist2), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:740:1"]
#[derive(Clone, Debug)]
pub struct thrlist1Var2 {
    thrlist2: thrlist2,
}
impl thrlist1Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist2 } = self;
        thrlist2.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::lr),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc1414() != (1u64 as i64) as u8 {
                return None;
            }
            let thrlist2 = if let Some((len, table)) = thrlist2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thrlist2), (), block_len))
        };
        let ((mut thrlist2), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist2 }))
    }
}
#[doc = "Table thrlist1"]
#[derive(Clone, Debug)]
pub enum thrlist1 {
    Var0(thrlist1Var0),
    Var1(thrlist1Var1),
    Var2(thrlist1Var2),
}
impl thrlist1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thrlist1Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thrlist1Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = thrlist1Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:627:1"]
#[derive(Clone, Debug)]
pub struct LdRtype3Var0 {
    LdRtype2: LdRtype2,
}
impl LdRtype3Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { LdRtype2 } = self;
        LdRtype2.display_extend(display, context);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let LdRtype2 = if let Some((len, table)) = LdRtype2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0303() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0407() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((LdRtype2), (), block_len))
        };
        let ((mut LdRtype2), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { LdRtype2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:629:1"]
#[derive(Clone, Debug)]
pub struct LdRtype3Var1 {
    LdRtype2: LdRtype2,
}
impl LdRtype3Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { LdRtype2 } = self;
        LdRtype2.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let LdRtype2 = if let Some((len, table)) = LdRtype2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0303() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((LdRtype2), (), block_len))
        };
        let ((mut LdRtype2), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { LdRtype2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:628:1"]
#[derive(Clone, Debug)]
pub struct LdRtype3Var2 {
    LdRtype2: LdRtype2,
}
impl LdRtype3Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { LdRtype2 } = self;
        LdRtype2.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r3),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let LdRtype2 = if let Some((len, table)) = LdRtype2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0303() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((LdRtype2), (), block_len))
        };
        let ((mut LdRtype2), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { LdRtype2 }))
    }
}
#[doc = "Table LdRtype3"]
#[derive(Clone, Debug)]
pub enum LdRtype3 {
    Var0(LdRtype3Var0),
    Var1(LdRtype3Var1),
    Var2(LdRtype3Var2),
}
impl LdRtype3 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = LdRtype3Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = LdRtype3Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = LdRtype3Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1089:1"]
#[derive(Clone, Debug)]
pub struct linc3Var0 {
    linc4: linc4,
}
impl linc3Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { linc4 } = self;
        linc4.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1212() != (0u64 as i64) as u8 {
                return None;
            }
            let linc4 = if let Some((len, table)) = linc4::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((linc4), (), block_len))
        };
        let ((mut linc4), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { linc4 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1087:1"]
#[derive(Clone, Debug)]
pub struct linc3Var1 {
    linc4: linc4,
}
impl linc3Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { linc4 } = self;
        linc4.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r12),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1212() != (1u64 as i64) as u8 {
                return None;
            }
            let linc4 = if let Some((len, table)) = linc4::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((linc4), (), block_len))
        };
        let ((mut linc4), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { linc4 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1088:1"]
#[derive(Clone, Debug)]
pub struct linc3Var2 {}
impl linc3Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r12)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1212() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0011() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table linc3"]
#[derive(Clone, Debug)]
pub enum linc3 {
    Var0(linc3Var0),
    Var1(linc3Var1),
    Var2(linc3Var2),
}
impl linc3 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = linc3Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = linc3Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = linc3Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:685:1"]
#[derive(Clone, Debug)]
pub struct PshType3Var0 {
    PshType4: PshType4,
}
impl PshType3Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { PshType4 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r3),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        PshType4.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let PshType4 = if let Some((len, table)) = PshType4::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0303() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((PshType4), (), block_len))
        };
        let ((mut PshType4), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { PshType4 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:683:1"]
#[derive(Clone, Debug)]
pub struct PshType3Var1 {
    PshType4: PshType4,
}
impl PshType3Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { PshType4 } = self;
        PshType4.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let PshType4 = if let Some((len, table)) = PshType4::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0303() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((PshType4), (), block_len))
        };
        let ((mut PshType4), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { PshType4 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:684:1"]
#[derive(Clone, Debug)]
pub struct PshType3Var2 {}
impl PshType3Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0303() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0407() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table PshType3"]
#[derive(Clone, Debug)]
pub enum PshType3 {
    Var0(PshType3Var0),
    Var1(PshType3Var1),
    Var2(PshType3Var2),
}
impl PshType3 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = PshType3Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = PshType3Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = PshType3Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:932:1"]
#[derive(Clone, Debug)]
pub struct RnRmIndirectVar0 {
    Rm0608: u8,
    Rn0305: u8,
}
impl RnRmIndirectVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { Rm0608, Rn0305 } = self;
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("["),
            meaning_94047783056016(usize::try_from(*Rn0305).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047783056016(usize::try_from(*Rm0608).unwrap()),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0305 = token_parser.Rn0305();
            let Rm0608 = token_parser.Rm0608();
            *context = context_current;
            Some(((), (Rm0608, Rn0305), block_len))
        };
        let ((), (Rm0608, Rn0305), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { Rm0608, Rn0305 }))
    }
}
#[doc = "Table RnRmIndirect"]
#[derive(Clone, Debug)]
pub enum RnRmIndirect {
    Var0(RnRmIndirectVar0),
}
impl RnRmIndirect {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = RnRmIndirectVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:901:1"]
#[derive(Clone, Debug)]
pub struct pclbraceVar0 {
    ldlist: ldlist,
}
impl pclbraceVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldlist } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("{")];
        display.extend_from_slice(&extend);
        ldlist.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let ldlist = if let Some((len, table)) = ldlist::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldlist), (), block_len))
        };
        let ((mut ldlist), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldlist }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:902:1"]
#[derive(Clone, Debug)]
pub struct pclbraceVar1 {}
impl pclbraceVar1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("{"),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0007() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table pclbrace"]
#[derive(Clone, Debug)]
pub enum pclbrace {
    Var0(pclbraceVar0),
    Var1(pclbraceVar1),
}
impl pclbrace {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = pclbraceVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = pclbraceVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1127:1"]
#[derive(Clone, Debug)]
pub struct sinc7Var0 {
    sinc8: sinc8,
}
impl sinc7Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sinc8 } = self;
        sinc8.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0808() != (0u64 as i64) as u8 {
                return None;
            }
            let sinc8 = if let Some((len, table)) = sinc8::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sinc8), (), block_len))
        };
        let ((mut sinc8), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sinc8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1125:1"]
#[derive(Clone, Debug)]
pub struct sinc7Var1 {
    sinc8: sinc8,
}
impl sinc7Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sinc8 } = self;
        sinc8.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r8),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0808() != (1u64 as i64) as u8 {
                return None;
            }
            let sinc8 = if let Some((len, table)) = sinc8::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sinc8), (), block_len))
        };
        let ((mut sinc8), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sinc8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1126:1"]
#[derive(Clone, Debug)]
pub struct sinc7Var2 {}
impl sinc7Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r8)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0808() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0007() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table sinc7"]
#[derive(Clone, Debug)]
pub enum sinc7 {
    Var0(sinc7Var0),
    Var1(sinc7Var1),
    Var2(sinc7Var2),
}
impl sinc7 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = sinc7Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = sinc7Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = sinc7Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1092:1"]
#[derive(Clone, Debug)]
pub struct linc2Var0 {
    linc3: linc3,
}
impl linc2Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { linc3 } = self;
        linc3.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1313() != (0u64 as i64) as u8 {
                return None;
            }
            let linc3 = if let Some((len, table)) = linc3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((linc3), (), block_len))
        };
        let ((mut linc3), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { linc3 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1090:1"]
#[derive(Clone, Debug)]
pub struct linc2Var1 {
    linc3: linc3,
}
impl linc2Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { linc3 } = self;
        linc3.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::sp),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1313() != (1u64 as i64) as u8 {
                return None;
            }
            let linc3 = if let Some((len, table)) = linc3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((linc3), (), block_len))
        };
        let ((mut linc3), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { linc3 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1091:1"]
#[derive(Clone, Debug)]
pub struct linc2Var2 {}
impl linc2Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sp)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1313() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0012() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table linc2"]
#[derive(Clone, Debug)]
pub enum linc2 {
    Var0(linc2Var0),
    Var1(linc2Var1),
    Var2(linc2Var2),
}
impl linc2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = linc2Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = linc2Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = linc2Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:546:1"]
#[derive(Clone, Debug)]
pub struct Addr11Var0 {
    reloc: i64,
}
impl Addr11Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { reloc } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Signed(true, *reloc)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut reloc = 0i64;
        reloc = (((i64::try_from(inst_start).unwrap() + (4u64 as i64))
            + (2u64 as i64))
            * i64::try_from(soffset11).unwrap());
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let soffset11 = token_parser.soffset11();
            *context = context_current;
            Some(((), (soffset11), block_len))
        };
        let ((), (soffset11), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let reloc = 0i64;
        *context = context_current;
        Some((inst_len, Self { reloc }))
    }
}
#[doc = "Table Addr11"]
#[derive(Clone, Debug)]
pub enum Addr11 {
    Var0(Addr11Var0),
}
impl Addr11 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = Addr11Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:604:1"]
#[derive(Clone, Debug)]
pub struct rnVar0 {}
impl rnVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1619() != (15u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:605:1"]
#[derive(Clone, Debug)]
pub struct rnVar1 {
    Rn: u8,
}
impl rnVar1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { Rn } = self;
        let extend: [DisplayElement; 1usize] =
            [meaning_94047766862464(usize::try_from(*Rn).unwrap())];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rn = token_parser.Rn();
            *context = context_current;
            Some(((), (Rn), block_len))
        };
        let ((), (Rn), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { Rn }))
    }
}
#[doc = "Table rn"]
#[derive(Clone, Debug)]
pub enum rn {
    Var0(rnVar0),
    Var1(rnVar1),
}
impl rn {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = rnVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = rnVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:862:1"]
#[derive(Clone, Debug)]
pub struct thsdec10Var0 {}
impl thsdec10Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r10)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc1010() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc1115() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:864:1"]
#[derive(Clone, Debug)]
pub struct thsdec10Var1 {
    thsdec11: thsdec11,
}
impl thsdec10Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thsdec11 } = self;
        thsdec11.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc1010() != (0u64 as i64) as u8 {
                return None;
            }
            let thsdec11 = if let Some((len, table)) = thsdec11::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thsdec11), (), block_len))
        };
        let ((mut thsdec11), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thsdec11 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:863:1"]
#[derive(Clone, Debug)]
pub struct thsdec10Var2 {
    thsdec11: thsdec11,
}
impl thsdec10Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thsdec11 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r10),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        thsdec11.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc1010() != (1u64 as i64) as u8 {
                return None;
            }
            let thsdec11 = if let Some((len, table)) = thsdec11::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thsdec11), (), block_len))
        };
        let ((mut thsdec11), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thsdec11 }))
    }
}
#[doc = "Table thsdec10"]
#[derive(Clone, Debug)]
pub enum thsdec10 {
    Var0(thsdec10Var0),
    Var1(thsdec10Var1),
    Var2(thsdec10Var2),
}
impl thsdec10 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thsdec10Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thsdec10Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = thsdec10Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1210:1"]
#[derive(Clone, Debug)]
pub struct sdec13Var0 {
    sdec14: sdec14,
}
impl sdec13Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sdec14 } = self;
        sdec14.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1313() != (0u64 as i64) as u8 {
                return None;
            }
            let sdec14 = if let Some((len, table)) = sdec14::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sdec14), (), block_len))
        };
        let ((mut sdec14), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sdec14 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1208:1"]
#[derive(Clone, Debug)]
pub struct sdec13Var1 {
    sdec14: sdec14,
}
impl sdec13Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sdec14 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::sp),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        sdec14.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1313() != (1u64 as i64) as u8 {
                return None;
            }
            let sdec14 = if let Some((len, table)) = sdec14::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sdec14), (), block_len))
        };
        let ((mut sdec14), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sdec14 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1209:1"]
#[derive(Clone, Debug)]
pub struct sdec13Var2 {}
impl sdec13Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sp)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1313() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1415() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table sdec13"]
#[derive(Clone, Debug)]
pub enum sdec13 {
    Var0(sdec13Var0),
    Var1(sdec13Var1),
    Var2(sdec13Var2),
}
impl sdec13 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = sdec13Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = sdec13Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = sdec13Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:636:1"]
#[derive(Clone, Debug)]
pub struct LdRtype6Var0 {
    LdRtype5: LdRtype5,
}
impl LdRtype6Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { LdRtype5 } = self;
        LdRtype5.display_extend(display, context);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let LdRtype5 = if let Some((len, table)) = LdRtype5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0606() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0707() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((LdRtype5), (), block_len))
        };
        let ((mut LdRtype5), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { LdRtype5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:638:1"]
#[derive(Clone, Debug)]
pub struct LdRtype6Var1 {
    LdRtype5: LdRtype5,
}
impl LdRtype6Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { LdRtype5 } = self;
        LdRtype5.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let LdRtype5 = if let Some((len, table)) = LdRtype5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0606() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((LdRtype5), (), block_len))
        };
        let ((mut LdRtype5), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { LdRtype5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:637:1"]
#[derive(Clone, Debug)]
pub struct LdRtype6Var2 {
    LdRtype5: LdRtype5,
}
impl LdRtype6Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { LdRtype5 } = self;
        LdRtype5.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r6),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let LdRtype5 = if let Some((len, table)) = LdRtype5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0606() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((LdRtype5), (), block_len))
        };
        let ((mut LdRtype5), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { LdRtype5 }))
    }
}
#[doc = "Table LdRtype6"]
#[derive(Clone, Debug)]
pub enum LdRtype6 {
    Var0(LdRtype6Var0),
    Var1(LdRtype6Var1),
    Var2(LdRtype6Var2),
}
impl LdRtype6 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = LdRtype6Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = LdRtype6Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = LdRtype6Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1103:1"]
#[derive(Clone, Debug)]
pub struct sinc15Var0 {}
impl sinc15Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0000() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1102:1"]
#[derive(Clone, Debug)]
pub struct sinc15Var1 {}
impl sinc15Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r0)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0000() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table sinc15"]
#[derive(Clone, Debug)]
pub enum sinc15 {
    Var0(sinc15Var0),
    Var1(sinc15Var1),
}
impl sinc15 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = sinc15Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = sinc15Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:871:1"]
#[derive(Clone, Debug)]
pub struct thsdec7Var0 {}
impl thsdec7Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0707() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0815() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:873:1"]
#[derive(Clone, Debug)]
pub struct thsdec7Var1 {
    thsdec8: thsdec8,
}
impl thsdec7Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thsdec8 } = self;
        thsdec8.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0707() != (0u64 as i64) as u8 {
                return None;
            }
            let thsdec8 = if let Some((len, table)) = thsdec8::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thsdec8), (), block_len))
        };
        let ((mut thsdec8), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thsdec8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:872:1"]
#[derive(Clone, Debug)]
pub struct thsdec7Var2 {
    thsdec8: thsdec8,
}
impl thsdec7Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thsdec8 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r7),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        thsdec8.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0707() != (1u64 as i64) as u8 {
                return None;
            }
            let thsdec8 = if let Some((len, table)) = thsdec8::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thsdec8), (), block_len))
        };
        let ((mut thsdec8), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thsdec8 }))
    }
}
#[doc = "Table thsdec7"]
#[derive(Clone, Debug)]
pub enum thsdec7 {
    Var0(thsdec7Var0),
    Var1(thsdec7Var1),
    Var2(thsdec7Var2),
}
impl thsdec7 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thsdec7Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thsdec7Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = thsdec7Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARM.sinc:244:1"]
#[derive(Clone, Debug)]
pub struct CheckInIT_ZNVar0 {}
impl CheckInIT_ZNVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table CheckInIT_ZN"]
#[derive(Clone, Debug)]
pub enum CheckInIT_ZN {
    Var0(CheckInIT_ZNVar0),
}
impl CheckInIT_ZN {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = CheckInIT_ZNVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:649:1"]
#[derive(Clone, Debug)]
pub struct StrType2Var0 {
    StrType1: StrType1,
}
impl StrType2Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { StrType1 } = self;
        StrType1.display_extend(display, context);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let StrType1 = if let Some((len, table)) = StrType1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0202() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0307() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((StrType1), (), block_len))
        };
        let ((mut StrType1), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { StrType1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:651:1"]
#[derive(Clone, Debug)]
pub struct StrType2Var1 {
    StrType1: StrType1,
}
impl StrType2Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { StrType1 } = self;
        StrType1.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let StrType1 = if let Some((len, table)) = StrType1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0202() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((StrType1), (), block_len))
        };
        let ((mut StrType1), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { StrType1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:650:1"]
#[derive(Clone, Debug)]
pub struct StrType2Var2 {
    StrType1: StrType1,
}
impl StrType2Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { StrType1 } = self;
        StrType1.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r2),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let StrType1 = if let Some((len, table)) = StrType1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0202() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((StrType1), (), block_len))
        };
        let ((mut StrType1), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { StrType1 }))
    }
}
#[doc = "Table StrType2"]
#[derive(Clone, Debug)]
pub enum StrType2 {
    Var0(StrType2Var0),
    Var1(StrType2Var1),
    Var2(StrType2Var2),
}
impl StrType2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = StrType2Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = StrType2Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = StrType2Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:640:1"]
#[derive(Clone, Debug)]
pub struct SBIT_ZNVar0 {}
impl SBIT_ZNVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("s")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.S20() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:639:1"]
#[derive(Clone, Debug)]
pub struct SBIT_ZNVar1 {}
impl SBIT_ZNVar1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.S20() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table SBIT_ZN"]
#[derive(Clone, Debug)]
pub enum SBIT_ZN {
    Var0(SBIT_ZNVar0),
    Var1(SBIT_ZNVar1),
}
impl SBIT_ZN {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = SBIT_ZNVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = SBIT_ZNVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1077:1"]
#[derive(Clone, Debug)]
pub struct linc7Var0 {
    linc8: linc8,
}
impl linc7Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { linc8 } = self;
        linc8.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0808() != (0u64 as i64) as u8 {
                return None;
            }
            let linc8 = if let Some((len, table)) = linc8::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((linc8), (), block_len))
        };
        let ((mut linc8), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { linc8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1075:1"]
#[derive(Clone, Debug)]
pub struct linc7Var1 {
    linc8: linc8,
}
impl linc7Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { linc8 } = self;
        linc8.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r8),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0808() != (1u64 as i64) as u8 {
                return None;
            }
            let linc8 = if let Some((len, table)) = linc8::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((linc8), (), block_len))
        };
        let ((mut linc8), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { linc8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1076:1"]
#[derive(Clone, Debug)]
pub struct linc7Var2 {}
impl linc7Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r8)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0808() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0007() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table linc7"]
#[derive(Clone, Debug)]
pub enum linc7 {
    Var0(linc7Var0),
    Var1(linc7Var1),
    Var2(linc7Var2),
}
impl linc7 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = linc7Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = linc7Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = linc7Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:646:1"]
#[derive(Clone, Debug)]
pub struct StrType1Var0 {
    StrType0: StrType0,
}
impl StrType1Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { StrType0 } = self;
        StrType0.display_extend(display, context);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let StrType0 = if let Some((len, table)) = StrType0::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0101() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0207() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((StrType0), (), block_len))
        };
        let ((mut StrType0), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { StrType0 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:648:1"]
#[derive(Clone, Debug)]
pub struct StrType1Var1 {
    StrType0: StrType0,
}
impl StrType1Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { StrType0 } = self;
        StrType0.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let StrType0 = if let Some((len, table)) = StrType0::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0101() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((StrType0), (), block_len))
        };
        let ((mut StrType0), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { StrType0 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:647:1"]
#[derive(Clone, Debug)]
pub struct StrType1Var2 {
    StrType0: StrType0,
}
impl StrType1Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { StrType0 } = self;
        StrType0.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r1),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let StrType0 = if let Some((len, table)) = StrType0::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0101() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((StrType0), (), block_len))
        };
        let ((mut StrType0), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { StrType0 }))
    }
}
#[doc = "Table StrType1"]
#[derive(Clone, Debug)]
pub enum StrType1 {
    Var0(StrType1Var0),
    Var1(StrType1Var1),
    Var2(StrType1Var2),
}
impl StrType1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = StrType1Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = StrType1Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = StrType1Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3837:1"]
#[derive(Clone, Debug)]
pub struct thdXtopVar0 {}
impl thdXtopVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("X")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rm0003 = token_parser.Rm0003();
            if token_parser.thc0404() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rm0003), block_len))
        };
        let ((), (Rm0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3836:1"]
#[derive(Clone, Debug)]
pub struct thdXtopVar1 {}
impl thdXtopVar1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(""), DisplayElement::Literal("")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rm0003 = token_parser.Rm0003();
            if token_parser.thc0404() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rm0003), block_len))
        };
        let ((), (Rm0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table thdXtop"]
#[derive(Clone, Debug)]
pub enum thdXtop {
    Var0(thdXtopVar0),
    Var1(thdXtopVar1),
}
impl thdXtop {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thdXtopVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thdXtopVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:706:1"]
#[derive(Clone, Debug)]
pub struct thrlist12Var0 {
    thrlist13: thrlist13,
}
impl thrlist12Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist13 } = self;
        thrlist13.display_extend(display, context);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0303() != (1u64 as i64) as u8 {
                return None;
            }
            let thrlist13 = if let Some((len, table)) = thrlist13::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0415() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((thrlist13), (), block_len))
        };
        let ((mut thrlist13), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist13 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:708:1"]
#[derive(Clone, Debug)]
pub struct thrlist12Var1 {
    thrlist13: thrlist13,
}
impl thrlist12Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist13 } = self;
        thrlist13.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0303() != (0u64 as i64) as u8 {
                return None;
            }
            let thrlist13 = if let Some((len, table)) = thrlist13::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thrlist13), (), block_len))
        };
        let ((mut thrlist13), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist13 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:707:1"]
#[derive(Clone, Debug)]
pub struct thrlist12Var2 {
    thrlist13: thrlist13,
}
impl thrlist12Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist13 } = self;
        thrlist13.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r3),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0303() != (1u64 as i64) as u8 {
                return None;
            }
            let thrlist13 = if let Some((len, table)) = thrlist13::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thrlist13), (), block_len))
        };
        let ((mut thrlist13), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist13 }))
    }
}
#[doc = "Table thrlist12"]
#[derive(Clone, Debug)]
pub enum thrlist12 {
    Var0(thrlist12Var0),
    Var1(thrlist12Var1),
    Var2(thrlist12Var2),
}
impl thrlist12 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thrlist12Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thrlist12Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = thrlist12Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:691:1"]
#[derive(Clone, Debug)]
pub struct PshType1Var0 {
    PshType2: PshType2,
}
impl PshType1Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { PshType2 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r1),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        PshType2.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let PshType2 = if let Some((len, table)) = PshType2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0101() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((PshType2), (), block_len))
        };
        let ((mut PshType2), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { PshType2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:689:1"]
#[derive(Clone, Debug)]
pub struct PshType1Var1 {
    PshType2: PshType2,
}
impl PshType1Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { PshType2 } = self;
        PshType2.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let PshType2 = if let Some((len, table)) = PshType2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0101() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((PshType2), (), block_len))
        };
        let ((mut PshType2), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { PshType2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:690:1"]
#[derive(Clone, Debug)]
pub struct PshType1Var2 {}
impl PshType1Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0101() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0207() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table PshType1"]
#[derive(Clone, Debug)]
pub enum PshType1 {
    Var0(PshType1Var0),
    Var1(PshType1Var1),
    Var2(PshType1Var2),
}
impl PshType1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = PshType1Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = PshType1Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = PshType1Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1403:1"]
#[derive(Clone, Debug)]
pub struct reglistVar0 {
    rn: rn,
    stlist_dec: stlist_dec,
}
impl reglistVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, stlist_dec } = self;
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        stlist_dec.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.S22() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (0u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let stlist_dec = if let Some((len, table)) = stlist_dec::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, stlist_dec), (), block_len))
        };
        let ((mut rn, mut stlist_dec), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rn, stlist_dec }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1398:1"]
#[derive(Clone, Debug)]
pub struct reglistVar1 {
    stlist_dec: stlist_dec,
    rn: rn,
}
impl reglistVar1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { stlist_dec, rn } = self;
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        stlist_dec.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.S22() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (0u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let stlist_dec = if let Some((len, table)) = stlist_dec::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, stlist_dec), (), block_len))
        };
        let ((mut rn, mut stlist_dec), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { stlist_dec, rn }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1393:1"]
#[derive(Clone, Debug)]
pub struct reglistVar2 {
    stlist_dec: stlist_dec,
    rn: rn,
}
impl reglistVar2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { stlist_dec, rn } = self;
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        stlist_dec.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.S22() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (0u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let stlist_dec = if let Some((len, table)) = stlist_dec::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, stlist_dec), (), block_len))
        };
        let ((mut rn, mut stlist_dec), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { stlist_dec, rn }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1388:1"]
#[derive(Clone, Debug)]
pub struct reglistVar3 {
    rn: rn,
    stlist_dec: stlist_dec,
}
impl reglistVar3 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, stlist_dec } = self;
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        stlist_dec.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.S22() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (0u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let stlist_dec = if let Some((len, table)) = stlist_dec::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((stlist_dec, rn), (), block_len))
        };
        let ((mut stlist_dec, mut rn), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rn, stlist_dec }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1383:1"]
#[derive(Clone, Debug)]
pub struct reglistVar4 {
    rn: rn,
    stlist_dec: stlist_dec,
}
impl reglistVar4 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, stlist_dec } = self;
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        stlist_dec.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.S22() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (0u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let stlist_dec = if let Some((len, table)) = stlist_dec::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((stlist_dec, rn), (), block_len))
        };
        let ((mut stlist_dec, mut rn), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rn, stlist_dec }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1378:1"]
#[derive(Clone, Debug)]
pub struct reglistVar5 {
    rn: rn,
    stlist_dec: stlist_dec,
}
impl reglistVar5 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, stlist_dec } = self;
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        stlist_dec.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.S22() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (0u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let stlist_dec = if let Some((len, table)) = stlist_dec::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, stlist_dec), (), block_len))
        };
        let ((mut rn, mut stlist_dec), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rn, stlist_dec }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1373:1"]
#[derive(Clone, Debug)]
pub struct reglistVar6 {
    stlist_inc: stlist_inc,
    rn: rn,
}
impl reglistVar6 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { stlist_inc, rn } = self;
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        stlist_inc.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.S22() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (0u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let stlist_inc = if let Some((len, table)) = stlist_inc::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((stlist_inc, rn), (), block_len))
        };
        let ((mut stlist_inc, mut rn), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { stlist_inc, rn }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1368:1"]
#[derive(Clone, Debug)]
pub struct reglistVar7 {
    rn: rn,
    stlist_inc: stlist_inc,
}
impl reglistVar7 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, stlist_inc } = self;
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        stlist_inc.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.S22() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (0u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let stlist_inc = if let Some((len, table)) = stlist_inc::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((stlist_inc, rn), (), block_len))
        };
        let ((mut stlist_inc, mut rn), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rn, stlist_inc }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1363:1"]
#[derive(Clone, Debug)]
pub struct reglistVar8 {
    stlist_inc: stlist_inc,
    rn: rn,
}
impl reglistVar8 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { stlist_inc, rn } = self;
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        stlist_inc.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.S22() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (0u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let stlist_inc = if let Some((len, table)) = stlist_inc::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, stlist_inc), (), block_len))
        };
        let ((mut rn, mut stlist_inc), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { stlist_inc, rn }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1358:1"]
#[derive(Clone, Debug)]
pub struct reglistVar9 {
    stlist_inc: stlist_inc,
    rn: rn,
}
impl reglistVar9 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { stlist_inc, rn } = self;
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        stlist_inc.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.S22() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (0u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let stlist_inc = if let Some((len, table)) = stlist_inc::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((stlist_inc, rn), (), block_len))
        };
        let ((mut stlist_inc, mut rn), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { stlist_inc, rn }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1352:1"]
#[derive(Clone, Debug)]
pub struct reglistVar10 {
    rn: rn,
    stlist_inc: stlist_inc,
}
impl reglistVar10 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, stlist_inc } = self;
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        stlist_inc.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.S22() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (0u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let stlist_inc = if let Some((len, table)) = stlist_inc::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, stlist_inc), (), block_len))
        };
        let ((mut rn, mut stlist_inc), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rn, stlist_inc }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1341:1"]
#[derive(Clone, Debug)]
pub struct reglistVar11 {
    stlist_inc: stlist_inc,
    rn: rn,
}
impl reglistVar11 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { stlist_inc, rn } = self;
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        stlist_inc.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.S22() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (0u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let stlist_inc = if let Some((len, table)) = stlist_inc::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((stlist_inc, rn), (), block_len))
        };
        let ((mut stlist_inc, mut rn), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { stlist_inc, rn }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1336:1"]
#[derive(Clone, Debug)]
pub struct reglistVar12 {
    stlist_inc: stlist_inc,
    rn: rn,
}
impl reglistVar12 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { stlist_inc, rn } = self;
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        stlist_inc.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.S22() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (0u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let stlist_inc = if let Some((len, table)) = stlist_inc::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, stlist_inc), (), block_len))
        };
        let ((mut rn, mut stlist_inc), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { stlist_inc, rn }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1331:1"]
#[derive(Clone, Debug)]
pub struct reglistVar13 {
    ldlist_dec: ldlist_dec,
    rn: rn,
}
impl reglistVar13 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldlist_dec, rn } = self;
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        ldlist_dec.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.S22() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (1u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let ldlist_dec = if let Some((len, table)) = ldlist_dec::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldlist_dec, rn), (), block_len))
        };
        let ((mut ldlist_dec, mut rn), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldlist_dec, rn }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1326:1"]
#[derive(Clone, Debug)]
pub struct reglistVar14 {
    rn: rn,
    ldlist_dec: ldlist_dec,
}
impl reglistVar14 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, ldlist_dec } = self;
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        ldlist_dec.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.S22() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (1u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let ldlist_dec = if let Some((len, table)) = ldlist_dec::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, ldlist_dec), (), block_len))
        };
        let ((mut rn, mut ldlist_dec), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rn, ldlist_dec }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1321:1"]
#[derive(Clone, Debug)]
pub struct reglistVar15 {
    rn: rn,
    ldlist_dec: ldlist_dec,
}
impl reglistVar15 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, ldlist_dec } = self;
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        ldlist_dec.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.S22() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (1u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let ldlist_dec = if let Some((len, table)) = ldlist_dec::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, ldlist_dec), (), block_len))
        };
        let ((mut rn, mut ldlist_dec), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rn, ldlist_dec }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1316:1"]
#[derive(Clone, Debug)]
pub struct reglistVar16 {
    ldlist_dec: ldlist_dec,
    rn: rn,
}
impl reglistVar16 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldlist_dec, rn } = self;
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        ldlist_dec.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.S22() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (1u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let ldlist_dec = if let Some((len, table)) = ldlist_dec::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, ldlist_dec), (), block_len))
        };
        let ((mut rn, mut ldlist_dec), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldlist_dec, rn }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1311:1"]
#[derive(Clone, Debug)]
pub struct reglistVar17 {
    ldlist_dec: ldlist_dec,
    rn: rn,
}
impl reglistVar17 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldlist_dec, rn } = self;
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        ldlist_dec.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.S22() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (1u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let ldlist_dec = if let Some((len, table)) = ldlist_dec::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldlist_dec, rn), (), block_len))
        };
        let ((mut ldlist_dec, mut rn), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldlist_dec, rn }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1306:1"]
#[derive(Clone, Debug)]
pub struct reglistVar18 {
    ldlist_dec: ldlist_dec,
    rn: rn,
}
impl reglistVar18 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldlist_dec, rn } = self;
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        ldlist_dec.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.S22() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (1u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let ldlist_dec = if let Some((len, table)) = ldlist_dec::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, ldlist_dec), (), block_len))
        };
        let ((mut rn, mut ldlist_dec), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldlist_dec, rn }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1301:1"]
#[derive(Clone, Debug)]
pub struct reglistVar19 {
    rn: rn,
    ldlist_dec: ldlist_dec,
}
impl reglistVar19 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, ldlist_dec } = self;
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        ldlist_dec.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.S22() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (1u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let ldlist_dec = if let Some((len, table)) = ldlist_dec::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, ldlist_dec), (), block_len))
        };
        let ((mut rn, mut ldlist_dec), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rn, ldlist_dec }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1296:1"]
#[derive(Clone, Debug)]
pub struct reglistVar20 {
    ldlist_dec: ldlist_dec,
    rn: rn,
}
impl reglistVar20 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldlist_dec, rn } = self;
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        ldlist_dec.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.S22() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (1u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let ldlist_dec = if let Some((len, table)) = ldlist_dec::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldlist_dec, rn), (), block_len))
        };
        let ((mut ldlist_dec, mut rn), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldlist_dec, rn }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1291:1"]
#[derive(Clone, Debug)]
pub struct reglistVar21 {
    rn: rn,
    ldlist_inc: ldlist_inc,
}
impl reglistVar21 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, ldlist_inc } = self;
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        ldlist_inc.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.S22() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (1u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let ldlist_inc = if let Some((len, table)) = ldlist_inc::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, ldlist_inc), (), block_len))
        };
        let ((mut rn, mut ldlist_inc), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rn, ldlist_inc }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1286:1"]
#[derive(Clone, Debug)]
pub struct reglistVar22 {
    rn: rn,
    ldlist_inc: ldlist_inc,
}
impl reglistVar22 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, ldlist_inc } = self;
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        ldlist_inc.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.S22() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (1u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let ldlist_inc = if let Some((len, table)) = ldlist_inc::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldlist_inc, rn), (), block_len))
        };
        let ((mut ldlist_inc, mut rn), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rn, ldlist_inc }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1281:1"]
#[derive(Clone, Debug)]
pub struct reglistVar23 {
    ldlist_inc: ldlist_inc,
    rn: rn,
}
impl reglistVar23 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldlist_inc, rn } = self;
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        ldlist_inc.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.S22() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (1u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let ldlist_inc = if let Some((len, table)) = ldlist_inc::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldlist_inc, rn), (), block_len))
        };
        let ((mut ldlist_inc, mut rn), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldlist_inc, rn }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1276:1"]
#[derive(Clone, Debug)]
pub struct reglistVar24 {
    ldlist_inc: ldlist_inc,
    rn: rn,
}
impl reglistVar24 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldlist_inc, rn } = self;
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        ldlist_inc.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.S22() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (1u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let ldlist_inc = if let Some((len, table)) = ldlist_inc::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, ldlist_inc), (), block_len))
        };
        let ((mut rn, mut ldlist_inc), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldlist_inc, rn }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1271:1"]
#[derive(Clone, Debug)]
pub struct reglistVar25 {
    ldlist_inc: ldlist_inc,
    rn: rn,
}
impl reglistVar25 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldlist_inc, rn } = self;
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        ldlist_inc.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.S22() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (1u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let ldlist_inc = if let Some((len, table)) = ldlist_inc::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, ldlist_inc), (), block_len))
        };
        let ((mut rn, mut ldlist_inc), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldlist_inc, rn }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1266:1"]
#[derive(Clone, Debug)]
pub struct reglistVar26 {
    rn: rn,
    ldlist_inc: ldlist_inc,
}
impl reglistVar26 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, ldlist_inc } = self;
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("!,")];
        display.extend_from_slice(&extend);
        ldlist_inc.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.S22() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (1u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let ldlist_inc = if let Some((len, table)) = ldlist_inc::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldlist_inc, rn), (), block_len))
        };
        let ((mut ldlist_inc, mut rn), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rn, ldlist_inc }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1261:1"]
#[derive(Clone, Debug)]
pub struct reglistVar27 {
    ldlist_inc: ldlist_inc,
    rn: rn,
}
impl reglistVar27 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldlist_inc, rn } = self;
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        ldlist_inc.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.S22() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (1u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let ldlist_inc = if let Some((len, table)) = ldlist_inc::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, ldlist_inc), (), block_len))
        };
        let ((mut rn, mut ldlist_inc), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldlist_inc, rn }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1256:1"]
#[derive(Clone, Debug)]
pub struct reglistVar28 {
    rn: rn,
    ldlist_inc: ldlist_inc,
}
impl reglistVar28 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, ldlist_inc } = self;
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        ldlist_inc.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.S22() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (1u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let ldlist_inc = if let Some((len, table)) = ldlist_inc::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, ldlist_inc), (), block_len))
        };
        let ((mut rn, mut ldlist_inc), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rn, ldlist_inc }))
    }
}
#[doc = "Table reglist"]
#[derive(Clone, Debug)]
pub enum reglist {
    Var0(reglistVar0),
    Var1(reglistVar1),
    Var2(reglistVar2),
    Var3(reglistVar3),
    Var4(reglistVar4),
    Var5(reglistVar5),
    Var6(reglistVar6),
    Var7(reglistVar7),
    Var8(reglistVar8),
    Var9(reglistVar9),
    Var10(reglistVar10),
    Var11(reglistVar11),
    Var12(reglistVar12),
    Var13(reglistVar13),
    Var14(reglistVar14),
    Var15(reglistVar15),
    Var16(reglistVar16),
    Var17(reglistVar17),
    Var18(reglistVar18),
    Var19(reglistVar19),
    Var20(reglistVar20),
    Var21(reglistVar21),
    Var22(reglistVar22),
    Var23(reglistVar23),
    Var24(reglistVar24),
    Var25(reglistVar25),
    Var26(reglistVar26),
    Var27(reglistVar27),
    Var28(reglistVar28),
}
impl reglist {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
            Self::Var3(x) => x.display_extend(display, context),
            Self::Var4(x) => x.display_extend(display, context),
            Self::Var5(x) => x.display_extend(display, context),
            Self::Var6(x) => x.display_extend(display, context),
            Self::Var7(x) => x.display_extend(display, context),
            Self::Var8(x) => x.display_extend(display, context),
            Self::Var9(x) => x.display_extend(display, context),
            Self::Var10(x) => x.display_extend(display, context),
            Self::Var11(x) => x.display_extend(display, context),
            Self::Var12(x) => x.display_extend(display, context),
            Self::Var13(x) => x.display_extend(display, context),
            Self::Var14(x) => x.display_extend(display, context),
            Self::Var15(x) => x.display_extend(display, context),
            Self::Var16(x) => x.display_extend(display, context),
            Self::Var17(x) => x.display_extend(display, context),
            Self::Var18(x) => x.display_extend(display, context),
            Self::Var19(x) => x.display_extend(display, context),
            Self::Var20(x) => x.display_extend(display, context),
            Self::Var21(x) => x.display_extend(display, context),
            Self::Var22(x) => x.display_extend(display, context),
            Self::Var23(x) => x.display_extend(display, context),
            Self::Var24(x) => x.display_extend(display, context),
            Self::Var25(x) => x.display_extend(display, context),
            Self::Var26(x) => x.display_extend(display, context),
            Self::Var27(x) => x.display_extend(display, context),
            Self::Var28(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var14(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var15(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var16(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var17(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var18(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var19(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var20(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var21(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var22(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var23(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var24(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var25(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var26(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var27(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var28(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = reglistVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = reglistVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = reglistVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        if let Some((inst_next, parsed)) = reglistVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var3(parsed)));
        }
        if let Some((inst_next, parsed)) = reglistVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var4(parsed)));
        }
        if let Some((inst_next, parsed)) = reglistVar5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var5(parsed)));
        }
        if let Some((inst_next, parsed)) = reglistVar6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var6(parsed)));
        }
        if let Some((inst_next, parsed)) = reglistVar7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var7(parsed)));
        }
        if let Some((inst_next, parsed)) = reglistVar8::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var8(parsed)));
        }
        if let Some((inst_next, parsed)) = reglistVar9::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var9(parsed)));
        }
        if let Some((inst_next, parsed)) = reglistVar10::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var10(parsed)));
        }
        if let Some((inst_next, parsed)) = reglistVar11::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var11(parsed)));
        }
        if let Some((inst_next, parsed)) = reglistVar12::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var12(parsed)));
        }
        if let Some((inst_next, parsed)) = reglistVar13::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var13(parsed)));
        }
        if let Some((inst_next, parsed)) = reglistVar14::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var14(parsed)));
        }
        if let Some((inst_next, parsed)) = reglistVar15::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var15(parsed)));
        }
        if let Some((inst_next, parsed)) = reglistVar16::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var16(parsed)));
        }
        if let Some((inst_next, parsed)) = reglistVar17::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var17(parsed)));
        }
        if let Some((inst_next, parsed)) = reglistVar18::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var18(parsed)));
        }
        if let Some((inst_next, parsed)) = reglistVar19::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var19(parsed)));
        }
        if let Some((inst_next, parsed)) = reglistVar20::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var20(parsed)));
        }
        if let Some((inst_next, parsed)) = reglistVar21::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var21(parsed)));
        }
        if let Some((inst_next, parsed)) = reglistVar22::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var22(parsed)));
        }
        if let Some((inst_next, parsed)) = reglistVar23::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var23(parsed)));
        }
        if let Some((inst_next, parsed)) = reglistVar24::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var24(parsed)));
        }
        if let Some((inst_next, parsed)) = reglistVar25::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var25(parsed)));
        }
        if let Some((inst_next, parsed)) = reglistVar26::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var26(parsed)));
        }
        if let Some((inst_next, parsed)) = reglistVar27::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var27(parsed)));
        }
        if let Some((inst_next, parsed)) = reglistVar28::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var28(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1115:1"]
#[derive(Clone, Debug)]
pub struct sinc11Var0 {
    sinc12: sinc12,
}
impl sinc11Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sinc12 } = self;
        sinc12.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0404() != (0u64 as i64) as u8 {
                return None;
            }
            let sinc12 = if let Some((len, table)) = sinc12::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sinc12), (), block_len))
        };
        let ((mut sinc12), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sinc12 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1113:1"]
#[derive(Clone, Debug)]
pub struct sinc11Var1 {
    sinc12: sinc12,
}
impl sinc11Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sinc12 } = self;
        sinc12.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r4),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            let sinc12 = if let Some((len, table)) = sinc12::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sinc12), (), block_len))
        };
        let ((mut sinc12), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sinc12 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1114:1"]
#[derive(Clone, Debug)]
pub struct sinc11Var2 {}
impl sinc11Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0003() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table sinc11"]
#[derive(Clone, Debug)]
pub enum sinc11 {
    Var0(sinc11Var0),
    Var1(sinc11Var1),
    Var2(sinc11Var2),
}
impl sinc11 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = sinc11Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = sinc11Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = sinc11Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:630:1"]
#[derive(Clone, Debug)]
pub struct LdRtype4Var0 {
    LdRtype3: LdRtype3,
}
impl LdRtype4Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { LdRtype3 } = self;
        LdRtype3.display_extend(display, context);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let LdRtype3 = if let Some((len, table)) = LdRtype3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0507() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((LdRtype3), (), block_len))
        };
        let ((mut LdRtype3), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { LdRtype3 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:632:1"]
#[derive(Clone, Debug)]
pub struct LdRtype4Var1 {
    LdRtype3: LdRtype3,
}
impl LdRtype4Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { LdRtype3 } = self;
        LdRtype3.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let LdRtype3 = if let Some((len, table)) = LdRtype3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0404() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((LdRtype3), (), block_len))
        };
        let ((mut LdRtype3), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { LdRtype3 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:631:1"]
#[derive(Clone, Debug)]
pub struct LdRtype4Var2 {
    LdRtype3: LdRtype3,
}
impl LdRtype4Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { LdRtype3 } = self;
        LdRtype3.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r4),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let LdRtype3 = if let Some((len, table)) = LdRtype3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0404() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((LdRtype3), (), block_len))
        };
        let ((mut LdRtype3), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { LdRtype3 }))
    }
}
#[doc = "Table LdRtype4"]
#[derive(Clone, Debug)]
pub enum LdRtype4 {
    Var0(LdRtype4Var0),
    Var1(LdRtype4Var1),
    Var2(LdRtype4Var2),
}
impl LdRtype4 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = LdRtype4Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = LdRtype4Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = LdRtype4Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:896:1"]
#[derive(Clone, Debug)]
pub struct ldbraceVar0 {
    ldlist: ldlist,
}
impl ldbraceVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldlist } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("{")];
        display.extend_from_slice(&extend);
        ldlist.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let ldlist = if let Some((len, table)) = ldlist::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldlist), (), block_len))
        };
        let ((mut ldlist), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldlist }))
    }
}
#[doc = "Table ldbrace"]
#[derive(Clone, Debug)]
pub enum ldbrace {
    Var0(ldbraceVar0),
}
impl ldbrace {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = ldbraceVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1184:1"]
#[derive(Clone, Debug)]
pub struct ldec5Var0 {
    ldec6: ldec6,
}
impl ldec5Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldec6 } = self;
        ldec6.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0505() != (0u64 as i64) as u8 {
                return None;
            }
            let ldec6 = if let Some((len, table)) = ldec6::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldec6), (), block_len))
        };
        let ((mut ldec6), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldec6 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1182:1"]
#[derive(Clone, Debug)]
pub struct ldec5Var1 {
    ldec6: ldec6,
}
impl ldec5Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldec6 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r5),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        ldec6.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0505() != (1u64 as i64) as u8 {
                return None;
            }
            let ldec6 = if let Some((len, table)) = ldec6::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldec6), (), block_len))
        };
        let ((mut ldec6), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldec6 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1183:1"]
#[derive(Clone, Debug)]
pub struct ldec5Var2 {}
impl ldec5Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0505() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0615() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table ldec5"]
#[derive(Clone, Debug)]
pub enum ldec5 {
    Var0(ldec5Var0),
    Var1(ldec5Var1),
    Var2(ldec5Var2),
}
impl ldec5 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = ldec5Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = ldec5Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = ldec5Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1109:1"]
#[derive(Clone, Debug)]
pub struct sinc13Var0 {
    sinc14: sinc14,
}
impl sinc13Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sinc14 } = self;
        sinc14.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0202() != (0u64 as i64) as u8 {
                return None;
            }
            let sinc14 = if let Some((len, table)) = sinc14::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sinc14), (), block_len))
        };
        let ((mut sinc14), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sinc14 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1107:1"]
#[derive(Clone, Debug)]
pub struct sinc13Var1 {
    sinc14: sinc14,
}
impl sinc13Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sinc14 } = self;
        sinc14.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r2),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0202() != (1u64 as i64) as u8 {
                return None;
            }
            let sinc14 = if let Some((len, table)) = sinc14::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sinc14), (), block_len))
        };
        let ((mut sinc14), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sinc14 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1108:1"]
#[derive(Clone, Debug)]
pub struct sinc13Var2 {}
impl sinc13Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0202() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0001() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table sinc13"]
#[derive(Clone, Debug)]
pub enum sinc13 {
    Var0(sinc13Var0),
    Var1(sinc13Var1),
    Var2(sinc13Var2),
}
impl sinc13 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = sinc13Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = sinc13Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = sinc13Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:853:1"]
#[derive(Clone, Debug)]
pub struct thsdec13Var0 {}
impl thsdec13Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sp)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc1313() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc1415() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:855:1"]
#[derive(Clone, Debug)]
pub struct thsdec13Var1 {
    thsdec14: thsdec14,
}
impl thsdec13Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thsdec14 } = self;
        thsdec14.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc1313() != (0u64 as i64) as u8 {
                return None;
            }
            let thsdec14 = if let Some((len, table)) = thsdec14::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thsdec14), (), block_len))
        };
        let ((mut thsdec14), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thsdec14 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:854:1"]
#[derive(Clone, Debug)]
pub struct thsdec13Var2 {
    thsdec14: thsdec14,
}
impl thsdec13Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thsdec14 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::sp),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        thsdec14.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc1313() != (1u64 as i64) as u8 {
                return None;
            }
            let thsdec14 = if let Some((len, table)) = thsdec14::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thsdec14), (), block_len))
        };
        let ((mut thsdec14), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thsdec14 }))
    }
}
#[doc = "Table thsdec13"]
#[derive(Clone, Debug)]
pub enum thsdec13 {
    Var0(thsdec13Var0),
    Var1(thsdec13Var1),
    Var2(thsdec13Var2),
}
impl thsdec13 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thsdec13Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thsdec13Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = thsdec13Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1251:1"]
#[derive(Clone, Debug)]
pub struct stlist_decVar0 {
    sdec0: sdec0,
}
impl stlist_decVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sdec0 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("{")];
        display.extend_from_slice(&extend);
        sdec0.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let sdec0 = if let Some((len, table)) = sdec0::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sdec0), (), block_len))
        };
        let ((mut sdec0), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sdec0 }))
    }
}
#[doc = "Table stlist_dec"]
#[derive(Clone, Debug)]
pub enum stlist_dec {
    Var0(stlist_decVar0),
}
impl stlist_dec {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = stlist_decVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:730:1"]
#[derive(Clone, Debug)]
pub struct thrlist4Var0 {
    thrlist5: thrlist5,
}
impl thrlist4Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist5 } = self;
        thrlist5.display_extend(display, context);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r11)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc1111() != (1u64 as i64) as u8 {
                return None;
            }
            let thrlist5 = if let Some((len, table)) = thrlist5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc1215() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((thrlist5), (), block_len))
        };
        let ((mut thrlist5), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:732:1"]
#[derive(Clone, Debug)]
pub struct thrlist4Var1 {
    thrlist5: thrlist5,
}
impl thrlist4Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist5 } = self;
        thrlist5.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc1111() != (0u64 as i64) as u8 {
                return None;
            }
            let thrlist5 = if let Some((len, table)) = thrlist5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thrlist5), (), block_len))
        };
        let ((mut thrlist5), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:731:1"]
#[derive(Clone, Debug)]
pub struct thrlist4Var2 {
    thrlist5: thrlist5,
}
impl thrlist4Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist5 } = self;
        thrlist5.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r11),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc1111() != (1u64 as i64) as u8 {
                return None;
            }
            let thrlist5 = if let Some((len, table)) = thrlist5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thrlist5), (), block_len))
        };
        let ((mut thrlist5), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist5 }))
    }
}
#[doc = "Table thrlist4"]
#[derive(Clone, Debug)]
pub enum thrlist4 {
    Var0(thrlist4Var0),
    Var1(thrlist4Var1),
    Var2(thrlist4Var2),
}
impl thrlist4 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thrlist4Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thrlist4Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = thrlist4Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:534:1"]
#[derive(Clone, Debug)]
pub struct Addr5Var0 {
    reloc: i64,
}
impl Addr5Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { reloc } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Signed(true, *reloc)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut reloc = 0i64;
        reloc = ((i64::try_from(inst_start).unwrap() + (4u64 as i64))
            + ((i64::try_from(thc0909).unwrap() << (6u64 as i64))
                | (i64::try_from(imm5).unwrap() << (1u64 as i64))));
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let imm5 = token_parser.imm5();
            let thc0909 = token_parser.thc0909();
            *context = context_current;
            Some(((), (thc0909, imm5), block_len))
        };
        let ((), (thc0909, imm5), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let reloc = 0i64;
        *context = context_current;
        Some((inst_len, Self { reloc }))
    }
}
#[doc = "Table Addr5"]
#[derive(Clone, Debug)]
pub enum Addr5 {
    Var0(Addr5Var0),
}
impl Addr5 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = Addr5Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:697:1"]
#[derive(Clone, Debug)]
pub struct thrlist15Var0 {}
impl thrlist15Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r0)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0000() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0115() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:699:1"]
#[derive(Clone, Debug)]
pub struct thrlist15Var1 {}
impl thrlist15Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0000() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:698:1"]
#[derive(Clone, Debug)]
pub struct thrlist15Var2 {}
impl thrlist15Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r0),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0000() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table thrlist15"]
#[derive(Clone, Debug)]
pub enum thrlist15 {
    Var0(thrlist15Var0),
    Var1(thrlist15Var1),
    Var2(thrlist15Var2),
}
impl thrlist15 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thrlist15Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thrlist15Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = thrlist15Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:361:1"]
#[derive(Clone, Debug)]
pub struct Hrm0305Var0 {}
impl Hrm0305Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.hrm0305() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.h2() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:360:1"]
#[derive(Clone, Debug)]
pub struct Hrm0305Var1 {
    hrm0305: u8,
}
impl Hrm0305Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { hrm0305 } = self;
        let extend: [DisplayElement; 1usize] =
            [meaning_94047764607728(usize::try_from(*hrm0305).unwrap())];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let hrm0305 = token_parser.hrm0305();
            if token_parser.h2() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (hrm0305), block_len))
        };
        let ((), (hrm0305), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { hrm0305 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:359:1"]
#[derive(Clone, Debug)]
pub struct Hrm0305Var2 {
    Rm0305: u8,
}
impl Hrm0305Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { Rm0305 } = self;
        let extend: [DisplayElement; 1usize] =
            [meaning_94047783056016(usize::try_from(*Rm0305).unwrap())];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rm0305 = token_parser.Rm0305();
            if token_parser.h2() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rm0305), block_len))
        };
        let ((), (Rm0305), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { Rm0305 }))
    }
}
#[doc = "Table Hrm0305"]
#[derive(Clone, Debug)]
pub enum Hrm0305 {
    Var0(Hrm0305Var0),
    Var1(Hrm0305Var1),
    Var2(Hrm0305Var2),
}
impl Hrm0305 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = Hrm0305Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = Hrm0305Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = Hrm0305Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1080:1"]
#[derive(Clone, Debug)]
pub struct linc6Var0 {
    linc7: linc7,
}
impl linc6Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { linc7 } = self;
        linc7.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0909() != (0u64 as i64) as u8 {
                return None;
            }
            let linc7 = if let Some((len, table)) = linc7::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((linc7), (), block_len))
        };
        let ((mut linc7), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { linc7 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1078:1"]
#[derive(Clone, Debug)]
pub struct linc6Var1 {
    linc7: linc7,
}
impl linc6Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { linc7 } = self;
        linc7.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r9),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0909() != (1u64 as i64) as u8 {
                return None;
            }
            let linc7 = if let Some((len, table)) = linc7::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((linc7), (), block_len))
        };
        let ((mut linc7), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { linc7 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1079:1"]
#[derive(Clone, Debug)]
pub struct linc6Var2 {}
impl linc6Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r9)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0909() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0008() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table linc6"]
#[derive(Clone, Debug)]
pub enum linc6 {
    Var0(linc6Var0),
    Var1(linc6Var1),
    Var2(linc6Var2),
}
impl linc6 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = linc6Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = linc6Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = linc6Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1149:1"]
#[derive(Clone, Debug)]
pub struct stlist_incVar0 {
    sinc0: sinc0,
}
impl stlist_incVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sinc0 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("{")];
        display.extend_from_slice(&extend);
        sinc0.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let sinc0 = if let Some((len, table)) = sinc0::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sinc0), (), block_len))
        };
        let ((mut sinc0), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sinc0 }))
    }
}
#[doc = "Table stlist_inc"]
#[derive(Clone, Debug)]
pub enum stlist_inc {
    Var0(stlist_incVar0),
}
impl stlist_inc {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = stlist_incVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARM.sinc:242:1"]
#[derive(Clone, Debug)]
pub struct CheckInIT_CZNOVar0 {}
impl CheckInIT_CZNOVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table CheckInIT_CZNO"]
#[derive(Clone, Debug)]
pub enum CheckInIT_CZNO {
    Var0(CheckInIT_CZNOVar0),
}
impl CheckInIT_CZNO {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = CheckInIT_CZNOVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:846:1"]
#[derive(Clone, Debug)]
pub struct shift3Var0 {
    rs: rs,
    rm: rm,
}
impl shift3Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rs, rm } = self;
        rm.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(", "),
            DisplayElement::Literal("ror "),
        ];
        display.extend_from_slice(&extend);
        rs.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.I25() != (0u64 as i64) as u8 {
                return None;
            }
            let rs = if let Some((len, table)) =
                rs::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c0407() != (7u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rm, rs), (), block_len))
        };
        let ((mut rm, mut rs), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rs, rm }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:841:1"]
#[derive(Clone, Debug)]
pub struct shift3Var1 {
    rm: rm,
    rs: rs,
}
impl shift3Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rm, rs } = self;
        rm.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(", "),
            DisplayElement::Literal("asr "),
        ];
        display.extend_from_slice(&extend);
        rs.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.I25() != (0u64 as i64) as u8 {
                return None;
            }
            let rs = if let Some((len, table)) =
                rs::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c0407() != (5u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rs, rm), (), block_len))
        };
        let ((mut rs, mut rm), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rm, rs }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:836:1"]
#[derive(Clone, Debug)]
pub struct shift3Var2 {
    rm: rm,
    rs: rs,
}
impl shift3Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rm, rs } = self;
        rm.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(", "),
            DisplayElement::Literal("lsr "),
        ];
        display.extend_from_slice(&extend);
        rs.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.I25() != (0u64 as i64) as u8 {
                return None;
            }
            let rs = if let Some((len, table)) =
                rs::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c0407() != (3u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rs, rm), (), block_len))
        };
        let ((mut rs, mut rm), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rm, rs }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:831:1"]
#[derive(Clone, Debug)]
pub struct shift3Var3 {
    rm: rm,
    rs: rs,
}
impl shift3Var3 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rm, rs } = self;
        rm.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(", "),
            DisplayElement::Literal("lsl "),
        ];
        display.extend_from_slice(&extend);
        rs.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.I25() != (0u64 as i64) as u8 {
                return None;
            }
            let rs = if let Some((len, table)) =
                rs::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c0407() != (1u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rm, rs), (), block_len))
        };
        let ((mut rm, mut rs), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rm, rs }))
    }
}
#[doc = "Table shift3"]
#[derive(Clone, Debug)]
pub enum shift3 {
    Var0(shift3Var0),
    Var1(shift3Var1),
    Var2(shift3Var2),
    Var3(shift3Var3),
}
impl shift3 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
            Self::Var3(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = shift3Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = shift3Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = shift3Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        if let Some((inst_next, parsed)) = shift3Var3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var3(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:388:1"]
#[derive(Clone, Debug)]
pub struct Sprel8Var0 {
    immval: i64,
}
impl Sprel8Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { immval } = self;
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Register(Register::sp),
            DisplayElement::Literal(","),
            DisplayElement::Literal("#"),
            DisplayElement::Signed(true, *immval),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut immval = 0i64;
        immval = (i64::try_from(immed8).unwrap() * (4u64 as i64));
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let immed8 = token_parser.immed8();
            *context = context_current;
            Some(((), (immed8), block_len))
        };
        let ((), (immed8), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let immval = 0i64;
        *context = context_current;
        Some((inst_len, Self { immval }))
    }
}
#[doc = "Table Sprel8"]
#[derive(Clone, Debug)]
pub enum Sprel8 {
    Var0(Sprel8Var0),
}
impl Sprel8 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = Sprel8Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1225:1"]
#[derive(Clone, Debug)]
pub struct sdec8Var0 {
    sdec9: sdec9,
}
impl sdec8Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sdec9 } = self;
        sdec9.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0808() != (0u64 as i64) as u8 {
                return None;
            }
            let sdec9 = if let Some((len, table)) = sdec9::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sdec9), (), block_len))
        };
        let ((mut sdec9), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sdec9 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1223:1"]
#[derive(Clone, Debug)]
pub struct sdec8Var1 {
    sdec9: sdec9,
}
impl sdec8Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sdec9 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r8),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        sdec9.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0808() != (1u64 as i64) as u8 {
                return None;
            }
            let sdec9 = if let Some((len, table)) = sdec9::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sdec9), (), block_len))
        };
        let ((mut sdec9), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sdec9 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1224:1"]
#[derive(Clone, Debug)]
pub struct sdec8Var2 {}
impl sdec8Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r8)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0808() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0915() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table sdec8"]
#[derive(Clone, Debug)]
pub enum sdec8 {
    Var0(sdec8Var0),
    Var1(sdec8Var1),
    Var2(sdec8Var2),
}
impl sdec8 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = sdec8Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = sdec8Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = sdec8Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1196:1"]
#[derive(Clone, Debug)]
pub struct ldec1Var0 {
    ldec2: ldec2,
}
impl ldec1Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldec2 } = self;
        ldec2.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0101() != (0u64 as i64) as u8 {
                return None;
            }
            let ldec2 = if let Some((len, table)) = ldec2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldec2), (), block_len))
        };
        let ((mut ldec2), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldec2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1194:1"]
#[derive(Clone, Debug)]
pub struct ldec1Var1 {
    ldec2: ldec2,
}
impl ldec1Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldec2 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r1),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        ldec2.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0101() != (1u64 as i64) as u8 {
                return None;
            }
            let ldec2 = if let Some((len, table)) = ldec2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldec2), (), block_len))
        };
        let ((mut ldec2), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldec2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1195:1"]
#[derive(Clone, Debug)]
pub struct ldec1Var2 {}
impl ldec1Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0101() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0215() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table ldec1"]
#[derive(Clone, Debug)]
pub enum ldec1 {
    Var0(ldec1Var0),
    Var1(ldec1Var1),
    Var2(ldec1Var2),
}
impl ldec1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = ldec1Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = ldec1Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = ldec1Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1124:1"]
#[derive(Clone, Debug)]
pub struct sinc8Var0 {
    sinc9: sinc9,
}
impl sinc8Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sinc9 } = self;
        sinc9.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0707() != (0u64 as i64) as u8 {
                return None;
            }
            let sinc9 = if let Some((len, table)) = sinc9::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sinc9), (), block_len))
        };
        let ((mut sinc9), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sinc9 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1122:1"]
#[derive(Clone, Debug)]
pub struct sinc8Var1 {
    sinc9: sinc9,
}
impl sinc8Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sinc9 } = self;
        sinc9.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r7),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0707() != (1u64 as i64) as u8 {
                return None;
            }
            let sinc9 = if let Some((len, table)) = sinc9::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sinc9), (), block_len))
        };
        let ((mut sinc9), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sinc9 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1123:1"]
#[derive(Clone, Debug)]
pub struct sinc8Var2 {}
impl sinc8Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0707() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0006() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table sinc8"]
#[derive(Clone, Debug)]
pub enum sinc8 {
    Var0(sinc8Var0),
    Var1(sinc8Var1),
    Var2(sinc8Var2),
}
impl sinc8 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = sinc8Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = sinc8Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = sinc8Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:850:1"]
#[derive(Clone, Debug)]
pub struct thsdec14Var0 {}
impl thsdec14Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::lr)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc1414() != (1u64 as i64) as u8 {
                return None;
            }
            let thsdec15 = if let Some((len, table)) = thsdec15::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc1515() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((thsdec15), (), block_len))
        };
        let ((mut thsdec15), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:852:1"]
#[derive(Clone, Debug)]
pub struct thsdec14Var1 {
    thsdec15: thsdec15,
}
impl thsdec14Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thsdec15 } = self;
        thsdec15.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc1414() != (0u64 as i64) as u8 {
                return None;
            }
            let thsdec15 = if let Some((len, table)) = thsdec15::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thsdec15), (), block_len))
        };
        let ((mut thsdec15), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thsdec15 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:851:1"]
#[derive(Clone, Debug)]
pub struct thsdec14Var2 {
    thsdec15: thsdec15,
}
impl thsdec14Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thsdec15 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::lr),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        thsdec15.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc1414() != (1u64 as i64) as u8 {
                return None;
            }
            let thsdec15 = if let Some((len, table)) = thsdec15::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thsdec15), (), block_len))
        };
        let ((mut thsdec15), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thsdec15 }))
    }
}
#[doc = "Table thsdec14"]
#[derive(Clone, Debug)]
pub enum thsdec14 {
    Var0(thsdec14Var0),
    Var1(thsdec14Var1),
    Var2(thsdec14Var2),
}
impl thsdec14 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thsdec14Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thsdec14Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = thsdec14Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:633:1"]
#[derive(Clone, Debug)]
pub struct LdRtype5Var0 {
    LdRtype4: LdRtype4,
}
impl LdRtype5Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { LdRtype4 } = self;
        LdRtype4.display_extend(display, context);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let LdRtype4 = if let Some((len, table)) = LdRtype4::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0505() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0607() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((LdRtype4), (), block_len))
        };
        let ((mut LdRtype4), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { LdRtype4 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:635:1"]
#[derive(Clone, Debug)]
pub struct LdRtype5Var1 {
    LdRtype4: LdRtype4,
}
impl LdRtype5Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { LdRtype4 } = self;
        LdRtype4.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let LdRtype4 = if let Some((len, table)) = LdRtype4::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0505() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((LdRtype4), (), block_len))
        };
        let ((mut LdRtype4), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { LdRtype4 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:634:1"]
#[derive(Clone, Debug)]
pub struct LdRtype5Var2 {
    LdRtype4: LdRtype4,
}
impl LdRtype5Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { LdRtype4 } = self;
        LdRtype4.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r5),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let LdRtype4 = if let Some((len, table)) = LdRtype4::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0505() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((LdRtype4), (), block_len))
        };
        let ((mut LdRtype4), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { LdRtype4 }))
    }
}
#[doc = "Table LdRtype5"]
#[derive(Clone, Debug)]
pub enum LdRtype5 {
    Var0(LdRtype5Var0),
    Var1(LdRtype5Var1),
    Var2(LdRtype5Var2),
}
impl LdRtype5 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = LdRtype5Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = LdRtype5Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = LdRtype5Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1142:1"]
#[derive(Clone, Debug)]
pub struct sinc2Var0 {
    sinc3: sinc3,
}
impl sinc2Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sinc3 } = self;
        sinc3.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1313() != (0u64 as i64) as u8 {
                return None;
            }
            let sinc3 = if let Some((len, table)) = sinc3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sinc3), (), block_len))
        };
        let ((mut sinc3), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sinc3 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1140:1"]
#[derive(Clone, Debug)]
pub struct sinc2Var1 {
    sinc3: sinc3,
}
impl sinc2Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sinc3 } = self;
        sinc3.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::sp),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1313() != (1u64 as i64) as u8 {
                return None;
            }
            let sinc3 = if let Some((len, table)) = sinc3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sinc3), (), block_len))
        };
        let ((mut sinc3), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sinc3 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1141:1"]
#[derive(Clone, Debug)]
pub struct sinc2Var2 {}
impl sinc2Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sp)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1313() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0012() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table sinc2"]
#[derive(Clone, Debug)]
pub enum sinc2 {
    Var0(sinc2Var0),
    Var1(sinc2Var1),
    Var2(sinc2Var2),
}
impl sinc2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = sinc2Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = sinc2Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = sinc2Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1106:1"]
#[derive(Clone, Debug)]
pub struct sinc14Var0 {
    sinc15: sinc15,
}
impl sinc14Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sinc15 } = self;
        sinc15.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0101() != (0u64 as i64) as u8 {
                return None;
            }
            let sinc15 = if let Some((len, table)) = sinc15::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sinc15), (), block_len))
        };
        let ((mut sinc15), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sinc15 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1104:1"]
#[derive(Clone, Debug)]
pub struct sinc14Var1 {
    sinc15: sinc15,
}
impl sinc14Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sinc15 } = self;
        sinc15.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r1),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0101() != (1u64 as i64) as u8 {
                return None;
            }
            let sinc15 = if let Some((len, table)) = sinc15::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sinc15), (), block_len))
        };
        let ((mut sinc15), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sinc15 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1105:1"]
#[derive(Clone, Debug)]
pub struct sinc14Var2 {}
impl sinc14Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0101() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0000() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table sinc14"]
#[derive(Clone, Debug)]
pub enum sinc14 {
    Var0(sinc14Var0),
    Var1(sinc14Var1),
    Var2(sinc14Var2),
}
impl sinc14 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = sinc14Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = sinc14Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = sinc14Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:718:1"]
#[derive(Clone, Debug)]
pub struct thrlist8Var0 {
    thrlist9: thrlist9,
}
impl thrlist8Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist9 } = self;
        thrlist9.display_extend(display, context);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0707() != (1u64 as i64) as u8 {
                return None;
            }
            let thrlist9 = if let Some((len, table)) = thrlist9::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0815() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((thrlist9), (), block_len))
        };
        let ((mut thrlist9), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist9 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:720:1"]
#[derive(Clone, Debug)]
pub struct thrlist8Var1 {
    thrlist9: thrlist9,
}
impl thrlist8Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist9 } = self;
        thrlist9.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0707() != (0u64 as i64) as u8 {
                return None;
            }
            let thrlist9 = if let Some((len, table)) = thrlist9::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thrlist9), (), block_len))
        };
        let ((mut thrlist9), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist9 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:719:1"]
#[derive(Clone, Debug)]
pub struct thrlist8Var2 {
    thrlist9: thrlist9,
}
impl thrlist8Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist9 } = self;
        thrlist9.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r7),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0707() != (1u64 as i64) as u8 {
                return None;
            }
            let thrlist9 = if let Some((len, table)) = thrlist9::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thrlist9), (), block_len))
        };
        let ((mut thrlist9), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist9 }))
    }
}
#[doc = "Table thrlist8"]
#[derive(Clone, Debug)]
pub enum thrlist8 {
    Var0(thrlist8Var0),
    Var1(thrlist8Var1),
    Var2(thrlist8Var2),
}
impl thrlist8 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thrlist8Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thrlist8Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = thrlist8Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:935:1"]
#[derive(Clone, Debug)]
pub struct addrmode2Var0 {
    reloff: i64,
}
impl addrmode2Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { reloff } = self;
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            DisplayElement::Signed(true, *reloff),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut reloff = 0i64;
        reloff = ((i64::try_from(inst_start).unwrap() + (8u64 as i64))
            - i64::try_from(offset_12).unwrap());
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let offset_12 = token_parser.offset_12();
            if token_parser.I25() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1619() != (15u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (offset_12), block_len))
        };
        let ((), (offset_12), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let reloff = 0i64;
        *context = context_current;
        Some((inst_len, Self { reloff }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:929:1"]
#[derive(Clone, Debug)]
pub struct addrmode2Var1 {
    reloff: i64,
}
impl addrmode2Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { reloff } = self;
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            DisplayElement::Signed(true, *reloff),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut reloff = 0i64;
        reloff = ((i64::try_from(inst_start).unwrap() + (8u64 as i64))
            + i64::try_from(offset_12).unwrap());
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let offset_12 = token_parser.offset_12();
            if token_parser.I25() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1619() != (15u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (offset_12), block_len))
        };
        let ((), (offset_12), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let reloff = 0i64;
        *context = context_current;
        Some((inst_len, Self { reloff }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:957:1"]
#[derive(Clone, Debug)]
pub struct addrmode2Var2 {
    rn: rn,
    noff: i64,
}
impl addrmode2Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, noff } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("],"),
            DisplayElement::Literal("#"),
            DisplayElement::Signed(true, *noff),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut noff = 0i64;
        noff = (-i64::try_from(offset_12).unwrap());
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let offset_12 = token_parser.offset_12();
            if token_parser.I25() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (1u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn), (offset_12), block_len))
        };
        let ((mut rn), (offset_12), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let noff = 0i64;
        *context = context_current;
        Some((inst_len, Self { rn, noff }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:956:1"]
#[derive(Clone, Debug)]
pub struct addrmode2Var3 {
    rn: rn,
    offset_12: u16,
}
impl addrmode2Var3 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, offset_12 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("],"),
            DisplayElement::Literal("#"),
            DisplayElement::Unsigned(true, u64::try_from(*offset_12).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let offset_12 = token_parser.offset_12();
            if token_parser.I25() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (1u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn), (offset_12), block_len))
        };
        let ((mut rn), (offset_12), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:952:1"]
#[derive(Clone, Debug)]
pub struct addrmode2Var4 {
    rn: rn,
    noff: i64,
}
impl addrmode2Var4 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, noff } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("],"),
            DisplayElement::Literal("#"),
            DisplayElement::Signed(true, *noff),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut noff = 0i64;
        noff = (-i64::try_from(offset_12).unwrap());
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let offset_12 = token_parser.offset_12();
            if token_parser.I25() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (0u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn), (offset_12), block_len))
        };
        let ((mut rn), (offset_12), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let noff = 0i64;
        *context = context_current;
        Some((inst_len, Self { rn, noff }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:951:1"]
#[derive(Clone, Debug)]
pub struct addrmode2Var5 {
    rn: rn,
    offset_12: u16,
}
impl addrmode2Var5 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, offset_12 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("],"),
            DisplayElement::Literal("#"),
            DisplayElement::Unsigned(true, u64::try_from(*offset_12).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let offset_12 = token_parser.offset_12();
            if token_parser.I25() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (0u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn), (offset_12), block_len))
        };
        let ((mut rn), (offset_12), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:947:1"]
#[derive(Clone, Debug)]
pub struct addrmode2Var6 {
    rn: rn,
    noff: i64,
}
impl addrmode2Var6 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, noff } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal("#"),
            DisplayElement::Signed(true, *noff),
            DisplayElement::Literal("]!"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut noff = 0i64;
        noff = (-i64::try_from(offset_12).unwrap());
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let offset_12 = token_parser.offset_12();
            if token_parser.I25() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (1u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn), (offset_12), block_len))
        };
        let ((mut rn), (offset_12), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let noff = 0i64;
        *context = context_current;
        Some((inst_len, Self { rn, noff }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:946:1"]
#[derive(Clone, Debug)]
pub struct addrmode2Var7 {
    rn: rn,
    offset_12: u16,
}
impl addrmode2Var7 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, offset_12 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal("#"),
            DisplayElement::Unsigned(true, u64::try_from(*offset_12).unwrap()),
            DisplayElement::Literal("]!"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let offset_12 = token_parser.offset_12();
            if token_parser.I25() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (1u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn), (offset_12), block_len))
        };
        let ((mut rn), (offset_12), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:942:1"]
#[derive(Clone, Debug)]
pub struct addrmode2Var8 {
    rn: rn,
    noff: i64,
}
impl addrmode2Var8 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, noff } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal("#"),
            DisplayElement::Signed(true, *noff),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut noff = 0i64;
        noff = (-i64::try_from(offset_12).unwrap());
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let offset_12 = token_parser.offset_12();
            if token_parser.I25() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (0u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn), (offset_12), block_len))
        };
        let ((mut rn), (offset_12), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let noff = 0i64;
        *context = context_current;
        Some((inst_len, Self { rn, noff }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:941:1"]
#[derive(Clone, Debug)]
pub struct addrmode2Var9 {
    rn: rn,
    offset_12: u16,
}
impl addrmode2Var9 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, offset_12 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal("#"),
            DisplayElement::Unsigned(true, u64::try_from(*offset_12).unwrap()),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let offset_12 = token_parser.offset_12();
            if token_parser.I25() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (0u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn), (offset_12), block_len))
        };
        let ((mut rn), (offset_12), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:959:1"]
#[derive(Clone, Debug)]
pub struct addrmode2Var10 {
    rn: rn,
    addr2shift: addr2shift,
}
impl addrmode2Var10 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, addr2shift } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("],-")];
        display.extend_from_slice(&extend);
        addr2shift.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.I25() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (1u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let addr2shift = if let Some((len, table)) = addr2shift::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, addr2shift), (), block_len))
        };
        let ((mut rn, mut addr2shift), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rn, addr2shift }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:958:1"]
#[derive(Clone, Debug)]
pub struct addrmode2Var11 {
    addr2shift: addr2shift,
    rn: rn,
}
impl addrmode2Var11 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { addr2shift, rn } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("],")];
        display.extend_from_slice(&extend);
        addr2shift.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.I25() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (1u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let addr2shift = if let Some((len, table)) = addr2shift::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, addr2shift), (), block_len))
        };
        let ((mut rn, mut addr2shift), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { addr2shift, rn }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:954:1"]
#[derive(Clone, Debug)]
pub struct addrmode2Var12 {
    addr2shift: addr2shift,
    rn: rn,
}
impl addrmode2Var12 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { addr2shift, rn } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("],-")];
        display.extend_from_slice(&extend);
        addr2shift.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.I25() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (0u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let addr2shift = if let Some((len, table)) = addr2shift::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, addr2shift), (), block_len))
        };
        let ((mut rn, mut addr2shift), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { addr2shift, rn }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:953:1"]
#[derive(Clone, Debug)]
pub struct addrmode2Var13 {
    addr2shift: addr2shift,
    rn: rn,
}
impl addrmode2Var13 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { addr2shift, rn } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("],")];
        display.extend_from_slice(&extend);
        addr2shift.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.I25() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (0u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let addr2shift = if let Some((len, table)) = addr2shift::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, addr2shift), (), block_len))
        };
        let ((mut rn, mut addr2shift), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { addr2shift, rn }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:949:1"]
#[derive(Clone, Debug)]
pub struct addrmode2Var14 {
    rn: rn,
    addr2shift: addr2shift,
}
impl addrmode2Var14 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, addr2shift } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",-")];
        display.extend_from_slice(&extend);
        addr2shift.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("]!")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.I25() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (1u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let addr2shift = if let Some((len, table)) = addr2shift::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((addr2shift, rn), (), block_len))
        };
        let ((mut addr2shift, mut rn), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rn, addr2shift }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:948:1"]
#[derive(Clone, Debug)]
pub struct addrmode2Var15 {
    rn: rn,
    addr2shift: addr2shift,
}
impl addrmode2Var15 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, addr2shift } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        addr2shift.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("]!")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.I25() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (1u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let addr2shift = if let Some((len, table)) = addr2shift::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, addr2shift), (), block_len))
        };
        let ((mut rn, mut addr2shift), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rn, addr2shift }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:944:1"]
#[derive(Clone, Debug)]
pub struct addrmode2Var16 {
    rn: rn,
    addr2shift: addr2shift,
}
impl addrmode2Var16 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, addr2shift } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",-")];
        display.extend_from_slice(&extend);
        addr2shift.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("]")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.I25() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (0u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let addr2shift = if let Some((len, table)) = addr2shift::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, addr2shift), (), block_len))
        };
        let ((mut rn, mut addr2shift), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rn, addr2shift }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:943:1"]
#[derive(Clone, Debug)]
pub struct addrmode2Var17 {
    addr2shift: addr2shift,
    rn: rn,
}
impl addrmode2Var17 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { addr2shift, rn } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        addr2shift.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("]")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.I25() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (0u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let addr2shift = if let Some((len, table)) = addr2shift::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, addr2shift), (), block_len))
        };
        let ((mut rn, mut addr2shift), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { addr2shift, rn }))
    }
}
#[doc = "Table addrmode2"]
#[derive(Clone, Debug)]
pub enum addrmode2 {
    Var0(addrmode2Var0),
    Var1(addrmode2Var1),
    Var2(addrmode2Var2),
    Var3(addrmode2Var3),
    Var4(addrmode2Var4),
    Var5(addrmode2Var5),
    Var6(addrmode2Var6),
    Var7(addrmode2Var7),
    Var8(addrmode2Var8),
    Var9(addrmode2Var9),
    Var10(addrmode2Var10),
    Var11(addrmode2Var11),
    Var12(addrmode2Var12),
    Var13(addrmode2Var13),
    Var14(addrmode2Var14),
    Var15(addrmode2Var15),
    Var16(addrmode2Var16),
    Var17(addrmode2Var17),
}
impl addrmode2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
            Self::Var3(x) => x.display_extend(display, context),
            Self::Var4(x) => x.display_extend(display, context),
            Self::Var5(x) => x.display_extend(display, context),
            Self::Var6(x) => x.display_extend(display, context),
            Self::Var7(x) => x.display_extend(display, context),
            Self::Var8(x) => x.display_extend(display, context),
            Self::Var9(x) => x.display_extend(display, context),
            Self::Var10(x) => x.display_extend(display, context),
            Self::Var11(x) => x.display_extend(display, context),
            Self::Var12(x) => x.display_extend(display, context),
            Self::Var13(x) => x.display_extend(display, context),
            Self::Var14(x) => x.display_extend(display, context),
            Self::Var15(x) => x.display_extend(display, context),
            Self::Var16(x) => x.display_extend(display, context),
            Self::Var17(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var14(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var15(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var16(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var17(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = addrmode2Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode2Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode2Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode2Var3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var3(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode2Var4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var4(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode2Var5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var5(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode2Var6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var6(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode2Var7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var7(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode2Var8::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var8(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode2Var9::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var9(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode2Var10::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var10(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode2Var11::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var11(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode2Var12::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var12(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode2Var13::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var13(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode2Var14::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var14(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode2Var15::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var15(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode2Var16::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var16(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode2Var17::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var17(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1121:1"]
#[derive(Clone, Debug)]
pub struct sinc9Var0 {
    sinc10: sinc10,
}
impl sinc9Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sinc10 } = self;
        sinc10.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0606() != (0u64 as i64) as u8 {
                return None;
            }
            let sinc10 = if let Some((len, table)) = sinc10::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sinc10), (), block_len))
        };
        let ((mut sinc10), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sinc10 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1119:1"]
#[derive(Clone, Debug)]
pub struct sinc9Var1 {
    sinc10: sinc10,
}
impl sinc9Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sinc10 } = self;
        sinc10.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r6),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0606() != (1u64 as i64) as u8 {
                return None;
            }
            let sinc10 = if let Some((len, table)) = sinc10::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sinc10), (), block_len))
        };
        let ((mut sinc10), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sinc10 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1120:1"]
#[derive(Clone, Debug)]
pub struct sinc9Var2 {}
impl sinc9Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0606() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0005() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table sinc9"]
#[derive(Clone, Debug)]
pub enum sinc9 {
    Var0(sinc9Var0),
    Var1(sinc9Var1),
    Var2(sinc9Var2),
}
impl sinc9 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = sinc9Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = sinc9Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = sinc9Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1199:1"]
#[derive(Clone, Debug)]
pub struct ldec0Var0 {
    ldec1: ldec1,
}
impl ldec0Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldec1 } = self;
        ldec1.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0000() != (0u64 as i64) as u8 {
                return None;
            }
            let ldec1 = if let Some((len, table)) = ldec1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldec1), (), block_len))
        };
        let ((mut ldec1), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldec1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1197:1"]
#[derive(Clone, Debug)]
pub struct ldec0Var1 {
    ldec1: ldec1,
}
impl ldec0Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldec1 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r0),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        ldec1.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0000() != (1u64 as i64) as u8 {
                return None;
            }
            let ldec1 = if let Some((len, table)) = ldec1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldec1), (), block_len))
        };
        let ((mut ldec1), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldec1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1198:1"]
#[derive(Clone, Debug)]
pub struct ldec0Var2 {}
impl ldec0Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r0)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0000() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0115() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table ldec0"]
#[derive(Clone, Debug)]
pub enum ldec0 {
    Var0(ldec0Var0),
    Var1(ldec0Var1),
    Var2(ldec0Var2),
}
impl ldec0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = ldec0Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = ldec0Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = ldec0Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1095:1"]
#[derive(Clone, Debug)]
pub struct linc1Var0 {
    linc2: linc2,
}
impl linc1Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { linc2 } = self;
        linc2.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1414() != (0u64 as i64) as u8 {
                return None;
            }
            let linc2 = if let Some((len, table)) = linc2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((linc2), (), block_len))
        };
        let ((mut linc2), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { linc2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1093:1"]
#[derive(Clone, Debug)]
pub struct linc1Var1 {
    linc2: linc2,
}
impl linc1Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { linc2 } = self;
        linc2.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::lr),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1414() != (1u64 as i64) as u8 {
                return None;
            }
            let linc2 = if let Some((len, table)) = linc2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((linc2), (), block_len))
        };
        let ((mut linc2), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { linc2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1094:1"]
#[derive(Clone, Debug)]
pub struct linc1Var2 {}
impl linc1Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::lr)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1414() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0013() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table linc1"]
#[derive(Clone, Debug)]
pub enum linc1 {
    Var0(linc1Var0),
    Var1(linc1Var1),
    Var2(linc1Var2),
}
impl linc1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = linc1Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = linc1Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = linc1Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:930:1"]
#[derive(Clone, Debug)]
pub struct RnIndirect1Var0 {
    Rn0305: u8,
    immed5: u8,
}
impl RnIndirect1Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { Rn0305, immed5 } = self;
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("["),
            meaning_94047783056016(usize::try_from(*Rn0305).unwrap()),
            DisplayElement::Literal(","),
            DisplayElement::Literal("#"),
            DisplayElement::Unsigned(true, u64::try_from(*immed5).unwrap()),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0305 = token_parser.Rn0305();
            let immed5 = token_parser.immed5();
            *context = context_current;
            Some(((), (Rn0305, immed5), block_len))
        };
        let ((), (Rn0305, immed5), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { Rn0305, immed5 }))
    }
}
#[doc = "Table RnIndirect1"]
#[derive(Clone, Debug)]
pub enum RnIndirect1 {
    Var0(RnIndirect1Var0),
}
impl RnIndirect1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = RnIndirect1Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1148:1"]
#[derive(Clone, Debug)]
pub struct sinc0Var0 {
    sinc1: sinc1,
}
impl sinc0Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sinc1 } = self;
        sinc1.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1515() != (0u64 as i64) as u8 {
                return None;
            }
            let sinc1 = if let Some((len, table)) = sinc1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sinc1), (), block_len))
        };
        let ((mut sinc1), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sinc1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1146:1"]
#[derive(Clone, Debug)]
pub struct sinc0Var1 {
    sinc1: sinc1,
}
impl sinc0Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sinc1 } = self;
        sinc1.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::pc),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1515() != (1u64 as i64) as u8 {
                return None;
            }
            let sinc1 = if let Some((len, table)) = sinc1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sinc1), (), block_len))
        };
        let ((mut sinc1), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sinc1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1147:1"]
#[derive(Clone, Debug)]
pub struct sinc0Var2 {}
impl sinc0Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1515() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0014() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table sinc0"]
#[derive(Clone, Debug)]
pub enum sinc0 {
    Var0(sinc0Var0),
    Var1(sinc0Var1),
    Var2(sinc0Var2),
}
impl sinc0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = sinc0Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = sinc0Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = sinc0Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1086:1"]
#[derive(Clone, Debug)]
pub struct linc4Var0 {
    linc5: linc5,
}
impl linc4Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { linc5 } = self;
        linc5.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1111() != (0u64 as i64) as u8 {
                return None;
            }
            let linc5 = if let Some((len, table)) = linc5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((linc5), (), block_len))
        };
        let ((mut linc5), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { linc5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1084:1"]
#[derive(Clone, Debug)]
pub struct linc4Var1 {
    linc5: linc5,
}
impl linc4Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { linc5 } = self;
        linc5.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r11),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1111() != (1u64 as i64) as u8 {
                return None;
            }
            let linc5 = if let Some((len, table)) = linc5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((linc5), (), block_len))
        };
        let ((mut linc5), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { linc5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1085:1"]
#[derive(Clone, Debug)]
pub struct linc4Var2 {}
impl linc4Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r11)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1111() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0010() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table linc4"]
#[derive(Clone, Debug)]
pub enum linc4 {
    Var0(linc4Var0),
    Var1(linc4Var1),
    Var2(linc4Var2),
}
impl linc4 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = linc4Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = linc4Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = linc4Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:929:1"]
#[derive(Clone, Debug)]
pub struct RnIndirect2Var0 {
    immval: i64,
    Rn0305: u8,
}
impl RnIndirect2Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { immval, Rn0305 } = self;
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("["),
            meaning_94047783056016(usize::try_from(*Rn0305).unwrap()),
            DisplayElement::Literal(","),
            DisplayElement::Literal("#"),
            DisplayElement::Signed(true, *immval),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut immval = 0i64;
        immval = (i64::try_from(immed5).unwrap() * (2u64 as i64));
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0305 = token_parser.Rn0305();
            let immed5 = token_parser.immed5();
            *context = context_current;
            Some(((), (Rn0305, immed5), block_len))
        };
        let ((), (Rn0305, immed5), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let immval = 0i64;
        *context = context_current;
        Some((inst_len, Self { immval, Rn0305 }))
    }
}
#[doc = "Table RnIndirect2"]
#[derive(Clone, Debug)]
pub enum RnIndirect2 {
    Var0(RnIndirect2Var0),
}
impl RnIndirect2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = RnIndirect2Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:849:1"]
#[derive(Clone, Debug)]
pub struct thsdec15Var0 {}
impl thsdec15Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc1515() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:848:1"]
#[derive(Clone, Debug)]
pub struct thsdec15Var1 {}
impl thsdec15Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc1515() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table thsdec15"]
#[derive(Clone, Debug)]
pub enum thsdec15 {
    Var0(thsdec15Var0),
    Var1(thsdec15Var1),
}
impl thsdec15 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thsdec15Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thsdec15Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1098:1"]
#[derive(Clone, Debug)]
pub struct linc0Var0 {
    linc1: linc1,
}
impl linc0Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { linc1 } = self;
        linc1.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1515() != (0u64 as i64) as u8 {
                return None;
            }
            let linc1 = if let Some((len, table)) = linc1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((linc1), (), block_len))
        };
        let ((mut linc1), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { linc1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1096:1"]
#[derive(Clone, Debug)]
pub struct linc0Var1 {
    linc1: linc1,
}
impl linc0Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { linc1 } = self;
        linc1.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::pc),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1515() != (1u64 as i64) as u8 {
                return None;
            }
            let linc1 = if let Some((len, table)) = linc1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((linc1), (), block_len))
        };
        let ((mut linc1), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { linc1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1097:1"]
#[derive(Clone, Debug)]
pub struct linc0Var2 {}
impl linc0Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1515() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0014() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table linc0"]
#[derive(Clone, Debug)]
pub enum linc0 {
    Var0(linc0Var0),
    Var1(linc0Var1),
    Var2(linc0Var2),
}
impl linc0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = linc0Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = linc0Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = linc0Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:865:1"]
#[derive(Clone, Debug)]
pub struct thsdec9Var0 {}
impl thsdec9Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r9)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0909() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc1015() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:867:1"]
#[derive(Clone, Debug)]
pub struct thsdec9Var1 {
    thsdec10: thsdec10,
}
impl thsdec9Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thsdec10 } = self;
        thsdec10.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0909() != (0u64 as i64) as u8 {
                return None;
            }
            let thsdec10 = if let Some((len, table)) = thsdec10::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thsdec10), (), block_len))
        };
        let ((mut thsdec10), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thsdec10 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:866:1"]
#[derive(Clone, Debug)]
pub struct thsdec9Var2 {
    thsdec10: thsdec10,
}
impl thsdec9Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thsdec10 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r9),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        thsdec10.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0909() != (1u64 as i64) as u8 {
                return None;
            }
            let thsdec10 = if let Some((len, table)) = thsdec10::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thsdec10), (), block_len))
        };
        let ((mut thsdec10), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thsdec10 }))
    }
}
#[doc = "Table thsdec9"]
#[derive(Clone, Debug)]
pub enum thsdec9 {
    Var0(thsdec9Var0),
    Var1(thsdec9Var1),
    Var2(thsdec9Var2),
}
impl thsdec9 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thsdec9Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thsdec9Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = thsdec9Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:668:1"]
#[derive(Clone, Debug)]
pub struct shift1Var0 {
    value: i64,
}
impl shift1Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { value } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("#"),
            DisplayElement::Signed(true, *value),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut value = 0i64;
        value = (((i64::try_from(immed).unwrap()
            << (((32u64 as i64) - i64::try_from(rotate).unwrap())
                * (2u64 as i64)))
            | (i64::try_from(immed).unwrap()
                >> (i64::try_from(rotate).unwrap() * (2u64 as i64))))
            & (4294967295u64 as i64));
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let immed = token_parser.immed();
            let rotate = token_parser.rotate();
            if token_parser.I25() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (immed, rotate), block_len))
        };
        let ((), (immed, rotate), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let value = 0i64;
        *context = context_current;
        Some((inst_len, Self { value }))
    }
}
#[doc = "Table shift1"]
#[derive(Clone, Debug)]
pub enum shift1 {
    Var0(shift1Var0),
}
impl shift1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = shift1Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1062:1"]
#[derive(Clone, Debug)]
pub struct linc12Var0 {
    linc13: linc13,
}
impl linc12Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { linc13 } = self;
        linc13.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0303() != (0u64 as i64) as u8 {
                return None;
            }
            let linc13 = if let Some((len, table)) = linc13::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((linc13), (), block_len))
        };
        let ((mut linc13), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { linc13 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1060:1"]
#[derive(Clone, Debug)]
pub struct linc12Var1 {
    linc13: linc13,
}
impl linc12Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { linc13 } = self;
        linc13.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r3),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0303() != (1u64 as i64) as u8 {
                return None;
            }
            let linc13 = if let Some((len, table)) = linc13::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((linc13), (), block_len))
        };
        let ((mut linc13), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { linc13 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1061:1"]
#[derive(Clone, Debug)]
pub struct linc12Var2 {}
impl linc12Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0303() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0002() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table linc12"]
#[derive(Clone, Debug)]
pub enum linc12 {
    Var0(linc12Var0),
    Var1(linc12Var1),
    Var2(linc12Var2),
}
impl linc12 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = linc12Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = linc12Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = linc12Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:736:1"]
#[derive(Clone, Debug)]
pub struct thrlist2Var0 {
    thrlist3: thrlist3,
}
impl thrlist2Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist3 } = self;
        thrlist3.display_extend(display, context);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sp)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc1313() != (1u64 as i64) as u8 {
                return None;
            }
            let thrlist3 = if let Some((len, table)) = thrlist3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc1415() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((thrlist3), (), block_len))
        };
        let ((mut thrlist3), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist3 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:738:1"]
#[derive(Clone, Debug)]
pub struct thrlist2Var1 {
    thrlist3: thrlist3,
}
impl thrlist2Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist3 } = self;
        thrlist3.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc1313() != (0u64 as i64) as u8 {
                return None;
            }
            let thrlist3 = if let Some((len, table)) = thrlist3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thrlist3), (), block_len))
        };
        let ((mut thrlist3), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist3 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:737:1"]
#[derive(Clone, Debug)]
pub struct thrlist2Var2 {
    thrlist3: thrlist3,
}
impl thrlist2Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist3 } = self;
        thrlist3.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::sp),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc1313() != (1u64 as i64) as u8 {
                return None;
            }
            let thrlist3 = if let Some((len, table)) = thrlist3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thrlist3), (), block_len))
        };
        let ((mut thrlist3), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist3 }))
    }
}
#[doc = "Table thrlist2"]
#[derive(Clone, Debug)]
pub enum thrlist2 {
    Var0(thrlist2Var0),
    Var1(thrlist2Var1),
    Var2(thrlist2Var2),
}
impl thrlist2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thrlist2Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thrlist2Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = thrlist2Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1228:1"]
#[derive(Clone, Debug)]
pub struct sdec7Var0 {
    sdec8: sdec8,
}
impl sdec7Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sdec8 } = self;
        sdec8.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0707() != (0u64 as i64) as u8 {
                return None;
            }
            let sdec8 = if let Some((len, table)) = sdec8::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sdec8), (), block_len))
        };
        let ((mut sdec8), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sdec8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1226:1"]
#[derive(Clone, Debug)]
pub struct sdec7Var1 {
    sdec8: sdec8,
}
impl sdec7Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sdec8 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r7),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        sdec8.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0707() != (1u64 as i64) as u8 {
                return None;
            }
            let sdec8 = if let Some((len, table)) = sdec8::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sdec8), (), block_len))
        };
        let ((mut sdec8), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sdec8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1227:1"]
#[derive(Clone, Debug)]
pub struct sdec7Var2 {}
impl sdec7Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0707() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0815() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table sdec7"]
#[derive(Clone, Debug)]
pub enum sdec7 {
    Var0(sdec7Var0),
    Var1(sdec7Var1),
    Var2(sdec7Var2),
}
impl sdec7 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = sdec7Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = sdec7Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = sdec7Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:679:1"]
#[derive(Clone, Debug)]
pub struct PshType5Var0 {
    PshType6: PshType6,
}
impl PshType5Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { PshType6 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r5),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        PshType6.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let PshType6 = if let Some((len, table)) = PshType6::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0505() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((PshType6), (), block_len))
        };
        let ((mut PshType6), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { PshType6 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:677:1"]
#[derive(Clone, Debug)]
pub struct PshType5Var1 {
    PshType6: PshType6,
}
impl PshType5Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { PshType6 } = self;
        PshType6.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let PshType6 = if let Some((len, table)) = PshType6::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0505() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((PshType6), (), block_len))
        };
        let ((mut PshType6), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { PshType6 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:678:1"]
#[derive(Clone, Debug)]
pub struct PshType5Var2 {}
impl PshType5Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0505() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0607() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table PshType5"]
#[derive(Clone, Debug)]
pub enum PshType5 {
    Var0(PshType5Var0),
    Var1(PshType5Var1),
    Var2(PshType5Var2),
}
impl PshType5 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = PshType5Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = PshType5Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = PshType5Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1172:1"]
#[derive(Clone, Debug)]
pub struct ldec9Var0 {
    ldec10: ldec10,
}
impl ldec9Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldec10 } = self;
        ldec10.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0909() != (0u64 as i64) as u8 {
                return None;
            }
            let ldec10 = if let Some((len, table)) = ldec10::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldec10), (), block_len))
        };
        let ((mut ldec10), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldec10 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1170:1"]
#[derive(Clone, Debug)]
pub struct ldec9Var1 {
    ldec10: ldec10,
}
impl ldec9Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldec10 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r9),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        ldec10.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0909() != (1u64 as i64) as u8 {
                return None;
            }
            let ldec10 = if let Some((len, table)) = ldec10::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldec10), (), block_len))
        };
        let ((mut ldec10), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldec10 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1171:1"]
#[derive(Clone, Debug)]
pub struct ldec9Var2 {}
impl ldec9Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r9)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0909() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1015() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table ldec9"]
#[derive(Clone, Debug)]
pub enum ldec9 {
    Var0(ldec9Var0),
    Var1(ldec9Var1),
    Var2(ldec9Var2),
}
impl ldec9 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = ldec9Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = ldec9Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = ldec9Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:357:1"]
#[derive(Clone, Debug)]
pub struct Hrn0002Var0 {}
impl Hrn0002Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.hrn0002() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.h1() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:356:1"]
#[derive(Clone, Debug)]
pub struct Hrn0002Var1 {
    hrn0002: u8,
}
impl Hrn0002Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { hrn0002 } = self;
        let extend: [DisplayElement; 1usize] =
            [meaning_94047764607728(usize::try_from(*hrn0002).unwrap())];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let hrn0002 = token_parser.hrn0002();
            if token_parser.h1() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (hrn0002), block_len))
        };
        let ((), (hrn0002), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { hrn0002 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:355:1"]
#[derive(Clone, Debug)]
pub struct Hrn0002Var2 {
    Rn0002: u8,
}
impl Hrn0002Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { Rn0002 } = self;
        let extend: [DisplayElement; 1usize] =
            [meaning_94047783056016(usize::try_from(*Rn0002).unwrap())];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0002 = token_parser.Rn0002();
            if token_parser.h1() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rn0002), block_len))
        };
        let ((), (Rn0002), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { Rn0002 }))
    }
}
#[doc = "Table Hrn0002"]
#[derive(Clone, Debug)]
pub enum Hrn0002 {
    Var0(Hrn0002Var0),
    Var1(Hrn0002Var1),
    Var2(Hrn0002Var2),
}
impl Hrn0002 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = Hrn0002Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = Hrn0002Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = Hrn0002Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3820:1"]
#[derive(Clone, Debug)]
pub struct thXBITVar0 {}
impl thXBITVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("t")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0003 = token_parser.Rn0003();
            *context = context_current;
            Some(((), (Rn0003), block_len))
        };
        let ((), (Rn0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0505() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3819:1"]
#[derive(Clone, Debug)]
pub struct thXBITVar1 {}
impl thXBITVar1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0003 = token_parser.Rn0003();
            *context = context_current;
            Some(((), (Rn0003), block_len))
        };
        let ((), (Rn0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0505() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table thXBIT"]
#[derive(Clone, Debug)]
pub enum thXBIT {
    Var0(thXBITVar0),
    Var1(thXBITVar1),
}
impl thXBIT {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thXBITVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thXBITVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1219:1"]
#[derive(Clone, Debug)]
pub struct sdec10Var0 {
    sdec11: sdec11,
}
impl sdec10Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sdec11 } = self;
        sdec11.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1010() != (0u64 as i64) as u8 {
                return None;
            }
            let sdec11 = if let Some((len, table)) = sdec11::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sdec11), (), block_len))
        };
        let ((mut sdec11), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sdec11 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1217:1"]
#[derive(Clone, Debug)]
pub struct sdec10Var1 {
    sdec11: sdec11,
}
impl sdec10Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sdec11 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r10),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        sdec11.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1010() != (1u64 as i64) as u8 {
                return None;
            }
            let sdec11 = if let Some((len, table)) = sdec11::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sdec11), (), block_len))
        };
        let ((mut sdec11), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sdec11 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1218:1"]
#[derive(Clone, Debug)]
pub struct sdec10Var2 {}
impl sdec10Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r10)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1010() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1115() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table sdec10"]
#[derive(Clone, Debug)]
pub enum sdec10 {
    Var0(sdec10Var0),
    Var1(sdec10Var1),
    Var2(sdec10Var2),
}
impl sdec10 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = sdec10Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = sdec10Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = sdec10Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1059:1"]
#[derive(Clone, Debug)]
pub struct linc13Var0 {
    linc14: linc14,
}
impl linc13Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { linc14 } = self;
        linc14.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0202() != (0u64 as i64) as u8 {
                return None;
            }
            let linc14 = if let Some((len, table)) = linc14::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((linc14), (), block_len))
        };
        let ((mut linc14), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { linc14 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1057:1"]
#[derive(Clone, Debug)]
pub struct linc13Var1 {
    linc14: linc14,
}
impl linc13Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { linc14 } = self;
        linc14.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r2),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0202() != (1u64 as i64) as u8 {
                return None;
            }
            let linc14 = if let Some((len, table)) = linc14::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((linc14), (), block_len))
        };
        let ((mut linc14), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { linc14 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1058:1"]
#[derive(Clone, Debug)]
pub struct linc13Var2 {}
impl linc13Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0202() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0001() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table linc13"]
#[derive(Clone, Debug)]
pub enum linc13 {
    Var0(linc13Var0),
    Var1(linc13Var1),
    Var2(linc13Var2),
}
impl linc13 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = linc13Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = linc13Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = linc13Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:658:1"]
#[derive(Clone, Debug)]
pub struct YBITVar0 {}
impl YBITVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("t")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let smRm = token_parser.smRm();
            if token_parser.y() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (smRm), block_len))
        };
        let ((), (smRm), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:657:1"]
#[derive(Clone, Debug)]
pub struct YBITVar1 {}
impl YBITVar1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let smRm = token_parser.smRm();
            if token_parser.y() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (smRm), block_len))
        };
        let ((), (smRm), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table YBIT"]
#[derive(Clone, Debug)]
pub enum YBIT {
    Var0(YBITVar0),
    Var1(YBITVar1),
}
impl YBIT {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = YBITVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = YBITVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:880:1"]
#[derive(Clone, Debug)]
pub struct thsdec4Var0 {}
impl thsdec4Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0515() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:882:1"]
#[derive(Clone, Debug)]
pub struct thsdec4Var1 {
    thsdec5: thsdec5,
}
impl thsdec4Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thsdec5 } = self;
        thsdec5.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0404() != (0u64 as i64) as u8 {
                return None;
            }
            let thsdec5 = if let Some((len, table)) = thsdec5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thsdec5), (), block_len))
        };
        let ((mut thsdec5), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thsdec5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:881:1"]
#[derive(Clone, Debug)]
pub struct thsdec4Var2 {
    thsdec5: thsdec5,
}
impl thsdec4Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thsdec5 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r4),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        thsdec5.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0404() != (1u64 as i64) as u8 {
                return None;
            }
            let thsdec5 = if let Some((len, table)) = thsdec5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thsdec5), (), block_len))
        };
        let ((mut thsdec5), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thsdec5 }))
    }
}
#[doc = "Table thsdec4"]
#[derive(Clone, Debug)]
pub enum thsdec4 {
    Var0(thsdec4Var0),
    Var1(thsdec4Var1),
    Var2(thsdec4Var2),
}
impl thsdec4 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thsdec4Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thsdec4Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = thsdec4Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1213:1"]
#[derive(Clone, Debug)]
pub struct sdec12Var0 {
    sdec13: sdec13,
}
impl sdec12Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sdec13 } = self;
        sdec13.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1212() != (0u64 as i64) as u8 {
                return None;
            }
            let sdec13 = if let Some((len, table)) = sdec13::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sdec13), (), block_len))
        };
        let ((mut sdec13), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sdec13 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1211:1"]
#[derive(Clone, Debug)]
pub struct sdec12Var1 {
    sdec13: sdec13,
}
impl sdec12Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sdec13 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r12),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        sdec13.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1212() != (1u64 as i64) as u8 {
                return None;
            }
            let sdec13 = if let Some((len, table)) = sdec13::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sdec13), (), block_len))
        };
        let ((mut sdec13), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sdec13 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1212:1"]
#[derive(Clone, Debug)]
pub struct sdec12Var2 {}
impl sdec12Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r12)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1212() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1315() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table sdec12"]
#[derive(Clone, Debug)]
pub enum sdec12 {
    Var0(sdec12Var0),
    Var1(sdec12Var1),
    Var2(sdec12Var2),
}
impl sdec12 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = sdec12Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = sdec12Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = sdec12Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:918:1"]
#[derive(Clone, Debug)]
pub struct addr2shiftVar0 {
    rm: rm,
}
impl addr2shiftVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rm } = self;
        rm.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0411() != (0u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rm), (), block_len))
        };
        let ((mut rm), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rm }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:925:1"]
#[derive(Clone, Debug)]
pub struct addr2shiftVar1 {
    rm: rm,
}
impl addr2shiftVar1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rm } = self;
        rm.display_extend(display, context);
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal(","), DisplayElement::Literal("rrx")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.sftimm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.shft() != (3u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (0u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rm), (), block_len))
        };
        let ((mut rm), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rm }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:923:1"]
#[derive(Clone, Debug)]
pub struct addr2shiftVar2 {
    rm: rm,
}
impl addr2shiftVar2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rm } = self;
        rm.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal("asr #32"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.sftimm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.shft() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (0u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rm), (), block_len))
        };
        let ((mut rm), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rm }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:921:1"]
#[derive(Clone, Debug)]
pub struct addr2shiftVar3 {
    rm: rm,
}
impl addr2shiftVar3 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rm } = self;
        rm.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal("lsr #32"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.sftimm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.shft() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (0u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rm), (), block_len))
        };
        let ((mut rm), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rm }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:924:1"]
#[derive(Clone, Debug)]
pub struct addr2shiftVar4 {
    rm: rm,
    sftimm: u8,
}
impl addr2shiftVar4 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rm, sftimm } = self;
        rm.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal("ror #"),
            DisplayElement::Unsigned(true, u64::try_from(*sftimm).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let sftimm = token_parser.sftimm();
            if token_parser.shft() != (3u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (0u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rm), (sftimm), block_len))
        };
        let ((mut rm), (sftimm), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rm, sftimm }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:922:1"]
#[derive(Clone, Debug)]
pub struct addr2shiftVar5 {
    rm: rm,
    sftimm: u8,
}
impl addr2shiftVar5 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rm, sftimm } = self;
        rm.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal("asr #"),
            DisplayElement::Unsigned(true, u64::try_from(*sftimm).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let sftimm = token_parser.sftimm();
            if token_parser.shft() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (0u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rm), (sftimm), block_len))
        };
        let ((mut rm), (sftimm), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rm, sftimm }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:920:1"]
#[derive(Clone, Debug)]
pub struct addr2shiftVar6 {
    rm: rm,
    sftimm: u8,
}
impl addr2shiftVar6 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rm, sftimm } = self;
        rm.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal("lsr #"),
            DisplayElement::Unsigned(true, u64::try_from(*sftimm).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let sftimm = token_parser.sftimm();
            if token_parser.shft() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (0u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rm), (sftimm), block_len))
        };
        let ((mut rm), (sftimm), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rm, sftimm }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:919:1"]
#[derive(Clone, Debug)]
pub struct addr2shiftVar7 {
    rm: rm,
    sftimm: u8,
}
impl addr2shiftVar7 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rm, sftimm } = self;
        rm.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal("lsl #"),
            DisplayElement::Unsigned(true, u64::try_from(*sftimm).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let sftimm = token_parser.sftimm();
            if token_parser.shft() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (0u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rm), (sftimm), block_len))
        };
        let ((mut rm), (sftimm), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rm, sftimm }))
    }
}
#[doc = "Table addr2shift"]
#[derive(Clone, Debug)]
pub enum addr2shift {
    Var0(addr2shiftVar0),
    Var1(addr2shiftVar1),
    Var2(addr2shiftVar2),
    Var3(addr2shiftVar3),
    Var4(addr2shiftVar4),
    Var5(addr2shiftVar5),
    Var6(addr2shiftVar6),
    Var7(addr2shiftVar7),
}
impl addr2shift {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
            Self::Var3(x) => x.display_extend(display, context),
            Self::Var4(x) => x.display_extend(display, context),
            Self::Var5(x) => x.display_extend(display, context),
            Self::Var6(x) => x.display_extend(display, context),
            Self::Var7(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = addr2shiftVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = addr2shiftVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = addr2shiftVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        if let Some((inst_next, parsed)) = addr2shiftVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var3(parsed)));
        }
        if let Some((inst_next, parsed)) = addr2shiftVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var4(parsed)));
        }
        if let Some((inst_next, parsed)) = addr2shiftVar5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var5(parsed)));
        }
        if let Some((inst_next, parsed)) = addr2shiftVar6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var6(parsed)));
        }
        if let Some((inst_next, parsed)) = addr2shiftVar7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var7(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:712:1"]
#[derive(Clone, Debug)]
pub struct thrlist10Var0 {
    thrlist11: thrlist11,
}
impl thrlist10Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist11 } = self;
        thrlist11.display_extend(display, context);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0505() != (1u64 as i64) as u8 {
                return None;
            }
            let thrlist11 = if let Some((len, table)) = thrlist11::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0615() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((thrlist11), (), block_len))
        };
        let ((mut thrlist11), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist11 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:714:1"]
#[derive(Clone, Debug)]
pub struct thrlist10Var1 {
    thrlist11: thrlist11,
}
impl thrlist10Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist11 } = self;
        thrlist11.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0505() != (0u64 as i64) as u8 {
                return None;
            }
            let thrlist11 = if let Some((len, table)) = thrlist11::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thrlist11), (), block_len))
        };
        let ((mut thrlist11), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist11 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:713:1"]
#[derive(Clone, Debug)]
pub struct thrlist10Var2 {
    thrlist11: thrlist11,
}
impl thrlist10Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist11 } = self;
        thrlist11.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r5),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0505() != (1u64 as i64) as u8 {
                return None;
            }
            let thrlist11 = if let Some((len, table)) = thrlist11::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thrlist11), (), block_len))
        };
        let ((mut thrlist11), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist11 }))
    }
}
#[doc = "Table thrlist10"]
#[derive(Clone, Debug)]
pub enum thrlist10 {
    Var0(thrlist10Var0),
    Var1(thrlist10Var1),
    Var2(thrlist10Var2),
}
impl thrlist10 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thrlist10Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thrlist10Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = thrlist10Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1216:1"]
#[derive(Clone, Debug)]
pub struct sdec11Var0 {
    sdec12: sdec12,
}
impl sdec11Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sdec12 } = self;
        sdec12.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1111() != (0u64 as i64) as u8 {
                return None;
            }
            let sdec12 = if let Some((len, table)) = sdec12::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sdec12), (), block_len))
        };
        let ((mut sdec12), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sdec12 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1214:1"]
#[derive(Clone, Debug)]
pub struct sdec11Var1 {
    sdec12: sdec12,
}
impl sdec11Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sdec12 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r11),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        sdec12.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1111() != (1u64 as i64) as u8 {
                return None;
            }
            let sdec12 = if let Some((len, table)) = sdec12::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sdec12), (), block_len))
        };
        let ((mut sdec12), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sdec12 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1215:1"]
#[derive(Clone, Debug)]
pub struct sdec11Var2 {}
impl sdec11Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r11)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1111() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1215() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table sdec11"]
#[derive(Clone, Debug)]
pub enum sdec11 {
    Var0(sdec11Var0),
    Var1(sdec11Var1),
    Var2(sdec11Var2),
}
impl sdec11 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = sdec11Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = sdec11Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = sdec11Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1234:1"]
#[derive(Clone, Debug)]
pub struct sdec5Var0 {
    sdec6: sdec6,
}
impl sdec5Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sdec6 } = self;
        sdec6.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0505() != (0u64 as i64) as u8 {
                return None;
            }
            let sdec6 = if let Some((len, table)) = sdec6::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sdec6), (), block_len))
        };
        let ((mut sdec6), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sdec6 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1232:1"]
#[derive(Clone, Debug)]
pub struct sdec5Var1 {
    sdec6: sdec6,
}
impl sdec5Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sdec6 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r5),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        sdec6.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0505() != (1u64 as i64) as u8 {
                return None;
            }
            let sdec6 = if let Some((len, table)) = sdec6::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sdec6), (), block_len))
        };
        let ((mut sdec6), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sdec6 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1233:1"]
#[derive(Clone, Debug)]
pub struct sdec5Var2 {}
impl sdec5Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0505() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0615() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table sdec5"]
#[derive(Clone, Debug)]
pub enum sdec5 {
    Var0(sdec5Var0),
    Var1(sdec5Var1),
    Var2(sdec5Var2),
}
impl sdec5 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = sdec5Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = sdec5Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = sdec5Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3823:1"]
#[derive(Clone, Debug)]
pub struct thYBITVar0 {}
impl thYBITVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("t")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rm0003 = token_parser.Rm0003();
            if token_parser.thc0404() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rm0003), block_len))
        };
        let ((), (Rm0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3822:1"]
#[derive(Clone, Debug)]
pub struct thYBITVar1 {}
impl thYBITVar1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rm0003 = token_parser.Rm0003();
            if token_parser.thc0404() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rm0003), block_len))
        };
        let ((), (Rm0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table thYBIT"]
#[derive(Clone, Debug)]
pub enum thYBIT {
    Var0(thYBITVar0),
    Var1(thYBITVar1),
}
impl thYBIT {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thYBITVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thYBITVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:703:1"]
#[derive(Clone, Debug)]
pub struct thrlist13Var0 {
    thrlist14: thrlist14,
}
impl thrlist13Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist14 } = self;
        thrlist14.display_extend(display, context);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0202() != (1u64 as i64) as u8 {
                return None;
            }
            let thrlist14 = if let Some((len, table)) = thrlist14::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0315() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((thrlist14), (), block_len))
        };
        let ((mut thrlist14), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist14 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:705:1"]
#[derive(Clone, Debug)]
pub struct thrlist13Var1 {
    thrlist14: thrlist14,
}
impl thrlist13Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist14 } = self;
        thrlist14.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0202() != (0u64 as i64) as u8 {
                return None;
            }
            let thrlist14 = if let Some((len, table)) = thrlist14::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thrlist14), (), block_len))
        };
        let ((mut thrlist14), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist14 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:704:1"]
#[derive(Clone, Debug)]
pub struct thrlist13Var2 {
    thrlist14: thrlist14,
}
impl thrlist13Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist14 } = self;
        thrlist14.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r2),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0202() != (1u64 as i64) as u8 {
                return None;
            }
            let thrlist14 = if let Some((len, table)) = thrlist14::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thrlist14), (), block_len))
        };
        let ((mut thrlist14), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist14 }))
    }
}
#[doc = "Table thrlist13"]
#[derive(Clone, Debug)]
pub enum thrlist13 {
    Var0(thrlist13Var0),
    Var1(thrlist13Var1),
    Var2(thrlist13Var2),
}
impl thrlist13 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thrlist13Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thrlist13Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = thrlist13Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1246:1"]
#[derive(Clone, Debug)]
pub struct sdec1Var0 {
    sdec2: sdec2,
}
impl sdec1Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sdec2 } = self;
        sdec2.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0101() != (0u64 as i64) as u8 {
                return None;
            }
            let sdec2 = if let Some((len, table)) = sdec2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sdec2), (), block_len))
        };
        let ((mut sdec2), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sdec2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1244:1"]
#[derive(Clone, Debug)]
pub struct sdec1Var1 {
    sdec2: sdec2,
}
impl sdec1Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sdec2 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r1),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        sdec2.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0101() != (1u64 as i64) as u8 {
                return None;
            }
            let sdec2 = if let Some((len, table)) = sdec2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sdec2), (), block_len))
        };
        let ((mut sdec2), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sdec2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1245:1"]
#[derive(Clone, Debug)]
pub struct sdec1Var2 {}
impl sdec1Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0101() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0215() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table sdec1"]
#[derive(Clone, Debug)]
pub enum sdec1 {
    Var0(sdec1Var0),
    Var1(sdec1Var1),
    Var2(sdec1Var2),
}
impl sdec1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = sdec1Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = sdec1Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = sdec1Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:607:1"]
#[derive(Clone, Debug)]
pub struct Rn_exclaim_WBVar0 {}
impl Rn_exclaim_WBVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0810 = token_parser.Rn0810();
            if token_parser.thc0810() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0000() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rn0810), block_len))
        };
        let ((), (Rn0810), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:608:1"]
#[derive(Clone, Debug)]
pub struct Rn_exclaim_WBVar1 {}
impl Rn_exclaim_WBVar1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0810 = token_parser.Rn0810();
            if token_parser.thc0810() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0101() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rn0810), block_len))
        };
        let ((), (Rn0810), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:609:1"]
#[derive(Clone, Debug)]
pub struct Rn_exclaim_WBVar2 {}
impl Rn_exclaim_WBVar2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0810 = token_parser.Rn0810();
            if token_parser.thc0810() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0202() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rn0810), block_len))
        };
        let ((), (Rn0810), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:610:1"]
#[derive(Clone, Debug)]
pub struct Rn_exclaim_WBVar3 {}
impl Rn_exclaim_WBVar3 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0810 = token_parser.Rn0810();
            if token_parser.thc0810() != (3u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0303() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rn0810), block_len))
        };
        let ((), (Rn0810), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:611:1"]
#[derive(Clone, Debug)]
pub struct Rn_exclaim_WBVar4 {}
impl Rn_exclaim_WBVar4 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0810 = token_parser.Rn0810();
            if token_parser.thc0810() != (4u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0404() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rn0810), block_len))
        };
        let ((), (Rn0810), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:612:1"]
#[derive(Clone, Debug)]
pub struct Rn_exclaim_WBVar5 {}
impl Rn_exclaim_WBVar5 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0810 = token_parser.Rn0810();
            if token_parser.thc0810() != (5u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0505() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rn0810), block_len))
        };
        let ((), (Rn0810), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:613:1"]
#[derive(Clone, Debug)]
pub struct Rn_exclaim_WBVar6 {}
impl Rn_exclaim_WBVar6 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0810 = token_parser.Rn0810();
            if token_parser.thc0810() != (6u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0606() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rn0810), block_len))
        };
        let ((), (Rn0810), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:614:1"]
#[derive(Clone, Debug)]
pub struct Rn_exclaim_WBVar7 {}
impl Rn_exclaim_WBVar7 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0810 = token_parser.Rn0810();
            if token_parser.thc0810() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0707() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rn0810), block_len))
        };
        let ((), (Rn0810), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:615:1"]
#[derive(Clone, Debug)]
pub struct Rn_exclaim_WBVar8 {}
impl Rn_exclaim_WBVar8 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0810 = token_parser.Rn0810();
            let thc0810 = token_parser.thc0810();
            *context = context_current;
            Some(((), (Rn0810, thc0810), block_len))
        };
        let ((), (Rn0810, thc0810), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table Rn_exclaim_WB"]
#[derive(Clone, Debug)]
pub enum Rn_exclaim_WB {
    Var0(Rn_exclaim_WBVar0),
    Var1(Rn_exclaim_WBVar1),
    Var2(Rn_exclaim_WBVar2),
    Var3(Rn_exclaim_WBVar3),
    Var4(Rn_exclaim_WBVar4),
    Var5(Rn_exclaim_WBVar5),
    Var6(Rn_exclaim_WBVar6),
    Var7(Rn_exclaim_WBVar7),
    Var8(Rn_exclaim_WBVar8),
}
impl Rn_exclaim_WB {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
            Self::Var3(x) => x.display_extend(display, context),
            Self::Var4(x) => x.display_extend(display, context),
            Self::Var5(x) => x.display_extend(display, context),
            Self::Var6(x) => x.display_extend(display, context),
            Self::Var7(x) => x.display_extend(display, context),
            Self::Var8(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = Rn_exclaim_WBVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = Rn_exclaim_WBVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = Rn_exclaim_WBVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        if let Some((inst_next, parsed)) = Rn_exclaim_WBVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var3(parsed)));
        }
        if let Some((inst_next, parsed)) = Rn_exclaim_WBVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var4(parsed)));
        }
        if let Some((inst_next, parsed)) = Rn_exclaim_WBVar5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var5(parsed)));
        }
        if let Some((inst_next, parsed)) = Rn_exclaim_WBVar6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var6(parsed)));
        }
        if let Some((inst_next, parsed)) = Rn_exclaim_WBVar7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var7(parsed)));
        }
        if let Some((inst_next, parsed)) = Rn_exclaim_WBVar8::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var8(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1178:1"]
#[derive(Clone, Debug)]
pub struct ldec7Var0 {
    ldec8: ldec8,
}
impl ldec7Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldec8 } = self;
        ldec8.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0707() != (0u64 as i64) as u8 {
                return None;
            }
            let ldec8 = if let Some((len, table)) = ldec8::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldec8), (), block_len))
        };
        let ((mut ldec8), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldec8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1176:1"]
#[derive(Clone, Debug)]
pub struct ldec7Var1 {
    ldec8: ldec8,
}
impl ldec7Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldec8 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r7),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        ldec8.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0707() != (1u64 as i64) as u8 {
                return None;
            }
            let ldec8 = if let Some((len, table)) = ldec8::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldec8), (), block_len))
        };
        let ((mut ldec8), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldec8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1177:1"]
#[derive(Clone, Debug)]
pub struct ldec7Var2 {}
impl ldec7Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0707() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0815() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table ldec7"]
#[derive(Clone, Debug)]
pub enum ldec7 {
    Var0(ldec7Var0),
    Var1(ldec7Var1),
    Var2(ldec7Var2),
}
impl ldec7 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = ldec7Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = ldec7Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = ldec7Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1249:1"]
#[derive(Clone, Debug)]
pub struct sdec0Var0 {
    sdec1: sdec1,
}
impl sdec0Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sdec1 } = self;
        sdec1.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0000() != (0u64 as i64) as u8 {
                return None;
            }
            let sdec1 = if let Some((len, table)) = sdec1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sdec1), (), block_len))
        };
        let ((mut sdec1), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sdec1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1247:1"]
#[derive(Clone, Debug)]
pub struct sdec0Var1 {
    sdec1: sdec1,
}
impl sdec0Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sdec1 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r0),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        sdec1.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0000() != (1u64 as i64) as u8 {
                return None;
            }
            let sdec1 = if let Some((len, table)) = sdec1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sdec1), (), block_len))
        };
        let ((mut sdec1), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sdec1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1248:1"]
#[derive(Clone, Debug)]
pub struct sdec0Var2 {}
impl sdec0Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r0)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0000() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0115() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table sdec0"]
#[derive(Clone, Debug)]
pub enum sdec0 {
    Var0(sdec0Var0),
    Var1(sdec0Var1),
    Var2(sdec0Var2),
}
impl sdec0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = sdec0Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = sdec0Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = sdec0Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:715:1"]
#[derive(Clone, Debug)]
pub struct thrlist9Var0 {
    thrlist10: thrlist10,
}
impl thrlist9Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist10 } = self;
        thrlist10.display_extend(display, context);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0606() != (1u64 as i64) as u8 {
                return None;
            }
            let thrlist10 = if let Some((len, table)) = thrlist10::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc0715() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((thrlist10), (), block_len))
        };
        let ((mut thrlist10), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist10 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:717:1"]
#[derive(Clone, Debug)]
pub struct thrlist9Var1 {
    thrlist10: thrlist10,
}
impl thrlist9Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist10 } = self;
        thrlist10.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0606() != (0u64 as i64) as u8 {
                return None;
            }
            let thrlist10 = if let Some((len, table)) = thrlist10::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thrlist10), (), block_len))
        };
        let ((mut thrlist10), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist10 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:716:1"]
#[derive(Clone, Debug)]
pub struct thrlist9Var2 {
    thrlist10: thrlist10,
}
impl thrlist9Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thrlist10 } = self;
        thrlist10.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r6),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0606() != (1u64 as i64) as u8 {
                return None;
            }
            let thrlist10 = if let Some((len, table)) = thrlist10::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thrlist10), (), block_len))
        };
        let ((mut thrlist10), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thrlist10 }))
    }
}
#[doc = "Table thrlist9"]
#[derive(Clone, Debug)]
pub enum thrlist9 {
    Var0(thrlist9Var0),
    Var1(thrlist9Var1),
    Var2(thrlist9Var2),
}
impl thrlist9 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thrlist9Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thrlist9Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = thrlist9Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1133:1"]
#[derive(Clone, Debug)]
pub struct sinc5Var0 {
    sinc6: sinc6,
}
impl sinc5Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sinc6 } = self;
        sinc6.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1010() != (0u64 as i64) as u8 {
                return None;
            }
            let sinc6 = if let Some((len, table)) = sinc6::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sinc6), (), block_len))
        };
        let ((mut sinc6), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sinc6 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1131:1"]
#[derive(Clone, Debug)]
pub struct sinc5Var1 {
    sinc6: sinc6,
}
impl sinc5Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sinc6 } = self;
        sinc6.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::r10),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1010() != (1u64 as i64) as u8 {
                return None;
            }
            let sinc6 = if let Some((len, table)) = sinc6::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sinc6), (), block_len))
        };
        let ((mut sinc6), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sinc6 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1132:1"]
#[derive(Clone, Debug)]
pub struct sinc5Var2 {}
impl sinc5Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r10)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1010() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0009() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table sinc5"]
#[derive(Clone, Debug)]
pub enum sinc5 {
    Var0(sinc5Var0),
    Var1(sinc5Var1),
    Var2(sinc5Var2),
}
impl sinc5 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = sinc5Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = sinc5Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = sinc5Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1619:1"]
#[derive(Clone, Debug)]
pub struct instructionVar0 {
    immed12_4: immed12_4,
}
impl instructionVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { immed12_4 } = self;
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("udf"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        immed12_4.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cond() != (14u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2027() != (127u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0407() != (15u64 as i64) as u8 {
                return None;
            }
            let immed12_4 = if let Some((len, table)) = immed12_4::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((immed12_4), (), block_len))
        };
        let ((mut immed12_4), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        immed12_4.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { immed12_4 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1566:1"]
#[derive(Clone, Debug)]
pub struct instructionVar1 {
    immed12_4: immed12_4,
}
impl instructionVar1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { immed12_4 } = self;
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("hvc"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        immed12_4.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cond() != (14u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2027() != (20u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0407() != (7u64 as i64) as u8 {
                return None;
            }
            let immed12_4 = if let Some((len, table)) = immed12_4::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((immed12_4), (), block_len))
        };
        let ((mut immed12_4), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        immed12_4.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { immed12_4 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1561:1"]
#[derive(Clone, Debug)]
pub struct instructionVar2 {
    immed12_4: immed12_4,
}
impl instructionVar2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { immed12_4 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("bkpt"),
            DisplayElement::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        immed12_4.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cond() != (14u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2027() != (18u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0407() != (7u64 as i64) as u8 {
                return None;
            }
            let immed12_4 = if let Some((len, table)) = immed12_4::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((immed12_4), (), block_len))
        };
        let ((mut immed12_4), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        immed12_4.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { immed12_4 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1556:1"]
#[derive(Clone, Debug)]
pub struct instructionVar3 {
    immed12_4: immed12_4,
}
impl instructionVar3 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { immed12_4 } = self;
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("hlt"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        immed12_4.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cond() != (14u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2027() != (16u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0407() != (7u64 as i64) as u8 {
                return None;
            }
            let immed12_4 = if let Some((len, table)) = immed12_4::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((immed12_4), (), block_len))
        };
        let ((mut immed12_4), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        immed12_4.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { immed12_4 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2260:1"]
#[derive(Clone, Debug)]
pub struct instructionVar4 {
    COND: COND,
    Addr24: Addr24,
}
impl instructionVar4 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, Addr24 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bl")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        Addr24.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2527() != (5u64 as i64) as u8 {
                return None;
            }
            if token_parser.L24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.immed24() != (16777215u64 as i64) as u32 {
                return None;
            }
            let Addr24 = if let Some((len, table)) = Addr24::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((Addr24, COND), (), block_len))
        };
        let ((mut Addr24, mut COND), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        Addr24.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, Addr24 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1582:1"]
#[derive(Clone, Debug)]
pub struct instructionVar5 {
    COND: COND,
    immed4: u8,
}
impl instructionVar5 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, immed4 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("smc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Unsigned(true, u64::try_from(*immed4).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let immed4 = token_parser.immed4();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2027() != (22u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0407() != (7u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((COND), (immed4), block_len))
        };
        let ((mut COND), (immed4), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, immed4 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1660:1"]
#[derive(Clone, Debug)]
pub struct instructionVar6 {
    addrmode2: addrmode2,
}
impl instructionVar6 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { addrmode2 } = self;
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("pld"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        addrmode2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cond() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2424() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2022() != (5u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1215() != (15u64 as i64) as u8 {
                return None;
            }
            let mut sub_pattern_c58 = |token, context: &mut T| {
                let mut block_len = 0 as u32;
                let mut context_current = context.clone();
                let mut token_current = token;
                let mut block_0 = |tokens, context: &mut T| {
                    let token_parser = TokenParser32::new(tokens)?;
                    block_len = 4u64 as u32;
                    if token_parser.I25() == (0u64 as i64) as u8 {
                        return Some(((), (), u32::try_from(0u64).unwrap()));
                    }
                    let mut sub_pattern_c67 = |token, context: &mut T| {
                        let mut block_len = 0 as u32;
                        let mut context_current = context.clone();
                        let mut token_current = token;
                        let mut block_0 = |tokens, context: &mut T| {
                            let mut block_len = 0 as u32;
                            let mut context_current = context.clone();
                            let token_parser = TokenParser32::new(tokens)?;
                            block_len = 4u64 as u32;
                            if token_parser.I25() != (1u64 as i64) as u8 {
                                return None;
                            }
                            if token_parser.c0404() != (0u64 as i64) as u8 {
                                return None;
                            }
                            *context = context_current;
                            Some(((), (), block_len))
                        };
                        let ((), (), block_len) =
                            block_0(token_current, &mut context_current)?;
                        token_current = &token_current
                            [usize::try_from(block_len).unwrap()..];
                        *context = context_current;
                        Some(((), (), block_len))
                    };
                    let mut context_current = context.clone();
                    if let Some(((), (), sub_pattern_len)) =
                        sub_pattern_c67(tokens, &mut context_current)
                    {
                        *context = context_current;
                        return Some(((), (), sub_pattern_len));
                    }
                    None
                };
                let ((), (), block_len) =
                    block_0(token_current, &mut context_current)?;
                token_current =
                    &token_current[usize::try_from(block_len).unwrap()..];
                *context = context_current;
                Some(((), (), block_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c58(tokens, &mut context_current)?;
            block_len = block_len.max(sub_len);
            let addrmode2 = if let Some((len, table)) = addrmode2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((addrmode2), (), block_len))
        };
        let ((mut addrmode2), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        addrmode2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { addrmode2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3547:1"]
#[derive(Clone, Debug)]
pub struct instructionVar7 {
    rm: rm,
}
impl instructionVar7 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rm } = self;
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("mov"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::lr),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rm.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cond() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2527() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.S20() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2124() != (13u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1619() != (0u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.Rm2() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.sftimm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0406() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.Rd() != (14u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((rm), (), block_len))
        };
        let ((mut rm), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        rm.disassembly(&mut context_current, inst_start, inst_next, global_set);
        let context_tmp = &mut context_current;
        let mut LRset = context_tmp.read_LRset();
        LRset = u8::try_from((1u64 as i64)).unwrap();
        global_set.set_LRset(
            Some(u32::try_from(inst_next).unwrap()),
            u8::try_into(LRset).unwrap(),
        );
        context_tmp.write_LRset(LRset);
        *context = context_current;
        Some((inst_len, Self { rm }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1666:1"]
#[derive(Clone, Debug)]
pub struct instructionVar8 {
    addrmode2: addrmode2,
}
impl instructionVar8 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { addrmode2 } = self;
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("pld"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        addrmode2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cond() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2424() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2022() != (5u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1619() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1215() != (15u64 as i64) as u8 {
                return None;
            }
            let mut sub_pattern_c70 = |token, context: &mut T| {
                let mut block_len = 0 as u32;
                let mut context_current = context.clone();
                let mut token_current = token;
                let mut block_0 = |tokens, context: &mut T| {
                    let token_parser = TokenParser32::new(tokens)?;
                    block_len = 4u64 as u32;
                    if token_parser.I25() == (0u64 as i64) as u8 {
                        return Some(((), (), u32::try_from(0u64).unwrap()));
                    }
                    let mut sub_pattern_c79 = |token, context: &mut T| {
                        let mut block_len = 0 as u32;
                        let mut context_current = context.clone();
                        let mut token_current = token;
                        let mut block_0 = |tokens, context: &mut T| {
                            let mut block_len = 0 as u32;
                            let mut context_current = context.clone();
                            let token_parser = TokenParser32::new(tokens)?;
                            block_len = 4u64 as u32;
                            if token_parser.I25() != (1u64 as i64) as u8 {
                                return None;
                            }
                            if token_parser.c0404() != (0u64 as i64) as u8 {
                                return None;
                            }
                            *context = context_current;
                            Some(((), (), block_len))
                        };
                        let ((), (), block_len) =
                            block_0(token_current, &mut context_current)?;
                        token_current = &token_current
                            [usize::try_from(block_len).unwrap()..];
                        *context = context_current;
                        Some(((), (), block_len))
                    };
                    let mut context_current = context.clone();
                    if let Some(((), (), sub_pattern_len)) =
                        sub_pattern_c79(tokens, &mut context_current)
                    {
                        *context = context_current;
                        return Some(((), (), sub_pattern_len));
                    }
                    None
                };
                let ((), (), block_len) =
                    block_0(token_current, &mut context_current)?;
                token_current =
                    &token_current[usize::try_from(block_len).unwrap()..];
                *context = context_current;
                Some(((), (), block_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c70(tokens, &mut context_current)?;
            block_len = block_len.max(sub_len);
            let addrmode2 = if let Some((len, table)) = addrmode2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((addrmode2), (), block_len))
        };
        let ((mut addrmode2), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        addrmode2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { addrmode2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2685:1"]
#[derive(Clone, Debug)]
pub struct instructionVar9 {
    addrmode5: addrmode5,
    CRd: u8,
    cpn: u8,
}
impl instructionVar9 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            addrmode5,
            CRd,
            cpn,
        } = self;
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("ldc2l"),
            DisplayElement::Literal(" "),
            meaning_94047773010576(usize::try_from(*cpn).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047768585360(usize::try_from(*CRd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        addrmode5.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let cpn = token_parser.cpn();
            let CRd = token_parser.CRd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cond() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2527() != (6u64 as i64) as u8 {
                return None;
            }
            let addrmode5 = if let Some((len, table)) = addrmode5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.N22() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((addrmode5), (cpn, CRd), block_len))
        };
        let ((mut addrmode5), (cpn, CRd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        addrmode5.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                addrmode5,
                CRd,
                cpn,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2679:1"]
#[derive(Clone, Debug)]
pub struct instructionVar10 {
    addrmode5: addrmode5,
    cpn: u8,
    CRd: u8,
}
impl instructionVar10 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            addrmode5,
            cpn,
            CRd,
        } = self;
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("ldc2"),
            DisplayElement::Literal(" "),
            meaning_94047773010576(usize::try_from(*cpn).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047768585360(usize::try_from(*CRd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        addrmode5.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let cpn = token_parser.cpn();
            let CRd = token_parser.CRd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cond() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2527() != (6u64 as i64) as u8 {
                return None;
            }
            let addrmode5 = if let Some((len, table)) = addrmode5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.N22() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((addrmode5), (CRd, cpn), block_len))
        };
        let ((mut addrmode5), (CRd, cpn), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        addrmode5.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                addrmode5,
                cpn,
                CRd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1865:1"]
#[derive(Clone, Debug)]
pub struct instructionVar11 {
    addrmode5: addrmode5,
    cpn: u8,
    CRd: u8,
}
impl instructionVar11 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            addrmode5,
            cpn,
            CRd,
        } = self;
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("stc2l"),
            DisplayElement::Literal(" "),
            meaning_94047773010576(usize::try_from(*cpn).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047768585360(usize::try_from(*CRd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        addrmode5.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let cpn = token_parser.cpn();
            let CRd = token_parser.CRd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cond() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2527() != (6u64 as i64) as u8 {
                return None;
            }
            let addrmode5 = if let Some((len, table)) = addrmode5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.N22() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((addrmode5), (CRd, cpn), block_len))
        };
        let ((mut addrmode5), (CRd, cpn), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        addrmode5.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                addrmode5,
                cpn,
                CRd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1859:1"]
#[derive(Clone, Debug)]
pub struct instructionVar12 {
    addrmode5: addrmode5,
    cpn: u8,
    CRd: u8,
}
impl instructionVar12 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            addrmode5,
            cpn,
            CRd,
        } = self;
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("stc2"),
            DisplayElement::Literal(" "),
            meaning_94047773010576(usize::try_from(*cpn).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047768585360(usize::try_from(*CRd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        addrmode5.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let cpn = token_parser.cpn();
            let CRd = token_parser.CRd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cond() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2527() != (6u64 as i64) as u8 {
                return None;
            }
            let addrmode5 = if let Some((len, table)) = addrmode5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.N22() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((addrmode5), (CRd, cpn), block_len))
        };
        let ((mut addrmode5), (CRd, cpn), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        addrmode5.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                addrmode5,
                cpn,
                CRd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4158:1"]
#[derive(Clone, Debug)]
pub struct instructionVar13 {
    spsrmask: spsrmask,
    COND: COND,
    shift1: shift1,
}
impl instructionVar13 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            spsrmask,
            COND,
            shift1,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("msr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        spsrmask.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift1.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2027() != (54u64 as i64) as u8 {
                return None;
            }
            let spsrmask = if let Some((len, table)) = spsrmask::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c1215() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift1 = if let Some((len, table)) = shift1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, spsrmask, shift1), (), block_len))
        };
        let ((mut COND, mut spsrmask, mut shift1), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        spsrmask.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift1.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                spsrmask,
                COND,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4136:1"]
#[derive(Clone, Debug)]
pub struct instructionVar14 {
    COND: COND,
    cpsrmask: cpsrmask,
    shift1: shift1,
}
impl instructionVar14 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            cpsrmask,
            shift1,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("msr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        cpsrmask.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift1.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2027() != (50u64 as i64) as u8 {
                return None;
            }
            let cpsrmask = if let Some((len, table)) = cpsrmask::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c1215() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift1 = if let Some((len, table)) = shift1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((cpsrmask, shift1, COND), (), block_len))
        };
        let ((mut cpsrmask, mut shift1, mut COND), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        cpsrmask.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift1.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                cpsrmask,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5831:1"]
#[derive(Clone, Debug)]
pub struct instructionVar15 {
    shift3: shift3,
    rn: rn,
    COND: COND,
}
impl instructionVar15 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { shift3, rn, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("tst")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2024() != (17u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c1215() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift3 = if let Some((len, table)) = shift3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((shift3, COND, rn), (), block_len))
        };
        let ((mut shift3, mut COND, mut rn), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        shift3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { shift3, rn, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5820:1"]
#[derive(Clone, Debug)]
pub struct instructionVar16 {
    shift2: shift2,
    rn: rn,
    COND: COND,
}
impl instructionVar16 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { shift2, rn, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("tst")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2024() != (17u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c1215() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift2 = if let Some((len, table)) = shift2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, COND, shift2), (), block_len))
        };
        let ((mut rn, mut COND, mut shift2), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        shift2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { shift2, rn, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5809:1"]
#[derive(Clone, Debug)]
pub struct instructionVar17 {
    shift1: shift1,
    COND: COND,
    rn: rn,
}
impl instructionVar17 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { shift1, COND, rn } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("tst")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift1.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2024() != (17u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c1215() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift1 = if let Some((len, table)) = shift1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((shift1, COND, rn), (), block_len))
        };
        let ((mut shift1, mut COND, mut rn), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        shift1.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        *context = context_current;
        Some((inst_len, Self { shift1, COND, rn }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5797:1"]
#[derive(Clone, Debug)]
pub struct instructionVar18 {
    COND: COND,
    shift3: shift3,
    rn: rn,
}
impl instructionVar18 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, shift3, rn } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("teq")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("p"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2024() != (19u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c1215() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift3 = if let Some((len, table)) = shift3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, shift3, COND), (), block_len))
        };
        let ((mut rn, mut shift3, mut COND), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        *context = context_current;
        Some((inst_len, Self { COND, shift3, rn }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5786:1"]
#[derive(Clone, Debug)]
pub struct instructionVar19 {
    shift2: shift2,
    COND: COND,
    rn: rn,
}
impl instructionVar19 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { shift2, COND, rn } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("teq")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("p"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2024() != (19u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c1215() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift2 = if let Some((len, table)) = shift2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, shift2, rn), (), block_len))
        };
        let ((mut COND, mut shift2, mut rn), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        shift2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        *context = context_current;
        Some((inst_len, Self { shift2, COND, rn }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5775:1"]
#[derive(Clone, Debug)]
pub struct instructionVar20 {
    rn: rn,
    COND: COND,
    shift1: shift1,
}
impl instructionVar20 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, COND, shift1 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("teq")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("p"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift1.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2024() != (19u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c1215() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift1 = if let Some((len, table)) = shift1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, rn, shift1), (), block_len))
        };
        let ((mut COND, mut rn, mut shift1), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift1.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { rn, COND, shift1 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5764:1"]
#[derive(Clone, Debug)]
pub struct instructionVar21 {
    COND: COND,
    rn: rn,
    shift3: shift3,
}
impl instructionVar21 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, rn, shift3 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("teq")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2024() != (19u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c1215() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift3 = if let Some((len, table)) = shift3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, shift3, COND), (), block_len))
        };
        let ((mut rn, mut shift3, mut COND), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        shift3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, rn, shift3 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5753:1"]
#[derive(Clone, Debug)]
pub struct instructionVar22 {
    shift2: shift2,
    COND: COND,
    rn: rn,
}
impl instructionVar22 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { shift2, COND, rn } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("teq")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2024() != (19u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c1215() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift2 = if let Some((len, table)) = shift2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, COND, shift2), (), block_len))
        };
        let ((mut rn, mut COND, mut shift2), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        shift2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        *context = context_current;
        Some((inst_len, Self { shift2, COND, rn }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5742:1"]
#[derive(Clone, Debug)]
pub struct instructionVar23 {
    shift1: shift1,
    rn: rn,
    COND: COND,
}
impl instructionVar23 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { shift1, rn, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("teq")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift1.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2024() != (19u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c1215() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift1 = if let Some((len, table)) = shift1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((shift1, rn, COND), (), block_len))
        };
        let ((mut shift1, mut rn, mut COND), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        shift1.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { shift1, rn, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2531:1"]
#[derive(Clone, Debug)]
pub struct instructionVar24 {
    COND: COND,
    rn: rn,
    shift3: shift3,
}
impl instructionVar24 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, rn, shift3 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cmp")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2024() != (21u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c1215() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift3 = if let Some((len, table)) = shift3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, rn, shift3), (), block_len))
        };
        let ((mut COND, mut rn, mut shift3), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        shift3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, rn, shift3 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2520:1"]
#[derive(Clone, Debug)]
pub struct instructionVar25 {
    COND: COND,
    shift2: shift2,
    rn: rn,
}
impl instructionVar25 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, shift2, rn } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cmp")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2024() != (21u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c1215() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift2 = if let Some((len, table)) = shift2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, shift2, COND), (), block_len))
        };
        let ((mut rn, mut shift2, mut COND), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        *context = context_current;
        Some((inst_len, Self { COND, shift2, rn }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2509:1"]
#[derive(Clone, Debug)]
pub struct instructionVar26 {
    shift1: shift1,
    COND: COND,
    rn: rn,
}
impl instructionVar26 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { shift1, COND, rn } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cmp")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift1.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2024() != (21u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c1215() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift1 = if let Some((len, table)) = shift1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((shift1, COND, rn), (), block_len))
        };
        let ((mut shift1, mut COND, mut rn), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        shift1.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        *context = context_current;
        Some((inst_len, Self { shift1, COND, rn }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2498:1"]
#[derive(Clone, Debug)]
pub struct instructionVar27 {
    COND: COND,
    rn: rn,
    shift3: shift3,
}
impl instructionVar27 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, rn, shift3 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cmn")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2024() != (23u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c1215() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift3 = if let Some((len, table)) = shift3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, rn, shift3), (), block_len))
        };
        let ((mut COND, mut rn, mut shift3), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        shift3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, rn, shift3 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2487:1"]
#[derive(Clone, Debug)]
pub struct instructionVar28 {
    COND: COND,
    rn: rn,
    shift2: shift2,
}
impl instructionVar28 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, rn, shift2 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cmn")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2024() != (23u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c1215() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift2 = if let Some((len, table)) = shift2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, rn, shift2), (), block_len))
        };
        let ((mut COND, mut rn, mut shift2), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        shift2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, rn, shift2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2476:1"]
#[derive(Clone, Debug)]
pub struct instructionVar29 {
    rn: rn,
    shift1: shift1,
    COND: COND,
}
impl instructionVar29 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, shift1, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cmn")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift1.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2024() != (23u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c1215() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift1 = if let Some((len, table)) = shift1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((shift1, rn, COND), (), block_len))
        };
        let ((mut shift1, mut rn, mut COND), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        shift1.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { rn, shift1, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5637:1"]
#[derive(Clone, Debug)]
pub struct instructionVar30 {
    SBIT_CZNO: SBIT_CZNO,
    COND: COND,
    shift3: shift3,
    rn: rn,
}
impl instructionVar30 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            SBIT_CZNO,
            COND,
            shift3,
            rn,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sub")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (2u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift3 = if let Some((len, table)) = shift3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((shift3, COND, SBIT_CZNO, rn), (), block_len))
        };
        let ((mut shift3, mut COND, mut SBIT_CZNO, mut rn), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        *context = context_current;
        Some((
            inst_len,
            Self {
                SBIT_CZNO,
                COND,
                shift3,
                rn,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5622:1"]
#[derive(Clone, Debug)]
pub struct instructionVar31 {
    SBIT_CZNO: SBIT_CZNO,
    rn: rn,
    COND: COND,
    shift2: shift2,
}
impl instructionVar31 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            SBIT_CZNO,
            rn,
            COND,
            shift2,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sub")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (2u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift2 = if let Some((len, table)) = shift2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((shift2, COND, rn, SBIT_CZNO), (), block_len))
        };
        let ((mut shift2, mut COND, mut rn, mut SBIT_CZNO), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                SBIT_CZNO,
                rn,
                COND,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5593:1"]
#[derive(Clone, Debug)]
pub struct instructionVar32 {
    COND: COND,
    SBIT_CZNO: SBIT_CZNO,
    shift1: shift1,
    rn: rn,
}
impl instructionVar32 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            SBIT_CZNO,
            shift1,
            rn,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sub")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift1.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (2u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift1 = if let Some((len, table)) = shift1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((SBIT_CZNO, shift1, COND, rn), (), block_len))
        };
        let ((mut SBIT_CZNO, mut shift1, mut COND, mut rn), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift1.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                SBIT_CZNO,
                shift1,
                rn,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4858:1"]
#[derive(Clone, Debug)]
pub struct instructionVar33 {
    shift3: shift3,
    SBIT_CZNO: SBIT_CZNO,
    COND: COND,
    rn: rn,
}
impl instructionVar33 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            shift3,
            SBIT_CZNO,
            COND,
            rn,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sbc")];
        display.extend_from_slice(&extend);
        SBIT_CZNO.display_extend(display, context);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (6u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift3 = if let Some((len, table)) = shift3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, SBIT_CZNO, rn, shift3), (), block_len))
        };
        let ((mut COND, mut SBIT_CZNO, mut rn, mut shift3), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        shift3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        *context = context_current;
        Some((
            inst_len,
            Self {
                shift3,
                SBIT_CZNO,
                COND,
                rn,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4845:1"]
#[derive(Clone, Debug)]
pub struct instructionVar34 {
    rn: rn,
    COND: COND,
    SBIT_CZNO: SBIT_CZNO,
    shift2: shift2,
}
impl instructionVar34 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            rn,
            COND,
            SBIT_CZNO,
            shift2,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sbc")];
        display.extend_from_slice(&extend);
        SBIT_CZNO.display_extend(display, context);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (6u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift2 = if let Some((len, table)) = shift2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((SBIT_CZNO, rn, COND, shift2), (), block_len))
        };
        let ((mut SBIT_CZNO, mut rn, mut COND, mut shift2), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                rn,
                COND,
                SBIT_CZNO,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4832:1"]
#[derive(Clone, Debug)]
pub struct instructionVar35 {
    rn: rn,
    shift1: shift1,
    COND: COND,
    SBIT_CZNO: SBIT_CZNO,
}
impl instructionVar35 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            rn,
            shift1,
            COND,
            SBIT_CZNO,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sbc")];
        display.extend_from_slice(&extend);
        SBIT_CZNO.display_extend(display, context);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift1.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (6u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift1 = if let Some((len, table)) = shift1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((shift1, SBIT_CZNO, COND, rn), (), block_len))
        };
        let ((mut shift1, mut SBIT_CZNO, mut COND, mut rn), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        shift1.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                rn,
                shift1,
                COND,
                SBIT_CZNO,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4726:1"]
#[derive(Clone, Debug)]
pub struct instructionVar36 {
    shift3: shift3,
    rn: rn,
    COND: COND,
    SBIT_CZNO: SBIT_CZNO,
}
impl instructionVar36 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            shift3,
            rn,
            COND,
            SBIT_CZNO,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (7u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift3 = if let Some((len, table)) = shift3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((SBIT_CZNO, rn, COND, shift3), (), block_len))
        };
        let ((mut SBIT_CZNO, mut rn, mut COND, mut shift3), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        shift3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                shift3,
                rn,
                COND,
                SBIT_CZNO,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4713:1"]
#[derive(Clone, Debug)]
pub struct instructionVar37 {
    rn: rn,
    COND: COND,
    SBIT_CZNO: SBIT_CZNO,
    shift2: shift2,
}
impl instructionVar37 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            rn,
            COND,
            SBIT_CZNO,
            shift2,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (7u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift2 = if let Some((len, table)) = shift2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((SBIT_CZNO, rn, shift2, COND), (), block_len))
        };
        let ((mut SBIT_CZNO, mut rn, mut shift2, mut COND), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                rn,
                COND,
                SBIT_CZNO,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4700:1"]
#[derive(Clone, Debug)]
pub struct instructionVar38 {
    rn: rn,
    shift1: shift1,
    SBIT_CZNO: SBIT_CZNO,
    COND: COND,
}
impl instructionVar38 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            rn,
            shift1,
            SBIT_CZNO,
            COND,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift1.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (7u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift1 = if let Some((len, table)) = shift1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, SBIT_CZNO, shift1, rn), (), block_len))
        };
        let ((mut COND, mut SBIT_CZNO, mut shift1, mut rn), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        shift1.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                rn,
                shift1,
                SBIT_CZNO,
                COND,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4654:1"]
#[derive(Clone, Debug)]
pub struct instructionVar39 {
    rn: rn,
    SBIT_CZNO: SBIT_CZNO,
    shift3: shift3,
    COND: COND,
}
impl instructionVar39 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            rn,
            SBIT_CZNO,
            shift3,
            COND,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsb")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (3u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift3 = if let Some((len, table)) = shift3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, rn, SBIT_CZNO, shift3), (), block_len))
        };
        let ((mut COND, mut rn, mut SBIT_CZNO, mut shift3), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                rn,
                SBIT_CZNO,
                shift3,
                COND,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4641:1"]
#[derive(Clone, Debug)]
pub struct instructionVar40 {
    SBIT_CZNO: SBIT_CZNO,
    COND: COND,
    shift2: shift2,
    rn: rn,
}
impl instructionVar40 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            SBIT_CZNO,
            COND,
            shift2,
            rn,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsb")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (3u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift2 = if let Some((len, table)) = shift2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, shift2, rn, SBIT_CZNO), (), block_len))
        };
        let ((mut COND, mut shift2, mut rn, mut SBIT_CZNO), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        *context = context_current;
        Some((
            inst_len,
            Self {
                SBIT_CZNO,
                COND,
                shift2,
                rn,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4628:1"]
#[derive(Clone, Debug)]
pub struct instructionVar41 {
    shift1: shift1,
    rn: rn,
    COND: COND,
    SBIT_CZNO: SBIT_CZNO,
}
impl instructionVar41 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            shift1,
            rn,
            COND,
            SBIT_CZNO,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsb")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift1.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (3u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift1 = if let Some((len, table)) = shift1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((SBIT_CZNO, COND, rn, shift1), (), block_len))
        };
        let ((mut SBIT_CZNO, mut COND, mut rn, mut shift1), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        shift1.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                shift1,
                rn,
                COND,
                SBIT_CZNO,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4312:1"]
#[derive(Clone, Debug)]
pub struct instructionVar42 {
    rn: rn,
    shift3: shift3,
    COND: COND,
    SBIT_CZNO: SBIT_CZNO,
}
impl instructionVar42 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            rn,
            shift3,
            COND,
            SBIT_CZNO,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("orr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (12u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift3 = if let Some((len, table)) = shift3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((SBIT_CZNO, shift3, COND, rn), (), block_len))
        };
        let ((mut SBIT_CZNO, mut shift3, mut COND, mut rn), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        shift3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                rn,
                shift3,
                COND,
                SBIT_CZNO,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4299:1"]
#[derive(Clone, Debug)]
pub struct instructionVar43 {
    SBIT_CZNO: SBIT_CZNO,
    COND: COND,
    shift2: shift2,
    rn: rn,
}
impl instructionVar43 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            SBIT_CZNO,
            COND,
            shift2,
            rn,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("orr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (12u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift2 = if let Some((len, table)) = shift2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((SBIT_CZNO, shift2, COND, rn), (), block_len))
        };
        let ((mut SBIT_CZNO, mut shift2, mut COND, mut rn), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        *context = context_current;
        Some((
            inst_len,
            Self {
                SBIT_CZNO,
                COND,
                shift2,
                rn,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4286:1"]
#[derive(Clone, Debug)]
pub struct instructionVar44 {
    SBIT_CZNO: SBIT_CZNO,
    rn: rn,
    shift1: shift1,
    COND: COND,
}
impl instructionVar44 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            SBIT_CZNO,
            rn,
            shift1,
            COND,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("orr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift1.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (12u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift1 = if let Some((len, table)) = shift1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, SBIT_CZNO, rn, shift1), (), block_len))
        };
        let ((mut COND, mut SBIT_CZNO, mut rn, mut shift1), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        shift1.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                SBIT_CZNO,
                rn,
                shift1,
                COND,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2654:1"]
#[derive(Clone, Debug)]
pub struct instructionVar45 {
    SBIT_CZNO: SBIT_CZNO,
    rn: rn,
    COND: COND,
    shift3: shift3,
}
impl instructionVar45 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            SBIT_CZNO,
            rn,
            COND,
            shift3,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("eor")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (1u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift3 = if let Some((len, table)) = shift3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, COND, SBIT_CZNO, shift3), (), block_len))
        };
        let ((mut rn, mut COND, mut SBIT_CZNO, mut shift3), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                SBIT_CZNO,
                rn,
                COND,
                shift3,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2641:1"]
#[derive(Clone, Debug)]
pub struct instructionVar46 {
    rn: rn,
    COND: COND,
    SBIT_CZNO: SBIT_CZNO,
    shift2: shift2,
}
impl instructionVar46 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            rn,
            COND,
            SBIT_CZNO,
            shift2,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("eor")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (1u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift2 = if let Some((len, table)) = shift2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, rn, SBIT_CZNO, shift2), (), block_len))
        };
        let ((mut COND, mut rn, mut SBIT_CZNO, mut shift2), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                rn,
                COND,
                SBIT_CZNO,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2628:1"]
#[derive(Clone, Debug)]
pub struct instructionVar47 {
    SBIT_CZNO: SBIT_CZNO,
    COND: COND,
    rn: rn,
    shift1: shift1,
}
impl instructionVar47 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            SBIT_CZNO,
            COND,
            rn,
            shift1,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("eor")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift1.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (1u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift1 = if let Some((len, table)) = shift1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, SBIT_CZNO, shift1, COND), (), block_len))
        };
        let ((mut rn, mut SBIT_CZNO, mut shift1, mut COND), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        shift1.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                SBIT_CZNO,
                COND,
                rn,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2239:1"]
#[derive(Clone, Debug)]
pub struct instructionVar48 {
    SBIT_CZNO: SBIT_CZNO,
    shift3: shift3,
    COND: COND,
    rn: rn,
}
impl instructionVar48 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            SBIT_CZNO,
            shift3,
            COND,
            rn,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bic")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (14u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift3 = if let Some((len, table)) = shift3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((shift3, SBIT_CZNO, rn, COND), (), block_len))
        };
        let ((mut shift3, mut SBIT_CZNO, mut rn, mut COND), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        *context = context_current;
        Some((
            inst_len,
            Self {
                SBIT_CZNO,
                shift3,
                COND,
                rn,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2226:1"]
#[derive(Clone, Debug)]
pub struct instructionVar49 {
    COND: COND,
    shift2: shift2,
    rn: rn,
    SBIT_CZNO: SBIT_CZNO,
}
impl instructionVar49 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            shift2,
            rn,
            SBIT_CZNO,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bic")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (14u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift2 = if let Some((len, table)) = shift2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((shift2, rn, COND, SBIT_CZNO), (), block_len))
        };
        let ((mut shift2, mut rn, mut COND, mut SBIT_CZNO), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                shift2,
                rn,
                SBIT_CZNO,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2213:1"]
#[derive(Clone, Debug)]
pub struct instructionVar50 {
    rn: rn,
    SBIT_CZNO: SBIT_CZNO,
    COND: COND,
    shift1: shift1,
}
impl instructionVar50 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            rn,
            SBIT_CZNO,
            COND,
            shift1,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bic")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift1.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (14u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift1 = if let Some((len, table)) = shift1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, COND, SBIT_CZNO, shift1), (), block_len))
        };
        let ((mut rn, mut COND, mut SBIT_CZNO, mut shift1), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift1.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                rn,
                SBIT_CZNO,
                COND,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2130:1"]
#[derive(Clone, Debug)]
pub struct instructionVar51 {
    COND: COND,
    shift3: shift3,
    SBIT_CZNO: SBIT_CZNO,
    rn: rn,
}
impl instructionVar51 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            shift3,
            SBIT_CZNO,
            rn,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("and")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (0u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift3 = if let Some((len, table)) = shift3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((SBIT_CZNO, rn, COND, shift3), (), block_len))
        };
        let ((mut SBIT_CZNO, mut rn, mut COND, mut shift3), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                shift3,
                SBIT_CZNO,
                rn,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2117:1"]
#[derive(Clone, Debug)]
pub struct instructionVar52 {
    COND: COND,
    SBIT_CZNO: SBIT_CZNO,
    rn: rn,
    shift2: shift2,
}
impl instructionVar52 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            SBIT_CZNO,
            rn,
            shift2,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("and")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (0u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift2 = if let Some((len, table)) = shift2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((shift2, SBIT_CZNO, COND, rn), (), block_len))
        };
        let ((mut shift2, mut SBIT_CZNO, mut COND, mut rn), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        shift2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2104:1"]
#[derive(Clone, Debug)]
pub struct instructionVar53 {
    COND: COND,
    SBIT_CZNO: SBIT_CZNO,
    rn: rn,
    shift1: shift1,
}
impl instructionVar53 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            SBIT_CZNO,
            rn,
            shift1,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("and")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift1.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (0u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift1 = if let Some((len, table)) = shift1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, shift1, SBIT_CZNO, rn), (), block_len))
        };
        let ((mut COND, mut shift1, mut SBIT_CZNO, mut rn), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        shift1.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2058:1"]
#[derive(Clone, Debug)]
pub struct instructionVar54 {
    rn: rn,
    COND: COND,
    SBIT_CZNO: SBIT_CZNO,
    shift3: shift3,
}
impl instructionVar54 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            rn,
            COND,
            SBIT_CZNO,
            shift3,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("add")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (4u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift3 = if let Some((len, table)) = shift3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, COND, shift3, SBIT_CZNO), (), block_len))
        };
        let ((mut rn, mut COND, mut shift3, mut SBIT_CZNO), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                rn,
                COND,
                SBIT_CZNO,
                shift3,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2045:1"]
#[derive(Clone, Debug)]
pub struct instructionVar55 {
    COND: COND,
    shift2: shift2,
    rn: rn,
    SBIT_CZNO: SBIT_CZNO,
}
impl instructionVar55 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            shift2,
            rn,
            SBIT_CZNO,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("add")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (4u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift2 = if let Some((len, table)) = shift2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, rn, shift2, SBIT_CZNO), (), block_len))
        };
        let ((mut COND, mut rn, mut shift2, mut SBIT_CZNO), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                shift2,
                rn,
                SBIT_CZNO,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2032:1"]
#[derive(Clone, Debug)]
pub struct instructionVar56 {
    rn: rn,
    shift1: shift1,
    SBIT_CZNO: SBIT_CZNO,
    COND: COND,
}
impl instructionVar56 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            rn,
            shift1,
            SBIT_CZNO,
            COND,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("add")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift1.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (4u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift1 = if let Some((len, table)) = shift1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((shift1, rn, SBIT_CZNO, COND), (), block_len))
        };
        let ((mut shift1, mut rn, mut SBIT_CZNO, mut COND), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        shift1.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                rn,
                shift1,
                SBIT_CZNO,
                COND,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1955:1"]
#[derive(Clone, Debug)]
pub struct instructionVar57 {
    SBIT_CZNO: SBIT_CZNO,
    rn: rn,
    COND: COND,
    shift3: shift3,
}
impl instructionVar57 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            SBIT_CZNO,
            rn,
            COND,
            shift3,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("adc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (5u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift3 = if let Some((len, table)) = shift3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((SBIT_CZNO, COND, rn, shift3), (), block_len))
        };
        let ((mut SBIT_CZNO, mut COND, mut rn, mut shift3), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                SBIT_CZNO,
                rn,
                COND,
                shift3,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1942:1"]
#[derive(Clone, Debug)]
pub struct instructionVar58 {
    rn: rn,
    shift2: shift2,
    COND: COND,
    SBIT_CZNO: SBIT_CZNO,
}
impl instructionVar58 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            rn,
            shift2,
            COND,
            SBIT_CZNO,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("adc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (5u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift2 = if let Some((len, table)) = shift2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((SBIT_CZNO, COND, rn, shift2), (), block_len))
        };
        let ((mut SBIT_CZNO, mut COND, mut rn, mut shift2), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        shift2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                rn,
                shift2,
                COND,
                SBIT_CZNO,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1929:1"]
#[derive(Clone, Debug)]
pub struct instructionVar59 {
    rn: rn,
    COND: COND,
    shift1: shift1,
    SBIT_CZNO: SBIT_CZNO,
}
impl instructionVar59 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            rn,
            COND,
            shift1,
            SBIT_CZNO,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("adc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift1.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (5u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift1 = if let Some((len, table)) = shift1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((SBIT_CZNO, COND, rn, shift1), (), block_len))
        };
        let ((mut SBIT_CZNO, mut COND, mut rn, mut shift1), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift1.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                rn,
                COND,
                shift1,
                SBIT_CZNO,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5582:1"]
#[derive(Clone, Debug)]
pub struct instructionVar60 {
    shift3: shift3,
    rn: rn,
    COND: COND,
    SBIT_CZNO: SBIT_CZNO,
    Rd: u8,
}
impl instructionVar60 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            shift3,
            rn,
            COND,
            SBIT_CZNO,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sub")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (2u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift3 = if let Some((len, table)) = shift3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, COND, SBIT_CZNO, shift3), (Rd), block_len))
        };
        let ((mut rn, mut COND, mut SBIT_CZNO, mut shift3), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        shift3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                shift3,
                rn,
                COND,
                SBIT_CZNO,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5571:1"]
#[derive(Clone, Debug)]
pub struct instructionVar61 {
    rn: rn,
    COND: COND,
    shift2: shift2,
    SBIT_CZNO: SBIT_CZNO,
    Rd: u8,
}
impl instructionVar61 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            rn,
            COND,
            shift2,
            SBIT_CZNO,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sub")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (2u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift2 = if let Some((len, table)) = shift2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, SBIT_CZNO, COND, shift2), (Rd), block_len))
        };
        let ((mut rn, mut SBIT_CZNO, mut COND, mut shift2), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                rn,
                COND,
                shift2,
                SBIT_CZNO,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5560:1"]
#[derive(Clone, Debug)]
pub struct instructionVar62 {
    rn: rn,
    SBIT_CZNO: SBIT_CZNO,
    COND: COND,
    shift1: shift1,
    Rd: u8,
}
impl instructionVar62 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            rn,
            SBIT_CZNO,
            COND,
            shift1,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sub")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift1.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (2u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift1 = if let Some((len, table)) = shift1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((shift1, rn, COND, SBIT_CZNO), (Rd), block_len))
        };
        let ((mut shift1, mut rn, mut COND, mut SBIT_CZNO), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift1.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                rn,
                SBIT_CZNO,
                COND,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4821:1"]
#[derive(Clone, Debug)]
pub struct instructionVar63 {
    SBIT_CZNO: SBIT_CZNO,
    shift3: shift3,
    rn: rn,
    COND: COND,
    Rd: u8,
}
impl instructionVar63 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            SBIT_CZNO,
            shift3,
            rn,
            COND,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sbc")];
        display.extend_from_slice(&extend);
        SBIT_CZNO.display_extend(display, context);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (6u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift3 = if let Some((len, table)) = shift3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((shift3, rn, SBIT_CZNO, COND), (Rd), block_len))
        };
        let ((mut shift3, mut rn, mut SBIT_CZNO, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                SBIT_CZNO,
                shift3,
                rn,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4810:1"]
#[derive(Clone, Debug)]
pub struct instructionVar64 {
    shift2: shift2,
    rn: rn,
    SBIT_CZNO: SBIT_CZNO,
    COND: COND,
    Rd: u8,
}
impl instructionVar64 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            shift2,
            rn,
            SBIT_CZNO,
            COND,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sbc")];
        display.extend_from_slice(&extend);
        SBIT_CZNO.display_extend(display, context);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (6u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift2 = if let Some((len, table)) = shift2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, rn, SBIT_CZNO, shift2), (Rd), block_len))
        };
        let ((mut COND, mut rn, mut SBIT_CZNO, mut shift2), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        shift2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                shift2,
                rn,
                SBIT_CZNO,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4799:1"]
#[derive(Clone, Debug)]
pub struct instructionVar65 {
    COND: COND,
    SBIT_CZNO: SBIT_CZNO,
    rn: rn,
    shift1: shift1,
    Rd: u8,
}
impl instructionVar65 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            SBIT_CZNO,
            rn,
            shift1,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sbc")];
        display.extend_from_slice(&extend);
        SBIT_CZNO.display_extend(display, context);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift1.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (6u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift1 = if let Some((len, table)) = shift1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((shift1, rn, COND, SBIT_CZNO), (Rd), block_len))
        };
        let ((mut shift1, mut rn, mut COND, mut SBIT_CZNO), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        shift1.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4689:1"]
#[derive(Clone, Debug)]
pub struct instructionVar66 {
    COND: COND,
    SBIT_CZNO: SBIT_CZNO,
    shift3: shift3,
    rn: rn,
    Rd: u8,
}
impl instructionVar66 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            SBIT_CZNO,
            shift3,
            rn,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (7u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift3 = if let Some((len, table)) = shift3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((shift3, rn, COND, SBIT_CZNO), (Rd), block_len))
        };
        let ((mut shift3, mut rn, mut COND, mut SBIT_CZNO), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                SBIT_CZNO,
                shift3,
                rn,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4678:1"]
#[derive(Clone, Debug)]
pub struct instructionVar67 {
    rn: rn,
    shift2: shift2,
    COND: COND,
    SBIT_CZNO: SBIT_CZNO,
    Rd: u8,
}
impl instructionVar67 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            rn,
            shift2,
            COND,
            SBIT_CZNO,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (7u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift2 = if let Some((len, table)) = shift2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, COND, shift2, SBIT_CZNO), (Rd), block_len))
        };
        let ((mut rn, mut COND, mut shift2, mut SBIT_CZNO), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        shift2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                rn,
                shift2,
                COND,
                SBIT_CZNO,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4667:1"]
#[derive(Clone, Debug)]
pub struct instructionVar68 {
    rn: rn,
    COND: COND,
    shift1: shift1,
    SBIT_CZNO: SBIT_CZNO,
    Rd: u8,
}
impl instructionVar68 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            rn,
            COND,
            shift1,
            SBIT_CZNO,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift1.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (7u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift1 = if let Some((len, table)) = shift1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((shift1, COND, SBIT_CZNO, rn), (Rd), block_len))
        };
        let ((mut shift1, mut COND, mut SBIT_CZNO, mut rn), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift1.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                rn,
                COND,
                shift1,
                SBIT_CZNO,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4617:1"]
#[derive(Clone, Debug)]
pub struct instructionVar69 {
    SBIT_CZNO: SBIT_CZNO,
    shift3: shift3,
    COND: COND,
    rn: rn,
    Rd: u8,
}
impl instructionVar69 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            SBIT_CZNO,
            shift3,
            COND,
            rn,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsb")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (3u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift3 = if let Some((len, table)) = shift3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, SBIT_CZNO, shift3, COND), (Rd), block_len))
        };
        let ((mut rn, mut SBIT_CZNO, mut shift3, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        *context = context_current;
        Some((
            inst_len,
            Self {
                SBIT_CZNO,
                shift3,
                COND,
                rn,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4606:1"]
#[derive(Clone, Debug)]
pub struct instructionVar70 {
    shift2: shift2,
    SBIT_CZNO: SBIT_CZNO,
    rn: rn,
    COND: COND,
    Rd: u8,
}
impl instructionVar70 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            shift2,
            SBIT_CZNO,
            rn,
            COND,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsb")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (3u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift2 = if let Some((len, table)) = shift2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((shift2, rn, SBIT_CZNO, COND), (Rd), block_len))
        };
        let ((mut shift2, mut rn, mut SBIT_CZNO, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        shift2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                shift2,
                SBIT_CZNO,
                rn,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4595:1"]
#[derive(Clone, Debug)]
pub struct instructionVar71 {
    SBIT_CZNO: SBIT_CZNO,
    rn: rn,
    shift1: shift1,
    COND: COND,
    Rd: u8,
}
impl instructionVar71 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            SBIT_CZNO,
            rn,
            shift1,
            COND,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsb")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift1.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (3u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift1 = if let Some((len, table)) = shift1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, SBIT_CZNO, shift1, COND), (Rd), block_len))
        };
        let ((mut rn, mut SBIT_CZNO, mut shift1, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        shift1.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                SBIT_CZNO,
                rn,
                shift1,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4275:1"]
#[derive(Clone, Debug)]
pub struct instructionVar72 {
    shift3: shift3,
    COND: COND,
    SBIT_CZNO: SBIT_CZNO,
    rn: rn,
    Rd: u8,
}
impl instructionVar72 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            shift3,
            COND,
            SBIT_CZNO,
            rn,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("orr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (12u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift3 = if let Some((len, table)) = shift3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((SBIT_CZNO, rn, shift3, COND), (Rd), block_len))
        };
        let ((mut SBIT_CZNO, mut rn, mut shift3, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        shift3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        *context = context_current;
        Some((
            inst_len,
            Self {
                shift3,
                COND,
                SBIT_CZNO,
                rn,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4264:1"]
#[derive(Clone, Debug)]
pub struct instructionVar73 {
    shift2: shift2,
    COND: COND,
    SBIT_CZNO: SBIT_CZNO,
    rn: rn,
    Rd: u8,
}
impl instructionVar73 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            shift2,
            COND,
            SBIT_CZNO,
            rn,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("orr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (12u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift2 = if let Some((len, table)) = shift2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((SBIT_CZNO, rn, COND, shift2), (Rd), block_len))
        };
        let ((mut SBIT_CZNO, mut rn, mut COND, mut shift2), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        shift2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        *context = context_current;
        Some((
            inst_len,
            Self {
                shift2,
                COND,
                SBIT_CZNO,
                rn,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4253:1"]
#[derive(Clone, Debug)]
pub struct instructionVar74 {
    SBIT_CZNO: SBIT_CZNO,
    shift1: shift1,
    COND: COND,
    rn: rn,
    Rd: u8,
}
impl instructionVar74 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            SBIT_CZNO,
            shift1,
            COND,
            rn,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("orr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift1.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (12u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift1 = if let Some((len, table)) = shift1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, SBIT_CZNO, rn, shift1), (Rd), block_len))
        };
        let ((mut COND, mut SBIT_CZNO, mut rn, mut shift1), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift1.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        *context = context_current;
        Some((
            inst_len,
            Self {
                SBIT_CZNO,
                shift1,
                COND,
                rn,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2617:1"]
#[derive(Clone, Debug)]
pub struct instructionVar75 {
    shift3: shift3,
    COND: COND,
    SBIT_CZNO: SBIT_CZNO,
    rn: rn,
    Rd: u8,
}
impl instructionVar75 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            shift3,
            COND,
            SBIT_CZNO,
            rn,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("eor")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (1u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift3 = if let Some((len, table)) = shift3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, COND, SBIT_CZNO, shift3), (Rd), block_len))
        };
        let ((mut rn, mut COND, mut SBIT_CZNO, mut shift3), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        shift3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        *context = context_current;
        Some((
            inst_len,
            Self {
                shift3,
                COND,
                SBIT_CZNO,
                rn,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2606:1"]
#[derive(Clone, Debug)]
pub struct instructionVar76 {
    SBIT_CZNO: SBIT_CZNO,
    shift2: shift2,
    COND: COND,
    rn: rn,
    Rd: u8,
}
impl instructionVar76 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            SBIT_CZNO,
            shift2,
            COND,
            rn,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("eor")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (1u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift2 = if let Some((len, table)) = shift2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, shift2, COND, SBIT_CZNO), (Rd), block_len))
        };
        let ((mut rn, mut shift2, mut COND, mut SBIT_CZNO), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        *context = context_current;
        Some((
            inst_len,
            Self {
                SBIT_CZNO,
                shift2,
                COND,
                rn,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2595:1"]
#[derive(Clone, Debug)]
pub struct instructionVar77 {
    SBIT_CZNO: SBIT_CZNO,
    shift1: shift1,
    COND: COND,
    rn: rn,
    Rd: u8,
}
impl instructionVar77 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            SBIT_CZNO,
            shift1,
            COND,
            rn,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("eor")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift1.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (1u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift1 = if let Some((len, table)) = shift1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, shift1, SBIT_CZNO, rn), (Rd), block_len))
        };
        let ((mut COND, mut shift1, mut SBIT_CZNO, mut rn), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift1.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        *context = context_current;
        Some((
            inst_len,
            Self {
                SBIT_CZNO,
                shift1,
                COND,
                rn,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2202:1"]
#[derive(Clone, Debug)]
pub struct instructionVar78 {
    SBIT_CZNO: SBIT_CZNO,
    rn: rn,
    COND: COND,
    shift3: shift3,
    Rd: u8,
}
impl instructionVar78 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            SBIT_CZNO,
            rn,
            COND,
            shift3,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bic")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (14u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift3 = if let Some((len, table)) = shift3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, shift3, SBIT_CZNO, rn), (Rd), block_len))
        };
        let ((mut COND, mut shift3, mut SBIT_CZNO, mut rn), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                SBIT_CZNO,
                rn,
                COND,
                shift3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2191:1"]
#[derive(Clone, Debug)]
pub struct instructionVar79 {
    COND: COND,
    rn: rn,
    SBIT_CZNO: SBIT_CZNO,
    shift2: shift2,
    Rd: u8,
}
impl instructionVar79 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            rn,
            SBIT_CZNO,
            shift2,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bic")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (14u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift2 = if let Some((len, table)) = shift2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, SBIT_CZNO, rn, shift2), (Rd), block_len))
        };
        let ((mut COND, mut SBIT_CZNO, mut rn, mut shift2), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                rn,
                SBIT_CZNO,
                shift2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2180:1"]
#[derive(Clone, Debug)]
pub struct instructionVar80 {
    COND: COND,
    rn: rn,
    SBIT_CZNO: SBIT_CZNO,
    shift1: shift1,
    Rd: u8,
}
impl instructionVar80 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            rn,
            SBIT_CZNO,
            shift1,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bic")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift1.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (14u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift1 = if let Some((len, table)) = shift1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, shift1, SBIT_CZNO, rn), (Rd), block_len))
        };
        let ((mut COND, mut shift1, mut SBIT_CZNO, mut rn), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift1.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                rn,
                SBIT_CZNO,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2093:1"]
#[derive(Clone, Debug)]
pub struct instructionVar81 {
    COND: COND,
    rn: rn,
    shift3: shift3,
    SBIT_CZNO: SBIT_CZNO,
    Rd: u8,
}
impl instructionVar81 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            rn,
            shift3,
            SBIT_CZNO,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("and")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (0u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift3 = if let Some((len, table)) = shift3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((SBIT_CZNO, rn, shift3, COND), (Rd), block_len))
        };
        let ((mut SBIT_CZNO, mut rn, mut shift3, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        shift3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                rn,
                shift3,
                SBIT_CZNO,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2082:1"]
#[derive(Clone, Debug)]
pub struct instructionVar82 {
    rn: rn,
    SBIT_CZNO: SBIT_CZNO,
    shift2: shift2,
    COND: COND,
    Rd: u8,
}
impl instructionVar82 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            rn,
            SBIT_CZNO,
            shift2,
            COND,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("and")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (0u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift2 = if let Some((len, table)) = shift2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, COND, SBIT_CZNO, shift2), (Rd), block_len))
        };
        let ((mut rn, mut COND, mut SBIT_CZNO, mut shift2), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                rn,
                SBIT_CZNO,
                shift2,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2071:1"]
#[derive(Clone, Debug)]
pub struct instructionVar83 {
    rn: rn,
    shift1: shift1,
    COND: COND,
    SBIT_CZNO: SBIT_CZNO,
    Rd: u8,
}
impl instructionVar83 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            rn,
            shift1,
            COND,
            SBIT_CZNO,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("and")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift1.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (0u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift1 = if let Some((len, table)) = shift1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, SBIT_CZNO, shift1, rn), (Rd), block_len))
        };
        let ((mut COND, mut SBIT_CZNO, mut shift1, mut rn), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        shift1.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                rn,
                shift1,
                COND,
                SBIT_CZNO,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2021:1"]
#[derive(Clone, Debug)]
pub struct instructionVar84 {
    COND: COND,
    SBIT_CZNO: SBIT_CZNO,
    rn: rn,
    shift3: shift3,
    Rd: u8,
}
impl instructionVar84 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            SBIT_CZNO,
            rn,
            shift3,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("add")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (4u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift3 = if let Some((len, table)) = shift3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, shift3, SBIT_CZNO, rn), (Rd), block_len))
        };
        let ((mut COND, mut shift3, mut SBIT_CZNO, mut rn), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        shift3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2010:1"]
#[derive(Clone, Debug)]
pub struct instructionVar85 {
    rn: rn,
    COND: COND,
    SBIT_CZNO: SBIT_CZNO,
    shift2: shift2,
    Rd: u8,
}
impl instructionVar85 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            rn,
            COND,
            SBIT_CZNO,
            shift2,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("add")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (4u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift2 = if let Some((len, table)) = shift2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((SBIT_CZNO, COND, shift2, rn), (Rd), block_len))
        };
        let ((mut SBIT_CZNO, mut COND, mut shift2, mut rn), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                rn,
                COND,
                SBIT_CZNO,
                shift2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1999:1"]
#[derive(Clone, Debug)]
pub struct instructionVar86 {
    shift1: shift1,
    COND: COND,
    SBIT_CZNO: SBIT_CZNO,
    rn: rn,
    Rd: u8,
}
impl instructionVar86 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            shift1,
            COND,
            SBIT_CZNO,
            rn,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("add")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift1.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (4u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift1 = if let Some((len, table)) = shift1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((SBIT_CZNO, COND, shift1, rn), (Rd), block_len))
        };
        let ((mut SBIT_CZNO, mut COND, mut shift1, mut rn), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        shift1.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        *context = context_current;
        Some((
            inst_len,
            Self {
                shift1,
                COND,
                SBIT_CZNO,
                rn,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1918:1"]
#[derive(Clone, Debug)]
pub struct instructionVar87 {
    rn: rn,
    shift3: shift3,
    SBIT_CZNO: SBIT_CZNO,
    COND: COND,
    Rd: u8,
}
impl instructionVar87 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            rn,
            shift3,
            SBIT_CZNO,
            COND,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("adc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (5u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift3 = if let Some((len, table)) = shift3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, shift3, COND, SBIT_CZNO), (Rd), block_len))
        };
        let ((mut rn, mut shift3, mut COND, mut SBIT_CZNO), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        shift3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                rn,
                shift3,
                SBIT_CZNO,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1907:1"]
#[derive(Clone, Debug)]
pub struct instructionVar88 {
    shift2: shift2,
    COND: COND,
    SBIT_CZNO: SBIT_CZNO,
    rn: rn,
    Rd: u8,
}
impl instructionVar88 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            shift2,
            COND,
            SBIT_CZNO,
            rn,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("adc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (5u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift2 = if let Some((len, table)) = shift2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, COND, shift2, SBIT_CZNO), (Rd), block_len))
        };
        let ((mut rn, mut COND, mut shift2, mut SBIT_CZNO), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        shift2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        *context = context_current;
        Some((
            inst_len,
            Self {
                shift2,
                COND,
                SBIT_CZNO,
                rn,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1896:1"]
#[derive(Clone, Debug)]
pub struct instructionVar89 {
    COND: COND,
    rn: rn,
    shift1: shift1,
    SBIT_CZNO: SBIT_CZNO,
    Rd: u8,
}
impl instructionVar89 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            rn,
            shift1,
            SBIT_CZNO,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("adc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift1.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (5u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift1 = if let Some((len, table)) = shift1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, shift1, SBIT_CZNO, rn), (Rd), block_len))
        };
        let ((mut COND, mut shift1, mut SBIT_CZNO, mut rn), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        shift1.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                rn,
                shift1,
                SBIT_CZNO,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2378:1"]
#[derive(Clone, Debug)]
pub struct instructionVar90 {
    rm: rm,
    COND: COND,
}
impl instructionVar90 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rm, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bx")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        rm.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if context.read_REToverride() != (1u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2027() != (18u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1619() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1215() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0811() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0407() != (1u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, rm), (), block_len))
        };
        let ((mut COND, mut rm), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        rm.disassembly(&mut context_current, inst_start, inst_next, global_set);
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { rm, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2339:1"]
#[derive(Clone, Debug)]
pub struct instructionVar91 {
    rm: rm,
    COND: COND,
}
impl instructionVar91 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rm, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("blx")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        rm.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if context.read_CALLoverride() != (1u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2027() != (18u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1619() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1215() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0811() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0407() != (3u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rm, COND), (), block_len))
        };
        let ((mut rm, mut COND), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        rm.disassembly(&mut context_current, inst_start, inst_next, global_set);
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { rm, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2329:1"]
#[derive(Clone, Debug)]
pub struct instructionVar92 {
    COND: COND,
    rm: rm,
}
impl instructionVar92 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, rm } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("blx")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        rm.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2027() != (18u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1619() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1215() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0811() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0407() != (3u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, rm), (), block_len))
        };
        let ((mut COND, mut rm), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rm.disassembly(&mut context_current, inst_start, inst_next, global_set);
        *context = context_current;
        Some((inst_len, Self { COND, rm }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1990:1"]
#[derive(Clone, Debug)]
pub struct instructionVar93 {
    COND: COND,
    ArmPCRelImmed12: ArmPCRelImmed12,
}
impl instructionVar93 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            ArmPCRelImmed12,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("adr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        ArmPCRelImmed12.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2527() != (1u64 as i64) as u8 {
                return None;
            }
            let mut sub_pattern_c22 = |token, context: &mut T| {
                let mut block_len = 0 as u32;
                let mut context_current = context.clone();
                let mut token_current = token;
                let mut block_0 = |tokens, context: &mut T| {
                    let token_parser = TokenParser32::new(tokens)?;
                    block_len = 4u64 as u32;
                    if token_parser.c2024() == (8u64 as i64) as u8 {
                        return Some(((), (), u32::try_from(0u64).unwrap()));
                    }
                    let token_parser = TokenParser32::new(tokens)?;
                    block_len = 4u64 as u32;
                    if token_parser.c2024() == (4u64 as i64) as u8 {
                        return Some(((), (), u32::try_from(0u64).unwrap()));
                    }
                    None
                };
                let ((), (), block_len) =
                    block_0(token_current, &mut context_current)?;
                token_current =
                    &token_current[usize::try_from(block_len).unwrap()..];
                *context = context_current;
                Some(((), (), block_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c22(tokens, &mut context_current)?;
            block_len = block_len.max(sub_len);
            if token_parser.Rn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            let ArmPCRelImmed12 = if let Some((len, table)) =
                ArmPCRelImmed12::parse(
                    tokens,
                    &mut context_current,
                    inst_start,
                    global_set,
                ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ArmPCRelImmed12, COND), (), block_len))
        };
        let ((mut ArmPCRelImmed12, mut COND), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ArmPCRelImmed12.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                ArmPCRelImmed12,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2467:1"]
#[derive(Clone, Debug)]
pub struct instructionVar94 {
    COND: COND,
    rm: rm,
    Rd: u8,
}
impl instructionVar94 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, rm, Rd } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("clz")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rm.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2027() != (22u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1619() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0811() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0407() != (1u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, rm), (Rd), block_len))
        };
        let ((mut COND, mut rm), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rm.disassembly(&mut context_current, inst_start, inst_next, global_set);
        *context = context_current;
        Some((inst_len, Self { COND, rm, Rd }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1984:1"]
#[derive(Clone, Debug)]
pub struct instructionVar95 {
    COND: COND,
    ArmPCRelImmed12: ArmPCRelImmed12,
    Rd: u8,
}
impl instructionVar95 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            ArmPCRelImmed12,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("adr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        ArmPCRelImmed12.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2527() != (1u64 as i64) as u8 {
                return None;
            }
            let mut sub_pattern_c22 = |token, context: &mut T| {
                let mut block_len = 0 as u32;
                let mut context_current = context.clone();
                let mut token_current = token;
                let mut block_0 = |tokens, context: &mut T| {
                    let token_parser = TokenParser32::new(tokens)?;
                    block_len = 4u64 as u32;
                    if token_parser.c2024() == (8u64 as i64) as u8 {
                        return Some(((), (), u32::try_from(0u64).unwrap()));
                    }
                    let token_parser = TokenParser32::new(tokens)?;
                    block_len = 4u64 as u32;
                    if token_parser.c2024() == (4u64 as i64) as u8 {
                        return Some(((), (), u32::try_from(0u64).unwrap()));
                    }
                    None
                };
                let ((), (), block_len) =
                    block_0(token_current, &mut context_current)?;
                token_current =
                    &token_current[usize::try_from(block_len).unwrap()..];
                *context = context_current;
                Some(((), (), block_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c22(tokens, &mut context_current)?;
            block_len = block_len.max(sub_len);
            if token_parser.Rn() != (15u64 as i64) as u8 {
                return None;
            }
            let ArmPCRelImmed12 = if let Some((len, table)) =
                ArmPCRelImmed12::parse(
                    tokens,
                    &mut context_current,
                    inst_start,
                    global_set,
                ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, ArmPCRelImmed12), (Rd), block_len))
        };
        let ((mut COND, mut ArmPCRelImmed12), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ArmPCRelImmed12.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                ArmPCRelImmed12,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2318:1"]
#[derive(Clone, Debug)]
pub struct instructionVar96 {
    HAddr24: HAddr24,
}
impl instructionVar96 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { HAddr24 } = self;
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("blx"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        HAddr24.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if context.read_CALLoverride() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cond() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2527() != (5u64 as i64) as u8 {
                return None;
            }
            if token_parser.H24() != (1u64 as i64) as u8 {
                return None;
            }
            let HAddr24 = if let Some((len, table)) = HAddr24::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((HAddr24), (), block_len))
        };
        let ((mut HAddr24), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        HAddr24.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { HAddr24 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2310:1"]
#[derive(Clone, Debug)]
pub struct instructionVar97 {
    HAddr24: HAddr24,
}
impl instructionVar97 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { HAddr24 } = self;
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("blx"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        HAddr24.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if context.read_CALLoverride() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cond() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2527() != (5u64 as i64) as u8 {
                return None;
            }
            if token_parser.H24() != (1u64 as i64) as u8 {
                return None;
            }
            let HAddr24 = if let Some((len, table)) = HAddr24::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((HAddr24), (), block_len))
        };
        let ((mut HAddr24), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        HAddr24.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { HAddr24 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2302:1"]
#[derive(Clone, Debug)]
pub struct instructionVar98 {
    HAddr24: HAddr24,
}
impl instructionVar98 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { HAddr24 } = self;
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("blx"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        HAddr24.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if context.read_CALLoverride() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cond() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2527() != (5u64 as i64) as u8 {
                return None;
            }
            if token_parser.H24() != (0u64 as i64) as u8 {
                return None;
            }
            let HAddr24 = if let Some((len, table)) = HAddr24::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((HAddr24), (), block_len))
        };
        let ((mut HAddr24), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        HAddr24.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { HAddr24 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2294:1"]
#[derive(Clone, Debug)]
pub struct instructionVar99 {
    HAddr24: HAddr24,
}
impl instructionVar99 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { HAddr24 } = self;
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("blx"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        HAddr24.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if context.read_CALLoverride() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cond() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2527() != (5u64 as i64) as u8 {
                return None;
            }
            if token_parser.H24() != (0u64 as i64) as u8 {
                return None;
            }
            let HAddr24 = if let Some((len, table)) = HAddr24::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((HAddr24), (), block_len))
        };
        let ((mut HAddr24), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        HAddr24.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { HAddr24 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2268:1"]
#[derive(Clone, Debug)]
pub struct instructionVar100 {
    Addr24: Addr24,
}
impl instructionVar100 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { Addr24 } = self;
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("bl"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        Addr24.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cond() != (14u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2527() != (5u64 as i64) as u8 {
                return None;
            }
            if token_parser.L24() != (1u64 as i64) as u8 {
                return None;
            }
            let Addr24 = if let Some((len, table)) = Addr24::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((Addr24), (), block_len))
        };
        let ((mut Addr24), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        Addr24.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { Addr24 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2145:1"]
#[derive(Clone, Debug)]
pub struct instructionVar101 {
    Addr24: Addr24,
}
impl instructionVar101 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { Addr24 } = self;
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("b"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        Addr24.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cond() != (14u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2527() != (5u64 as i64) as u8 {
                return None;
            }
            if token_parser.L24() != (0u64 as i64) as u8 {
                return None;
            }
            let Addr24 = if let Some((len, table)) = Addr24::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((Addr24), (), block_len))
        };
        let ((mut Addr24), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        Addr24.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { Addr24 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5652:1"]
#[derive(Clone, Debug)]
pub struct instructionVar102 {
    COND: COND,
    immed24: u32,
}
impl instructionVar102 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, immed24 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("swi")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Unsigned(true, u64::try_from(*immed24).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let immed24 = token_parser.immed24();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2427() != (15u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((COND), (immed24), block_len))
        };
        let ((mut COND), (immed24), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, immed24 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2282:1"]
#[derive(Clone, Debug)]
pub struct instructionVar103 {
    Addr24: Addr24,
    COND: COND,
}
impl instructionVar103 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { Addr24, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bl")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        Addr24.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if context.read_CALLoverride() != (1u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2527() != (5u64 as i64) as u8 {
                return None;
            }
            if token_parser.L24() != (1u64 as i64) as u8 {
                return None;
            }
            let Addr24 = if let Some((len, table)) = Addr24::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((Addr24, COND), (), block_len))
        };
        let ((mut Addr24, mut COND), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        Addr24.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { Addr24, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2274:1"]
#[derive(Clone, Debug)]
pub struct instructionVar104 {
    Addr24: Addr24,
    COND: COND,
}
impl instructionVar104 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { Addr24, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bl")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        Addr24.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if context.read_CALLoverride() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2527() != (5u64 as i64) as u8 {
                return None;
            }
            if token_parser.L24() != (1u64 as i64) as u8 {
                return None;
            }
            let Addr24 = if let Some((len, table)) = Addr24::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((Addr24, COND), (), block_len))
        };
        let ((mut Addr24, mut COND), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        Addr24.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { Addr24, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2150:1"]
#[derive(Clone, Debug)]
pub struct instructionVar105 {
    cc: cc,
    Addr24: Addr24,
}
impl instructionVar105 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { cc, Addr24 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
        cc.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        Addr24.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let cc = if let Some((len, table)) =
                cc::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2527() != (5u64 as i64) as u8 {
                return None;
            }
            if token_parser.L24() != (0u64 as i64) as u8 {
                return None;
            }
            let Addr24 = if let Some((len, table)) = Addr24::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((cc, Addr24), (), block_len))
        };
        let ((mut cc, mut Addr24), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        cc.disassembly(&mut context_current, inst_start, inst_next, global_set);
        Addr24.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { cc, Addr24 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2253:1"]
#[derive(Clone, Debug)]
pub struct instructionVar106 {
    Addr24: Addr24,
}
impl instructionVar106 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { Addr24 } = self;
        let extend: [DisplayElement; 2usize] =
            [DisplayElement::Literal("bl"), DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        Addr24.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cond() != (14u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2527() != (5u64 as i64) as u8 {
                return None;
            }
            if token_parser.L24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.immed24() != (16777215u64 as i64) as u32 {
                return None;
            }
            let Addr24 = if let Some((len, table)) = Addr24::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((Addr24), (), block_len))
        };
        let ((mut Addr24), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        Addr24.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { Addr24 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2353:1"]
#[derive(Clone, Debug)]
pub struct instructionVar107 {
    COND: COND,
    rm: rm,
}
impl instructionVar107 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, rm } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bx")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        rm.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if context.read_REToverride() != (0u64 as i64) as u8 {
                return None;
            }
            if context.read_LRset() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2027() != (18u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1619() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1215() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0811() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0407() != (1u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.Rm() != (14u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((rm, COND), (), block_len))
        };
        let ((mut rm, mut COND), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rm.disassembly(&mut context_current, inst_start, inst_next, global_set);
        *context = context_current;
        Some((inst_len, Self { COND, rm }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2370:1"]
#[derive(Clone, Debug)]
pub struct instructionVar108 {
    COND: COND,
    rm: rm,
}
impl instructionVar108 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, rm } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bx")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        rm.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rm = token_parser.Rm();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if context.read_REToverride() != (0u64 as i64) as u8 {
                return None;
            }
            if context.read_LRset() != (1u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2027() != (18u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1619() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1215() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0811() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0407() != (1u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, rm), (Rm), block_len))
        };
        let ((mut COND, mut rm), (Rm), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rm.disassembly(&mut context_current, inst_start, inst_next, global_set);
        *context = context_current;
        Some((inst_len, Self { COND, rm }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2361:1"]
#[derive(Clone, Debug)]
pub struct instructionVar109 {
    rm: rm,
    COND: COND,
}
impl instructionVar109 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rm, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bx")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        rm.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rm = token_parser.Rm();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if context.read_REToverride() != (0u64 as i64) as u8 {
                return None;
            }
            if context.read_LRset() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2027() != (18u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1619() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1215() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0811() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0407() != (1u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, rm), (Rm), block_len))
        };
        let ((mut COND, mut rm), (Rm), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        rm.disassembly(&mut context_current, inst_start, inst_next, global_set);
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { rm, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2438:1"]
#[derive(Clone, Debug)]
pub struct instructionVar110 {
    CRm: u8,
    cpn: u8,
    CRd: u8,
    CRn: u8,
    opcode2: u8,
    opcode1: u8,
}
impl instructionVar110 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            CRm,
            cpn,
            CRd,
            CRn,
            opcode2,
            opcode1,
        } = self;
        let extend: [DisplayElement; 13usize] = [
            DisplayElement::Literal("cdp2"),
            DisplayElement::Literal(" "),
            meaning_94047773010576(usize::try_from(*cpn).unwrap()),
            DisplayElement::Literal(","),
            DisplayElement::Unsigned(true, u64::try_from(*opcode1).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047768585360(usize::try_from(*CRd).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047768585360(usize::try_from(*CRn).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047768585360(usize::try_from(*CRm).unwrap()),
            DisplayElement::Literal(","),
            DisplayElement::Unsigned(true, u64::try_from(*opcode2).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let opcode1 = token_parser.opcode1();
            let CRn = token_parser.CRn();
            let CRd = token_parser.CRd();
            let cpn = token_parser.cpn();
            let opcode2 = token_parser.opcode2();
            let CRm = token_parser.CRm();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cond() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (CRd, opcode1, CRn, opcode2, cpn, CRm), block_len))
        };
        let ((), (CRd, opcode1, CRn, opcode2, cpn, CRm), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        *context = context_current;
        Some((
            inst_len,
            Self {
                CRm,
                cpn,
                CRd,
                CRn,
                opcode2,
                opcode1,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3553:1"]
#[derive(Clone, Debug)]
pub struct instructionVar111 {
    COND: COND,
}
impl instructionVar111 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::lr),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2527() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.S20() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2124() != (13u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1619() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.sftimm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0406() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.Rm() != (14u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((COND), (), block_len))
        };
        let ((mut COND), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5292:1"]
#[derive(Clone, Debug)]
pub struct instructionVar112 {
    YBIT: YBIT,
    COND: COND,
    smRn: u8,
    smRm: u8,
    smRd: u8,
}
impl instructionVar112 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            YBIT,
            COND,
            smRn,
            smRm,
            smRd,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smulw")];
        display.extend_from_slice(&extend);
        YBIT.display_extend(display, context);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("   "),
            meaning_94047766862464(usize::try_from(*smRd).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*smRn).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*smRm).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let smRd = token_parser.smRd();
            let smRn = token_parser.smRn();
            let smRm = token_parser.smRm();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2027() != (18u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1215() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0707() != (1u64 as i64) as u8 {
                return None;
            }
            let YBIT = if let Some((len, table)) = YBIT::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.x() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((YBIT, COND), (smRn, smRd, smRm), block_len))
        };
        let ((mut YBIT, mut COND), (smRn, smRd, smRm), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        YBIT.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                YBIT,
                COND,
                smRn,
                smRm,
                smRd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5118:1"]
#[derive(Clone, Debug)]
pub struct instructionVar113 {
    YBIT: YBIT,
    COND: COND,
    smRm: u8,
    smRa: u8,
    smRd: u8,
    smRn: u8,
}
impl instructionVar113 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            YBIT,
            COND,
            smRm,
            smRa,
            smRd,
            smRn,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smlaw")];
        display.extend_from_slice(&extend);
        YBIT.display_extend(display, context);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal("   "),
            meaning_94047766862464(usize::try_from(*smRd).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*smRn).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*smRm).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*smRa).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let smRd = token_parser.smRd();
            let smRn = token_parser.smRn();
            let smRm = token_parser.smRm();
            let smRa = token_parser.smRa();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2027() != (18u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0707() != (1u64 as i64) as u8 {
                return None;
            }
            let YBIT = if let Some((len, table)) = YBIT::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.x() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((COND, YBIT), (smRn, smRa, smRd, smRm), block_len))
        };
        let ((mut COND, mut YBIT), (smRn, smRa, smRd, smRm), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        YBIT.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                YBIT,
                COND,
                smRm,
                smRa,
                smRd,
                smRn,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2448:1"]
#[derive(Clone, Debug)]
pub struct instructionVar114 {
    COND: COND,
    opcode2: u8,
    CRd: u8,
    CRm: u8,
    opcode1: u8,
    cpn: u8,
    CRn: u8,
}
impl instructionVar114 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            opcode2,
            CRd,
            CRm,
            opcode1,
            cpn,
            CRn,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cdp")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 12usize] = [
            DisplayElement::Literal(" "),
            meaning_94047773010576(usize::try_from(*cpn).unwrap()),
            DisplayElement::Literal(","),
            DisplayElement::Unsigned(true, u64::try_from(*opcode1).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047768585360(usize::try_from(*CRd).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047768585360(usize::try_from(*CRn).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047768585360(usize::try_from(*CRm).unwrap()),
            DisplayElement::Literal(","),
            DisplayElement::Unsigned(true, u64::try_from(*opcode2).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let opcode1 = token_parser.opcode1();
            let CRn = token_parser.CRn();
            let CRd = token_parser.CRd();
            let cpn = token_parser.cpn();
            let opcode2 = token_parser.opcode2();
            let CRm = token_parser.CRm();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((COND), (opcode2, CRn, cpn, CRd, CRm, opcode1), block_len))
        };
        let ((mut COND), (opcode2, CRn, cpn, CRd, CRm, opcode1), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                opcode2,
                CRd,
                CRm,
                opcode1,
                cpn,
                CRn,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5415:1"]
#[derive(Clone, Debug)]
pub struct instructionVar115 {
    COND: COND,
    addrmode5: addrmode5,
    CRd: u8,
    cpn: u8,
}
impl instructionVar115 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            addrmode5,
            CRd,
            cpn,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("stcl")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal(" "),
            meaning_94047773010576(usize::try_from(*cpn).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047768585360(usize::try_from(*CRd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        addrmode5.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let cpn = token_parser.cpn();
            let CRd = token_parser.CRd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2527() != (6u64 as i64) as u8 {
                return None;
            }
            let addrmode5 = if let Some((len, table)) = addrmode5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.N22() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((addrmode5, COND), (CRd, cpn), block_len))
        };
        let ((mut addrmode5, mut COND), (CRd, cpn), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        addrmode5.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                addrmode5,
                CRd,
                cpn,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5407:1"]
#[derive(Clone, Debug)]
pub struct instructionVar116 {
    addrmode5: addrmode5,
    COND: COND,
    CRd: u8,
    cpn: u8,
}
impl instructionVar116 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            addrmode5,
            COND,
            CRd,
            cpn,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("stc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal(" "),
            meaning_94047773010576(usize::try_from(*cpn).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047768585360(usize::try_from(*CRd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        addrmode5.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let cpn = token_parser.cpn();
            let CRd = token_parser.CRd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2527() != (6u64 as i64) as u8 {
                return None;
            }
            let addrmode5 = if let Some((len, table)) = addrmode5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.N22() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((addrmode5, COND), (CRd, cpn), block_len))
        };
        let ((mut addrmode5, mut COND), (CRd, cpn), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        addrmode5.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                addrmode5,
                COND,
                CRd,
                cpn,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2702:1"]
#[derive(Clone, Debug)]
pub struct instructionVar117 {
    COND: COND,
    addrmode5: addrmode5,
    cpn: u8,
    CRd: u8,
}
impl instructionVar117 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            addrmode5,
            cpn,
            CRd,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldcl")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal(" "),
            meaning_94047773010576(usize::try_from(*cpn).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047768585360(usize::try_from(*CRd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        addrmode5.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let cpn = token_parser.cpn();
            let CRd = token_parser.CRd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2527() != (6u64 as i64) as u8 {
                return None;
            }
            let addrmode5 = if let Some((len, table)) = addrmode5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.N22() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((addrmode5, COND), (CRd, cpn), block_len))
        };
        let ((mut addrmode5, mut COND), (CRd, cpn), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        addrmode5.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                addrmode5,
                cpn,
                CRd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2694:1"]
#[derive(Clone, Debug)]
pub struct instructionVar118 {
    COND: COND,
    addrmode5: addrmode5,
    CRd: u8,
    cpn: u8,
}
impl instructionVar118 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            addrmode5,
            CRd,
            cpn,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ldc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal(" "),
            meaning_94047773010576(usize::try_from(*cpn).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047768585360(usize::try_from(*CRd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        addrmode5.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let cpn = token_parser.cpn();
            let CRd = token_parser.CRd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2527() != (6u64 as i64) as u8 {
                return None;
            }
            let addrmode5 = if let Some((len, table)) = addrmode5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.N22() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((addrmode5, COND), (cpn, CRd), block_len))
        };
        let ((mut addrmode5, mut COND), (cpn, CRd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        addrmode5.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                addrmode5,
                CRd,
                cpn,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2716:1"]
#[derive(Clone, Debug)]
pub struct instructionVar119 {
    mdir: mdir,
    COND: COND,
    reglist: reglist,
}
impl instructionVar119 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            mdir,
            COND,
            reglist,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ldm")];
        display.extend_from_slice(&extend);
        mdir.display_extend(display, context);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        reglist.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2527() != (4u64 as i64) as u8 {
                return None;
            }
            let mdir = if let Some((len, table)) = mdir::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.L20() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1515() != (1u64 as i64) as u8 {
                return None;
            }
            let reglist = if let Some((len, table)) = reglist::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mdir, reglist), (), block_len))
        };
        let ((mut COND, mut mdir, mut reglist), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mdir.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        reglist.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                mdir,
                COND,
                reglist,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2710:1"]
#[derive(Clone, Debug)]
pub struct instructionVar120 {
    mdir: mdir,
    COND: COND,
    reglist: reglist,
}
impl instructionVar120 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            mdir,
            COND,
            reglist,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ldm")];
        display.extend_from_slice(&extend);
        mdir.display_extend(display, context);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        reglist.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2527() != (4u64 as i64) as u8 {
                return None;
            }
            let mdir = if let Some((len, table)) = mdir::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.L20() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1515() != (0u64 as i64) as u8 {
                return None;
            }
            let reglist = if let Some((len, table)) = reglist::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((reglist, mdir, COND), (), block_len))
        };
        let ((mut reglist, mut mdir, mut COND), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mdir.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        reglist.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                mdir,
                COND,
                reglist,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5269:1"]
#[derive(Clone, Debug)]
pub struct instructionVar121 {
    XBIT: XBIT,
    YBIT: YBIT,
    COND: COND,
    smRd: u8,
    smRn: u8,
    smRm: u8,
}
impl instructionVar121 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            XBIT,
            YBIT,
            COND,
            smRd,
            smRn,
            smRm,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smul")];
        display.extend_from_slice(&extend);
        XBIT.display_extend(display, context);
        YBIT.display_extend(display, context);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("   "),
            meaning_94047766862464(usize::try_from(*smRd).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*smRn).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*smRm).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let smRd = token_parser.smRd();
            let smRm = token_parser.smRm();
            let smRn = token_parser.smRn();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2027() != (22u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1215() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0707() != (1u64 as i64) as u8 {
                return None;
            }
            let XBIT = if let Some((len, table)) = XBIT::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let YBIT = if let Some((len, table)) = YBIT::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c0404() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((COND, XBIT, YBIT), (smRm, smRd, smRn), block_len))
        };
        let ((mut COND, mut XBIT, mut YBIT), (smRm, smRd, smRn), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        XBIT.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        YBIT.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                XBIT,
                YBIT,
                COND,
                smRd,
                smRn,
                smRm,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5072:1"]
#[derive(Clone, Debug)]
pub struct instructionVar122 {
    YBIT: YBIT,
    COND: COND,
    XBIT: XBIT,
    RdLo: u8,
    RdHi: u8,
    smRn: u8,
    smRm: u8,
}
impl instructionVar122 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            YBIT,
            COND,
            XBIT,
            RdLo,
            RdHi,
            smRn,
            smRm,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smlal")];
        display.extend_from_slice(&extend);
        XBIT.display_extend(display, context);
        YBIT.display_extend(display, context);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal("   "),
            meaning_94047766862464(usize::try_from(*RdLo).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*RdHi).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*smRn).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*smRm).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let RdLo = token_parser.RdLo();
            let RdHi = token_parser.RdHi();
            let smRm = token_parser.smRm();
            let smRn = token_parser.smRn();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2027() != (20u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0707() != (1u64 as i64) as u8 {
                return None;
            }
            let XBIT = if let Some((len, table)) = XBIT::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let YBIT = if let Some((len, table)) = YBIT::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c0404() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((YBIT, XBIT, COND), (smRm, RdHi, smRn, RdLo), block_len))
        };
        let (
            (mut YBIT, mut XBIT, mut COND),
            (smRm, RdHi, smRn, RdLo),
            block_len,
        ) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        YBIT.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        XBIT.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                YBIT,
                COND,
                XBIT,
                RdLo,
                RdHi,
                smRn,
                smRm,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5011:1"]
#[derive(Clone, Debug)]
pub struct instructionVar123 {
    COND: COND,
    XBIT: XBIT,
    YBIT: YBIT,
    smRn: u8,
    smRa: u8,
    smRm: u8,
    smRd: u8,
}
impl instructionVar123 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            XBIT,
            YBIT,
            smRn,
            smRa,
            smRm,
            smRd,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smla")];
        display.extend_from_slice(&extend);
        XBIT.display_extend(display, context);
        YBIT.display_extend(display, context);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal("   "),
            meaning_94047766862464(usize::try_from(*smRd).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*smRn).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*smRm).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*smRa).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let smRd = token_parser.smRd();
            let smRn = token_parser.smRn();
            let smRm = token_parser.smRm();
            let smRa = token_parser.smRa();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2027() != (16u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0707() != (1u64 as i64) as u8 {
                return None;
            }
            let XBIT = if let Some((len, table)) = XBIT::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let YBIT = if let Some((len, table)) = YBIT::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c0404() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((XBIT, COND, YBIT), (smRd, smRn, smRa, smRm), block_len))
        };
        let (
            (mut XBIT, mut COND, mut YBIT),
            (smRd, smRn, smRa, smRm),
            block_len,
        ) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        XBIT.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        YBIT.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                XBIT,
                YBIT,
                smRn,
                smRa,
                smRm,
                smRd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5445:1"]
#[derive(Clone, Debug)]
pub struct instructionVar124 {
    COND: COND,
    addrmode2: addrmode2,
    Rd: u8,
}
impl instructionVar124 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            addrmode2,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("strb")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        addrmode2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.B22() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (0u64 as i64) as u8 {
                return None;
            }
            let mut sub_pattern_c43 = |token, context: &mut T| {
                let mut block_len = 0 as u32;
                let mut context_current = context.clone();
                let mut token_current = token;
                let mut block_0 = |tokens, context: &mut T| {
                    let token_parser = TokenParser32::new(tokens)?;
                    block_len = 4u64 as u32;
                    if token_parser.I25() == (0u64 as i64) as u8 {
                        return Some(((), (), u32::try_from(0u64).unwrap()));
                    }
                    let mut sub_pattern_c52 = |token, context: &mut T| {
                        let mut block_len = 0 as u32;
                        let mut context_current = context.clone();
                        let mut token_current = token;
                        let mut block_0 = |tokens, context: &mut T| {
                            let mut block_len = 0 as u32;
                            let mut context_current = context.clone();
                            let token_parser = TokenParser32::new(tokens)?;
                            block_len = 4u64 as u32;
                            if token_parser.I25() != (1u64 as i64) as u8 {
                                return None;
                            }
                            if token_parser.c0404() != (0u64 as i64) as u8 {
                                return None;
                            }
                            *context = context_current;
                            Some(((), (), block_len))
                        };
                        let ((), (), block_len) =
                            block_0(token_current, &mut context_current)?;
                        token_current = &token_current
                            [usize::try_from(block_len).unwrap()..];
                        *context = context_current;
                        Some(((), (), block_len))
                    };
                    let mut context_current = context.clone();
                    if let Some(((), (), sub_pattern_len)) =
                        sub_pattern_c52(tokens, &mut context_current)
                    {
                        *context = context_current;
                        return Some(((), (), sub_pattern_len));
                    }
                    None
                };
                let ((), (), block_len) =
                    block_0(token_current, &mut context_current)?;
                token_current =
                    &token_current[usize::try_from(block_len).unwrap()..];
                *context = context_current;
                Some(((), (), block_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c43(tokens, &mut context_current)?;
            block_len = block_len.max(sub_len);
            let addrmode2 = if let Some((len, table)) = addrmode2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, addrmode2), (Rd), block_len))
        };
        let ((mut COND, mut addrmode2), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        addrmode2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                addrmode2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5438:1"]
#[derive(Clone, Debug)]
pub struct instructionVar125 {
    COND: COND,
    addrmode2: addrmode2,
    Rd: u8,
}
impl instructionVar125 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            addrmode2,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("str")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        addrmode2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.B22() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (0u64 as i64) as u8 {
                return None;
            }
            let mut sub_pattern_c43 = |token, context: &mut T| {
                let mut block_len = 0 as u32;
                let mut context_current = context.clone();
                let mut token_current = token;
                let mut block_0 = |tokens, context: &mut T| {
                    let token_parser = TokenParser32::new(tokens)?;
                    block_len = 4u64 as u32;
                    if token_parser.I25() == (0u64 as i64) as u8 {
                        return Some(((), (), u32::try_from(0u64).unwrap()));
                    }
                    let mut sub_pattern_c52 = |token, context: &mut T| {
                        let mut block_len = 0 as u32;
                        let mut context_current = context.clone();
                        let mut token_current = token;
                        let mut block_0 = |tokens, context: &mut T| {
                            let mut block_len = 0 as u32;
                            let mut context_current = context.clone();
                            let token_parser = TokenParser32::new(tokens)?;
                            block_len = 4u64 as u32;
                            if token_parser.I25() != (1u64 as i64) as u8 {
                                return None;
                            }
                            if token_parser.c0404() != (0u64 as i64) as u8 {
                                return None;
                            }
                            *context = context_current;
                            Some(((), (), block_len))
                        };
                        let ((), (), block_len) =
                            block_0(token_current, &mut context_current)?;
                        token_current = &token_current
                            [usize::try_from(block_len).unwrap()..];
                        *context = context_current;
                        Some(((), (), block_len))
                    };
                    let mut context_current = context.clone();
                    if let Some(((), (), sub_pattern_len)) =
                        sub_pattern_c52(tokens, &mut context_current)
                    {
                        *context = context_current;
                        return Some(((), (), sub_pattern_len));
                    }
                    None
                };
                let ((), (), block_len) =
                    block_0(token_current, &mut context_current)?;
                token_current =
                    &token_current[usize::try_from(block_len).unwrap()..];
                *context = context_current;
                Some(((), (), block_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c43(tokens, &mut context_current)?;
            block_len = block_len.max(sub_len);
            let addrmode2 = if let Some((len, table)) = addrmode2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, addrmode2), (Rd), block_len))
        };
        let ((mut COND, mut addrmode2), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        addrmode2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                addrmode2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2786:1"]
#[derive(Clone, Debug)]
pub struct instructionVar126 {
    addrmode2: addrmode2,
    COND: COND,
    Rd: u8,
}
impl instructionVar126 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            addrmode2,
            COND,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldrb")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        addrmode2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.B22() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (1u64 as i64) as u8 {
                return None;
            }
            let mut sub_pattern_c43 = |token, context: &mut T| {
                let mut block_len = 0 as u32;
                let mut context_current = context.clone();
                let mut token_current = token;
                let mut block_0 = |tokens, context: &mut T| {
                    let token_parser = TokenParser32::new(tokens)?;
                    block_len = 4u64 as u32;
                    if token_parser.I25() == (0u64 as i64) as u8 {
                        return Some(((), (), u32::try_from(0u64).unwrap()));
                    }
                    let mut sub_pattern_c52 = |token, context: &mut T| {
                        let mut block_len = 0 as u32;
                        let mut context_current = context.clone();
                        let mut token_current = token;
                        let mut block_0 = |tokens, context: &mut T| {
                            let mut block_len = 0 as u32;
                            let mut context_current = context.clone();
                            let token_parser = TokenParser32::new(tokens)?;
                            block_len = 4u64 as u32;
                            if token_parser.I25() != (1u64 as i64) as u8 {
                                return None;
                            }
                            if token_parser.c0404() != (0u64 as i64) as u8 {
                                return None;
                            }
                            *context = context_current;
                            Some(((), (), block_len))
                        };
                        let ((), (), block_len) =
                            block_0(token_current, &mut context_current)?;
                        token_current = &token_current
                            [usize::try_from(block_len).unwrap()..];
                        *context = context_current;
                        Some(((), (), block_len))
                    };
                    let mut context_current = context.clone();
                    if let Some(((), (), sub_pattern_len)) =
                        sub_pattern_c52(tokens, &mut context_current)
                    {
                        *context = context_current;
                        return Some(((), (), sub_pattern_len));
                    }
                    None
                };
                let ((), (), block_len) =
                    block_0(token_current, &mut context_current)?;
                token_current =
                    &token_current[usize::try_from(block_len).unwrap()..];
                *context = context_current;
                Some(((), (), block_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c43(tokens, &mut context_current)?;
            block_len = block_len.max(sub_len);
            let addrmode2 = if let Some((len, table)) = addrmode2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((addrmode2, COND), (Rd), block_len))
        };
        let ((mut addrmode2, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        addrmode2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                addrmode2,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2735:1"]
#[derive(Clone, Debug)]
pub struct instructionVar127 {
    addrmode2: addrmode2,
    COND: COND,
    Rd: u8,
}
impl instructionVar127 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            addrmode2,
            COND,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ldr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        addrmode2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.B22() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (1u64 as i64) as u8 {
                return None;
            }
            let mut sub_pattern_c43 = |token, context: &mut T| {
                let mut block_len = 0 as u32;
                let mut context_current = context.clone();
                let mut token_current = token;
                let mut block_0 = |tokens, context: &mut T| {
                    let token_parser = TokenParser32::new(tokens)?;
                    block_len = 4u64 as u32;
                    if token_parser.I25() == (0u64 as i64) as u8 {
                        return Some(((), (), u32::try_from(0u64).unwrap()));
                    }
                    let mut sub_pattern_c52 = |token, context: &mut T| {
                        let mut block_len = 0 as u32;
                        let mut context_current = context.clone();
                        let mut token_current = token;
                        let mut block_0 = |tokens, context: &mut T| {
                            let mut block_len = 0 as u32;
                            let mut context_current = context.clone();
                            let token_parser = TokenParser32::new(tokens)?;
                            block_len = 4u64 as u32;
                            if token_parser.I25() != (1u64 as i64) as u8 {
                                return None;
                            }
                            if token_parser.c0404() != (0u64 as i64) as u8 {
                                return None;
                            }
                            *context = context_current;
                            Some(((), (), block_len))
                        };
                        let ((), (), block_len) =
                            block_0(token_current, &mut context_current)?;
                        token_current = &token_current
                            [usize::try_from(block_len).unwrap()..];
                        *context = context_current;
                        Some(((), (), block_len))
                    };
                    let mut context_current = context.clone();
                    if let Some(((), (), sub_pattern_len)) =
                        sub_pattern_c52(tokens, &mut context_current)
                    {
                        *context = context_current;
                        return Some(((), (), sub_pattern_len));
                    }
                    None
                };
                let ((), (), block_len) =
                    block_0(token_current, &mut context_current)?;
                token_current =
                    &token_current[usize::try_from(block_len).unwrap()..];
                *context = context_current;
                Some(((), (), block_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c43(tokens, &mut context_current)?;
            block_len = block_len.max(sub_len);
            let addrmode2 = if let Some((len, table)) = addrmode2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((addrmode2, COND), (Rd), block_len))
        };
        let ((mut addrmode2, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        addrmode2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                addrmode2,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2768:1"]
#[derive(Clone, Debug)]
pub struct instructionVar128 {
    COND: COND,
    addrmode2: addrmode2,
}
impl instructionVar128 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, addrmode2 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ldr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        addrmode2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.B22() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            let mut sub_pattern_c59 = |token, context: &mut T| {
                let mut block_len = 0 as u32;
                let mut context_current = context.clone();
                let mut token_current = token;
                let mut block_0 = |tokens, context: &mut T| {
                    let token_parser = TokenParser32::new(tokens)?;
                    block_len = 4u64 as u32;
                    if token_parser.I25() == (0u64 as i64) as u8 {
                        return Some(((), (), u32::try_from(0u64).unwrap()));
                    }
                    let mut sub_pattern_c68 = |token, context: &mut T| {
                        let mut block_len = 0 as u32;
                        let mut context_current = context.clone();
                        let mut token_current = token;
                        let mut block_0 = |tokens, context: &mut T| {
                            let mut block_len = 0 as u32;
                            let mut context_current = context.clone();
                            let token_parser = TokenParser32::new(tokens)?;
                            block_len = 4u64 as u32;
                            if token_parser.I25() != (1u64 as i64) as u8 {
                                return None;
                            }
                            if token_parser.c0404() != (0u64 as i64) as u8 {
                                return None;
                            }
                            *context = context_current;
                            Some(((), (), block_len))
                        };
                        let ((), (), block_len) =
                            block_0(token_current, &mut context_current)?;
                        token_current = &token_current
                            [usize::try_from(block_len).unwrap()..];
                        *context = context_current;
                        Some(((), (), block_len))
                    };
                    let mut context_current = context.clone();
                    if let Some(((), (), sub_pattern_len)) =
                        sub_pattern_c68(tokens, &mut context_current)
                    {
                        *context = context_current;
                        return Some(((), (), sub_pattern_len));
                    }
                    None
                };
                let ((), (), block_len) =
                    block_0(token_current, &mut context_current)?;
                token_current =
                    &token_current[usize::try_from(block_len).unwrap()..];
                *context = context_current;
                Some(((), (), block_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c59(tokens, &mut context_current)?;
            block_len = block_len.max(sub_len);
            let addrmode2 = if let Some((len, table)) = addrmode2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, addrmode2), (), block_len))
        };
        let ((mut COND, mut addrmode2), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        addrmode2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, addrmode2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2743:1"]
#[derive(Clone, Debug)]
pub struct instructionVar129 {
    addrmode2: addrmode2,
    COND: COND,
}
impl instructionVar129 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { addrmode2, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ldr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        addrmode2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if context.read_LRset() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.B22() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            let mut sub_pattern_c69 = |token, context: &mut T| {
                let mut block_len = 0 as u32;
                let mut context_current = context.clone();
                let mut token_current = token;
                let mut block_0 = |tokens, context: &mut T| {
                    let token_parser = TokenParser32::new(tokens)?;
                    block_len = 4u64 as u32;
                    if token_parser.I25() == (0u64 as i64) as u8 {
                        return Some(((), (), u32::try_from(0u64).unwrap()));
                    }
                    let mut sub_pattern_c78 = |token, context: &mut T| {
                        let mut block_len = 0 as u32;
                        let mut context_current = context.clone();
                        let mut token_current = token;
                        let mut block_0 = |tokens, context: &mut T| {
                            let mut block_len = 0 as u32;
                            let mut context_current = context.clone();
                            let token_parser = TokenParser32::new(tokens)?;
                            block_len = 4u64 as u32;
                            if token_parser.I25() != (1u64 as i64) as u8 {
                                return None;
                            }
                            if token_parser.c0404() != (0u64 as i64) as u8 {
                                return None;
                            }
                            *context = context_current;
                            Some(((), (), block_len))
                        };
                        let ((), (), block_len) =
                            block_0(token_current, &mut context_current)?;
                        token_current = &token_current
                            [usize::try_from(block_len).unwrap()..];
                        *context = context_current;
                        Some(((), (), block_len))
                    };
                    let mut context_current = context.clone();
                    if let Some(((), (), sub_pattern_len)) =
                        sub_pattern_c78(tokens, &mut context_current)
                    {
                        *context = context_current;
                        return Some(((), (), sub_pattern_len));
                    }
                    None
                };
                let ((), (), block_len) =
                    block_0(token_current, &mut context_current)?;
                token_current =
                    &token_current[usize::try_from(block_len).unwrap()..];
                *context = context_current;
                Some(((), (), block_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c69(tokens, &mut context_current)?;
            block_len = block_len.max(sub_len);
            let addrmode2 = if let Some((len, table)) = addrmode2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((addrmode2, COND), (), block_len))
        };
        let ((mut addrmode2, mut COND), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        addrmode2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        let context_tmp = &mut context_current;
        let mut LRset = context_tmp.read_LRset();
        LRset = u8::try_from((0u64 as i64)).unwrap();
        global_set.set_LRset(
            Some(u32::try_from(inst_next).unwrap()),
            u8::try_into(LRset).unwrap(),
        );
        context_tmp.write_LRset(LRset);
        *context = context_current;
        Some((inst_len, Self { addrmode2, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2777:1"]
#[derive(Clone, Debug)]
pub struct instructionVar130 {
    addrmode2: addrmode2,
    COND: COND,
}
impl instructionVar130 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { addrmode2, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ldr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        addrmode2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.B22() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (0u64 as i64) as u8 {
                return None;
            }
            let mut sub_pattern_c67 = |token, context: &mut T| {
                let mut block_len = 0 as u32;
                let mut context_current = context.clone();
                let mut token_current = token;
                let mut block_0 = |tokens, context: &mut T| {
                    let token_parser = TokenParser32::new(tokens)?;
                    block_len = 4u64 as u32;
                    if token_parser.I25() == (0u64 as i64) as u8 {
                        return Some(((), (), u32::try_from(0u64).unwrap()));
                    }
                    let mut sub_pattern_c76 = |token, context: &mut T| {
                        let mut block_len = 0 as u32;
                        let mut context_current = context.clone();
                        let mut token_current = token;
                        let mut block_0 = |tokens, context: &mut T| {
                            let mut block_len = 0 as u32;
                            let mut context_current = context.clone();
                            let token_parser = TokenParser32::new(tokens)?;
                            block_len = 4u64 as u32;
                            if token_parser.I25() != (1u64 as i64) as u8 {
                                return None;
                            }
                            if token_parser.c0404() != (0u64 as i64) as u8 {
                                return None;
                            }
                            *context = context_current;
                            Some(((), (), block_len))
                        };
                        let ((), (), block_len) =
                            block_0(token_current, &mut context_current)?;
                        token_current = &token_current
                            [usize::try_from(block_len).unwrap()..];
                        *context = context_current;
                        Some(((), (), block_len))
                    };
                    let mut context_current = context.clone();
                    if let Some(((), (), sub_pattern_len)) =
                        sub_pattern_c76(tokens, &mut context_current)
                    {
                        *context = context_current;
                        return Some(((), (), sub_pattern_len));
                    }
                    None
                };
                let ((), (), block_len) =
                    block_0(token_current, &mut context_current)?;
                token_current =
                    &token_current[usize::try_from(block_len).unwrap()..];
                *context = context_current;
                Some(((), (), block_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c67(tokens, &mut context_current)?;
            block_len = block_len.max(sub_len);
            let addrmode2 = if let Some((len, table)) = addrmode2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((addrmode2, COND), (), block_len))
        };
        let ((mut addrmode2, mut COND), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        addrmode2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { addrmode2, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2755:1"]
#[derive(Clone, Debug)]
pub struct instructionVar131 {
    COND: COND,
    addrmode2: addrmode2,
}
impl instructionVar131 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, addrmode2 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ldr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        addrmode2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if context.read_LRset() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.B22() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (0u64 as i64) as u8 {
                return None;
            }
            let mut sub_pattern_c77 = |token, context: &mut T| {
                let mut block_len = 0 as u32;
                let mut context_current = context.clone();
                let mut token_current = token;
                let mut block_0 = |tokens, context: &mut T| {
                    let token_parser = TokenParser32::new(tokens)?;
                    block_len = 4u64 as u32;
                    if token_parser.I25() == (0u64 as i64) as u8 {
                        return Some(((), (), u32::try_from(0u64).unwrap()));
                    }
                    let mut sub_pattern_c86 = |token, context: &mut T| {
                        let mut block_len = 0 as u32;
                        let mut context_current = context.clone();
                        let mut token_current = token;
                        let mut block_0 = |tokens, context: &mut T| {
                            let mut block_len = 0 as u32;
                            let mut context_current = context.clone();
                            let token_parser = TokenParser32::new(tokens)?;
                            block_len = 4u64 as u32;
                            if token_parser.I25() != (1u64 as i64) as u8 {
                                return None;
                            }
                            if token_parser.c0404() != (0u64 as i64) as u8 {
                                return None;
                            }
                            *context = context_current;
                            Some(((), (), block_len))
                        };
                        let ((), (), block_len) =
                            block_0(token_current, &mut context_current)?;
                        token_current = &token_current
                            [usize::try_from(block_len).unwrap()..];
                        *context = context_current;
                        Some(((), (), block_len))
                    };
                    let mut context_current = context.clone();
                    if let Some(((), (), sub_pattern_len)) =
                        sub_pattern_c86(tokens, &mut context_current)
                    {
                        *context = context_current;
                        return Some(((), (), sub_pattern_len));
                    }
                    None
                };
                let ((), (), block_len) =
                    block_0(token_current, &mut context_current)?;
                token_current =
                    &token_current[usize::try_from(block_len).unwrap()..];
                *context = context_current;
                Some(((), (), block_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c77(tokens, &mut context_current)?;
            block_len = block_len.max(sub_len);
            let addrmode2 = if let Some((len, table)) = addrmode2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((addrmode2, COND), (), block_len))
        };
        let ((mut addrmode2, mut COND), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        addrmode2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        let context_tmp = &mut context_current;
        let mut LRset = context_tmp.read_LRset();
        LRset = u8::try_from((0u64 as i64)).unwrap();
        global_set.set_LRset(
            Some(u32::try_from(inst_next).unwrap()),
            u8::try_into(LRset).unwrap(),
        );
        context_tmp.write_LRset(LRset);
        *context = context_current;
        Some((inst_len, Self { COND, addrmode2 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3991:1"]
#[derive(Clone, Debug)]
pub struct instructionVar132 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar132 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (4u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3981:1"]
#[derive(Clone, Debug)]
pub struct instructionVar133 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar133 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (4u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (13u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3971:1"]
#[derive(Clone, Debug)]
pub struct instructionVar134 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar134 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (3u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (13u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3961:1"]
#[derive(Clone, Debug)]
pub struct instructionVar135 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar135 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (13u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3951:1"]
#[derive(Clone, Debug)]
pub struct instructionVar136 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar136 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (13u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3941:1"]
#[derive(Clone, Debug)]
pub struct instructionVar137 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar137 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (13u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3931:1"]
#[derive(Clone, Debug)]
pub struct instructionVar138 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar138 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (8u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3921:1"]
#[derive(Clone, Debug)]
pub struct instructionVar139 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar139 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (8u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3911:1"]
#[derive(Clone, Debug)]
pub struct instructionVar140 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar140 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (8u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3901:1"]
#[derive(Clone, Debug)]
pub struct instructionVar141 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar141 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (14u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3891:1"]
#[derive(Clone, Debug)]
pub struct instructionVar142 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar142 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (14u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3881:1"]
#[derive(Clone, Debug)]
pub struct instructionVar143 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar143 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (10u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (5u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3871:1"]
#[derive(Clone, Debug)]
pub struct instructionVar144 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar144 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (10u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (4u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3861:1"]
#[derive(Clone, Debug)]
pub struct instructionVar145 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar145 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (10u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3851:1"]
#[derive(Clone, Debug)]
pub struct instructionVar146 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar146 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (10u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3841:1"]
#[derive(Clone, Debug)]
pub struct instructionVar147 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar147 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (10u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3831:1"]
#[derive(Clone, Debug)]
pub struct instructionVar148 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar148 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (6u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3821:1"]
#[derive(Clone, Debug)]
pub struct instructionVar149 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar149 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (6u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3811:1"]
#[derive(Clone, Debug)]
pub struct instructionVar150 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar150 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (6u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3801:1"]
#[derive(Clone, Debug)]
pub struct instructionVar151 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar151 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (5u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (4u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3791:1"]
#[derive(Clone, Debug)]
pub struct instructionVar152 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar152 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (5u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3781:1"]
#[derive(Clone, Debug)]
pub struct instructionVar153 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar153 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (5u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3771:1"]
#[derive(Clone, Debug)]
pub struct instructionVar154 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar154 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (4u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3761:1"]
#[derive(Clone, Debug)]
pub struct instructionVar155 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar155 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (6u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3751:1"]
#[derive(Clone, Debug)]
pub struct instructionVar156 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar156 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (6u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3741:1"]
#[derive(Clone, Debug)]
pub struct instructionVar157 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar157 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (5u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3731:1"]
#[derive(Clone, Debug)]
pub struct instructionVar158 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar158 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (5u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3721:1"]
#[derive(Clone, Debug)]
pub struct instructionVar159 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar159 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (3u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3711:1"]
#[derive(Clone, Debug)]
pub struct instructionVar160 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar160 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3701:1"]
#[derive(Clone, Debug)]
pub struct instructionVar161 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar161 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3691:1"]
#[derive(Clone, Debug)]
pub struct instructionVar162 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar162 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3681:1"]
#[derive(Clone, Debug)]
pub struct instructionVar163 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar163 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3671:1"]
#[derive(Clone, Debug)]
pub struct instructionVar164 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar164 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3661:1"]
#[derive(Clone, Debug)]
pub struct instructionVar165 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar165 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3651:1"]
#[derive(Clone, Debug)]
pub struct instructionVar166 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar166 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3641:1"]
#[derive(Clone, Debug)]
pub struct instructionVar167 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar167 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3631:1"]
#[derive(Clone, Debug)]
pub struct instructionVar168 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar168 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3621:1"]
#[derive(Clone, Debug)]
pub struct instructionVar169 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar169 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (3u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3611:1"]
#[derive(Clone, Debug)]
pub struct instructionVar170 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar170 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3601:1"]
#[derive(Clone, Debug)]
pub struct instructionVar171 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar171 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3591:1"]
#[derive(Clone, Debug)]
pub struct instructionVar172 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar172 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3280:1"]
#[derive(Clone, Debug)]
pub struct instructionVar173 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar173 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (4u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3271:1"]
#[derive(Clone, Debug)]
pub struct instructionVar174 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar174 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (4u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (13u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3262:1"]
#[derive(Clone, Debug)]
pub struct instructionVar175 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar175 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (3u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (13u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3253:1"]
#[derive(Clone, Debug)]
pub struct instructionVar176 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar176 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (13u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3244:1"]
#[derive(Clone, Debug)]
pub struct instructionVar177 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar177 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (13u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3235:1"]
#[derive(Clone, Debug)]
pub struct instructionVar178 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar178 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (13u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3226:1"]
#[derive(Clone, Debug)]
pub struct instructionVar179 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar179 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (8u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3217:1"]
#[derive(Clone, Debug)]
pub struct instructionVar180 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar180 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (8u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3208:1"]
#[derive(Clone, Debug)]
pub struct instructionVar181 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar181 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (8u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3199:1"]
#[derive(Clone, Debug)]
pub struct instructionVar182 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar182 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (14u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3190:1"]
#[derive(Clone, Debug)]
pub struct instructionVar183 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar183 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (14u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3181:1"]
#[derive(Clone, Debug)]
pub struct instructionVar184 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar184 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (10u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (5u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3172:1"]
#[derive(Clone, Debug)]
pub struct instructionVar185 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar185 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (10u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (4u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3163:1"]
#[derive(Clone, Debug)]
pub struct instructionVar186 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar186 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (10u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3154:1"]
#[derive(Clone, Debug)]
pub struct instructionVar187 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar187 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (10u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3145:1"]
#[derive(Clone, Debug)]
pub struct instructionVar188 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar188 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (10u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3136:1"]
#[derive(Clone, Debug)]
pub struct instructionVar189 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar189 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (6u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3127:1"]
#[derive(Clone, Debug)]
pub struct instructionVar190 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar190 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (6u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3118:1"]
#[derive(Clone, Debug)]
pub struct instructionVar191 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar191 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (6u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3109:1"]
#[derive(Clone, Debug)]
pub struct instructionVar192 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar192 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (5u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (4u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3100:1"]
#[derive(Clone, Debug)]
pub struct instructionVar193 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar193 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (5u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3091:1"]
#[derive(Clone, Debug)]
pub struct instructionVar194 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar194 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (5u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3082:1"]
#[derive(Clone, Debug)]
pub struct instructionVar195 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar195 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (4u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3073:1"]
#[derive(Clone, Debug)]
pub struct instructionVar196 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar196 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (6u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3064:1"]
#[derive(Clone, Debug)]
pub struct instructionVar197 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar197 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (6u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3055:1"]
#[derive(Clone, Debug)]
pub struct instructionVar198 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar198 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (5u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3046:1"]
#[derive(Clone, Debug)]
pub struct instructionVar199 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar199 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (5u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3037:1"]
#[derive(Clone, Debug)]
pub struct instructionVar200 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar200 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (3u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3028:1"]
#[derive(Clone, Debug)]
pub struct instructionVar201 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar201 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3019:1"]
#[derive(Clone, Debug)]
pub struct instructionVar202 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar202 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3010:1"]
#[derive(Clone, Debug)]
pub struct instructionVar203 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar203 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3001:1"]
#[derive(Clone, Debug)]
pub struct instructionVar204 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar204 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2992:1"]
#[derive(Clone, Debug)]
pub struct instructionVar205 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar205 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2983:1"]
#[derive(Clone, Debug)]
pub struct instructionVar206 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar206 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2974:1"]
#[derive(Clone, Debug)]
pub struct instructionVar207 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar207 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2965:1"]
#[derive(Clone, Debug)]
pub struct instructionVar208 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar208 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2956:1"]
#[derive(Clone, Debug)]
pub struct instructionVar209 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar209 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2947:1"]
#[derive(Clone, Debug)]
pub struct instructionVar210 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar210 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (3u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2938:1"]
#[derive(Clone, Debug)]
pub struct instructionVar211 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar211 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2929:1"]
#[derive(Clone, Debug)]
pub struct instructionVar212 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar212 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2920:1"]
#[derive(Clone, Debug)]
pub struct instructionVar213 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar213 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc2() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4078:1"]
#[derive(Clone, Debug)]
pub struct instructionVar214 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar214 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let opc2 = token_parser.opc2();
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (10u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd, opc2), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd, opc2), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4067:1"]
#[derive(Clone, Debug)]
pub struct instructionVar215 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar215 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let opc2 = token_parser.opc2();
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (5u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (opc2, Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (opc2, Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4056:1"]
#[derive(Clone, Debug)]
pub struct instructionVar216 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar216 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let opc2 = token_parser.opc2();
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (opc2, Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (opc2, Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4045:1"]
#[derive(Clone, Debug)]
pub struct instructionVar217 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar217 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let opc2 = token_parser.opc2();
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd, opc2), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd, opc2), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4034:1"]
#[derive(Clone, Debug)]
pub struct instructionVar218 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar218 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let opc2 = token_parser.opc2();
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (opc2, Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (opc2, Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4023:1"]
#[derive(Clone, Debug)]
pub struct instructionVar219 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar219 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let opc2 = token_parser.opc2();
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (4u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (opc2, Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (opc2, Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4012:1"]
#[derive(Clone, Debug)]
pub struct instructionVar220 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar220 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let opc2 = token_parser.opc2();
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd, opc2), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd, opc2), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4001:1"]
#[derive(Clone, Debug)]
pub struct instructionVar221 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar221 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let opc2 = token_parser.opc2();
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd, opc2), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd, opc2), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3359:1"]
#[derive(Clone, Debug)]
pub struct instructionVar222 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar222 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let opc2 = token_parser.opc2();
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (10u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (opc2, Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (opc2, Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3349:1"]
#[derive(Clone, Debug)]
pub struct instructionVar223 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar223 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let opc2 = token_parser.opc2();
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (5u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd, opc2), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd, opc2), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3339:1"]
#[derive(Clone, Debug)]
pub struct instructionVar224 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar224 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let opc2 = token_parser.opc2();
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd, opc2), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd, opc2), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3329:1"]
#[derive(Clone, Debug)]
pub struct instructionVar225 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar225 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let opc2 = token_parser.opc2();
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd, opc2), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd, opc2), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3319:1"]
#[derive(Clone, Debug)]
pub struct instructionVar226 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar226 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let opc2 = token_parser.opc2();
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd, opc2), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd, opc2), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3309:1"]
#[derive(Clone, Debug)]
pub struct instructionVar227 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar227 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let opc2 = token_parser.opc2();
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (4u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd, opc2), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd, opc2), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3299:1"]
#[derive(Clone, Debug)]
pub struct instructionVar228 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar228 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let opc2 = token_parser.opc2();
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (opc2, Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (opc2, Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3289:1"]
#[derive(Clone, Debug)]
pub struct instructionVar229 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar229 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let opc2 = token_parser.opc2();
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRm() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (opc2, Rd), block_len))
        };
        let ((mut COND, mut mcrOperands), (opc2, Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4089:1"]
#[derive(Clone, Debug)]
pub struct instructionVar230 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar230 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let CRm = token_parser.CRm();
            let opc2 = token_parser.opc2();
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (opc2, CRm, Rd), block_len))
        };
        let ((mut mcrOperands, mut COND), (opc2, CRm, Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3369:1"]
#[derive(Clone, Debug)]
pub struct instructionVar231 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar231 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let CRm = token_parser.CRm();
            let opc2 = token_parser.opc2();
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.opc1() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (CRm, Rd, opc2), block_len))
        };
        let ((mut COND, mut mcrOperands), (CRm, Rd, opc2), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5553:1"]
#[derive(Clone, Debug)]
pub struct instructionVar232 {
    addrmode2: addrmode2,
    COND: COND,
    Rd: u8,
}
impl instructionVar232 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            addrmode2,
            COND,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("strt")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        addrmode2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.B22() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (1u64 as i64) as u8 {
                return None;
            }
            let mut sub_pattern_c59 = |token, context: &mut T| {
                let mut block_len = 0 as u32;
                let mut context_current = context.clone();
                let mut token_current = token;
                let mut block_0 = |tokens, context: &mut T| {
                    let token_parser = TokenParser32::new(tokens)?;
                    block_len = 4u64 as u32;
                    if token_parser.I25() == (0u64 as i64) as u8 {
                        return Some(((), (), u32::try_from(0u64).unwrap()));
                    }
                    let mut sub_pattern_c68 = |token, context: &mut T| {
                        let mut block_len = 0 as u32;
                        let mut context_current = context.clone();
                        let mut token_current = token;
                        let mut block_0 = |tokens, context: &mut T| {
                            let mut block_len = 0 as u32;
                            let mut context_current = context.clone();
                            let token_parser = TokenParser32::new(tokens)?;
                            block_len = 4u64 as u32;
                            if token_parser.I25() != (1u64 as i64) as u8 {
                                return None;
                            }
                            if token_parser.c0404() != (0u64 as i64) as u8 {
                                return None;
                            }
                            *context = context_current;
                            Some(((), (), block_len))
                        };
                        let ((), (), block_len) =
                            block_0(token_current, &mut context_current)?;
                        token_current = &token_current
                            [usize::try_from(block_len).unwrap()..];
                        *context = context_current;
                        Some(((), (), block_len))
                    };
                    let mut context_current = context.clone();
                    if let Some(((), (), sub_pattern_len)) =
                        sub_pattern_c68(tokens, &mut context_current)
                    {
                        *context = context_current;
                        return Some(((), (), sub_pattern_len));
                    }
                    None
                };
                let ((), (), block_len) =
                    block_0(token_current, &mut context_current)?;
                token_current =
                    &token_current[usize::try_from(block_len).unwrap()..];
                *context = context_current;
                Some(((), (), block_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c59(tokens, &mut context_current)?;
            block_len = block_len.max(sub_len);
            let addrmode2 = if let Some((len, table)) = addrmode2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, addrmode2), (Rd), block_len))
        };
        let ((mut COND, mut addrmode2), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        addrmode2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                addrmode2,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5453:1"]
#[derive(Clone, Debug)]
pub struct instructionVar233 {
    addrmode2: addrmode2,
    COND: COND,
    Rd: u8,
}
impl instructionVar233 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            addrmode2,
            COND,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("strbt")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        addrmode2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.B22() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (0u64 as i64) as u8 {
                return None;
            }
            let mut sub_pattern_c58 = |token, context: &mut T| {
                let mut block_len = 0 as u32;
                let mut context_current = context.clone();
                let mut token_current = token;
                let mut block_0 = |tokens, context: &mut T| {
                    let token_parser = TokenParser32::new(tokens)?;
                    block_len = 4u64 as u32;
                    if token_parser.I25() == (0u64 as i64) as u8 {
                        return Some(((), (), u32::try_from(0u64).unwrap()));
                    }
                    let mut sub_pattern_c67 = |token, context: &mut T| {
                        let mut block_len = 0 as u32;
                        let mut context_current = context.clone();
                        let mut token_current = token;
                        let mut block_0 = |tokens, context: &mut T| {
                            let mut block_len = 0 as u32;
                            let mut context_current = context.clone();
                            let token_parser = TokenParser32::new(tokens)?;
                            block_len = 4u64 as u32;
                            if token_parser.I25() != (1u64 as i64) as u8 {
                                return None;
                            }
                            if token_parser.c0404() != (0u64 as i64) as u8 {
                                return None;
                            }
                            *context = context_current;
                            Some(((), (), block_len))
                        };
                        let ((), (), block_len) =
                            block_0(token_current, &mut context_current)?;
                        token_current = &token_current
                            [usize::try_from(block_len).unwrap()..];
                        *context = context_current;
                        Some(((), (), block_len))
                    };
                    let mut context_current = context.clone();
                    if let Some(((), (), sub_pattern_len)) =
                        sub_pattern_c67(tokens, &mut context_current)
                    {
                        *context = context_current;
                        return Some(((), (), sub_pattern_len));
                    }
                    None
                };
                let ((), (), block_len) =
                    block_0(token_current, &mut context_current)?;
                token_current =
                    &token_current[usize::try_from(block_len).unwrap()..];
                *context = context_current;
                Some(((), (), block_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c58(tokens, &mut context_current)?;
            block_len = block_len.max(sub_len);
            let addrmode2 = if let Some((len, table)) = addrmode2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, addrmode2), (Rd), block_len))
        };
        let ((mut COND, mut addrmode2), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        addrmode2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                addrmode2,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2897:1"]
#[derive(Clone, Debug)]
pub struct instructionVar234 {
    COND: COND,
    addrmode2: addrmode2,
    Rd: u8,
}
impl instructionVar234 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            addrmode2,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldrt")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        addrmode2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.B22() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (1u64 as i64) as u8 {
                return None;
            }
            let mut sub_pattern_c58 = |token, context: &mut T| {
                let mut block_len = 0 as u32;
                let mut context_current = context.clone();
                let mut token_current = token;
                let mut block_0 = |tokens, context: &mut T| {
                    let token_parser = TokenParser32::new(tokens)?;
                    block_len = 4u64 as u32;
                    if token_parser.I25() == (0u64 as i64) as u8 {
                        return Some(((), (), u32::try_from(0u64).unwrap()));
                    }
                    let mut sub_pattern_c67 = |token, context: &mut T| {
                        let mut block_len = 0 as u32;
                        let mut context_current = context.clone();
                        let mut token_current = token;
                        let mut block_0 = |tokens, context: &mut T| {
                            let mut block_len = 0 as u32;
                            let mut context_current = context.clone();
                            let token_parser = TokenParser32::new(tokens)?;
                            block_len = 4u64 as u32;
                            if token_parser.I25() != (1u64 as i64) as u8 {
                                return None;
                            }
                            if token_parser.c0404() != (0u64 as i64) as u8 {
                                return None;
                            }
                            *context = context_current;
                            Some(((), (), block_len))
                        };
                        let ((), (), block_len) =
                            block_0(token_current, &mut context_current)?;
                        token_current = &token_current
                            [usize::try_from(block_len).unwrap()..];
                        *context = context_current;
                        Some(((), (), block_len))
                    };
                    let mut context_current = context.clone();
                    if let Some(((), (), sub_pattern_len)) =
                        sub_pattern_c67(tokens, &mut context_current)
                    {
                        *context = context_current;
                        return Some(((), (), sub_pattern_len));
                    }
                    None
                };
                let ((), (), block_len) =
                    block_0(token_current, &mut context_current)?;
                token_current =
                    &token_current[usize::try_from(block_len).unwrap()..];
                *context = context_current;
                Some(((), (), block_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c58(tokens, &mut context_current)?;
            block_len = block_len.max(sub_len);
            let addrmode2 = if let Some((len, table)) = addrmode2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((addrmode2, COND), (Rd), block_len))
        };
        let ((mut addrmode2, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        addrmode2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                addrmode2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2793:1"]
#[derive(Clone, Debug)]
pub struct instructionVar235 {
    COND: COND,
    addrmode2: addrmode2,
    Rd: u8,
}
impl instructionVar235 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            addrmode2,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldrbt")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        addrmode2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2627() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.B22() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.W21() != (1u64 as i64) as u8 {
                return None;
            }
            let mut sub_pattern_c59 = |token, context: &mut T| {
                let mut block_len = 0 as u32;
                let mut context_current = context.clone();
                let mut token_current = token;
                let mut block_0 = |tokens, context: &mut T| {
                    let token_parser = TokenParser32::new(tokens)?;
                    block_len = 4u64 as u32;
                    if token_parser.I25() == (0u64 as i64) as u8 {
                        return Some(((), (), u32::try_from(0u64).unwrap()));
                    }
                    let mut sub_pattern_c68 = |token, context: &mut T| {
                        let mut block_len = 0 as u32;
                        let mut context_current = context.clone();
                        let mut token_current = token;
                        let mut block_0 = |tokens, context: &mut T| {
                            let mut block_len = 0 as u32;
                            let mut context_current = context.clone();
                            let token_parser = TokenParser32::new(tokens)?;
                            block_len = 4u64 as u32;
                            if token_parser.I25() != (1u64 as i64) as u8 {
                                return None;
                            }
                            if token_parser.c0404() != (0u64 as i64) as u8 {
                                return None;
                            }
                            *context = context_current;
                            Some(((), (), block_len))
                        };
                        let ((), (), block_len) =
                            block_0(token_current, &mut context_current)?;
                        token_current = &token_current
                            [usize::try_from(block_len).unwrap()..];
                        *context = context_current;
                        Some(((), (), block_len))
                    };
                    let mut context_current = context.clone();
                    if let Some(((), (), sub_pattern_len)) =
                        sub_pattern_c68(tokens, &mut context_current)
                    {
                        *context = context_current;
                        return Some(((), (), sub_pattern_len));
                    }
                    None
                };
                let ((), (), block_len) =
                    block_0(token_current, &mut context_current)?;
                token_current =
                    &token_current[usize::try_from(block_len).unwrap()..];
                *context = context_current;
                Some(((), (), block_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c59(tokens, &mut context_current)?;
            block_len = block_len.max(sub_len);
            let addrmode2 = if let Some((len, table)) = addrmode2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, addrmode2), (Rd), block_len))
        };
        let ((mut COND, mut addrmode2), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        addrmode2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                addrmode2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2802:1"]
#[derive(Clone, Debug)]
pub struct instructionVar236 {
    COND: COND,
    addrmode3: addrmode3,
    Rd2: u8,
    Rd: u8,
}
impl instructionVar236 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            addrmode3,
            Rd2,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldrd")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766867488(usize::try_from(*Rd2).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        addrmode3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            let Rd2 = token_parser.Rd2();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2527() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0407() != (13u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1212() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (0u64 as i64) as u8 {
                return None;
            }
            let addrmode3 = if let Some((len, table)) = addrmode3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((addrmode3, COND), (Rd, Rd2), block_len))
        };
        let ((mut addrmode3, mut COND), (Rd, Rd2), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        addrmode3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                addrmode3,
                Rd2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4130:1"]
#[derive(Clone, Debug)]
pub struct instructionVar237 {
    COND: COND,
    Rd: u8,
}
impl instructionVar237 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, Rd } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrs")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::spsr),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2027() != (20u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1619() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.offset_12() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((COND), (Rd), block_len))
        };
        let ((mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, Rd }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4123:1"]
#[derive(Clone, Debug)]
pub struct instructionVar238 {
    COND: COND,
    Rd: u8,
}
impl instructionVar238 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, Rd } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrs")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::cpsr),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2027() != (16u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1619() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.offset_12() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((COND), (Rd), block_len))
        };
        let ((mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, Rd }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4166:1"]
#[derive(Clone, Debug)]
pub struct instructionVar239 {
    rm: rm,
    COND: COND,
    spsrmask: spsrmask,
}
impl instructionVar239 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rm, COND, spsrmask } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("msr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        spsrmask.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        rm.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2027() != (22u64 as i64) as u8 {
                return None;
            }
            let spsrmask = if let Some((len, table)) = spsrmask::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c1215() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0811() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0407() != (0u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rm, COND, spsrmask), (), block_len))
        };
        let ((mut rm, mut COND, mut spsrmask), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        rm.disassembly(&mut context_current, inst_start, inst_next, global_set);
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        spsrmask.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { rm, COND, spsrmask }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4144:1"]
#[derive(Clone, Debug)]
pub struct instructionVar240 {
    COND: COND,
    rm: rm,
    cpsrmask: cpsrmask,
}
impl instructionVar240 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, rm, cpsrmask } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("msr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        cpsrmask.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        rm.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2027() != (18u64 as i64) as u8 {
                return None;
            }
            let cpsrmask = if let Some((len, table)) = cpsrmask::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c1215() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0811() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0407() != (0u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((cpsrmask, rm, COND), (), block_len))
        };
        let ((mut cpsrmask, mut rm, mut COND), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rm.disassembly(&mut context_current, inst_start, inst_next, global_set);
        cpsrmask.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, rm, cpsrmask }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5461:1"]
#[derive(Clone, Debug)]
pub struct instructionVar241 {
    COND: COND,
    addrmode3: addrmode3,
    Rd: u8,
}
impl instructionVar241 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            addrmode3,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("strh")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        addrmode3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2527() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0407() != (11u64 as i64) as u8 {
                return None;
            }
            let addrmode3 = if let Some((len, table)) = addrmode3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, addrmode3), (Rd), block_len))
        };
        let ((mut COND, mut addrmode3), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        addrmode3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                addrmode3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2879:1"]
#[derive(Clone, Debug)]
pub struct instructionVar242 {
    COND: COND,
    addrmode3: addrmode3,
    Rd: u8,
}
impl instructionVar242 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            addrmode3,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldrsh")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        addrmode3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2527() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0407() != (15u64 as i64) as u8 {
                return None;
            }
            let addrmode3 = if let Some((len, table)) = addrmode3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, addrmode3), (Rd), block_len))
        };
        let ((mut COND, mut addrmode3), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        addrmode3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                addrmode3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2862:1"]
#[derive(Clone, Debug)]
pub struct instructionVar243 {
    addrmode3: addrmode3,
    COND: COND,
    Rd: u8,
}
impl instructionVar243 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            addrmode3,
            COND,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldrsb")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        addrmode3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2527() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0407() != (13u64 as i64) as u8 {
                return None;
            }
            let addrmode3 = if let Some((len, table)) = addrmode3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((addrmode3, COND), (Rd), block_len))
        };
        let ((mut addrmode3, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        addrmode3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                addrmode3,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2845:1"]
#[derive(Clone, Debug)]
pub struct instructionVar244 {
    addrmode3: addrmode3,
    COND: COND,
    Rd: u8,
}
impl instructionVar244 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            addrmode3,
            COND,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldrh")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        addrmode3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2527() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0407() != (11u64 as i64) as u8 {
                return None;
            }
            let addrmode3 = if let Some((len, table)) = addrmode3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((addrmode3, COND), (Rd), block_len))
        };
        let ((mut addrmode3, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        addrmode3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                addrmode3,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3579:1"]
#[derive(Clone, Debug)]
pub struct instructionVar245 {
    opc2: u8,
    cpn: u8,
    Rd: u8,
    CRn: u8,
    CRm: u8,
    opc1: u8,
}
impl instructionVar245 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            opc2,
            cpn,
            Rd,
            CRn,
            CRm,
            opc1,
        } = self;
        let extend: [DisplayElement; 13usize] = [
            DisplayElement::Literal("mrc2"),
            DisplayElement::Literal(" "),
            meaning_94047773010576(usize::try_from(*cpn).unwrap()),
            DisplayElement::Literal(","),
            DisplayElement::Unsigned(true, u64::try_from(*opc1).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047768585360(usize::try_from(*CRn).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047768585360(usize::try_from(*CRm).unwrap()),
            DisplayElement::Literal(","),
            DisplayElement::Unsigned(true, u64::try_from(*opc2).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let opc1 = token_parser.opc1();
            let CRn = token_parser.CRn();
            let Rd = token_parser.Rd();
            let cpn = token_parser.cpn();
            let opc2 = token_parser.opc2();
            let CRm = token_parser.CRm();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cond() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (CRn, opc2, CRm, Rd, opc1, cpn), block_len))
        };
        let ((), (CRn, opc2, CRm, Rd, opc1, cpn), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        *context = context_current;
        Some((
            inst_len,
            Self {
                opc2,
                cpn,
                Rd,
                CRn,
                CRm,
                opc1,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:2907:1"]
#[derive(Clone, Debug)]
pub struct instructionVar246 {
    CRn: u8,
    cpn: u8,
    CRm: u8,
    opc2: u8,
    opc1: u8,
    Rd: u8,
}
impl instructionVar246 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            CRn,
            cpn,
            CRm,
            opc2,
            opc1,
            Rd,
        } = self;
        let extend: [DisplayElement; 13usize] = [
            DisplayElement::Literal("mcr2"),
            DisplayElement::Literal(" "),
            meaning_94047773010576(usize::try_from(*cpn).unwrap()),
            DisplayElement::Literal(","),
            DisplayElement::Unsigned(true, u64::try_from(*opc1).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047768585360(usize::try_from(*CRn).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047768585360(usize::try_from(*CRm).unwrap()),
            DisplayElement::Literal(","),
            DisplayElement::Unsigned(true, u64::try_from(*opc2).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let opc1 = token_parser.opc1();
            let CRn = token_parser.CRn();
            let Rd = token_parser.Rd();
            let cpn = token_parser.cpn();
            let opc2 = token_parser.opc2();
            let CRm = token_parser.CRm();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.cond() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (CRm, cpn, Rd, opc1, CRn, opc2), block_len))
        };
        let ((), (CRm, cpn, Rd, opc1, CRn, opc2), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        *context = context_current;
        Some((
            inst_len,
            Self {
                CRn,
                cpn,
                CRm,
                opc2,
                opc1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4100:1"]
#[derive(Clone, Debug)]
pub struct instructionVar247 {
    mcrOperands: mcrOperands,
    COND: COND,
}
impl instructionVar247 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { mcrOperands, COND } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let CRm = token_parser.CRm();
            let opc2 = token_parser.opc2();
            let Rd = token_parser.Rd();
            let opc1 = token_parser.opc1();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((mcrOperands, COND), (Rd, opc2, opc1, CRm), block_len))
        };
        let ((mut mcrOperands, mut COND), (Rd, opc2, opc1, CRm), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3379:1"]
#[derive(Clone, Debug)]
pub struct instructionVar248 {
    COND: COND,
    mcrOperands: mcrOperands,
}
impl instructionVar248 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, mcrOperands } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        mcrOperands.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let CRm = token_parser.CRm();
            let opc2 = token_parser.opc2();
            let Rd = token_parser.Rd();
            let opc1 = token_parser.opc1();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.cpn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.CRn() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mcrOperands = if let Some((len, table)) = mcrOperands::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, mcrOperands), (Rd, opc2, CRm, opc1), block_len))
        };
        let ((mut COND, mut mcrOperands), (Rd, opc2, CRm, opc1), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        mcrOperands.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4113:1"]
#[derive(Clone, Debug)]
pub struct instructionVar249 {
    COND: COND,
    opc2: u8,
    cpn: u8,
    CRn: u8,
    Rd: u8,
    CRm: u8,
    opc1: u8,
}
impl instructionVar249 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            opc2,
            cpn,
            CRn,
            Rd,
            CRm,
            opc1,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 12usize] = [
            DisplayElement::Literal(" "),
            meaning_94047773010576(usize::try_from(*cpn).unwrap()),
            DisplayElement::Literal(","),
            DisplayElement::Unsigned(true, u64::try_from(*opc1).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047768585360(usize::try_from(*CRn).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047768585360(usize::try_from(*CRm).unwrap()),
            DisplayElement::Literal(","),
            DisplayElement::Unsigned(true, u64::try_from(*opc2).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let opc1 = token_parser.opc1();
            let CRn = token_parser.CRn();
            let Rd = token_parser.Rd();
            let cpn = token_parser.cpn();
            let opc2 = token_parser.opc2();
            let CRm = token_parser.CRm();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((COND), (CRn, opc1, CRm, Rd, cpn, opc2), block_len))
        };
        let ((mut COND), (CRn, opc1, CRm, Rd, cpn, opc2), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                opc2,
                cpn,
                CRn,
                Rd,
                CRm,
                opc1,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3391:1"]
#[derive(Clone, Debug)]
pub struct instructionVar250 {
    COND: COND,
    Rd: u8,
    cpn: u8,
    CRn: u8,
    CRm: u8,
    opc2: u8,
    opc1: u8,
}
impl instructionVar250 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            Rd,
            cpn,
            CRn,
            CRm,
            opc2,
            opc1,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 12usize] = [
            DisplayElement::Literal(" "),
            meaning_94047773010576(usize::try_from(*cpn).unwrap()),
            DisplayElement::Literal(","),
            DisplayElement::Unsigned(true, u64::try_from(*opc1).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047768585360(usize::try_from(*CRn).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047768585360(usize::try_from(*CRm).unwrap()),
            DisplayElement::Literal(","),
            DisplayElement::Unsigned(true, u64::try_from(*opc2).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let opc1 = token_parser.opc1();
            let CRn = token_parser.CRn();
            let Rd = token_parser.Rd();
            let cpn = token_parser.cpn();
            let opc2 = token_parser.opc2();
            let CRm = token_parser.CRm();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2427() != (14u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2020() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((COND), (Rd, CRm, cpn, CRn, opc2, opc1), block_len))
        };
        let ((mut COND), (Rd, CRm, cpn, CRn, opc2, opc1), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                Rd,
                cpn,
                CRn,
                CRm,
                opc2,
                opc1,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5679:1"]
#[derive(Clone, Debug)]
pub struct instructionVar251 {
    COND: COND,
    Rd: u8,
    Rn: u8,
    Rm: u8,
}
impl instructionVar251 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, Rd, Rn, Rm } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("swpb")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*Rm).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*Rn).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rn = token_parser.Rn();
            let Rd = token_parser.Rd();
            let Rm = token_parser.Rm();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2027() != (20u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0811() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0407() != (9u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((COND), (Rn, Rd, Rm), block_len))
        };
        let ((mut COND), (Rn, Rd, Rm), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, Rd, Rn, Rm }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5671:1"]
#[derive(Clone, Debug)]
pub struct instructionVar252 {
    COND: COND,
    Rd: u8,
    Rn: u8,
    Rm: u8,
}
impl instructionVar252 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, Rd, Rn, Rm } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("swp")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*Rm).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*Rn).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rn = token_parser.Rn();
            let Rd = token_parser.Rd();
            let Rm = token_parser.Rm();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2027() != (16u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0811() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0407() != (9u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((COND), (Rm, Rn, Rd), block_len))
        };
        let ((mut COND), (Rm, Rn, Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, Rd, Rn, Rm }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4462:1"]
#[derive(Clone, Debug)]
pub struct instructionVar253 {
    COND: COND,
    Rm: u8,
    Rn: u8,
    Rd: u8,
}
impl instructionVar253 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, Rm, Rn, Rd } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("qsub")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("   "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*Rm).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*Rn).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rn = token_parser.Rn();
            let Rd = token_parser.Rd();
            let Rm = token_parser.Rm();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2027() != (18u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0811() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0407() != (5u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((COND), (Rm, Rn, Rd), block_len))
        };
        let ((mut COND), (Rm, Rn, Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, Rm, Rn, Rd }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4427:1"]
#[derive(Clone, Debug)]
pub struct instructionVar254 {
    COND: COND,
    Rn: u8,
    Rd: u8,
    Rm: u8,
}
impl instructionVar254 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, Rn, Rd, Rm } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("qdsub")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*Rm).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*Rn).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rn = token_parser.Rn();
            let Rd = token_parser.Rd();
            let Rm = token_parser.Rm();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2027() != (22u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0811() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0407() != (5u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((COND), (Rm, Rd, Rn), block_len))
        };
        let ((mut COND), (Rm, Rd, Rn), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, Rn, Rd, Rm }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4415:1"]
#[derive(Clone, Debug)]
pub struct instructionVar255 {
    COND: COND,
    Rn: u8,
    Rd: u8,
    Rm: u8,
}
impl instructionVar255 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, Rn, Rd, Rm } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("qdadd")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("  "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*Rm).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*Rn).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rn = token_parser.Rn();
            let Rd = token_parser.Rd();
            let Rm = token_parser.Rm();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2027() != (20u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0811() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0407() != (5u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((COND), (Rn, Rd, Rm), block_len))
        };
        let ((mut COND), (Rn, Rd, Rm), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, Rn, Rd, Rm }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4347:1"]
#[derive(Clone, Debug)]
pub struct instructionVar256 {
    COND: COND,
    Rn: u8,
    Rd: u8,
    Rm: u8,
}
impl instructionVar256 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { COND, Rn, Rd, Rm } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("qadd")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("   "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*Rm).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*Rn).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rn = token_parser.Rn();
            let Rd = token_parser.Rd();
            let Rm = token_parser.Rm();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2027() != (16u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0811() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0407() != (5u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((COND), (Rm, Rd, Rn), block_len))
        };
        let ((mut COND), (Rm, Rd, Rn), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { COND, Rn, Rd, Rm }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3430:1"]
#[derive(Clone, Debug)]
pub struct instructionVar257 {
    COND: COND,
    cpn: u8,
    Rn: u8,
    opcode3: u8,
    CRm: u8,
    Rd: u8,
}
impl instructionVar257 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            cpn,
            Rn,
            opcode3,
            CRm,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("mrrc")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 10usize] = [
            DisplayElement::Literal("  "),
            meaning_94047773010576(usize::try_from(*cpn).unwrap()),
            DisplayElement::Literal(","),
            DisplayElement::Unsigned(true, u64::try_from(*opcode3).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*Rn).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047768585360(usize::try_from(*CRm).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let cpn = token_parser.cpn();
            let opcode3 = token_parser.opcode3();
            let Rd = token_parser.Rd();
            let Rn = token_parser.Rn();
            let CRm = token_parser.CRm();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2027() != (197u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND), (opcode3, Rd, cpn, CRm, Rn), block_len))
        };
        let ((mut COND), (opcode3, Rd, cpn, CRm, Rn), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                cpn,
                Rn,
                opcode3,
                CRm,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3422:1"]
#[derive(Clone, Debug)]
pub struct instructionVar258 {
    COND: COND,
    Rn: u8,
    Rd: u8,
    opcode3: u8,
    CRm: u8,
    cpn: u8,
}
impl instructionVar258 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            Rn,
            Rd,
            opcode3,
            CRm,
            cpn,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("mcrr")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 10usize] = [
            DisplayElement::Literal("  "),
            meaning_94047773010576(usize::try_from(*cpn).unwrap()),
            DisplayElement::Literal(","),
            DisplayElement::Unsigned(true, u64::try_from(*opcode3).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*Rn).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047768585360(usize::try_from(*CRm).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let cpn = token_parser.cpn();
            let opcode3 = token_parser.opcode3();
            let Rd = token_parser.Rd();
            let Rn = token_parser.Rn();
            let CRm = token_parser.CRm();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2027() != (196u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND), (cpn, opcode3, Rn, Rd, CRm), block_len))
        };
        let ((mut COND), (cpn, opcode3, Rn, Rd, CRm), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                Rn,
                Rd,
                opcode3,
                CRm,
                cpn,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5608:1"]
#[derive(Clone, Debug)]
pub struct instructionVar259 {
    shift1: shift1,
    rn: rn,
    COND: COND,
    SBIT_CZNO: SBIT_CZNO,
}
impl instructionVar259 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            shift1,
            rn,
            COND,
            SBIT_CZNO,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sub")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        shift1.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (2u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.Rn() != (14u64 as i64) as u8 {
                return None;
            }
            if token_parser.I25() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.immed() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.rotate() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift1 = if let Some((len, table)) = shift1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, SBIT_CZNO, rn, shift1), (), block_len))
        };
        let ((mut COND, mut SBIT_CZNO, mut rn, mut shift1), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        shift1.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                shift1,
                rn,
                COND,
                SBIT_CZNO,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5278:1"]
#[derive(Clone, Debug)]
pub struct instructionVar260 {
    COND: COND,
    SBIT_ZN: SBIT_ZN,
    smRm: u8,
    smRn: u8,
    RdLo: u8,
    RdHi: u8,
}
impl instructionVar260 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            SBIT_ZN,
            smRm,
            smRn,
            RdLo,
            RdHi,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smull")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_ZN.display_extend(display, context);
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*RdLo).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*RdHi).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*smRn).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*smRm).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let RdHi = token_parser.RdHi();
            let RdLo = token_parser.RdLo();
            let smRn = token_parser.smRn();
            let smRm = token_parser.smRm();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2527() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2124() != (6u64 as i64) as u8 {
                return None;
            }
            let SBIT_ZN = if let Some((len, table)) = SBIT_ZN::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c0407() != (9u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((SBIT_ZN, COND), (RdHi, smRn, RdLo, smRm), block_len))
        };
        let ((mut SBIT_ZN, mut COND), (RdHi, smRn, RdLo, smRm), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_ZN.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                SBIT_ZN,
                smRm,
                smRn,
                RdLo,
                RdHi,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5057:1"]
#[derive(Clone, Debug)]
pub struct instructionVar261 {
    SBIT_ZN: SBIT_ZN,
    COND: COND,
    smRn: u8,
    RdLo: u8,
    RdHi: u8,
    smRm: u8,
}
impl instructionVar261 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            SBIT_ZN,
            COND,
            smRn,
            RdLo,
            RdHi,
            smRm,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smlal")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_ZN.display_extend(display, context);
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal("  "),
            meaning_94047766862464(usize::try_from(*RdLo).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*RdHi).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*smRn).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*smRm).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let RdLo = token_parser.RdLo();
            let RdHi = token_parser.RdHi();
            let smRn = token_parser.smRn();
            let smRm = token_parser.smRm();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2527() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2124() != (7u64 as i64) as u8 {
                return None;
            }
            let SBIT_ZN = if let Some((len, table)) = SBIT_ZN::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c0407() != (9u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((SBIT_ZN, COND), (RdLo, smRm, RdHi, smRn), block_len))
        };
        let ((mut SBIT_ZN, mut COND), (RdLo, smRm, RdHi, smRn), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        SBIT_ZN.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                SBIT_ZN,
                COND,
                smRn,
                RdLo,
                RdHi,
                smRm,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3441:1"]
#[derive(Clone, Debug)]
pub struct instructionVar262 {
    COND: COND,
    SBIT_ZN: SBIT_ZN,
    Rd: u8,
    Rm: u8,
    Rn: u8,
    Rs: u8,
}
impl instructionVar262 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            SBIT_ZN,
            Rd,
            Rm,
            Rn,
            Rs,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mla")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_ZN.display_extend(display, context);
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rn).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*Rm).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*Rs).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rn = token_parser.Rn();
            let Rd = token_parser.Rd();
            let Rs = token_parser.Rs();
            let Rm = token_parser.Rm();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2527() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2124() != (1u64 as i64) as u8 {
                return None;
            }
            let SBIT_ZN = if let Some((len, table)) = SBIT_ZN::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c0407() != (9u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((COND, SBIT_ZN), (Rs, Rd, Rm, Rn), block_len))
        };
        let ((mut COND, mut SBIT_ZN), (Rs, Rd, Rm, Rn), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_ZN.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                SBIT_ZN,
                Rd,
                Rm,
                Rn,
                Rs,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4235:1"]
#[derive(Clone, Debug)]
pub struct instructionVar263 {
    COND: COND,
    shift3: shift3,
    SBIT_ZN: SBIT_ZN,
}
impl instructionVar263 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            shift3,
            SBIT_ZN,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mvn")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_ZN.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        shift3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (15u64 as i64) as u8 {
                return None;
            }
            let SBIT_ZN = if let Some((len, table)) = SBIT_ZN::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c1619() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift3 = if let Some((len, table)) = shift3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((SBIT_ZN, shift3, COND), (), block_len))
        };
        let ((mut SBIT_ZN, mut shift3, mut COND), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_ZN.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                shift3,
                SBIT_ZN,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4224:1"]
#[derive(Clone, Debug)]
pub struct instructionVar264 {
    SBIT_ZN: SBIT_ZN,
    COND: COND,
    shift2: shift2,
}
impl instructionVar264 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            SBIT_ZN,
            COND,
            shift2,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mvn")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_ZN.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        shift2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (15u64 as i64) as u8 {
                return None;
            }
            let SBIT_ZN = if let Some((len, table)) = SBIT_ZN::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c1619() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift2 = if let Some((len, table)) = shift2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((shift2, COND, SBIT_ZN), (), block_len))
        };
        let ((mut shift2, mut COND, mut SBIT_ZN), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        SBIT_ZN.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                SBIT_ZN,
                COND,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4213:1"]
#[derive(Clone, Debug)]
pub struct instructionVar265 {
    SBIT_ZN: SBIT_ZN,
    shift1: shift1,
    COND: COND,
}
impl instructionVar265 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            SBIT_ZN,
            shift1,
            COND,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mvn")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_ZN.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        shift1.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (15u64 as i64) as u8 {
                return None;
            }
            let SBIT_ZN = if let Some((len, table)) = SBIT_ZN::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c1619() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift1 = if let Some((len, table)) = shift1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((SBIT_ZN, COND, shift1), (), block_len))
        };
        let ((mut SBIT_ZN, mut COND, mut shift1), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        SBIT_ZN.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift1.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                SBIT_ZN,
                shift1,
                COND,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3534:1"]
#[derive(Clone, Debug)]
pub struct instructionVar266 {
    shift3: shift3,
    COND: COND,
    SBIT_CZNO: SBIT_CZNO,
}
impl instructionVar266 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            shift3,
            COND,
            SBIT_CZNO,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        shift3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (13u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c1619() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift3 = if let Some((len, table)) = shift3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((shift3, COND, SBIT_CZNO), (), block_len))
        };
        let ((mut shift3, mut COND, mut SBIT_CZNO), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        shift3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                shift3,
                COND,
                SBIT_CZNO,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3521:1"]
#[derive(Clone, Debug)]
pub struct instructionVar267 {
    shift2: shift2,
    SBIT_CZNO: SBIT_CZNO,
    COND: COND,
}
impl instructionVar267 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            shift2,
            SBIT_CZNO,
            COND,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        shift2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if context.read_LRset() != (1u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (13u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c1619() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift2 = if let Some((len, table)) = shift2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, SBIT_CZNO, shift2), (), block_len))
        };
        let ((mut COND, mut SBIT_CZNO, mut shift2), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        shift2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                shift2,
                SBIT_CZNO,
                COND,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3509:1"]
#[derive(Clone, Debug)]
pub struct instructionVar268 {
    shift2: shift2,
    SBIT_CZNO: SBIT_CZNO,
    COND: COND,
}
impl instructionVar268 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            shift2,
            SBIT_CZNO,
            COND,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        shift2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (13u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c1619() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift2 = if let Some((len, table)) = shift2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((shift2, SBIT_CZNO, COND), (), block_len))
        };
        let ((mut shift2, mut SBIT_CZNO, mut COND), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        shift2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                shift2,
                SBIT_CZNO,
                COND,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3496:1"]
#[derive(Clone, Debug)]
pub struct instructionVar269 {
    SBIT_CZNO: SBIT_CZNO,
    shift1: shift1,
    COND: COND,
}
impl instructionVar269 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            SBIT_CZNO,
            shift1,
            COND,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::pc),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        shift1.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (13u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c1619() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.Rd() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift1 = if let Some((len, table)) = shift1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((shift1, COND, SBIT_CZNO), (), block_len))
        };
        let ((mut shift1, mut COND, mut SBIT_CZNO), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift1.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                SBIT_CZNO,
                shift1,
                COND,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4203:1"]
#[derive(Clone, Debug)]
pub struct instructionVar270 {
    COND: COND,
    SBIT_CZNO: SBIT_CZNO,
    shift3: shift3,
    Rd: u8,
}
impl instructionVar270 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            SBIT_CZNO,
            shift3,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mvn")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        shift3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (15u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c1619() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift3 = if let Some((len, table)) = shift3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, SBIT_CZNO, shift3), (Rd), block_len))
        };
        let ((mut COND, mut SBIT_CZNO, mut shift3), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                SBIT_CZNO,
                shift3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4193:1"]
#[derive(Clone, Debug)]
pub struct instructionVar271 {
    shift2: shift2,
    COND: COND,
    SBIT_CZNO: SBIT_CZNO,
    Rd: u8,
}
impl instructionVar271 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            shift2,
            COND,
            SBIT_CZNO,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mvn")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        shift2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (15u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c1619() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift2 = if let Some((len, table)) = shift2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, shift2, SBIT_CZNO), (Rd), block_len))
        };
        let ((mut COND, mut shift2, mut SBIT_CZNO), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        shift2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                shift2,
                COND,
                SBIT_CZNO,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4183:1"]
#[derive(Clone, Debug)]
pub struct instructionVar272 {
    COND: COND,
    SBIT_CZNO: SBIT_CZNO,
    shift1: shift1,
    Rd: u8,
}
impl instructionVar272 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            SBIT_CZNO,
            shift1,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mvn")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        shift1.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (15u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c1619() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift1 = if let Some((len, table)) = shift1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, SBIT_CZNO, shift1), (Rd), block_len))
        };
        let ((mut COND, mut SBIT_CZNO, mut shift1), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift1.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                SBIT_CZNO,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3486:1"]
#[derive(Clone, Debug)]
pub struct instructionVar273 {
    COND: COND,
    shift3: shift3,
    SBIT_CZNO: SBIT_CZNO,
    Rd: u8,
}
impl instructionVar273 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            shift3,
            SBIT_CZNO,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        shift3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (13u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c1619() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift3 = if let Some((len, table)) = shift3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, SBIT_CZNO, shift3), (Rd), block_len))
        };
        let ((mut COND, mut SBIT_CZNO, mut shift3), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                shift3,
                SBIT_CZNO,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3468:1"]
#[derive(Clone, Debug)]
pub struct instructionVar274 {
    COND: COND,
    SBIT_CZNO: SBIT_CZNO,
    shift2: shift2,
    Rd: u8,
}
impl instructionVar274 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            SBIT_CZNO,
            shift2,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        shift2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (13u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c1619() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift2 = if let Some((len, table)) = shift2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((SBIT_CZNO, shift2, COND), (Rd), block_len))
        };
        let ((mut SBIT_CZNO, mut shift2, mut COND), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        shift2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                SBIT_CZNO,
                shift2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3458:1"]
#[derive(Clone, Debug)]
pub struct instructionVar275 {
    shift1: shift1,
    COND: COND,
    SBIT_CZNO: SBIT_CZNO,
    Rd: u8,
}
impl instructionVar275 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            shift1,
            COND,
            SBIT_CZNO,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_CZNO.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        shift1.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2124() != (13u64 as i64) as u8 {
                return None;
            }
            let SBIT_CZNO = if let Some((len, table)) = SBIT_CZNO::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c1619() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2627() != (0u64 as i64) as u8 {
                return None;
            }
            let shift1 = if let Some((len, table)) = shift1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, SBIT_CZNO, shift1), (Rd), block_len))
        };
        let ((mut COND, mut SBIT_CZNO, mut shift1), (Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        shift1.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        SBIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                shift1,
                COND,
                SBIT_CZNO,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:2952:1"]
#[derive(Clone, Debug)]
pub struct instructionVar276 {
    ItCond: ItCond,
}
impl instructionVar276 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ItCond } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("nop")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(".w")];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op0() != (62383u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (), block_len))
        };
        let ((mut ItCond), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.op0() != (32768u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { ItCond }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:3478:1"]
#[derive(Clone, Debug)]
pub struct instructionVar277 {}
impl instructionVar277 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("mov"),
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::lr),
            DisplayElement::Literal(","),
            DisplayElement::Register(Register::pc),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0031() != (3785416719u64 as i64) as u32 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        let context_tmp = &mut context_current;
        let mut LRset = context_tmp.read_LRset();
        LRset = u8::try_from((1u64 as i64)).unwrap();
        global_set.set_LRset(
            Some(u32::try_from(inst_next).unwrap()),
            u8::try_into(LRset).unwrap(),
        );
        context_tmp.write_LRset(LRset);
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:4173:1"]
#[derive(Clone, Debug)]
pub struct instructionVar278 {
    rs: rs,
    SBIT_ZN: SBIT_ZN,
    rm: rm,
    rn: rn,
    COND: COND,
}
impl instructionVar278 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            rs,
            SBIT_ZN,
            rm,
            rn,
            COND,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mul")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_ZN.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        rm.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        rs.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2527() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2124() != (0u64 as i64) as u8 {
                return None;
            }
            let SBIT_ZN = if let Some((len, table)) = SBIT_ZN::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c1215() != (0u64 as i64) as u8 {
                return None;
            }
            let rs = if let Some((len, table)) =
                rs::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c0407() != (9u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((SBIT_ZN, rm, rn, COND, rs), (), block_len))
        };
        let ((mut SBIT_ZN, mut rm, mut rn, mut COND, mut rs), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        rs.disassembly(&mut context_current, inst_start, inst_next, global_set);
        SBIT_ZN.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rm.disassembly(&mut context_current, inst_start, inst_next, global_set);
        rn.disassembly(&mut context_current, inst_start, inst_next, global_set);
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                rs,
                SBIT_ZN,
                rm,
                rn,
                COND,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5423:1"]
#[derive(Clone, Debug)]
pub struct instructionVar279 {
    mdir: mdir,
    reglist: reglist,
    COND: COND,
}
impl instructionVar279 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            mdir,
            reglist,
            COND,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("stm")];
        display.extend_from_slice(&extend);
        mdir.display_extend(display, context);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" ")];
        display.extend_from_slice(&extend);
        reglist.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2527() != (4u64 as i64) as u8 {
                return None;
            }
            let mdir = if let Some((len, table)) = mdir::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.L20() != (0u64 as i64) as u8 {
                return None;
            }
            let reglist = if let Some((len, table)) = reglist::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((reglist, mdir, COND), (), block_len))
        };
        let ((mut reglist, mut mdir, mut COND), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        mdir.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        reglist.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                mdir,
                reglist,
                COND,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:5471:1"]
#[derive(Clone, Debug)]
pub struct instructionVar280 {
    COND: COND,
    addrmode3: addrmode3,
    Rd2: u8,
    Rd: u8,
}
impl instructionVar280 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            addrmode3,
            Rd2,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("strd")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766867488(usize::try_from(*Rd2).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        addrmode3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rd = token_parser.Rd();
            let Rd2 = token_parser.Rd2();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2527() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0407() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.L20() != (0u64 as i64) as u8 {
                return None;
            }
            let addrmode3 = if let Some((len, table)) = addrmode3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((addrmode3, COND), (Rd, Rd2), block_len))
        };
        let ((mut addrmode3, mut COND), (Rd, Rd2), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        addrmode3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                addrmode3,
                Rd2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:6079:1"]
#[derive(Clone, Debug)]
pub struct instructionVar281 {
    COND: COND,
    rs: rs,
    SBIT_ZN: SBIT_ZN,
    rm: rm,
    Rd: u8,
    Rn: u8,
}
impl instructionVar281 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            COND,
            rs,
            SBIT_ZN,
            rm,
            Rd,
            Rn,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("umull")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_ZN.display_extend(display, context);
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal(" "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*Rn).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rm.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        rs.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rn = token_parser.Rn();
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2527() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2124() != (4u64 as i64) as u8 {
                return None;
            }
            let SBIT_ZN = if let Some((len, table)) = SBIT_ZN::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rs = if let Some((len, table)) =
                rs::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c0407() != (9u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((COND, rm, rs, SBIT_ZN), (Rn, Rd), block_len))
        };
        let ((mut COND, mut rm, mut rs, mut SBIT_ZN), (Rn, Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rs.disassembly(&mut context_current, inst_start, inst_next, global_set);
        SBIT_ZN.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rm.disassembly(&mut context_current, inst_start, inst_next, global_set);
        *context = context_current;
        Some((
            inst_len,
            Self {
                COND,
                rs,
                SBIT_ZN,
                rm,
                Rd,
                Rn,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:6064:1"]
#[derive(Clone, Debug)]
pub struct instructionVar282 {
    SBIT_ZN: SBIT_ZN,
    rs: rs,
    COND: COND,
    rm: rm,
    Rn: u8,
    Rd: u8,
}
impl instructionVar282 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            SBIT_ZN,
            rs,
            COND,
            rm,
            Rn,
            Rd,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("umlal")];
        display.extend_from_slice(&extend);
        COND.display_extend(display, context);
        SBIT_ZN.display_extend(display, context);
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("  "),
            meaning_94047766862464(usize::try_from(*Rd).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047766862464(usize::try_from(*Rn).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        rm.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        rs.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rn = token_parser.Rn();
            let Rd = token_parser.Rd();
            if context.read_TMode() != (0u64 as i64) as u8 {
                return None;
            }
            let COND = if let Some((len, table)) = COND::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c2527() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2124() != (5u64 as i64) as u8 {
                return None;
            }
            let SBIT_ZN = if let Some((len, table)) = SBIT_ZN::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let rs = if let Some((len, table)) =
                rs::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c0407() != (9u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((SBIT_ZN, rs, COND, rm), (Rn, Rd), block_len))
        };
        let ((mut SBIT_ZN, mut rs, mut COND, mut rm), (Rn, Rd), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        SBIT_ZN.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rs.disassembly(&mut context_current, inst_start, inst_next, global_set);
        COND.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        rm.disassembly(&mut context_current, inst_start, inst_next, global_set);
        *context = context_current;
        Some((
            inst_len,
            Self {
                SBIT_ZN,
                rs,
                COND,
                rm,
                Rn,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1413:1"]
#[derive(Clone, Debug)]
pub struct instructionVar283 {
    ItCond: ItCond,
    thc0003: u8,
}
impl instructionVar283 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ItCond, thc0003 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("smc")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#"),
            DisplayElement::Unsigned(true, u64::try_from(*thc0003).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let thc0003 = token_parser.thc0003();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op4() != (3967u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (thc0003), block_len))
        };
        let ((mut ItCond), (thc0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.op12() != (8u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { ItCond, thc0003 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1523:1"]
#[derive(Clone, Debug)]
pub struct instructionVar284 {
    ItCond: ItCond,
    bxns: bxns,
    Hrm0305: Hrm0305,
}
impl instructionVar284 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            bxns,
            Hrm0305,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bx")];
        display.extend_from_slice(&extend);
        bxns.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("\t")];
        display.extend_from_slice(&extend);
        Hrm0305.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op7() != (142u64 as i64) as u16 {
                return None;
            }
            let Hrm0305 = if let Some((len, table)) = Hrm0305::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.hrm0305() != (6u64 as i64) as u8 {
                return None;
            }
            if token_parser.h2() != (1u64 as i64) as u8 {
                return None;
            }
            let bxns = if let Some((len, table)) = bxns::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, Hrm0305, bxns), (), block_len))
        };
        let ((mut ItCond, mut Hrm0305, mut bxns), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        bxns.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        Hrm0305.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                bxns,
                Hrm0305,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:4797:1"]
#[derive(Clone, Debug)]
pub struct instructionVar285 {
    ItCond: ItCond,
    Rn0002: u8,
    Rm0305: u8,
}
impl instructionVar285 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            Rn0002,
            Rm0305,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("tst")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rn0002).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047783056016(usize::try_from(*Rm0305).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rm0305 = token_parser.Rm0305();
            let Rn0002 = token_parser.Rn0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op6() != (264u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (Rm0305, Rn0002), block_len))
        };
        let ((mut ItCond), (Rm0305, Rn0002), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                Rn0002,
                Rm0305,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3697:1"]
#[derive(Clone, Debug)]
pub struct instructionVar286 {
    ItCond: ItCond,
    CheckInIT_CZNO: CheckInIT_CZNO,
    Rm0305: u8,
    Rd0002: u8,
}
impl instructionVar286 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            CheckInIT_CZNO,
            Rm0305,
            Rd0002,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sbc")];
        display.extend_from_slice(&extend);
        CheckInIT_CZNO.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047783056016(usize::try_from(*Rm0305).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rm0305 = token_parser.Rm0305();
            let Rd0002 = token_parser.Rd0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op6() != (262u64 as i64) as u16 {
                return None;
            }
            let CheckInIT_CZNO = if let Some((len, table)) =
                CheckInIT_CZNO::parse(
                    tokens,
                    &mut context_current,
                    inst_start,
                    global_set,
                ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, CheckInIT_CZNO), (Rm0305, Rd0002), block_len))
        };
        let ((mut ItCond, mut CheckInIT_CZNO), (Rm0305, Rd0002), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        CheckInIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                CheckInIT_CZNO,
                Rm0305,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3597:1"]
#[derive(Clone, Debug)]
pub struct instructionVar287 {
    CheckInIT_CZN: CheckInIT_CZN,
    ItCond: ItCond,
    Rd0002: u8,
    Rs0305: u8,
}
impl instructionVar287 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            CheckInIT_CZN,
            ItCond,
            Rd0002,
            Rs0305,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ror")];
        display.extend_from_slice(&extend);
        CheckInIT_CZN.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047783056016(usize::try_from(*Rs0305).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rs0305 = token_parser.Rs0305();
            let Rd0002 = token_parser.Rd0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op6() != (263u64 as i64) as u16 {
                return None;
            }
            let CheckInIT_CZN = if let Some((len, table)) = CheckInIT_CZN::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((CheckInIT_CZN, ItCond), (Rs0305, Rd0002), block_len))
        };
        let ((mut CheckInIT_CZN, mut ItCond), (Rs0305, Rd0002), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        CheckInIT_CZN.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                CheckInIT_CZN,
                ItCond,
                Rd0002,
                Rs0305,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3410:1"]
#[derive(Clone, Debug)]
pub struct instructionVar288 {
    ItCond: ItCond,
    CheckInIT_CZNO: CheckInIT_CZNO,
    Rm0305: u8,
    Rd0002: u8,
}
impl instructionVar288 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            CheckInIT_CZNO,
            Rm0305,
            Rd0002,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("rsb")];
        display.extend_from_slice(&extend);
        CheckInIT_CZNO.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047783056016(usize::try_from(*Rm0305).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rm0305 = token_parser.Rm0305();
            let Rd0002 = token_parser.Rd0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op6() != (265u64 as i64) as u16 {
                return None;
            }
            let CheckInIT_CZNO = if let Some((len, table)) =
                CheckInIT_CZNO::parse(
                    tokens,
                    &mut context_current,
                    inst_start,
                    global_set,
                ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, CheckInIT_CZNO), (Rm0305, Rd0002), block_len))
        };
        let ((mut ItCond, mut CheckInIT_CZNO), (Rm0305, Rd0002), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        CheckInIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                CheckInIT_CZNO,
                Rm0305,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:2960:1"]
#[derive(Clone, Debug)]
pub struct instructionVar289 {
    CheckInIT_ZN: CheckInIT_ZN,
    ItCond: ItCond,
    Rm0305: u8,
    Rd0002: u8,
}
impl instructionVar289 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            CheckInIT_ZN,
            ItCond,
            Rm0305,
            Rd0002,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("orr")];
        display.extend_from_slice(&extend);
        CheckInIT_ZN.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047783056016(usize::try_from(*Rm0305).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rm0305 = token_parser.Rm0305();
            let Rd0002 = token_parser.Rd0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op6() != (268u64 as i64) as u16 {
                return None;
            }
            let CheckInIT_ZN = if let Some((len, table)) = CheckInIT_ZN::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, CheckInIT_ZN), (Rm0305, Rd0002), block_len))
        };
        let ((mut ItCond, mut CheckInIT_ZN), (Rm0305, Rd0002), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        CheckInIT_ZN.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                CheckInIT_ZN,
                ItCond,
                Rm0305,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:2940:1"]
#[derive(Clone, Debug)]
pub struct instructionVar290 {
    CheckInIT_ZN: CheckInIT_ZN,
    ItCond: ItCond,
    Rd0002: u8,
    Rm0305: u8,
}
impl instructionVar290 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            CheckInIT_ZN,
            ItCond,
            Rd0002,
            Rm0305,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mvn")];
        display.extend_from_slice(&extend);
        CheckInIT_ZN.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047783056016(usize::try_from(*Rm0305).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rm0305 = token_parser.Rm0305();
            let Rd0002 = token_parser.Rd0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op6() != (271u64 as i64) as u16 {
                return None;
            }
            let CheckInIT_ZN = if let Some((len, table)) = CheckInIT_ZN::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((CheckInIT_ZN, ItCond), (Rd0002, Rm0305), block_len))
        };
        let ((mut CheckInIT_ZN, mut ItCond), (Rd0002, Rm0305), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        CheckInIT_ZN.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                CheckInIT_ZN,
                ItCond,
                Rd0002,
                Rm0305,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:2910:1"]
#[derive(Clone, Debug)]
pub struct instructionVar291 {
    CheckInIT_ZN: CheckInIT_ZN,
    ItCond: ItCond,
    Rd0002: u8,
    Rm0305: u8,
}
impl instructionVar291 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            CheckInIT_ZN,
            ItCond,
            Rd0002,
            Rm0305,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mul")];
        display.extend_from_slice(&extend);
        CheckInIT_ZN.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047783056016(usize::try_from(*Rm0305).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rm0305 = token_parser.Rm0305();
            let Rd0002 = token_parser.Rd0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op6() != (269u64 as i64) as u16 {
                return None;
            }
            let CheckInIT_ZN = if let Some((len, table)) = CheckInIT_ZN::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, CheckInIT_ZN), (Rm0305, Rd0002), block_len))
        };
        let ((mut ItCond, mut CheckInIT_ZN), (Rm0305, Rd0002), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        CheckInIT_ZN.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                CheckInIT_ZN,
                ItCond,
                Rd0002,
                Rm0305,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:2510:1"]
#[derive(Clone, Debug)]
pub struct instructionVar292 {
    CheckInIT_ZN: CheckInIT_ZN,
    ItCond: ItCond,
    Rd0002: u8,
    Rn0305: u8,
}
impl instructionVar292 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            CheckInIT_ZN,
            ItCond,
            Rd0002,
            Rn0305,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        CheckInIT_ZN.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047783056016(usize::try_from(*Rn0305).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0305 = token_parser.Rn0305();
            let Rd0002 = token_parser.Rd0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op6() != (0u64 as i64) as u16 {
                return None;
            }
            let CheckInIT_ZN = if let Some((len, table)) = CheckInIT_ZN::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, CheckInIT_ZN), (Rd0002, Rn0305), block_len))
        };
        let ((mut ItCond, mut CheckInIT_ZN), (Rd0002, Rn0305), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        CheckInIT_ZN.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                CheckInIT_ZN,
                ItCond,
                Rd0002,
                Rn0305,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:2414:1"]
#[derive(Clone, Debug)]
pub struct instructionVar293 {
    CheckInIT_CZN: CheckInIT_CZN,
    ItCond: ItCond,
    Rs0305: u8,
    Rd0002: u8,
}
impl instructionVar293 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            CheckInIT_CZN,
            ItCond,
            Rs0305,
            Rd0002,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("lsr")];
        display.extend_from_slice(&extend);
        CheckInIT_CZN.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047783056016(usize::try_from(*Rs0305).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0002 = token_parser.Rd0002();
            let Rs0305 = token_parser.Rs0305();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op6() != (259u64 as i64) as u16 {
                return None;
            }
            let CheckInIT_CZN = if let Some((len, table)) = CheckInIT_CZN::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, CheckInIT_CZN), (Rd0002, Rs0305), block_len))
        };
        let ((mut ItCond, mut CheckInIT_CZN), (Rd0002, Rs0305), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        CheckInIT_CZN.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                CheckInIT_CZN,
                ItCond,
                Rs0305,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:2379:1"]
#[derive(Clone, Debug)]
pub struct instructionVar294 {
    ItCond: ItCond,
    CheckInIT_CZN: CheckInIT_CZN,
    Rs0305: u8,
    Rd0002: u8,
}
impl instructionVar294 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            CheckInIT_CZN,
            Rs0305,
            Rd0002,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("lsl")];
        display.extend_from_slice(&extend);
        CheckInIT_CZN.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047783056016(usize::try_from(*Rs0305).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rs0305 = token_parser.Rs0305();
            let Rd0002 = token_parser.Rd0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op6() != (258u64 as i64) as u16 {
                return None;
            }
            let CheckInIT_CZN = if let Some((len, table)) = CheckInIT_CZN::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, CheckInIT_CZN), (Rs0305, Rd0002), block_len))
        };
        let ((mut ItCond, mut CheckInIT_CZN), (Rs0305, Rd0002), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        CheckInIT_CZN.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                CheckInIT_CZN,
                Rs0305,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1832:1"]
#[derive(Clone, Debug)]
pub struct instructionVar295 {
    ItCond: ItCond,
    CheckInIT_ZN: CheckInIT_ZN,
    Rd0002: u8,
    Rm0305: u8,
}
impl instructionVar295 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            CheckInIT_ZN,
            Rd0002,
            Rm0305,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("eor")];
        display.extend_from_slice(&extend);
        CheckInIT_ZN.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047783056016(usize::try_from(*Rm0305).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rm0305 = token_parser.Rm0305();
            let Rd0002 = token_parser.Rd0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op6() != (257u64 as i64) as u16 {
                return None;
            }
            let CheckInIT_ZN = if let Some((len, table)) = CheckInIT_ZN::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, CheckInIT_ZN), (Rd0002, Rm0305), block_len))
        };
        let ((mut ItCond, mut CheckInIT_ZN), (Rd0002, Rm0305), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        CheckInIT_ZN.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                CheckInIT_ZN,
                Rd0002,
                Rm0305,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1678:1"]
#[derive(Clone, Debug)]
pub struct instructionVar296 {
    ItCond: ItCond,
    Rn0002: u8,
    Rm0305: u8,
}
impl instructionVar296 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            Rn0002,
            Rm0305,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cmp")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rn0002).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047783056016(usize::try_from(*Rm0305).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rm0305 = token_parser.Rm0305();
            let Rn0002 = token_parser.Rn0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op6() != (266u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (Rm0305, Rn0002), block_len))
        };
        let ((mut ItCond), (Rm0305, Rn0002), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                Rn0002,
                Rm0305,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1638:1"]
#[derive(Clone, Debug)]
pub struct instructionVar297 {
    ItCond: ItCond,
    Rn0002: u8,
    Rm0305: u8,
}
impl instructionVar297 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            Rn0002,
            Rm0305,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cmn")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rn0002).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047783056016(usize::try_from(*Rm0305).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rm0305 = token_parser.Rm0305();
            let Rn0002 = token_parser.Rn0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op6() != (267u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (Rm0305, Rn0002), block_len))
        };
        let ((mut ItCond), (Rm0305, Rn0002), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                Rn0002,
                Rm0305,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1360:1"]
#[derive(Clone, Debug)]
pub struct instructionVar298 {
    CheckInIT_ZN: CheckInIT_ZN,
    ItCond: ItCond,
    Rd0002: u8,
    Rm0305: u8,
}
impl instructionVar298 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            CheckInIT_ZN,
            ItCond,
            Rd0002,
            Rm0305,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bic")];
        display.extend_from_slice(&extend);
        CheckInIT_ZN.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047783056016(usize::try_from(*Rm0305).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0002 = token_parser.Rd0002();
            let Rm0305 = token_parser.Rm0305();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op6() != (270u64 as i64) as u16 {
                return None;
            }
            let CheckInIT_ZN = if let Some((len, table)) = CheckInIT_ZN::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((CheckInIT_ZN, ItCond), (Rd0002, Rm0305), block_len))
        };
        let ((mut CheckInIT_ZN, mut ItCond), (Rd0002, Rm0305), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        CheckInIT_ZN.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                CheckInIT_ZN,
                ItCond,
                Rd0002,
                Rm0305,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1270:1"]
#[derive(Clone, Debug)]
pub struct instructionVar299 {
    CheckInIT_CZN: CheckInIT_CZN,
    ItCond: ItCond,
    Rs0305: u8,
    Rd0002: u8,
}
impl instructionVar299 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            CheckInIT_CZN,
            ItCond,
            Rs0305,
            Rd0002,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("asr")];
        display.extend_from_slice(&extend);
        CheckInIT_CZN.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047783056016(usize::try_from(*Rs0305).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0002 = token_parser.Rd0002();
            let Rs0305 = token_parser.Rs0305();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op6() != (260u64 as i64) as u16 {
                return None;
            }
            let CheckInIT_CZN = if let Some((len, table)) = CheckInIT_CZN::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, CheckInIT_CZN), (Rs0305, Rd0002), block_len))
        };
        let ((mut ItCond, mut CheckInIT_CZN), (Rs0305, Rd0002), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        CheckInIT_CZN.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                CheckInIT_CZN,
                ItCond,
                Rs0305,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1217:1"]
#[derive(Clone, Debug)]
pub struct instructionVar300 {
    ItCond: ItCond,
    CheckInIT_ZN: CheckInIT_ZN,
    Rm0305: u8,
    Rd0002: u8,
}
impl instructionVar300 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            CheckInIT_ZN,
            Rm0305,
            Rd0002,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("and")];
        display.extend_from_slice(&extend);
        CheckInIT_ZN.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047783056016(usize::try_from(*Rm0305).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0002 = token_parser.Rd0002();
            let Rm0305 = token_parser.Rm0305();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op6() != (256u64 as i64) as u16 {
                return None;
            }
            let CheckInIT_ZN = if let Some((len, table)) = CheckInIT_ZN::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((CheckInIT_ZN, ItCond), (Rd0002, Rm0305), block_len))
        };
        let ((mut CheckInIT_ZN, mut ItCond), (Rd0002, Rm0305), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        CheckInIT_ZN.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                CheckInIT_ZN,
                Rm0305,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1033:1"]
#[derive(Clone, Debug)]
pub struct instructionVar301 {
    ItCond: ItCond,
    CheckInIT_CZNO: CheckInIT_CZNO,
    Rm0305: u8,
    Rd0002: u8,
}
impl instructionVar301 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            CheckInIT_CZNO,
            Rm0305,
            Rd0002,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("adc")];
        display.extend_from_slice(&extend);
        CheckInIT_CZNO.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047783056016(usize::try_from(*Rm0305).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rm0305 = token_parser.Rm0305();
            let Rd0002 = token_parser.Rd0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op6() != (261u64 as i64) as u16 {
                return None;
            }
            let CheckInIT_CZNO = if let Some((len, table)) =
                CheckInIT_CZNO::parse(
                    tokens,
                    &mut context_current,
                    inst_start,
                    global_set,
                ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((CheckInIT_CZNO, ItCond), (Rd0002, Rm0305), block_len))
        };
        let ((mut CheckInIT_CZNO, mut ItCond), (Rd0002, Rm0305), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        CheckInIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                CheckInIT_CZNO,
                Rm0305,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:2524:1"]
#[derive(Clone, Debug)]
pub struct instructionVar302 {
    ItCond: ItCond,
    Hrd0002: Hrd0002,
    Hrm0305: Hrm0305,
}
impl instructionVar302 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            Hrd0002,
            Hrm0305,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("\t")];
        display.extend_from_slice(&extend);
        Hrd0002.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        Hrm0305.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op8() != (70u64 as i64) as u8 {
                return None;
            }
            let Hrm0305 = if let Some((len, table)) = Hrm0305::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let Hrd0002 = if let Some((len, table)) = Hrd0002::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.hrd0002() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.h1() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((ItCond, Hrm0305, Hrd0002), (), block_len))
        };
        let ((mut ItCond, mut Hrm0305, mut Hrd0002), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        Hrd0002.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        Hrm0305.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                Hrd0002,
                Hrm0305,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1161:1"]
#[derive(Clone, Debug)]
pub struct instructionVar303 {
    Hrd0002: Hrd0002,
    Hrm0305: Hrm0305,
    ItCond: ItCond,
}
impl instructionVar303 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            Hrd0002,
            Hrm0305,
            ItCond,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("add")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("\t")];
        display.extend_from_slice(&extend);
        Hrd0002.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        Hrm0305.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op8() != (68u64 as i64) as u8 {
                return None;
            }
            let Hrd0002 = if let Some((len, table)) = Hrd0002::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let Hrm0305 = if let Some((len, table)) = Hrm0305::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.hrd0002() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.h1() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((ItCond, Hrm0305, Hrd0002), (), block_len))
        };
        let ((mut ItCond, mut Hrm0305, mut Hrd0002), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        Hrd0002.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        Hrm0305.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                Hrd0002,
                Hrm0305,
                ItCond,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:4504:1"]
#[derive(Clone, Debug)]
pub struct instructionVar304 {
    ItCond: ItCond,
    CheckInIT_CZNO: CheckInIT_CZNO,
    Immed3: Immed3,
    Rn0305: u8,
    Rd0002: u8,
}
impl instructionVar304 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            CheckInIT_CZNO,
            Immed3,
            Rn0305,
            Rd0002,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sub")];
        display.extend_from_slice(&extend);
        CheckInIT_CZNO.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047783056016(usize::try_from(*Rn0305).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        Immed3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0305 = token_parser.Rn0305();
            let Rd0002 = token_parser.Rd0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op9() != (15u64 as i64) as u8 {
                return None;
            }
            let Immed3 = if let Some((len, table)) = Immed3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let CheckInIT_CZNO = if let Some((len, table)) =
                CheckInIT_CZNO::parse(
                    tokens,
                    &mut context_current,
                    inst_start,
                    global_set,
                ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some((
                (Immed3, ItCond, CheckInIT_CZNO),
                (Rn0305, Rd0002),
                block_len,
            ))
        };
        let (
            (mut Immed3, mut ItCond, mut CheckInIT_CZNO),
            (Rn0305, Rd0002),
            block_len,
        ) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        CheckInIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        Immed3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                CheckInIT_CZNO,
                Immed3,
                Rn0305,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1066:1"]
#[derive(Clone, Debug)]
pub struct instructionVar305 {
    CheckInIT_CZNO: CheckInIT_CZNO,
    Immed3: Immed3,
    ItCond: ItCond,
    Rd0002: u8,
    Rn0305: u8,
}
impl instructionVar305 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            CheckInIT_CZNO,
            Immed3,
            ItCond,
            Rd0002,
            Rn0305,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("add")];
        display.extend_from_slice(&extend);
        CheckInIT_CZNO.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047783056016(usize::try_from(*Rn0305).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        Immed3.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0305 = token_parser.Rn0305();
            let Rd0002 = token_parser.Rd0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op9() != (14u64 as i64) as u8 {
                return None;
            }
            let Immed3 = if let Some((len, table)) = Immed3::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let CheckInIT_CZNO = if let Some((len, table)) =
                CheckInIT_CZNO::parse(
                    tokens,
                    &mut context_current,
                    inst_start,
                    global_set,
                ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some((
                (ItCond, Immed3, CheckInIT_CZNO),
                (Rd0002, Rn0305),
                block_len,
            ))
        };
        let (
            (mut ItCond, mut Immed3, mut CheckInIT_CZNO),
            (Rd0002, Rn0305),
            block_len,
        ) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        CheckInIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        Immed3.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                CheckInIT_CZNO,
                Immed3,
                ItCond,
                Rd0002,
                Rn0305,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3135:1"]
#[derive(Clone, Debug)]
pub struct instructionVar306 {
    ItCond: ItCond,
    thldrlist_inc: thldrlist_inc,
}
impl instructionVar306 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            thldrlist_inc,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("pop")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("    ")];
        display.extend_from_slice(&extend);
        thldrlist_inc.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op0() != (59581u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (), block_len))
        };
        let ((mut ItCond), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let thldrlist_inc = if let Some((len, table)) = thldrlist_inc::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.thc1515() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((thldrlist_inc), (), block_len))
        };
        let ((mut thldrlist_inc), (), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        thldrlist_inc.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                thldrlist_inc,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1395:1"]
#[derive(Clone, Debug)]
pub struct instructionVar307 {
    immed6: u8,
}
impl instructionVar307 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { immed6 } = self;
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("hlt"),
            DisplayElement::Literal(" "),
            DisplayElement::Unsigned(true, u64::try_from(*immed6).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let immed6 = token_parser.immed6();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.op6() != (746u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (immed6), block_len))
        };
        let ((), (immed6), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        *context = context_current;
        Some((inst_len, Self { immed6 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:4612:1"]
#[derive(Clone, Debug)]
pub struct instructionVar308 {
    ItCond: ItCond,
    immed8: u8,
}
impl instructionVar308 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ItCond, immed8 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("svc")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("\t"),
            DisplayElement::Unsigned(true, u64::try_from(*immed8).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let immed8 = token_parser.immed8();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op8() != (223u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (immed8), block_len))
        };
        let ((mut ItCond), (immed8), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { ItCond, immed8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3208:1"]
#[derive(Clone, Debug)]
pub struct instructionVar309 {
    ItCond: ItCond,
    pcpbrace: pcpbrace,
}
impl instructionVar309 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ItCond, pcpbrace } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("push")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("\t")];
        display.extend_from_slice(&extend);
        pcpbrace.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op9() != (90u64 as i64) as u8 {
                return None;
            }
            if token_parser.R() != (1u64 as i64) as u8 {
                return None;
            }
            let pcpbrace = if let Some((len, table)) = pcpbrace::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, pcpbrace), (), block_len))
        };
        let ((mut ItCond, mut pcpbrace), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        pcpbrace.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { ItCond, pcpbrace }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3199:1"]
#[derive(Clone, Debug)]
pub struct instructionVar310 {
    ItCond: ItCond,
    psbrace: psbrace,
}
impl instructionVar310 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ItCond, psbrace } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("push")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("\t")];
        display.extend_from_slice(&extend);
        psbrace.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op9() != (90u64 as i64) as u8 {
                return None;
            }
            if token_parser.R() != (0u64 as i64) as u8 {
                return None;
            }
            let psbrace = if let Some((len, table)) = psbrace::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((psbrace, ItCond), (), block_len))
        };
        let ((mut psbrace, mut ItCond), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        psbrace.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { ItCond, psbrace }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3115:1"]
#[derive(Clone, Debug)]
pub struct instructionVar311 {
    ItCond: ItCond,
    pclbrace: pclbrace,
}
impl instructionVar311 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ItCond, pclbrace } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("pop")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("\t")];
        display.extend_from_slice(&extend);
        pclbrace.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op9() != (94u64 as i64) as u8 {
                return None;
            }
            if token_parser.R() != (1u64 as i64) as u8 {
                return None;
            }
            let pclbrace = if let Some((len, table)) = pclbrace::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, pclbrace), (), block_len))
        };
        let ((mut ItCond, mut pclbrace), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        pclbrace.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { ItCond, pclbrace }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3106:1"]
#[derive(Clone, Debug)]
pub struct instructionVar312 {
    ldbrace: ldbrace,
    ItCond: ItCond,
}
impl instructionVar312 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldbrace, ItCond } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("pop")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("\t")];
        display.extend_from_slice(&extend);
        ldbrace.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op9() != (94u64 as i64) as u8 {
                return None;
            }
            if token_parser.R() != (0u64 as i64) as u8 {
                return None;
            }
            let ldbrace = if let Some((len, table)) = ldbrace::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, ldbrace), (), block_len))
        };
        let ((mut ItCond, mut ldbrace), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ldbrace.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { ldbrace, ItCond }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1420:1"]
#[derive(Clone, Debug)]
pub struct instructionVar313 {
    ItCond: ItCond,
    thc0007: u8,
}
impl instructionVar313 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ItCond, thc0007 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("udf")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#"),
            DisplayElement::Unsigned(true, u64::try_from(*thc0007).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let thc0007 = token_parser.thc0007();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op8() != (222u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (thc0007), block_len))
        };
        let ((mut ItCond), (thc0007), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { ItCond, thc0007 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1400:1"]
#[derive(Clone, Debug)]
pub struct instructionVar314 {
    immed8: u8,
}
impl instructionVar314 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { immed8 } = self;
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("bkpt"),
            DisplayElement::Literal(" "),
            DisplayElement::Unsigned(true, u64::try_from(*immed8).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let immed8 = token_parser.immed8();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op8() != (190u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (immed8), block_len))
        };
        let ((mut ItCond), (immed8), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        *context = context_current;
        Some((inst_len, Self { immed8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1496:1"]
#[derive(Clone, Debug)]
pub struct instructionVar315 {
    ThArmAddr23: ThArmAddr23,
    ItCond: ItCond,
}
impl instructionVar315 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ThArmAddr23,
            ItCond,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("blx")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" \t")];
        display.extend_from_slice(&extend);
        ThArmAddr23.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut TMode = context_current.read_TMode();
        TMode = u8::try_from((0u64 as i64)).unwrap();
        global_set.set_TMode(None, u8::try_into(TMode).unwrap());
        TMode = u8::try_from((1u64 as i64)).unwrap();
        context_current.write_TMode(TMode);
        context_current.write_TMode(TMode);
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if context.read_CALLoverride() != (1u64 as i64) as u8 {
                return None;
            }
            let mut sub_pattern_c68 = |token, context: &mut T| {
                let mut block_len = 0 as u32;
                let mut context_current = context.clone();
                let mut token_current = token;
                let mut block_0 = |tokens, context: &mut T| {
                    let mut block_len = 0 as u32;
                    let mut context_current = context.clone();
                    let token_parser = TokenParser16::new(tokens)?;
                    block_len = 2u64 as u32;
                    if token_parser.op11() != (30u64 as i64) as u8 {
                        return None;
                    }
                    *context = context_current;
                    Some(((), (), block_len))
                };
                let ((), (), block_len) =
                    block_0(token_current, &mut context_current)?;
                token_current =
                    &token_current[usize::try_from(block_len).unwrap()..];
                let mut block_1 = |tokens, context: &mut T| {
                    let mut block_len = 0 as u32;
                    let mut context_current = context.clone();
                    let token_parser = TokenParser16::new(tokens)?;
                    block_len = 2u64 as u32;
                    if token_parser.part2op() != (29u64 as i64) as u8 {
                        return None;
                    }
                    *context = context_current;
                    Some(((), (), block_len))
                };
                let ((), (), block_len) =
                    block_1(token_current, &mut context_current)?;
                token_current =
                    &token_current[usize::try_from(block_len).unwrap()..];
                *context = context_current;
                Some(((), (), block_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c68(tokens, &mut context_current)?;
            block_len = block_len.max(sub_len);
            let ThArmAddr23 = if let Some((len, table)) = ThArmAddr23::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ThArmAddr23, ItCond), (), block_len))
        };
        let ((mut ThArmAddr23, mut ItCond), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ThArmAddr23.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ThArmAddr23,
                ItCond,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1487:1"]
#[derive(Clone, Debug)]
pub struct instructionVar316 {
    ItCond: ItCond,
    ThArmAddr23: ThArmAddr23,
}
impl instructionVar316 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            ThArmAddr23,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("blx")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" \t")];
        display.extend_from_slice(&extend);
        ThArmAddr23.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut TMode = context_current.read_TMode();
        TMode = u8::try_from((0u64 as i64)).unwrap();
        global_set.set_TMode(None, u8::try_into(TMode).unwrap());
        TMode = u8::try_from((1u64 as i64)).unwrap();
        context_current.write_TMode(TMode);
        context_current.write_TMode(TMode);
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mut sub_pattern_c51 = |token, context: &mut T| {
                let mut block_len = 0 as u32;
                let mut context_current = context.clone();
                let mut token_current = token;
                let mut block_0 = |tokens, context: &mut T| {
                    let mut block_len = 0 as u32;
                    let mut context_current = context.clone();
                    let token_parser = TokenParser16::new(tokens)?;
                    block_len = 2u64 as u32;
                    if token_parser.op11() != (30u64 as i64) as u8 {
                        return None;
                    }
                    *context = context_current;
                    Some(((), (), block_len))
                };
                let ((), (), block_len) =
                    block_0(token_current, &mut context_current)?;
                token_current =
                    &token_current[usize::try_from(block_len).unwrap()..];
                let mut block_1 = |tokens, context: &mut T| {
                    let mut block_len = 0 as u32;
                    let mut context_current = context.clone();
                    let token_parser = TokenParser16::new(tokens)?;
                    block_len = 2u64 as u32;
                    if token_parser.part2op() != (29u64 as i64) as u8 {
                        return None;
                    }
                    *context = context_current;
                    Some(((), (), block_len))
                };
                let ((), (), block_len) =
                    block_1(token_current, &mut context_current)?;
                token_current =
                    &token_current[usize::try_from(block_len).unwrap()..];
                *context = context_current;
                Some(((), (), block_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c51(tokens, &mut context_current)?;
            block_len = block_len.max(sub_len);
            let ThArmAddr23 = if let Some((len, table)) = ThArmAddr23::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ThArmAddr23, ItCond), (), block_len))
        };
        let ((mut ThArmAddr23, mut ItCond), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ThArmAddr23.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                ThArmAddr23,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:4341:1"]
#[derive(Clone, Debug)]
pub struct instructionVar317 {
    ItCond: ItCond,
    RnRmIndirect: RnRmIndirect,
    Rd0002: u8,
}
impl instructionVar317 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            RnRmIndirect,
            Rd0002,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("strh")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        RnRmIndirect.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0002 = token_parser.Rd0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op9() != (41u64 as i64) as u8 {
                return None;
            }
            let RnRmIndirect = if let Some((len, table)) = RnRmIndirect::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, RnRmIndirect), (Rd0002), block_len))
        };
        let ((mut ItCond, mut RnRmIndirect), (Rd0002), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        RnRmIndirect.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                RnRmIndirect,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:4327:1"]
#[derive(Clone, Debug)]
pub struct instructionVar318 {
    RnRmIndirect: RnRmIndirect,
    ItCond: ItCond,
    Rd0002: u8,
}
impl instructionVar318 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            RnRmIndirect,
            ItCond,
            Rd0002,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("strb")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        RnRmIndirect.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0002 = token_parser.Rd0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op9() != (42u64 as i64) as u8 {
                return None;
            }
            let RnRmIndirect = if let Some((len, table)) = RnRmIndirect::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((RnRmIndirect, ItCond), (Rd0002), block_len))
        };
        let ((mut RnRmIndirect, mut ItCond), (Rd0002), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        RnRmIndirect.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                RnRmIndirect,
                ItCond,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:4307:1"]
#[derive(Clone, Debug)]
pub struct instructionVar319 {
    RnRmIndirect: RnRmIndirect,
    ItCond: ItCond,
    Rd0002: u8,
}
impl instructionVar319 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            RnRmIndirect,
            ItCond,
            Rd0002,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("str")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        RnRmIndirect.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0002 = token_parser.Rd0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op9() != (40u64 as i64) as u8 {
                return None;
            }
            let RnRmIndirect = if let Some((len, table)) = RnRmIndirect::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, RnRmIndirect), (Rd0002), block_len))
        };
        let ((mut ItCond, mut RnRmIndirect), (Rd0002), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        RnRmIndirect.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                RnRmIndirect,
                ItCond,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:2068:1"]
#[derive(Clone, Debug)]
pub struct instructionVar320 {
    ItCond: ItCond,
    RnRmIndirect: RnRmIndirect,
    Rd0002: u8,
}
impl instructionVar320 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            RnRmIndirect,
            Rd0002,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldrsh")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        RnRmIndirect.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0002 = token_parser.Rd0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op9() != (47u64 as i64) as u8 {
                return None;
            }
            let RnRmIndirect = if let Some((len, table)) = RnRmIndirect::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, RnRmIndirect), (Rd0002), block_len))
        };
        let ((mut ItCond, mut RnRmIndirect), (Rd0002), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        RnRmIndirect.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                RnRmIndirect,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:2061:1"]
#[derive(Clone, Debug)]
pub struct instructionVar321 {
    ItCond: ItCond,
    RnRmIndirect: RnRmIndirect,
    Rd0002: u8,
}
impl instructionVar321 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            RnRmIndirect,
            Rd0002,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldrsb")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        RnRmIndirect.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0002 = token_parser.Rd0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op9() != (43u64 as i64) as u8 {
                return None;
            }
            let RnRmIndirect = if let Some((len, table)) = RnRmIndirect::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((RnRmIndirect, ItCond), (Rd0002), block_len))
        };
        let ((mut RnRmIndirect, mut ItCond), (Rd0002), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        RnRmIndirect.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                RnRmIndirect,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:2054:1"]
#[derive(Clone, Debug)]
pub struct instructionVar322 {
    RnRmIndirect: RnRmIndirect,
    ItCond: ItCond,
    Rd0002: u8,
}
impl instructionVar322 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            RnRmIndirect,
            ItCond,
            Rd0002,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldrh")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        RnRmIndirect.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0002 = token_parser.Rd0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op9() != (45u64 as i64) as u8 {
                return None;
            }
            let RnRmIndirect = if let Some((len, table)) = RnRmIndirect::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((RnRmIndirect, ItCond), (Rd0002), block_len))
        };
        let ((mut RnRmIndirect, mut ItCond), (Rd0002), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        RnRmIndirect.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                RnRmIndirect,
                ItCond,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:2040:1"]
#[derive(Clone, Debug)]
pub struct instructionVar323 {
    ItCond: ItCond,
    RnRmIndirect: RnRmIndirect,
    Rd0002: u8,
}
impl instructionVar323 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            RnRmIndirect,
            Rd0002,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldrb")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        RnRmIndirect.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0002 = token_parser.Rd0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op9() != (46u64 as i64) as u8 {
                return None;
            }
            let RnRmIndirect = if let Some((len, table)) = RnRmIndirect::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, RnRmIndirect), (Rd0002), block_len))
        };
        let ((mut ItCond, mut RnRmIndirect), (Rd0002), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        RnRmIndirect.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                RnRmIndirect,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:2011:1"]
#[derive(Clone, Debug)]
pub struct instructionVar324 {
    RnRmIndirect: RnRmIndirect,
    ItCond: ItCond,
    Rd0002: u8,
}
impl instructionVar324 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            RnRmIndirect,
            ItCond,
            Rd0002,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ldr")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        RnRmIndirect.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0002 = token_parser.Rd0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op9() != (44u64 as i64) as u8 {
                return None;
            }
            let RnRmIndirect = if let Some((len, table)) = RnRmIndirect::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, RnRmIndirect), (Rd0002), block_len))
        };
        let ((mut ItCond, mut RnRmIndirect), (Rd0002), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        RnRmIndirect.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                RnRmIndirect,
                ItCond,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:4513:1"]
#[derive(Clone, Debug)]
pub struct instructionVar325 {
    Immed8: Immed8,
    ItCond: ItCond,
    CheckInIT_CZNO: CheckInIT_CZNO,
    Rd0810: u8,
}
impl instructionVar325 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            Immed8,
            ItCond,
            CheckInIT_CZNO,
            Rd0810,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sub")];
        display.extend_from_slice(&extend);
        CheckInIT_CZNO.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0810).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        Immed8.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0810 = token_parser.Rd0810();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op11() != (7u64 as i64) as u8 {
                return None;
            }
            let Immed8 = if let Some((len, table)) = Immed8::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let CheckInIT_CZNO = if let Some((len, table)) =
                CheckInIT_CZNO::parse(
                    tokens,
                    &mut context_current,
                    inst_start,
                    global_set,
                ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, CheckInIT_CZNO, Immed8), (Rd0810), block_len))
        };
        let ((mut ItCond, mut CheckInIT_CZNO, mut Immed8), (Rd0810), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        Immed8.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        CheckInIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                Immed8,
                ItCond,
                CheckInIT_CZNO,
                Rd0810,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:4334:1"]
#[derive(Clone, Debug)]
pub struct instructionVar326 {
    RnIndirect2: RnIndirect2,
    ItCond: ItCond,
    Rd0002: u8,
}
impl instructionVar326 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            RnIndirect2,
            ItCond,
            Rd0002,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("strh")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        RnIndirect2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0002 = token_parser.Rd0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op11() != (16u64 as i64) as u8 {
                return None;
            }
            let RnIndirect2 = if let Some((len, table)) = RnIndirect2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, RnIndirect2), (Rd0002), block_len))
        };
        let ((mut ItCond, mut RnIndirect2), (Rd0002), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        RnIndirect2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                RnIndirect2,
                ItCond,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:4320:1"]
#[derive(Clone, Debug)]
pub struct instructionVar327 {
    ItCond: ItCond,
    RnIndirect1: RnIndirect1,
    Rd0002: u8,
}
impl instructionVar327 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            RnIndirect1,
            Rd0002,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("strb")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        RnIndirect1.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0002 = token_parser.Rd0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op11() != (14u64 as i64) as u8 {
                return None;
            }
            let RnIndirect1 = if let Some((len, table)) = RnIndirect1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((RnIndirect1, ItCond), (Rd0002), block_len))
        };
        let ((mut RnIndirect1, mut ItCond), (Rd0002), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        RnIndirect1.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                RnIndirect1,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:4313:1"]
#[derive(Clone, Debug)]
pub struct instructionVar328 {
    ItCond: ItCond,
    Sprel8Indirect: Sprel8Indirect,
    Rd0810: u8,
}
impl instructionVar328 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            Sprel8Indirect,
            Rd0810,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("str")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0810).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        Sprel8Indirect.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0810 = token_parser.Rd0810();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op11() != (18u64 as i64) as u8 {
                return None;
            }
            let Sprel8Indirect = if let Some((len, table)) =
                Sprel8Indirect::parse(
                    tokens,
                    &mut context_current,
                    inst_start,
                    global_set,
                ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, Sprel8Indirect), (Rd0810), block_len))
        };
        let ((mut ItCond, mut Sprel8Indirect), (Rd0810), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        Sprel8Indirect.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                Sprel8Indirect,
                Rd0810,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:4301:1"]
#[derive(Clone, Debug)]
pub struct instructionVar329 {
    ItCond: ItCond,
    RnIndirect4: RnIndirect4,
    Rd0002: u8,
}
impl instructionVar329 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            RnIndirect4,
            Rd0002,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("str")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        RnIndirect4.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0002 = token_parser.Rd0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op11() != (12u64 as i64) as u8 {
                return None;
            }
            let RnIndirect4 = if let Some((len, table)) = RnIndirect4::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, RnIndirect4), (Rd0002), block_len))
        };
        let ((mut ItCond, mut RnIndirect4), (Rd0002), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        RnIndirect4.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                RnIndirect4,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:2502:1"]
#[derive(Clone, Debug)]
pub struct instructionVar330 {
    CheckInIT_ZN: CheckInIT_ZN,
    ItCond: ItCond,
    Immed8: Immed8,
    Rd0810: u8,
}
impl instructionVar330 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            CheckInIT_ZN,
            ItCond,
            Immed8,
            Rd0810,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        CheckInIT_ZN.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0810).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        Immed8.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0810 = token_parser.Rd0810();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op11() != (4u64 as i64) as u8 {
                return None;
            }
            let Immed8 = if let Some((len, table)) = Immed8::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let CheckInIT_ZN = if let Some((len, table)) = CheckInIT_ZN::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, Immed8, CheckInIT_ZN), (Rd0810), block_len))
        };
        let ((mut ItCond, mut Immed8, mut CheckInIT_ZN), (Rd0810), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        CheckInIT_ZN.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        Immed8.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                CheckInIT_ZN,
                ItCond,
                Immed8,
                Rd0810,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:2047:1"]
#[derive(Clone, Debug)]
pub struct instructionVar331 {
    ItCond: ItCond,
    RnIndirect2: RnIndirect2,
    Rd0002: u8,
}
impl instructionVar331 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            RnIndirect2,
            Rd0002,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldrh")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        RnIndirect2.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0002 = token_parser.Rd0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op11() != (17u64 as i64) as u8 {
                return None;
            }
            let RnIndirect2 = if let Some((len, table)) = RnIndirect2::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((RnIndirect2, ItCond), (Rd0002), block_len))
        };
        let ((mut RnIndirect2, mut ItCond), (Rd0002), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        RnIndirect2.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                RnIndirect2,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:2033:1"]
#[derive(Clone, Debug)]
pub struct instructionVar332 {
    ItCond: ItCond,
    RnIndirect1: RnIndirect1,
    Rd0002: u8,
}
impl instructionVar332 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            RnIndirect1,
            Rd0002,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldrb")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        RnIndirect1.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0002 = token_parser.Rd0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op11() != (15u64 as i64) as u8 {
                return None;
            }
            let RnIndirect1 = if let Some((len, table)) = RnIndirect1::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, RnIndirect1), (Rd0002), block_len))
        };
        let ((mut ItCond, mut RnIndirect1), (Rd0002), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        RnIndirect1.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                RnIndirect1,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:2026:1"]
#[derive(Clone, Debug)]
pub struct instructionVar333 {
    ItCond: ItCond,
    Sprel8Indirect: Sprel8Indirect,
    Rd0810: u8,
}
impl instructionVar333 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            Sprel8Indirect,
            Rd0810,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ldr")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0810).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        Sprel8Indirect.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0810 = token_parser.Rd0810();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op11() != (19u64 as i64) as u8 {
                return None;
            }
            let Sprel8Indirect = if let Some((len, table)) =
                Sprel8Indirect::parse(
                    tokens,
                    &mut context_current,
                    inst_start,
                    global_set,
                ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((Sprel8Indirect, ItCond), (Rd0810), block_len))
        };
        let ((mut Sprel8Indirect, mut ItCond), (Rd0810), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        Sprel8Indirect.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                Sprel8Indirect,
                Rd0810,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:2018:1"]
#[derive(Clone, Debug)]
pub struct instructionVar334 {
    Pcrel8Indirect: Pcrel8Indirect,
    ItCond: ItCond,
    Rd0810: u8,
}
impl instructionVar334 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            Pcrel8Indirect,
            ItCond,
            Rd0810,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ldr")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0810).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        Pcrel8Indirect.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0810 = token_parser.Rd0810();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op11() != (9u64 as i64) as u8 {
                return None;
            }
            let Pcrel8Indirect = if let Some((len, table)) =
                Pcrel8Indirect::parse(
                    tokens,
                    &mut context_current,
                    inst_start,
                    global_set,
                ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, Pcrel8Indirect), (Rd0810), block_len))
        };
        let ((mut ItCond, mut Pcrel8Indirect), (Rd0810), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        Pcrel8Indirect.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                Pcrel8Indirect,
                ItCond,
                Rd0810,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:2004:1"]
#[derive(Clone, Debug)]
pub struct instructionVar335 {
    RnIndirect4: RnIndirect4,
    ItCond: ItCond,
    Rd0002: u8,
}
impl instructionVar335 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            RnIndirect4,
            ItCond,
            Rd0002,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ldr")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        RnIndirect4.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0002 = token_parser.Rd0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op11() != (13u64 as i64) as u8 {
                return None;
            }
            let RnIndirect4 = if let Some((len, table)) = RnIndirect4::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, RnIndirect4), (Rd0002), block_len))
        };
        let ((mut ItCond, mut RnIndirect4), (Rd0002), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        RnIndirect4.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                RnIndirect4,
                ItCond,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1647:1"]
#[derive(Clone, Debug)]
pub struct instructionVar336 {
    Immed8: Immed8,
    ItCond: ItCond,
    Rn0810: u8,
}
impl instructionVar336 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            Immed8,
            ItCond,
            Rn0810,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cmp")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rn0810).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        Immed8.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0810 = token_parser.Rn0810();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op11() != (5u64 as i64) as u8 {
                return None;
            }
            let Immed8 = if let Some((len, table)) = Immed8::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((Immed8, ItCond), (Rn0810), block_len))
        };
        let ((mut Immed8, mut ItCond), (Rn0810), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        Immed8.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                Immed8,
                ItCond,
                Rn0810,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1455:1"]
#[derive(Clone, Debug)]
pub struct instructionVar337 {
    ItCond: ItCond,
    off: i64,
}
impl instructionVar337 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ItCond, off } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bl")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" \t"),
            DisplayElement::Literal("#"),
            DisplayElement::Signed(true, *off),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut off = 0i64;
        off = (i64::try_from(offset11).unwrap() << (1u64 as i64));
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let offset11 = token_parser.offset11();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op11() != (31u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (offset11), block_len))
        };
        let ((mut ItCond), (offset11), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        let off = 0i64;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { ItCond, off }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1449:1"]
#[derive(Clone, Debug)]
pub struct instructionVar338 {
    ItCond: ItCond,
    off: i64,
}
impl instructionVar338 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ItCond, off } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bl")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" \t"),
            DisplayElement::Literal("#"),
            DisplayElement::Signed(true, *off),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut off = 0i64;
        off = ((i64::try_from(inst_start).unwrap() + (4u64 as i64))
            + (i64::try_from(soffset11).unwrap() << (12u64 as i64)));
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let soffset11 = token_parser.soffset11();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op11() != (30u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (soffset11), block_len))
        };
        let ((mut ItCond), (soffset11), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        let off = 0i64;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { ItCond, off }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1181:1"]
#[derive(Clone, Debug)]
pub struct instructionVar339 {
    Pcrel8: Pcrel8,
    ItCond: ItCond,
    Rd0810: u8,
}
impl instructionVar339 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            Pcrel8,
            ItCond,
            Rd0810,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("adr")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0810).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        Pcrel8.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0810 = token_parser.Rd0810();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op11() != (20u64 as i64) as u8 {
                return None;
            }
            let Pcrel8 = if let Some((len, table)) = Pcrel8::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, Pcrel8), (Rd0810), block_len))
        };
        let ((mut ItCond, mut Pcrel8), (Rd0810), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        Pcrel8.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                Pcrel8,
                ItCond,
                Rd0810,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1169:1"]
#[derive(Clone, Debug)]
pub struct instructionVar340 {
    Sprel8: Sprel8,
    ItCond: ItCond,
    Rd0810: u8,
}
impl instructionVar340 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            Sprel8,
            ItCond,
            Rd0810,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("add")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0810).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        Sprel8.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0810 = token_parser.Rd0810();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op11() != (21u64 as i64) as u8 {
                return None;
            }
            let Sprel8 = if let Some((len, table)) = Sprel8::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((Sprel8, ItCond), (Rd0810), block_len))
        };
        let ((mut Sprel8, mut ItCond), (Rd0810), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        Sprel8.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                Sprel8,
                ItCond,
                Rd0810,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1075:1"]
#[derive(Clone, Debug)]
pub struct instructionVar341 {
    CheckInIT_CZNO: CheckInIT_CZNO,
    ItCond: ItCond,
    Immed8: Immed8,
    Rd0810: u8,
}
impl instructionVar341 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            CheckInIT_CZNO,
            ItCond,
            Immed8,
            Rd0810,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("add")];
        display.extend_from_slice(&extend);
        CheckInIT_CZNO.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0810).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        Immed8.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0810 = token_parser.Rd0810();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op11() != (6u64 as i64) as u8 {
                return None;
            }
            let Immed8 = if let Some((len, table)) = Immed8::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let CheckInIT_CZNO = if let Some((len, table)) =
                CheckInIT_CZNO::parse(
                    tokens,
                    &mut context_current,
                    inst_start,
                    global_set,
                ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((CheckInIT_CZNO, Immed8, ItCond), (Rd0810), block_len))
        };
        let ((mut CheckInIT_CZNO, mut Immed8, mut ItCond), (Rd0810), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        CheckInIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        Immed8.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                CheckInIT_CZNO,
                ItCond,
                Immed8,
                Rd0810,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1429:1"]
#[derive(Clone, Debug)]
pub struct instructionVar342 {
    ItCond: ItCond,
    tmp: i64,
}
impl instructionVar342 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ItCond, tmp } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("udf")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#"),
            DisplayElement::Signed(true, *tmp),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut tmp = 0i64;
        tmp = ((i64::try_from(thc0003).unwrap() << (12u64 as i64))
            | i64::try_from(thc0011).unwrap());
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let thc0003 = token_parser.thc0003();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op4() != (3967u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (thc0003), block_len))
        };
        let ((mut ItCond), (thc0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let thc0011 = token_parser.thc0011();
            if token_parser.op12() != (10u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (thc0011), block_len))
        };
        let ((), (thc0011), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        let tmp = 0i64;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { ItCond, tmp }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1407:1"]
#[derive(Clone, Debug)]
pub struct instructionVar343 {
    tmp: i64,
}
impl instructionVar343 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { tmp } = self;
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal("hvc"),
            DisplayElement::Literal(" "),
            DisplayElement::Literal("#"),
            DisplayElement::Signed(true, *tmp),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut tmp = 0i64;
        tmp = ((i64::try_from(thc0003).unwrap() << (12u64 as i64))
            | i64::try_from(thc0011).unwrap());
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let thc0003 = token_parser.thc0003();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.op4() != (3966u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (thc0003), block_len))
        };
        let ((), (thc0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let thc0011 = token_parser.thc0011();
            if token_parser.op12() != (8u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (thc0011), block_len))
        };
        let ((), (thc0011), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        let tmp = 0i64;
        *context = context_current;
        Some((inst_len, Self { tmp }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:2532:1"]
#[derive(Clone, Debug)]
pub struct instructionVar344 {
    ItCond: ItCond,
    Hrd0002: Hrd0002,
    Hrm0305: Hrm0305,
}
impl instructionVar344 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            Hrd0002,
            Hrm0305,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("\t")];
        display.extend_from_slice(&extend);
        Hrd0002.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        Hrm0305.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op8() != (70u64 as i64) as u8 {
                return None;
            }
            let Hrm0305 = if let Some((len, table)) = Hrm0305::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.rm0306() != (14u64 as i64) as u8 {
                return None;
            }
            let Hrd0002 = if let Some((len, table)) = Hrd0002::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.hrd0002() != (7u64 as i64) as u8 {
                return None;
            }
            if token_parser.h1() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((ItCond, Hrm0305, Hrd0002), (), block_len))
        };
        let ((mut ItCond, mut Hrm0305, mut Hrd0002), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        Hrd0002.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        Hrm0305.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                Hrd0002,
                Hrm0305,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:2395:1"]
#[derive(Clone, Debug)]
pub struct instructionVar345 {
    ItCond: ItCond,
    CheckInIT_CZN: CheckInIT_CZN,
    Rm0305: u8,
    Rd0002: u8,
}
impl instructionVar345 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            CheckInIT_CZN,
            Rm0305,
            Rd0002,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("lsr")];
        display.extend_from_slice(&extend);
        CheckInIT_CZN.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047783056016(usize::try_from(*Rm0305).unwrap()),
            DisplayElement::Literal(","),
            DisplayElement::Literal("#0x20"),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rm0305 = token_parser.Rm0305();
            let Rd0002 = token_parser.Rd0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op11() != (1u64 as i64) as u8 {
                return None;
            }
            let Immed5 = if let Some((len, table)) = Immed5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.immed5() != (0u64 as i64) as u8 {
                return None;
            }
            let CheckInIT_CZN = if let Some((len, table)) = CheckInIT_CZN::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, Immed5, CheckInIT_CZN), (Rm0305, Rd0002), block_len))
        };
        let (
            (mut ItCond, mut Immed5, mut CheckInIT_CZN),
            (Rm0305, Rd0002),
            block_len,
        ) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        CheckInIT_CZN.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                CheckInIT_CZN,
                Rm0305,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1252:1"]
#[derive(Clone, Debug)]
pub struct instructionVar346 {
    ItCond: ItCond,
    CheckInIT_CZN: CheckInIT_CZN,
    Rm0305: u8,
    Rd0002: u8,
}
impl instructionVar346 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            CheckInIT_CZN,
            Rm0305,
            Rd0002,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("asr")];
        display.extend_from_slice(&extend);
        CheckInIT_CZN.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047783056016(usize::try_from(*Rm0305).unwrap()),
            DisplayElement::Literal(","),
            DisplayElement::Literal("#0x20"),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rm0305 = token_parser.Rm0305();
            let Rd0002 = token_parser.Rd0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op11() != (2u64 as i64) as u8 {
                return None;
            }
            let Immed5 = if let Some((len, table)) = Immed5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.immed5() != (0u64 as i64) as u8 {
                return None;
            }
            let CheckInIT_CZN = if let Some((len, table)) = CheckInIT_CZN::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((CheckInIT_CZN, ItCond, Immed5), (Rm0305, Rd0002), block_len))
        };
        let (
            (mut CheckInIT_CZN, mut ItCond, mut Immed5),
            (Rm0305, Rd0002),
            block_len,
        ) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        CheckInIT_CZN.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                CheckInIT_CZN,
                Rm0305,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:2540:1"]
#[derive(Clone, Debug)]
pub struct instructionVar347 {
    ItCond: ItCond,
    Hrm0305: Hrm0305,
    Hrd0002: Hrd0002,
}
impl instructionVar347 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            Hrm0305,
            Hrd0002,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("\t")];
        display.extend_from_slice(&extend);
        Hrd0002.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        Hrm0305.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op8() != (70u64 as i64) as u8 {
                return None;
            }
            let Hrm0305 = if let Some((len, table)) = Hrm0305::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.hrm0305() != (7u64 as i64) as u8 {
                return None;
            }
            let Hrd0002 = if let Some((len, table)) = Hrd0002::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.hrd0002() != (6u64 as i64) as u8 {
                return None;
            }
            if token_parser.h1() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((Hrm0305, ItCond, Hrd0002), (), block_len))
        };
        let ((mut Hrm0305, mut ItCond, mut Hrd0002), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        Hrm0305.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        Hrd0002.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        let context_tmp = &mut context_current;
        let mut LRset = context_tmp.read_LRset();
        let mut TMode = context_tmp.read_TMode();
        LRset = u8::try_from((1u64 as i64)).unwrap();
        TMode = u8::try_from((1u64 as i64)).unwrap();
        global_set.set_LRset(
            Some(u32::try_from(inst_next).unwrap()),
            u8::try_into(LRset).unwrap(),
        );
        global_set.set_TMode(
            Some(u32::try_from(inst_next).unwrap()),
            u8::try_into(TMode).unwrap(),
        );
        context_tmp.write_LRset(LRset);
        context_tmp.write_TMode(TMode);
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                Hrm0305,
                Hrd0002,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:4522:1"]
#[derive(Clone, Debug)]
pub struct instructionVar348 {
    CheckInIT_CZNO: CheckInIT_CZNO,
    ItCond: ItCond,
    Rd0002: u8,
    Rm0608: u8,
    Rn0305: u8,
}
impl instructionVar348 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            CheckInIT_CZNO,
            ItCond,
            Rd0002,
            Rm0608,
            Rn0305,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sub")];
        display.extend_from_slice(&extend);
        CheckInIT_CZNO.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047783056016(usize::try_from(*Rn0305).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047783056016(usize::try_from(*Rm0608).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rm0608 = token_parser.Rm0608();
            let Rn0305 = token_parser.Rn0305();
            let Rd0002 = token_parser.Rd0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op9() != (13u64 as i64) as u8 {
                return None;
            }
            let CheckInIT_CZNO = if let Some((len, table)) =
                CheckInIT_CZNO::parse(
                    tokens,
                    &mut context_current,
                    inst_start,
                    global_set,
                ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some((
                (ItCond, CheckInIT_CZNO),
                (Rm0608, Rn0305, Rd0002),
                block_len,
            ))
        };
        let (
            (mut ItCond, mut CheckInIT_CZNO),
            (Rm0608, Rn0305, Rd0002),
            block_len,
        ) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        CheckInIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                CheckInIT_CZNO,
                ItCond,
                Rd0002,
                Rm0608,
                Rn0305,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1146:1"]
#[derive(Clone, Debug)]
pub struct instructionVar349 {
    ItCond: ItCond,
    CheckInIT_CZNO: CheckInIT_CZNO,
    Rd0002: u8,
    Rm0608: u8,
    Rn0305: u8,
}
impl instructionVar349 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            CheckInIT_CZNO,
            Rd0002,
            Rm0608,
            Rn0305,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("add")];
        display.extend_from_slice(&extend);
        CheckInIT_CZNO.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047783056016(usize::try_from(*Rn0305).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047783056016(usize::try_from(*Rm0608).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rm0608 = token_parser.Rm0608();
            let Rn0305 = token_parser.Rn0305();
            let Rd0002 = token_parser.Rd0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op9() != (12u64 as i64) as u8 {
                return None;
            }
            let CheckInIT_CZNO = if let Some((len, table)) =
                CheckInIT_CZNO::parse(
                    tokens,
                    &mut context_current,
                    inst_start,
                    global_set,
                ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some((
                (ItCond, CheckInIT_CZNO),
                (Rn0305, Rm0608, Rd0002),
                block_len,
            ))
        };
        let (
            (mut ItCond, mut CheckInIT_CZNO),
            (Rn0305, Rm0608, Rd0002),
            block_len,
        ) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        CheckInIT_CZNO.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                CheckInIT_CZNO,
                Rd0002,
                Rm0608,
                Rn0305,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3217:1"]
#[derive(Clone, Debug)]
pub struct instructionVar350 {
    thstrlist_dec: thstrlist_dec,
    ItCond: ItCond,
}
impl instructionVar350 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            thstrlist_dec,
            ItCond,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("push")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("    ")];
        display.extend_from_slice(&extend);
        thstrlist_dec.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op0() != (59693u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (), block_len))
        };
        let ((mut ItCond), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let thstrlist_dec = if let Some((len, table)) = thstrlist_dec::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thstrlist_dec), (), block_len))
        };
        let ((mut thstrlist_dec), (), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        thstrlist_dec.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                thstrlist_dec,
                ItCond,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3126:1"]
#[derive(Clone, Debug)]
pub struct instructionVar351 {
    ItCond: ItCond,
    thldrlist_inc: thldrlist_inc,
}
impl instructionVar351 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            thldrlist_inc,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("pop")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("    ")];
        display.extend_from_slice(&extend);
        thldrlist_inc.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op0() != (59581u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (), block_len))
        };
        let ((mut ItCond), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let thldrlist_inc = if let Some((len, table)) = thldrlist_inc::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thldrlist_inc), (), block_len))
        };
        let ((mut thldrlist_inc), (), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        thldrlist_inc.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                thldrlist_inc,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:2956:1"]
#[derive(Clone, Debug)]
pub struct instructionVar352 {}
impl instructionVar352 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("nop")];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.op0() != (18112u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:2948:1"]
#[derive(Clone, Debug)]
pub struct instructionVar353 {
    ItCond: ItCond,
}
impl instructionVar353 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ItCond } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("nop")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op0() != (48896u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (), block_len))
        };
        let ((mut ItCond), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { ItCond }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:4531:1"]
#[derive(Clone, Debug)]
pub struct instructionVar354 {
    ItCond: ItCond,
    Immed7_4: Immed7_4,
}
impl instructionVar354 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ItCond, Immed7_4 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("sub")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("\t"),
            DisplayElement::Register(Register::sp),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        Immed7_4.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op7() != (353u64 as i64) as u16 {
                return None;
            }
            let Immed7_4 = if let Some((len, table)) = Immed7_4::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((Immed7_4, ItCond), (), block_len))
        };
        let ((mut Immed7_4, mut ItCond), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        Immed7_4.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { ItCond, Immed7_4 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1537:1"]
#[derive(Clone, Debug)]
pub struct instructionVar355 {
    ItCond: ItCond,
    Hrm0305: Hrm0305,
    bxns: bxns,
}
impl instructionVar355 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            Hrm0305,
            bxns,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bx")];
        display.extend_from_slice(&extend);
        bxns.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("\t")];
        display.extend_from_slice(&extend);
        Hrm0305.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if context.read_LRset() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.op7() != (142u64 as i64) as u16 {
                return None;
            }
            let Hrm0305 = if let Some((len, table)) = Hrm0305::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let bxns = if let Some((len, table)) = bxns::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((Hrm0305, ItCond, bxns), (), block_len))
        };
        let ((mut Hrm0305, mut ItCond, mut bxns), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        Hrm0305.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        bxns.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        let context_tmp = &mut context_current;
        let mut LRset = context_tmp.read_LRset();
        let mut TMode = context_tmp.read_TMode();
        LRset = u8::try_from((0u64 as i64)).unwrap();
        TMode = u8::try_from((1u64 as i64)).unwrap();
        global_set.set_LRset(
            Some(u32::try_from(inst_next).unwrap()),
            u8::try_into(LRset).unwrap(),
        );
        global_set.set_TMode(
            Some(u32::try_from(inst_next).unwrap()),
            u8::try_into(TMode).unwrap(),
        );
        context_tmp.write_LRset(LRset);
        context_tmp.write_TMode(TMode);
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                Hrm0305,
                bxns,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1530:1"]
#[derive(Clone, Debug)]
pub struct instructionVar356 {
    ItCond: ItCond,
    bxns: bxns,
    Hrm0305: Hrm0305,
}
impl instructionVar356 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            bxns,
            Hrm0305,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bx")];
        display.extend_from_slice(&extend);
        bxns.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("\t")];
        display.extend_from_slice(&extend);
        Hrm0305.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op7() != (142u64 as i64) as u16 {
                return None;
            }
            let Hrm0305 = if let Some((len, table)) = Hrm0305::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let bxns = if let Some((len, table)) = bxns::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, bxns, Hrm0305), (), block_len))
        };
        let ((mut ItCond, mut bxns, mut Hrm0305), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        bxns.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        Hrm0305.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                bxns,
                Hrm0305,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1512:1"]
#[derive(Clone, Debug)]
pub struct instructionVar357 {
    ItCond: ItCond,
    bxns: bxns,
    Hrm0305: Hrm0305,
}
impl instructionVar357 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            bxns,
            Hrm0305,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("blx")];
        display.extend_from_slice(&extend);
        bxns.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("\t")];
        display.extend_from_slice(&extend);
        Hrm0305.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op7() != (143u64 as i64) as u16 {
                return None;
            }
            let Hrm0305 = if let Some((len, table)) = Hrm0305::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let bxns = if let Some((len, table)) = bxns::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((bxns, ItCond, Hrm0305), (), block_len))
        };
        let ((mut bxns, mut ItCond, mut Hrm0305), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        bxns.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        Hrm0305.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                bxns,
                Hrm0305,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1175:1"]
#[derive(Clone, Debug)]
pub struct instructionVar358 {
    Immed7_4: Immed7_4,
    ItCond: ItCond,
}
impl instructionVar358 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { Immed7_4, ItCond } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("add")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("\t"),
            DisplayElement::Register(Register::sp),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        Immed7_4.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op7() != (352u64 as i64) as u16 {
                return None;
            }
            let Immed7_4 = if let Some((len, table)) = Immed7_4::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((Immed7_4, ItCond), (), block_len))
        };
        let ((mut Immed7_4, mut ItCond), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        Immed7_4.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { Immed7_4, ItCond }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:2518:1"]
#[derive(Clone, Debug)]
pub struct instructionVar359 {
    Hrm0305: Hrm0305,
    Hrd0002: Hrd0002,
    ItCond: ItCond,
}
impl instructionVar359 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            Hrm0305,
            Hrd0002,
            ItCond,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mov")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("\t")];
        display.extend_from_slice(&extend);
        Hrd0002.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        Hrm0305.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op8() != (70u64 as i64) as u8 {
                return None;
            }
            let Hrm0305 = if let Some((len, table)) = Hrm0305::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let Hrd0002 = if let Some((len, table)) = Hrd0002::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((Hrd0002, Hrm0305, ItCond), (), block_len))
        };
        let ((mut Hrd0002, mut Hrm0305, mut ItCond), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        Hrm0305.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        Hrd0002.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                Hrm0305,
                Hrd0002,
                ItCond,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1687:1"]
#[derive(Clone, Debug)]
pub struct instructionVar360 {
    Hrn0002: Hrn0002,
    Hrm0305: Hrm0305,
    ItCond: ItCond,
}
impl instructionVar360 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            Hrn0002,
            Hrm0305,
            ItCond,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cmp")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("\t")];
        display.extend_from_slice(&extend);
        Hrn0002.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        Hrm0305.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op8() != (69u64 as i64) as u8 {
                return None;
            }
            let Hrm0305 = if let Some((len, table)) = Hrm0305::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let Hrn0002 = if let Some((len, table)) = Hrn0002::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, Hrn0002, Hrm0305), (), block_len))
        };
        let ((mut ItCond, mut Hrn0002, mut Hrm0305), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        Hrn0002.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        Hrm0305.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                Hrn0002,
                Hrm0305,
                ItCond,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1155:1"]
#[derive(Clone, Debug)]
pub struct instructionVar361 {
    ItCond: ItCond,
    Hrm0305: Hrm0305,
    Hrd0002: Hrd0002,
}
impl instructionVar361 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            Hrm0305,
            Hrd0002,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("add")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("\t")];
        display.extend_from_slice(&extend);
        Hrd0002.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        Hrm0305.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op8() != (68u64 as i64) as u8 {
                return None;
            }
            let Hrd0002 = if let Some((len, table)) = Hrd0002::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let Hrm0305 = if let Some((len, table)) = Hrm0305::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, Hrd0002, Hrm0305), (), block_len))
        };
        let ((mut ItCond, mut Hrd0002, mut Hrm0305), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        Hrm0305.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        Hrd0002.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                Hrm0305,
                Hrd0002,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1504:1"]
#[derive(Clone, Debug)]
pub struct instructionVar362 {
    ThArmAddr23: ThArmAddr23,
    ItCond: ItCond,
}
impl instructionVar362 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ThArmAddr23,
            ItCond,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("blx")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" \t")];
        display.extend_from_slice(&extend);
        ThArmAddr23.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut TMode = context_current.read_TMode();
        TMode = u8::try_from((0u64 as i64)).unwrap();
        global_set.set_TMode(None, u8::try_into(TMode).unwrap());
        TMode = u8::try_from((1u64 as i64)).unwrap();
        context_current.write_TMode(TMode);
        context_current.write_TMode(TMode);
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mut sub_pattern_c51 = |token, context: &mut T| {
                let mut block_len = 0 as u32;
                let mut context_current = context.clone();
                let mut token_current = token;
                let mut block_0 = |tokens, context: &mut T| {
                    let mut block_len = 0 as u32;
                    let mut context_current = context.clone();
                    let token_parser = TokenParser16::new(tokens)?;
                    block_len = 2u64 as u32;
                    if token_parser.op11() != (30u64 as i64) as u8 {
                        return None;
                    }
                    *context = context_current;
                    Some(((), (), block_len))
                };
                let ((), (), block_len) =
                    block_0(token_current, &mut context_current)?;
                token_current =
                    &token_current[usize::try_from(block_len).unwrap()..];
                let mut block_1 = |tokens, context: &mut T| {
                    let mut block_len = 0 as u32;
                    let mut context_current = context.clone();
                    let token_parser = TokenParser16::new(tokens)?;
                    block_len = 2u64 as u32;
                    if token_parser.part2c1415() != (3u64 as i64) as u8 {
                        return None;
                    }
                    if token_parser.part2c1212() != (0u64 as i64) as u8 {
                        return None;
                    }
                    *context = context_current;
                    Some(((), (), block_len))
                };
                let ((), (), block_len) =
                    block_1(token_current, &mut context_current)?;
                token_current =
                    &token_current[usize::try_from(block_len).unwrap()..];
                *context = context_current;
                Some(((), (), block_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c51(tokens, &mut context_current)?;
            block_len = block_len.max(sub_len);
            let ThArmAddr23 = if let Some((len, table)) = ThArmAddr23::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ThArmAddr23, ItCond), (), block_len))
        };
        let ((mut ThArmAddr23, mut ItCond), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ThArmAddr23.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ThArmAddr23,
                ItCond,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1474:1"]
#[derive(Clone, Debug)]
pub struct instructionVar363 {
    ItCond: ItCond,
    ThAddr24: ThAddr24,
}
impl instructionVar363 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ItCond, ThAddr24 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bl")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" \t")];
        display.extend_from_slice(&extend);
        ThAddr24.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            if context.read_CALLoverride() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mut sub_pattern_c64 = |token, context: &mut T| {
                let mut block_len = 0 as u32;
                let mut context_current = context.clone();
                let mut token_current = token;
                let mut block_0 = |tokens, context: &mut T| {
                    let mut block_len = 0 as u32;
                    let mut context_current = context.clone();
                    let token_parser = TokenParser16::new(tokens)?;
                    block_len = 2u64 as u32;
                    if token_parser.op11() != (30u64 as i64) as u8 {
                        return None;
                    }
                    *context = context_current;
                    Some(((), (), block_len))
                };
                let ((), (), block_len) =
                    block_0(token_current, &mut context_current)?;
                token_current =
                    &token_current[usize::try_from(block_len).unwrap()..];
                let mut block_1 = |tokens, context: &mut T| {
                    let mut block_len = 0 as u32;
                    let mut context_current = context.clone();
                    let token_parser = TokenParser16::new(tokens)?;
                    block_len = 2u64 as u32;
                    if token_parser.part2c1415() != (3u64 as i64) as u8 {
                        return None;
                    }
                    if token_parser.part2c1212() != (1u64 as i64) as u8 {
                        return None;
                    }
                    *context = context_current;
                    Some(((), (), block_len))
                };
                let ((), (), block_len) =
                    block_1(token_current, &mut context_current)?;
                token_current =
                    &token_current[usize::try_from(block_len).unwrap()..];
                *context = context_current;
                Some(((), (), block_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c64(tokens, &mut context_current)?;
            block_len = block_len.max(sub_len);
            let ThAddr24 = if let Some((len, table)) = ThAddr24::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, ThAddr24), (), block_len))
        };
        let ((mut ItCond, mut ThAddr24), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ThAddr24.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { ItCond, ThAddr24 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1439:1"]
#[derive(Clone, Debug)]
pub struct instructionVar364 {
    ThAddr24: ThAddr24,
    ItCond: ItCond,
}
impl instructionVar364 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ThAddr24, ItCond } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("bl")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(" \t")];
        display.extend_from_slice(&extend);
        ThAddr24.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mut sub_pattern_c47 = |token, context: &mut T| {
                let mut block_len = 0 as u32;
                let mut context_current = context.clone();
                let mut token_current = token;
                let mut block_0 = |tokens, context: &mut T| {
                    let mut block_len = 0 as u32;
                    let mut context_current = context.clone();
                    let token_parser = TokenParser16::new(tokens)?;
                    block_len = 2u64 as u32;
                    if token_parser.op11() != (30u64 as i64) as u8 {
                        return None;
                    }
                    *context = context_current;
                    Some(((), (), block_len))
                };
                let ((), (), block_len) =
                    block_0(token_current, &mut context_current)?;
                token_current =
                    &token_current[usize::try_from(block_len).unwrap()..];
                let mut block_1 = |tokens, context: &mut T| {
                    let mut block_len = 0 as u32;
                    let mut context_current = context.clone();
                    let token_parser = TokenParser16::new(tokens)?;
                    block_len = 2u64 as u32;
                    if token_parser.part2c1415() != (3u64 as i64) as u8 {
                        return None;
                    }
                    if token_parser.part2c1212() != (1u64 as i64) as u8 {
                        return None;
                    }
                    *context = context_current;
                    Some(((), (), block_len))
                };
                let ((), (), block_len) =
                    block_1(token_current, &mut context_current)?;
                token_current =
                    &token_current[usize::try_from(block_len).unwrap()..];
                *context = context_current;
                Some(((), (), block_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c47(tokens, &mut context_current)?;
            block_len = block_len.max(sub_len);
            let ThAddr24 = if let Some((len, table)) = ThAddr24::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, ThAddr24), (), block_len))
        };
        let ((mut ItCond, mut ThAddr24), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ThAddr24.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { ThAddr24, ItCond }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1464:1"]
#[derive(Clone, Debug)]
pub struct instructionVar365 {
    ItCond: ItCond,
    off: i64,
}
impl instructionVar365 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ItCond, off } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("blx")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" \t"),
            DisplayElement::Literal("#"),
            DisplayElement::Signed(true, *off),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut off = 0i64;
        off = (i64::try_from(offset11).unwrap() << (1u64 as i64));
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let offset11 = token_parser.offset11();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op11() != (29u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0000() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (offset11), block_len))
        };
        let ((mut ItCond), (offset11), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        let off = 0i64;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { ItCond, off }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:2404:1"]
#[derive(Clone, Debug)]
pub struct instructionVar366 {
    ItCond: ItCond,
    CheckInIT_CZN: CheckInIT_CZN,
    Immed5: Immed5,
    Rd0002: u8,
    Rm0305: u8,
}
impl instructionVar366 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            CheckInIT_CZN,
            Immed5,
            Rd0002,
            Rm0305,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("lsr")];
        display.extend_from_slice(&extend);
        CheckInIT_CZN.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047783056016(usize::try_from(*Rm0305).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        Immed5.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rm0305 = token_parser.Rm0305();
            let Rd0002 = token_parser.Rd0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op11() != (1u64 as i64) as u8 {
                return None;
            }
            let Immed5 = if let Some((len, table)) = Immed5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let CheckInIT_CZN = if let Some((len, table)) = CheckInIT_CZN::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, Immed5, CheckInIT_CZN), (Rm0305, Rd0002), block_len))
        };
        let (
            (mut ItCond, mut Immed5, mut CheckInIT_CZN),
            (Rm0305, Rd0002),
            block_len,
        ) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        CheckInIT_CZN.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        Immed5.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                CheckInIT_CZN,
                Immed5,
                Rd0002,
                Rm0305,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:2370:1"]
#[derive(Clone, Debug)]
pub struct instructionVar367 {
    ItCond: ItCond,
    CheckInIT_CZN: CheckInIT_CZN,
    Immed5: Immed5,
    Rm0305: u8,
    Rd0002: u8,
}
impl instructionVar367 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            CheckInIT_CZN,
            Immed5,
            Rm0305,
            Rd0002,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("lsl")];
        display.extend_from_slice(&extend);
        CheckInIT_CZN.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047783056016(usize::try_from(*Rm0305).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        Immed5.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rm0305 = token_parser.Rm0305();
            let Rd0002 = token_parser.Rd0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op11() != (0u64 as i64) as u8 {
                return None;
            }
            let Immed5 = if let Some((len, table)) = Immed5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let CheckInIT_CZN = if let Some((len, table)) = CheckInIT_CZN::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((CheckInIT_CZN, Immed5, ItCond), (Rm0305, Rd0002), block_len))
        };
        let (
            (mut CheckInIT_CZN, mut Immed5, mut ItCond),
            (Rm0305, Rd0002),
            block_len,
        ) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        CheckInIT_CZN.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        Immed5.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                CheckInIT_CZN,
                Immed5,
                Rm0305,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1261:1"]
#[derive(Clone, Debug)]
pub struct instructionVar368 {
    Immed5: Immed5,
    CheckInIT_CZN: CheckInIT_CZN,
    ItCond: ItCond,
    Rd0002: u8,
    Rm0305: u8,
}
impl instructionVar368 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            Immed5,
            CheckInIT_CZN,
            ItCond,
            Rd0002,
            Rm0305,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("asr")];
        display.extend_from_slice(&extend);
        CheckInIT_CZN.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 5usize] = [
            DisplayElement::Literal("\t"),
            meaning_94047783056016(usize::try_from(*Rd0002).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047783056016(usize::try_from(*Rm0305).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        Immed5.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rm0305 = token_parser.Rm0305();
            let Rd0002 = token_parser.Rd0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op11() != (2u64 as i64) as u8 {
                return None;
            }
            let Immed5 = if let Some((len, table)) = Immed5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let CheckInIT_CZN = if let Some((len, table)) = CheckInIT_CZN::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, CheckInIT_CZN, Immed5), (Rm0305, Rd0002), block_len))
        };
        let (
            (mut ItCond, mut CheckInIT_CZN, mut Immed5),
            (Rm0305, Rd0002),
            block_len,
        ) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        Immed5.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        CheckInIT_CZN.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                Immed5,
                CheckInIT_CZN,
                ItCond,
                Rd0002,
                Rm0305,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1315:1"]
#[derive(Clone, Debug)]
pub struct instructionVar369 {
    thcc: thcc,
    Addr8: Addr8,
}
impl instructionVar369 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thcc, Addr8 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
        thcc.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("\t")];
        display.extend_from_slice(&extend);
        Addr8.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op12() != (13u64 as i64) as u8 {
                return None;
            }
            let thcc = if let Some((len, table)) = thcc::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mut sub_pattern_c9 = |token, context: &mut T| {
                let mut block_len = 0 as u32;
                let mut context_current = context.clone();
                let mut token_current = token;
                let mut block_0 = |tokens, context: &mut T| {
                    let token_parser = TokenParser16::new(tokens)?;
                    block_len = 2u64 as u32;
                    if token_parser.thc1515() == (0u64 as i64) as u8 {
                        return Some(((), (), u32::try_from(0u64).unwrap()));
                    }
                    let token_parser = TokenParser16::new(tokens)?;
                    block_len = 2u64 as u32;
                    if token_parser.thc1414() == (0u64 as i64) as u8 {
                        return Some(((), (), u32::try_from(0u64).unwrap()));
                    }
                    let token_parser = TokenParser16::new(tokens)?;
                    block_len = 2u64 as u32;
                    if token_parser.thc1313() == (0u64 as i64) as u8 {
                        return Some(((), (), u32::try_from(0u64).unwrap()));
                    }
                    None
                };
                let ((), (), block_len) =
                    block_0(token_current, &mut context_current)?;
                token_current =
                    &token_current[usize::try_from(block_len).unwrap()..];
                *context = context_current;
                Some(((), (), block_len))
            };
            let ((), (), sub_len) =
                sub_pattern_c9(tokens, &mut context_current)?;
            block_len = block_len.max(sub_len);
            let Addr8 = if let Some((len, table)) = Addr8::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, thcc, Addr8), (), block_len))
        };
        let ((mut ItCond, mut thcc, mut Addr8), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        thcc.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        Addr8.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { thcc, Addr8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:4293:1"]
#[derive(Clone, Debug)]
pub struct instructionVar370 {
    ItCond: ItCond,
    Rn_exclaim: Rn_exclaim,
    stbrace: stbrace,
}
impl instructionVar370 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            Rn_exclaim,
            stbrace,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("stmia")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("\t")];
        display.extend_from_slice(&extend);
        Rn_exclaim.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        stbrace.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op11() != (24u64 as i64) as u8 {
                return None;
            }
            let Rn_exclaim = if let Some((len, table)) = Rn_exclaim::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let stbrace = if let Some((len, table)) = stbrace::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let Rn_exclaim_WB = if let Some((len, table)) = Rn_exclaim_WB::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((Rn_exclaim_WB, Rn_exclaim, stbrace, ItCond), (), block_len))
        };
        let (
            (mut Rn_exclaim_WB, mut Rn_exclaim, mut stbrace, mut ItCond),
            (),
            block_len,
        ) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        Rn_exclaim.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        stbrace.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                Rn_exclaim,
                stbrace,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1923:1"]
#[derive(Clone, Debug)]
pub struct instructionVar371 {
    ItCond: ItCond,
    Rn_exclaim: Rn_exclaim,
    ldbrace: ldbrace,
}
impl instructionVar371 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            Rn_exclaim,
            ldbrace,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("ldmia")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("\t")];
        display.extend_from_slice(&extend);
        Rn_exclaim.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        ldbrace.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op11() != (25u64 as i64) as u8 {
                return None;
            }
            let Rn_exclaim = if let Some((len, table)) = Rn_exclaim::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let ldbrace = if let Some((len, table)) = ldbrace::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let Rn_exclaim_WB = if let Some((len, table)) = Rn_exclaim_WB::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((Rn_exclaim_WB, ItCond, ldbrace, Rn_exclaim), (), block_len))
        };
        let (
            (mut Rn_exclaim_WB, mut ItCond, mut ldbrace, mut Rn_exclaim),
            (),
            block_len,
        ) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        Rn_exclaim.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ldbrace.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                Rn_exclaim,
                ldbrace,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1320:1"]
#[derive(Clone, Debug)]
pub struct instructionVar372 {
    Addr11: Addr11,
    ItCond: ItCond,
}
impl instructionVar372 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { Addr11, ItCond } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("b")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("\t")];
        display.extend_from_slice(&extend);
        Addr11.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op11() != (28u64 as i64) as u8 {
                return None;
            }
            let Addr11 = if let Some((len, table)) = Addr11::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((Addr11, ItCond), (), block_len))
        };
        let ((mut Addr11, mut ItCond), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        Addr11.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { Addr11, ItCond }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:4085:1"]
#[derive(Clone, Debug)]
pub struct instructionVar373 {
    ItCond: ItCond,
    thSRSMode: thSRSMode,
}
impl instructionVar373 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ItCond, thSRSMode } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("srsia")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::sp),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        thSRSMode.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op6() != (934u64 as i64) as u16 {
                return None;
            }
            if token_parser.thc0505() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0004() != (13u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (), block_len))
        };
        let ((mut ItCond), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.op8() != (192u64 as i64) as u8 {
                return None;
            }
            if token_parser.sop0507() != (0u64 as i64) as u8 {
                return None;
            }
            let thSRSMode = if let Some((len, table)) = thSRSMode::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thSRSMode), (), block_len))
        };
        let ((mut thSRSMode), (), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        thSRSMode.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { ItCond, thSRSMode }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:4074:1"]
#[derive(Clone, Debug)]
pub struct instructionVar374 {
    thSRSMode: thSRSMode,
    ItCond: ItCond,
}
impl instructionVar374 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thSRSMode, ItCond } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("srsib")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::sp),
            DisplayElement::Literal("!"),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        thSRSMode.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op6() != (934u64 as i64) as u16 {
                return None;
            }
            if token_parser.thc0505() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0004() != (13u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (), block_len))
        };
        let ((mut ItCond), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.op8() != (192u64 as i64) as u8 {
                return None;
            }
            if token_parser.sop0507() != (0u64 as i64) as u8 {
                return None;
            }
            let thSRSMode = if let Some((len, table)) = thSRSMode::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thSRSMode), (), block_len))
        };
        let ((mut thSRSMode), (), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        thSRSMode.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { thSRSMode, ItCond }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:4064:1"]
#[derive(Clone, Debug)]
pub struct instructionVar375 {
    thSRSMode: thSRSMode,
    ItCond: ItCond,
}
impl instructionVar375 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thSRSMode, ItCond } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("srsdb")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::sp),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        thSRSMode.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op6() != (928u64 as i64) as u16 {
                return None;
            }
            if token_parser.thc0505() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0004() != (13u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (), block_len))
        };
        let ((mut ItCond), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.op8() != (192u64 as i64) as u8 {
                return None;
            }
            if token_parser.sop0507() != (0u64 as i64) as u8 {
                return None;
            }
            let thSRSMode = if let Some((len, table)) = thSRSMode::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thSRSMode), (), block_len))
        };
        let ((mut thSRSMode), (), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        thSRSMode.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { thSRSMode, ItCond }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:4053:1"]
#[derive(Clone, Debug)]
pub struct instructionVar376 {
    thSRSMode: thSRSMode,
    ItCond: ItCond,
}
impl instructionVar376 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thSRSMode, ItCond } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("srsdb")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(" "),
            DisplayElement::Register(Register::sp),
            DisplayElement::Literal("!"),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        thSRSMode.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op6() != (928u64 as i64) as u16 {
                return None;
            }
            if token_parser.thc0505() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0004() != (13u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (), block_len))
        };
        let ((mut ItCond), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.op8() != (192u64 as i64) as u8 {
                return None;
            }
            if token_parser.sop0507() != (0u64 as i64) as u8 {
                return None;
            }
            let thSRSMode = if let Some((len, table)) = thSRSMode::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thSRSMode), (), block_len))
        };
        let ((mut thSRSMode), (), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        thSRSMode.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((inst_len, Self { thSRSMode, ItCond }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1567:1"]
#[derive(Clone, Debug)]
pub struct instructionVar377 {
    ItCond: ItCond,
    Addr5: Addr5,
    Rn0002: u8,
}
impl instructionVar377 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            Addr5,
            Rn0002,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cbz")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("  "),
            meaning_94047783056016(usize::try_from(*Rn0002).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        Addr5.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0002 = token_parser.Rn0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op12() != (11u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc1111() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc1010() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0808() != (1u64 as i64) as u8 {
                return None;
            }
            let Addr5 = if let Some((len, table)) = Addr5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, Addr5), (Rn0002), block_len))
        };
        let ((mut ItCond, mut Addr5), (Rn0002), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        Addr5.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                Addr5,
                Rn0002,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:1560:1"]
#[derive(Clone, Debug)]
pub struct instructionVar378 {
    Addr5: Addr5,
    ItCond: ItCond,
    Rn0002: u8,
}
impl instructionVar378 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            Addr5,
            ItCond,
            Rn0002,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("cbnz")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("  "),
            meaning_94047783056016(usize::try_from(*Rn0002).unwrap()),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        Addr5.display_extend(display, context);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0002 = token_parser.Rn0002();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op12() != (11u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc1111() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc1010() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0808() != (1u64 as i64) as u8 {
                return None;
            }
            let Addr5 = if let Some((len, table)) = Addr5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ItCond, Addr5), (Rn0002), block_len))
        };
        let ((mut ItCond, mut Addr5), (Rn0002), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        Addr5.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                Addr5,
                ItCond,
                Rn0002,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:2476:1"]
#[derive(Clone, Debug)]
pub struct instructionVar379 {
    ItCond: ItCond,
    thcpn: u8,
    thc0507: u8,
    Rt1215: u8,
    thCRn: u8,
    thCRm: u8,
    thopcode2: u8,
}
impl instructionVar379 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            thcpn,
            thc0507,
            Rt1215,
            thCRn,
            thCRm,
            thopcode2,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("mcr2")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 12usize] = [
            DisplayElement::Literal(" "),
            meaning_94047764607584(usize::try_from(*thcpn).unwrap()),
            DisplayElement::Literal(","),
            DisplayElement::Unsigned(true, u64::try_from(*thc0507).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rt1215).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047764607520(usize::try_from(*thCRn).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047764607520(usize::try_from(*thCRm).unwrap()),
            DisplayElement::Literal(","),
            DisplayElement::Unsigned(true, u64::try_from(*thopcode2).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let thc0507 = token_parser.thc0507();
            let thCRn = token_parser.thCRn();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op8() != (254u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0404() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (thCRn, thc0507), block_len))
        };
        let ((mut ItCond), (thCRn, thc0507), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rt1215 = token_parser.Rt1215();
            let thcpn = token_parser.thcpn();
            let thopcode2 = token_parser.thopcode2();
            let thCRm = token_parser.thCRm();
            if token_parser.thc0404() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (thopcode2, Rt1215, thcpn, thCRm), block_len))
        };
        let ((), (thopcode2, Rt1215, thcpn, thCRm), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                thcpn,
                thc0507,
                Rt1215,
                thCRn,
                thCRm,
                thopcode2,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:2467:1"]
#[derive(Clone, Debug)]
pub struct instructionVar380 {
    ItCond: ItCond,
    thCRn: u8,
    thc0507: u8,
    Rt1215: u8,
    thCRm: u8,
    thopcode2: u8,
    thcpn: u8,
}
impl instructionVar380 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            thCRn,
            thc0507,
            Rt1215,
            thCRm,
            thopcode2,
            thcpn,
        } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mcr")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 12usize] = [
            DisplayElement::Literal(" "),
            meaning_94047764607584(usize::try_from(*thcpn).unwrap()),
            DisplayElement::Literal(","),
            DisplayElement::Unsigned(true, u64::try_from(*thc0507).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rt1215).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047764607520(usize::try_from(*thCRn).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047764607520(usize::try_from(*thCRm).unwrap()),
            DisplayElement::Literal(","),
            DisplayElement::Unsigned(true, u64::try_from(*thopcode2).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let thc0507 = token_parser.thc0507();
            let thCRn = token_parser.thCRn();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op8() != (238u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0404() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (thCRn, thc0507), block_len))
        };
        let ((mut ItCond), (thCRn, thc0507), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rt1215 = token_parser.Rt1215();
            let thcpn = token_parser.thcpn();
            let thopcode2 = token_parser.thopcode2();
            let thCRm = token_parser.thCRm();
            if token_parser.thc0404() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rt1215, thCRm, thopcode2, thcpn), block_len))
        };
        let ((), (Rt1215, thCRm, thopcode2, thcpn), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                thCRn,
                thc0507,
                Rt1215,
                thCRm,
                thopcode2,
                thcpn,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:4016:1"]
#[derive(Clone, Debug)]
pub struct instructionVar381 {
    ItCond: ItCond,
    Rm0003: u8,
    Rd0811: u8,
    Rn0003: u8,
}
impl instructionVar381 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            Rm0003,
            Rd0811,
            Rn0003,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smultt")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(" "),
            meaning_94047761878256(usize::try_from(*Rd0811).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rn0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rm0003).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0003 = token_parser.Rn0003();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op4() != (4017u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (Rn0003), block_len))
        };
        let ((mut ItCond), (Rn0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0811 = token_parser.Rd0811();
            let Rm0003 = token_parser.Rm0003();
            if token_parser.op12() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.sop0407() != (3u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rm0003, Rd0811), block_len))
        };
        let ((), (Rm0003, Rd0811), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                Rm0003,
                Rd0811,
                Rn0003,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:4006:1"]
#[derive(Clone, Debug)]
pub struct instructionVar382 {
    ItCond: ItCond,
    Rn0003: u8,
    Rd0811: u8,
    Rm0003: u8,
}
impl instructionVar382 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            Rn0003,
            Rd0811,
            Rm0003,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smultb")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(" "),
            meaning_94047761878256(usize::try_from(*Rd0811).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rn0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rm0003).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0003 = token_parser.Rn0003();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op4() != (4017u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (Rn0003), block_len))
        };
        let ((mut ItCond), (Rn0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0811 = token_parser.Rd0811();
            let Rm0003 = token_parser.Rm0003();
            if token_parser.op12() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.sop0407() != (2u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rm0003, Rd0811), block_len))
        };
        let ((), (Rm0003, Rd0811), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                Rn0003,
                Rd0811,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3996:1"]
#[derive(Clone, Debug)]
pub struct instructionVar383 {
    ItCond: ItCond,
    Rd0811: u8,
    Rn0003: u8,
    Rm0003: u8,
}
impl instructionVar383 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            Rd0811,
            Rn0003,
            Rm0003,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smulbt")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(" "),
            meaning_94047761878256(usize::try_from(*Rd0811).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rn0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rm0003).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0003 = token_parser.Rn0003();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op4() != (4017u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (Rn0003), block_len))
        };
        let ((mut ItCond), (Rn0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0811 = token_parser.Rd0811();
            let Rm0003 = token_parser.Rm0003();
            if token_parser.op12() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.sop0407() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rd0811, Rm0003), block_len))
        };
        let ((), (Rd0811, Rm0003), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                Rd0811,
                Rn0003,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3986:1"]
#[derive(Clone, Debug)]
pub struct instructionVar384 {
    ItCond: ItCond,
    Rm0003: u8,
    Rd0811: u8,
    Rn0003: u8,
}
impl instructionVar384 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            Rm0003,
            Rd0811,
            Rn0003,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smulbb")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal(" "),
            meaning_94047761878256(usize::try_from(*Rd0811).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rn0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rm0003).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0003 = token_parser.Rn0003();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op4() != (4017u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (Rn0003), block_len))
        };
        let ((mut ItCond), (Rn0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0811 = token_parser.Rd0811();
            let Rm0003 = token_parser.Rm0003();
            if token_parser.op12() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.sop0407() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rm0003, Rd0811), block_len))
        };
        let ((), (Rm0003, Rd0811), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                Rm0003,
                Rd0811,
                Rn0003,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3966:1"]
#[derive(Clone, Debug)]
pub struct instructionVar385 {
    ItCond: ItCond,
    Rm0003: u8,
    Rd0811: u8,
    Rn0003: u8,
}
impl instructionVar385 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            Rm0003,
            Rd0811,
            Rn0003,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smmulr")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("   "),
            meaning_94047761878256(usize::try_from(*Rd0811).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rn0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rm0003).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0003 = token_parser.Rn0003();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op4() != (4021u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (Rn0003), block_len))
        };
        let ((mut ItCond), (Rn0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0811 = token_parser.Rd0811();
            let Rm0003 = token_parser.Rm0003();
            if token_parser.thc1215() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0407() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rm0003, Rd0811), block_len))
        };
        let ((), (Rm0003, Rd0811), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                Rm0003,
                Rd0811,
                Rn0003,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3959:1"]
#[derive(Clone, Debug)]
pub struct instructionVar386 {
    ItCond: ItCond,
    Rd0811: u8,
    Rn0003: u8,
    Rm0003: u8,
}
impl instructionVar386 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            Rd0811,
            Rn0003,
            Rm0003,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smmul")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("   "),
            meaning_94047761878256(usize::try_from(*Rd0811).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rn0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rm0003).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0003 = token_parser.Rn0003();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op4() != (4021u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (Rn0003), block_len))
        };
        let ((mut ItCond), (Rn0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0811 = token_parser.Rd0811();
            let Rm0003 = token_parser.Rm0003();
            if token_parser.thc1215() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0407() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rd0811, Rm0003), block_len))
        };
        let ((), (Rd0811, Rm0003), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                Rd0811,
                Rn0003,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3343:1"]
#[derive(Clone, Debug)]
pub struct instructionVar387 {
    ItCond: ItCond,
    Rd0811: u8,
    Rn0003: u8,
    Rm0003: u8,
}
impl instructionVar387 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            Rd0811,
            Rn0003,
            Rm0003,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("qsub")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("   "),
            meaning_94047761878256(usize::try_from(*Rd0811).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rn0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rm0003).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0003 = token_parser.Rn0003();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op4() != (4008u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (Rn0003), block_len))
        };
        let ((mut ItCond), (Rn0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0811 = token_parser.Rd0811();
            let Rm0003 = token_parser.Rm0003();
            if token_parser.op12() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0407() != (10u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rd0811, Rm0003), block_len))
        };
        let ((), (Rd0811, Rm0003), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                Rd0811,
                Rn0003,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3308:1"]
#[derive(Clone, Debug)]
pub struct instructionVar388 {
    ItCond: ItCond,
    Rn0003: u8,
    Rd0811: u8,
    Rm0003: u8,
}
impl instructionVar388 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            Rn0003,
            Rd0811,
            Rm0003,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("qdsub")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("   "),
            meaning_94047761878256(usize::try_from(*Rd0811).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rn0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rm0003).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0003 = token_parser.Rn0003();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op4() != (4008u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (Rn0003), block_len))
        };
        let ((mut ItCond), (Rn0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0811 = token_parser.Rd0811();
            let Rm0003 = token_parser.Rm0003();
            if token_parser.op12() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0407() != (11u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rd0811, Rm0003), block_len))
        };
        let ((), (Rd0811, Rm0003), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                Rn0003,
                Rd0811,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3296:1"]
#[derive(Clone, Debug)]
pub struct instructionVar389 {
    ItCond: ItCond,
    Rn0003: u8,
    Rd0811: u8,
    Rm0003: u8,
}
impl instructionVar389 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            Rn0003,
            Rd0811,
            Rm0003,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("qdadd")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("   "),
            meaning_94047761878256(usize::try_from(*Rd0811).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rn0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rm0003).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0003 = token_parser.Rn0003();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op4() != (4008u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (Rn0003), block_len))
        };
        let ((mut ItCond), (Rn0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0811 = token_parser.Rd0811();
            let Rm0003 = token_parser.Rm0003();
            if token_parser.op12() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0407() != (9u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rm0003, Rd0811), block_len))
        };
        let ((), (Rm0003, Rd0811), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                Rn0003,
                Rd0811,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3228:1"]
#[derive(Clone, Debug)]
pub struct instructionVar390 {
    ItCond: ItCond,
    Rn0003: u8,
    Rd0811: u8,
    Rm0003: u8,
}
impl instructionVar390 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            Rn0003,
            Rd0811,
            Rm0003,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("qadd")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("   "),
            meaning_94047761878256(usize::try_from(*Rd0811).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rn0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rm0003).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0003 = token_parser.Rn0003();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op4() != (4008u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (Rn0003), block_len))
        };
        let ((mut ItCond), (Rn0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0811 = token_parser.Rd0811();
            let Rm0003 = token_parser.Rm0003();
            if token_parser.op12() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0407() != (8u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rm0003, Rd0811), block_len))
        };
        let ((), (Rm0003, Rd0811), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                Rn0003,
                Rd0811,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:4026:1"]
#[derive(Clone, Debug)]
pub struct instructionVar391 {
    ItCond: ItCond,
    Ra1215: u8,
    Rm0003: u8,
    Rd0811: u8,
    Rn0003: u8,
}
impl instructionVar391 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            Ra1215,
            Rm0003,
            Rd0811,
            Rn0003,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smull")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal("  "),
            meaning_94047761878256(usize::try_from(*Ra1215).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rd0811).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rn0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rm0003).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0003 = token_parser.Rn0003();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op4() != (4024u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (Rn0003), block_len))
        };
        let ((mut ItCond), (Rn0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Ra1215 = token_parser.Ra1215();
            let Rd0811 = token_parser.Rd0811();
            let Rm0003 = token_parser.Rm0003();
            if token_parser.sop0407() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Ra1215, Rd0811, Rm0003), block_len))
        };
        let ((), (Ra1215, Rd0811, Rm0003), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                Ra1215,
                Rm0003,
                Rd0811,
                Rn0003,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3950:1"]
#[derive(Clone, Debug)]
pub struct instructionVar392 {
    ItCond: ItCond,
    Rn0003: u8,
    Ra1215: u8,
    Rd0811: u8,
    Rm0003: u8,
}
impl instructionVar392 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            Rn0003,
            Ra1215,
            Rd0811,
            Rm0003,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smmlsr")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal("   "),
            meaning_94047761878256(usize::try_from(*Rd0811).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rn0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rm0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Ra1215).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0003 = token_parser.Rn0003();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op4() != (4022u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (Rn0003), block_len))
        };
        let ((mut ItCond), (Rn0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Ra1215 = token_parser.Ra1215();
            let Rd0811 = token_parser.Rd0811();
            let Rm0003 = token_parser.Rm0003();
            if token_parser.thc0407() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rd0811, Ra1215, Rm0003), block_len))
        };
        let ((), (Rd0811, Ra1215, Rm0003), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                Rn0003,
                Ra1215,
                Rd0811,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3942:1"]
#[derive(Clone, Debug)]
pub struct instructionVar393 {
    ItCond: ItCond,
    Rn0003: u8,
    Ra1215: u8,
    Rm0003: u8,
    Rd0811: u8,
}
impl instructionVar393 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            Rn0003,
            Ra1215,
            Rm0003,
            Rd0811,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smmls")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal("   "),
            meaning_94047761878256(usize::try_from(*Rd0811).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rn0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rm0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Ra1215).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0003 = token_parser.Rn0003();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op4() != (4022u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (Rn0003), block_len))
        };
        let ((mut ItCond), (Rn0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Ra1215 = token_parser.Ra1215();
            let Rd0811 = token_parser.Rd0811();
            let Rm0003 = token_parser.Rm0003();
            if token_parser.thc0407() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rd0811, Rm0003, Ra1215), block_len))
        };
        let ((), (Rd0811, Rm0003, Ra1215), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                Rn0003,
                Ra1215,
                Rm0003,
                Rd0811,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3933:1"]
#[derive(Clone, Debug)]
pub struct instructionVar394 {
    ItCond: ItCond,
    Rn0003: u8,
    Rm0003: u8,
    Ra1215: u8,
    Rd0811: u8,
}
impl instructionVar394 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            Rn0003,
            Rm0003,
            Ra1215,
            Rd0811,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smmlar")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal("   "),
            meaning_94047761878256(usize::try_from(*Rd0811).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rn0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rm0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Ra1215).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0003 = token_parser.Rn0003();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op4() != (4021u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (Rn0003), block_len))
        };
        let ((mut ItCond), (Rn0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Ra1215 = token_parser.Ra1215();
            let Rd0811 = token_parser.Rd0811();
            let Rm0003 = token_parser.Rm0003();
            if token_parser.thc0407() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Ra1215, Rd0811, Rm0003), block_len))
        };
        let ((), (Ra1215, Rd0811, Rm0003), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                Rn0003,
                Rm0003,
                Ra1215,
                Rd0811,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3924:1"]
#[derive(Clone, Debug)]
pub struct instructionVar395 {
    ItCond: ItCond,
    Ra1215: u8,
    Rm0003: u8,
    Rn0003: u8,
    Rd0811: u8,
}
impl instructionVar395 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            Ra1215,
            Rm0003,
            Rn0003,
            Rd0811,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smmla")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal("   "),
            meaning_94047761878256(usize::try_from(*Rd0811).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rn0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rm0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Ra1215).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0003 = token_parser.Rn0003();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op4() != (4021u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (Rn0003), block_len))
        };
        let ((mut ItCond), (Rn0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Ra1215 = token_parser.Ra1215();
            let Rd0811 = token_parser.Rd0811();
            let Rm0003 = token_parser.Rm0003();
            if token_parser.thc0407() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rd0811, Rm0003, Ra1215), block_len))
        };
        let ((), (Rd0811, Rm0003, Ra1215), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                Ra1215,
                Rm0003,
                Rn0003,
                Rd0811,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3867:1"]
#[derive(Clone, Debug)]
pub struct instructionVar396 {
    ItCond: ItCond,
    Rm0003: u8,
    Rd0811: u8,
    Rn0003: u8,
    Rt1215: u8,
}
impl instructionVar396 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            Rm0003,
            Rd0811,
            Rn0003,
            Rt1215,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smlal")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal("  "),
            meaning_94047761878256(usize::try_from(*Rt1215).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rd0811).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rn0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rm0003).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0003 = token_parser.Rn0003();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op4() != (4028u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (Rn0003), block_len))
        };
        let ((mut ItCond), (Rn0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rt1215 = token_parser.Rt1215();
            let Rd0811 = token_parser.Rd0811();
            let Rm0003 = token_parser.Rm0003();
            if token_parser.sop0407() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (Rm0003, Rt1215, Rd0811), block_len))
        };
        let ((), (Rm0003, Rt1215, Rd0811), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                Rm0003,
                Rd0811,
                Rn0003,
                Rt1215,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:4046:1"]
#[derive(Clone, Debug)]
pub struct instructionVar397 {
    thYBIT: thYBIT,
    ItCond: ItCond,
    Rm0003: u8,
    Rd0811: u8,
    Rn0003: u8,
}
impl instructionVar397 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            thYBIT,
            ItCond,
            Rm0003,
            Rd0811,
            Rn0003,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smulw")];
        display.extend_from_slice(&extend);
        thYBIT.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("   "),
            meaning_94047761878256(usize::try_from(*Rd0811).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rn0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rm0003).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0003 = token_parser.Rn0003();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op4() != (4019u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (Rn0003), block_len))
        };
        let ((mut ItCond), (Rn0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0811 = token_parser.Rd0811();
            let Rm0003 = token_parser.Rm0003();
            if token_parser.thc1215() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0507() != (0u64 as i64) as u8 {
                return None;
            }
            let thYBIT = if let Some((len, table)) = thYBIT::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thYBIT), (Rd0811, Rm0003), block_len))
        };
        let ((mut thYBIT), (Rd0811, Rm0003), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        thYBIT.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                thYBIT,
                ItCond,
                Rm0003,
                Rd0811,
                Rn0003,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:4034:1"]
#[derive(Clone, Debug)]
pub struct instructionVar398 {
    ItCond: ItCond,
    thdXbot: thdXbot,
    Rd0811: u8,
    Rm0003: u8,
    Rn0003: u8,
}
impl instructionVar398 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            thdXbot,
            Rd0811,
            Rm0003,
            Rn0003,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smusd")];
        display.extend_from_slice(&extend);
        thdXbot.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("   "),
            meaning_94047761878256(usize::try_from(*Rd0811).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rn0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rm0003).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0003 = token_parser.Rn0003();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op4() != (4020u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (Rn0003), block_len))
        };
        let ((mut ItCond), (Rn0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0811 = token_parser.Rd0811();
            let Rm0003 = token_parser.Rm0003();
            if token_parser.thc1215() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0507() != (0u64 as i64) as u8 {
                return None;
            }
            let thdXbot = if let Some((len, table)) = thdXbot::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let thdXtop = if let Some((len, table)) = thdXtop::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thdXbot, thdXtop), (Rm0003, Rd0811), block_len))
        };
        let ((mut thdXbot, mut thdXtop), (Rm0003, Rd0811), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        thdXbot.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                thdXbot,
                Rd0811,
                Rm0003,
                Rn0003,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3974:1"]
#[derive(Clone, Debug)]
pub struct instructionVar399 {
    ItCond: ItCond,
    thdXbot: thdXbot,
    Rd0811: u8,
    Rn0003: u8,
    Rm0003: u8,
}
impl instructionVar399 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            thdXbot,
            Rd0811,
            Rn0003,
            Rm0003,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smuad")];
        display.extend_from_slice(&extend);
        thdXbot.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("   "),
            meaning_94047761878256(usize::try_from(*Rd0811).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rn0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rm0003).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0003 = token_parser.Rn0003();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op4() != (4018u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (Rn0003), block_len))
        };
        let ((mut ItCond), (Rn0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rd0811 = token_parser.Rd0811();
            let Rm0003 = token_parser.Rm0003();
            if token_parser.thc1215() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0507() != (0u64 as i64) as u8 {
                return None;
            }
            let thdXbot = if let Some((len, table)) = thdXbot::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let thdXtop = if let Some((len, table)) = thdXtop::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thdXtop, thdXbot), (Rd0811, Rm0003), block_len))
        };
        let ((mut thdXtop, mut thdXbot), (Rd0811, Rm0003), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        thdXbot.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                thdXbot,
                Rd0811,
                Rn0003,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3909:1"]
#[derive(Clone, Debug)]
pub struct instructionVar400 {
    thdXbot: thdXbot,
    ItCond: ItCond,
    Rm0003: u8,
    Rt1215: u8,
    Rn0003: u8,
    Rd0811: u8,
}
impl instructionVar400 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            thdXbot,
            ItCond,
            Rm0003,
            Rt1215,
            Rn0003,
            Rd0811,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smlsld")];
        display.extend_from_slice(&extend);
        thdXbot.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal("   "),
            meaning_94047761878256(usize::try_from(*Rt1215).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rd0811).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rn0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rm0003).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0003 = token_parser.Rn0003();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op4() != (4029u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (Rn0003), block_len))
        };
        let ((mut ItCond), (Rn0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rt1215 = token_parser.Rt1215();
            let Rd0811 = token_parser.Rd0811();
            let Rm0003 = token_parser.Rm0003();
            if token_parser.thc0507() != (6u64 as i64) as u8 {
                return None;
            }
            let thdXbot = if let Some((len, table)) = thdXbot::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let thdXtop = if let Some((len, table)) = thdXtop::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thdXbot, thdXtop), (Rm0003, Rd0811, Rt1215), block_len))
        };
        let ((mut thdXbot, mut thdXtop), (Rm0003, Rd0811, Rt1215), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        thdXbot.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                thdXbot,
                ItCond,
                Rm0003,
                Rt1215,
                Rn0003,
                Rd0811,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3896:1"]
#[derive(Clone, Debug)]
pub struct instructionVar401 {
    thdXbot: thdXbot,
    ItCond: ItCond,
    Rn0003: u8,
    Ra1215: u8,
    Rm0003: u8,
    Rd0811: u8,
}
impl instructionVar401 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            thdXbot,
            ItCond,
            Rn0003,
            Ra1215,
            Rm0003,
            Rd0811,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smlsd")];
        display.extend_from_slice(&extend);
        thdXbot.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal("   "),
            meaning_94047761878256(usize::try_from(*Rd0811).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rn0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rm0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Ra1215).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0003 = token_parser.Rn0003();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op4() != (4020u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (Rn0003), block_len))
        };
        let ((mut ItCond), (Rn0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Ra1215 = token_parser.Ra1215();
            let Rd0811 = token_parser.Rd0811();
            let Rm0003 = token_parser.Rm0003();
            if token_parser.thc0507() != (0u64 as i64) as u8 {
                return None;
            }
            let thdXbot = if let Some((len, table)) = thdXbot::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let thdXtop = if let Some((len, table)) = thdXtop::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thdXtop, thdXbot), (Rm0003, Rd0811, Ra1215), block_len))
        };
        let ((mut thdXtop, mut thdXbot), (Rm0003, Rd0811, Ra1215), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        thdXbot.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                thdXbot,
                ItCond,
                Rn0003,
                Ra1215,
                Rm0003,
                Rd0811,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3886:1"]
#[derive(Clone, Debug)]
pub struct instructionVar402 {
    thYBIT: thYBIT,
    ItCond: ItCond,
    Rn0003: u8,
    Rm0003: u8,
    Ra1215: u8,
    Rd0811: u8,
}
impl instructionVar402 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            thYBIT,
            ItCond,
            Rn0003,
            Rm0003,
            Ra1215,
            Rd0811,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smlaw")];
        display.extend_from_slice(&extend);
        thYBIT.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal("   "),
            meaning_94047761878256(usize::try_from(*Rd0811).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rn0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rm0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Ra1215).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0003 = token_parser.Rn0003();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op4() != (4019u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (Rn0003), block_len))
        };
        let ((mut ItCond), (Rn0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Ra1215 = token_parser.Ra1215();
            let Rd0811 = token_parser.Rd0811();
            let Rm0003 = token_parser.Rm0003();
            if token_parser.thc0507() != (0u64 as i64) as u8 {
                return None;
            }
            let thYBIT = if let Some((len, table)) = thYBIT::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thYBIT), (Rm0003, Ra1215, Rd0811), block_len))
        };
        let ((mut thYBIT), (Rm0003, Ra1215, Rd0811), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        thYBIT.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                thYBIT,
                ItCond,
                Rn0003,
                Rm0003,
                Ra1215,
                Rd0811,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3852:1"]
#[derive(Clone, Debug)]
pub struct instructionVar403 {
    ItCond: ItCond,
    thdXbot: thdXbot,
    Rm0003: u8,
    Rn0003: u8,
    Rd0811: u8,
    Rt1215: u8,
}
impl instructionVar403 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            thdXbot,
            Rm0003,
            Rn0003,
            Rd0811,
            Rt1215,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smlald")];
        display.extend_from_slice(&extend);
        thdXbot.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal("   "),
            meaning_94047761878256(usize::try_from(*Rt1215).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rd0811).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rn0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rm0003).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0003 = token_parser.Rn0003();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op4() != (4028u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (Rn0003), block_len))
        };
        let ((mut ItCond), (Rn0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rt1215 = token_parser.Rt1215();
            let Rd0811 = token_parser.Rd0811();
            let Rm0003 = token_parser.Rm0003();
            if token_parser.thc0507() != (6u64 as i64) as u8 {
                return None;
            }
            let thdXbot = if let Some((len, table)) = thdXbot::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let thdXtop = if let Some((len, table)) = thdXtop::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thdXtop, thdXbot), (Rd0811, Rt1215, Rm0003), block_len))
        };
        let ((mut thdXtop, mut thdXbot), (Rd0811, Rt1215, Rm0003), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        thdXbot.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                thdXbot,
                Rm0003,
                Rn0003,
                Rd0811,
                Rt1215,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3839:1"]
#[derive(Clone, Debug)]
pub struct instructionVar404 {
    ItCond: ItCond,
    thdXbot: thdXbot,
    Rn0003: u8,
    Rd0811: u8,
    Ra1215: u8,
    Rm0003: u8,
}
impl instructionVar404 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            thdXbot,
            Rn0003,
            Rd0811,
            Ra1215,
            Rm0003,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smlad")];
        display.extend_from_slice(&extend);
        thdXbot.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal("   "),
            meaning_94047761878256(usize::try_from(*Rd0811).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rn0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rm0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Ra1215).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0003 = token_parser.Rn0003();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op4() != (4018u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (Rn0003), block_len))
        };
        let ((mut ItCond), (Rn0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Ra1215 = token_parser.Ra1215();
            let Rd0811 = token_parser.Rd0811();
            let Rm0003 = token_parser.Rm0003();
            if token_parser.thc0507() != (0u64 as i64) as u8 {
                return None;
            }
            let thdXbot = if let Some((len, table)) = thdXbot::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let thdXtop = if let Some((len, table)) = thdXtop::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thdXbot, thdXtop), (Ra1215, Rm0003, Rd0811), block_len))
        };
        let ((mut thdXbot, mut thdXtop), (Ra1215, Rm0003, Rd0811), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        thdXbot.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                thdXbot,
                Rn0003,
                Rd0811,
                Ra1215,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3876:1"]
#[derive(Clone, Debug)]
pub struct instructionVar405 {
    thYBIT: thYBIT,
    ItCond: ItCond,
    thXBIT: thXBIT,
    Rm0003: u8,
    Rn0003: u8,
    Rt1215: u8,
    Rd0811: u8,
}
impl instructionVar405 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            thYBIT,
            ItCond,
            thXBIT,
            Rm0003,
            Rn0003,
            Rt1215,
            Rd0811,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smlal")];
        display.extend_from_slice(&extend);
        thXBIT.display_extend(display, context);
        thYBIT.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal("   "),
            meaning_94047761878256(usize::try_from(*Rt1215).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rd0811).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rn0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rm0003).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mut sub_pattern_c82 = |token, context: &mut T| {
                let mut block_len = 0 as u32;
                let mut context_current = context.clone();
                let mut token_current = token;
                let mut block_0 = |tokens, context: &mut T| {
                    let mut block_len = 0 as u32;
                    let mut context_current = context.clone();
                    let token_parser = TokenParser16::new(tokens)?;
                    block_len = 2u64 as u32;
                    let Rn0003 = token_parser.Rn0003();
                    if token_parser.op4() != (4028u64 as i64) as u16 {
                        return None;
                    }
                    *context = context_current;
                    Some(((), (Rn0003), block_len))
                };
                let ((), (Rn0003), block_len) =
                    block_0(token_current, &mut context_current)?;
                token_current =
                    &token_current[usize::try_from(block_len).unwrap()..];
                let mut block_1 = |tokens, context: &mut T| {
                    let mut block_len = 0 as u32;
                    let mut context_current = context.clone();
                    let token_parser = TokenParser16::new(tokens)?;
                    block_len = 2u64 as u32;
                    let Rt1215 = token_parser.Rt1215();
                    let Rd0811 = token_parser.Rd0811();
                    let Rm0003 = token_parser.Rm0003();
                    if token_parser.thc0607() != (2u64 as i64) as u8 {
                        return None;
                    }
                    let thYBIT = if let Some((len, table)) = thYBIT::parse(
                        tokens,
                        &mut context_current,
                        inst_start,
                        global_set,
                    ) {
                        block_len = len as u32;
                        table
                    } else {
                        return None;
                    };
                    *context = context_current;
                    Some(((thYBIT), (Rm0003, Rt1215, Rd0811), block_len))
                };
                let ((mut thYBIT), (Rm0003, Rt1215, Rd0811), block_len) =
                    block_1(token_current, &mut context_current)?;
                token_current =
                    &token_current[usize::try_from(block_len).unwrap()..];
                *context = context_current;
                Some(((thYBIT), (Rn0003, Rm0003, Rt1215, Rd0811), block_len))
            };
            let ((mut thYBIT), (Rn0003, Rm0003, Rt1215, Rd0811), sub_len) =
                sub_pattern_c82(tokens, &mut context_current)?;
            block_len = block_len.max(sub_len);
            let thXBIT = if let Some((len, table)) = thXBIT::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some((
                (ItCond, thYBIT, thXBIT),
                (Rn0003, Rm0003, Rt1215, Rd0811),
                block_len,
            ))
        };
        let (
            (mut ItCond, mut thYBIT, mut thXBIT),
            (Rn0003, Rm0003, Rt1215, Rd0811),
            block_len,
        ) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        thYBIT.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        thXBIT.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                thYBIT,
                ItCond,
                thXBIT,
                Rm0003,
                Rn0003,
                Rt1215,
                Rd0811,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:3825:1"]
#[derive(Clone, Debug)]
pub struct instructionVar406 {
    thYBIT: thYBIT,
    ItCond: ItCond,
    thXBIT: thXBIT,
    Rd0811: u8,
    Rt1215: u8,
    Rm0003: u8,
    Rn0003: u8,
}
impl instructionVar406 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            thYBIT,
            ItCond,
            thXBIT,
            Rd0811,
            Rt1215,
            Rm0003,
            Rn0003,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("smla")];
        display.extend_from_slice(&extend);
        thXBIT.display_extend(display, context);
        thYBIT.display_extend(display, context);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 8usize] = [
            DisplayElement::Literal("   "),
            meaning_94047761878256(usize::try_from(*Rd0811).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rn0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rm0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rt1215).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            let mut sub_pattern_c81 = |token, context: &mut T| {
                let mut block_len = 0 as u32;
                let mut context_current = context.clone();
                let mut token_current = token;
                let mut block_0 = |tokens, context: &mut T| {
                    let mut block_len = 0 as u32;
                    let mut context_current = context.clone();
                    let token_parser = TokenParser16::new(tokens)?;
                    block_len = 2u64 as u32;
                    let Rn0003 = token_parser.Rn0003();
                    if token_parser.op4() != (4017u64 as i64) as u16 {
                        return None;
                    }
                    *context = context_current;
                    Some(((), (Rn0003), block_len))
                };
                let ((), (Rn0003), block_len) =
                    block_0(token_current, &mut context_current)?;
                token_current =
                    &token_current[usize::try_from(block_len).unwrap()..];
                let mut block_1 = |tokens, context: &mut T| {
                    let mut block_len = 0 as u32;
                    let mut context_current = context.clone();
                    let token_parser = TokenParser16::new(tokens)?;
                    block_len = 2u64 as u32;
                    let Rt1215 = token_parser.Rt1215();
                    let Rd0811 = token_parser.Rd0811();
                    let Rm0003 = token_parser.Rm0003();
                    if token_parser.thc0607() != (0u64 as i64) as u8 {
                        return None;
                    }
                    let thYBIT = if let Some((len, table)) = thYBIT::parse(
                        tokens,
                        &mut context_current,
                        inst_start,
                        global_set,
                    ) {
                        block_len = len as u32;
                        table
                    } else {
                        return None;
                    };
                    *context = context_current;
                    Some(((thYBIT), (Rm0003, Rt1215, Rd0811), block_len))
                };
                let ((mut thYBIT), (Rm0003, Rt1215, Rd0811), block_len) =
                    block_1(token_current, &mut context_current)?;
                token_current =
                    &token_current[usize::try_from(block_len).unwrap()..];
                *context = context_current;
                Some(((thYBIT), (Rn0003, Rm0003, Rd0811, Rt1215), block_len))
            };
            let ((mut thYBIT), (Rn0003, Rm0003, Rd0811, Rt1215), sub_len) =
                sub_pattern_c81(tokens, &mut context_current)?;
            block_len = block_len.max(sub_len);
            let thXBIT = if let Some((len, table)) = thXBIT::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some((
                (thYBIT, ItCond, thXBIT),
                (Rd0811, Rt1215, Rm0003, Rn0003),
                block_len,
            ))
        };
        let (
            (mut thYBIT, mut ItCond, mut thXBIT),
            (Rd0811, Rt1215, Rm0003, Rn0003),
            block_len,
        ) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        thYBIT.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        thXBIT.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                thYBIT,
                ItCond,
                thXBIT,
                Rd0811,
                Rt1215,
                Rm0003,
                Rn0003,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:2493:1"]
#[derive(Clone, Debug)]
pub struct instructionVar407 {
    ItCond: ItCond,
    Rn0003: u8,
    thCRm: u8,
    thopcode1: u8,
    thcpn: u8,
    Rt1215: u8,
}
impl instructionVar407 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            Rn0003,
            thCRm,
            thopcode1,
            thcpn,
            Rt1215,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("mcrr")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 10usize] = [
            DisplayElement::Literal(" "),
            meaning_94047764607584(usize::try_from(*thcpn).unwrap()),
            DisplayElement::Literal(","),
            DisplayElement::Unsigned(true, u64::try_from(*thopcode1).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rt1215).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rn0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047764607520(usize::try_from(*thCRm).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0003 = token_parser.Rn0003();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op4() != (4036u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (Rn0003), block_len))
        };
        let ((mut ItCond), (Rn0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rt1215 = token_parser.Rt1215();
            let thcpn = token_parser.thcpn();
            let thopcode1 = token_parser.thopcode1();
            let thCRm = token_parser.thCRm();
            *context = context_current;
            Some(((), (thcpn, thCRm, Rt1215, thopcode1), block_len))
        };
        let ((), (thcpn, thCRm, Rt1215, thopcode1), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                Rn0003,
                thCRm,
                thopcode1,
                thcpn,
                Rt1215,
            },
        ))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:2485:1"]
#[derive(Clone, Debug)]
pub struct instructionVar408 {
    ItCond: ItCond,
    Rt1215: u8,
    thcpn: u8,
    Rn0003: u8,
    thCRm: u8,
    thopcode1: u8,
}
impl instructionVar408 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {
            ItCond,
            Rt1215,
            thcpn,
            Rn0003,
            thCRm,
            thopcode1,
        } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("mcrr")];
        display.extend_from_slice(&extend);
        ItCond.display_extend(display, context);
        let extend: [DisplayElement; 10usize] = [
            DisplayElement::Literal(" "),
            meaning_94047764607584(usize::try_from(*thcpn).unwrap()),
            DisplayElement::Literal(","),
            DisplayElement::Unsigned(true, u64::try_from(*thopcode1).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rt1215).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047761878256(usize::try_from(*Rn0003).unwrap()),
            DisplayElement::Literal(","),
            meaning_94047764607520(usize::try_from(*thCRm).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0003 = token_parser.Rn0003();
            if context.read_TMode() != (1u64 as i64) as u8 {
                return None;
            }
            let ItCond = if let Some((len, table)) = ItCond::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.op4() != (3780u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((ItCond), (Rn0003), block_len))
        };
        let ((mut ItCond), (Rn0003), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rt1215 = token_parser.Rt1215();
            let thcpn = token_parser.thcpn();
            let thopcode1 = token_parser.thopcode1();
            let thCRm = token_parser.thCRm();
            *context = context_current;
            Some(((), (Rt1215, thopcode1, thCRm, thcpn), block_len))
        };
        let ((), (Rt1215, thopcode1, thCRm, thcpn), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let inst_next = inst_start + inst_len;
        ItCond.disassembly(
            &mut context_current,
            inst_start,
            inst_next,
            global_set,
        );
        *context = context_current;
        Some((
            inst_len,
            Self {
                ItCond,
                Rt1215,
                thcpn,
                Rn0003,
                thCRm,
                thopcode1,
            },
        ))
    }
}
#[doc = "Table instruction"]
#[derive(Clone, Debug)]
pub enum instruction {
    Var0(instructionVar0),
    Var1(instructionVar1),
    Var2(instructionVar2),
    Var3(instructionVar3),
    Var4(instructionVar4),
    Var5(instructionVar5),
    Var6(instructionVar6),
    Var7(instructionVar7),
    Var8(instructionVar8),
    Var9(instructionVar9),
    Var10(instructionVar10),
    Var11(instructionVar11),
    Var12(instructionVar12),
    Var13(instructionVar13),
    Var14(instructionVar14),
    Var15(instructionVar15),
    Var16(instructionVar16),
    Var17(instructionVar17),
    Var18(instructionVar18),
    Var19(instructionVar19),
    Var20(instructionVar20),
    Var21(instructionVar21),
    Var22(instructionVar22),
    Var23(instructionVar23),
    Var24(instructionVar24),
    Var25(instructionVar25),
    Var26(instructionVar26),
    Var27(instructionVar27),
    Var28(instructionVar28),
    Var29(instructionVar29),
    Var30(instructionVar30),
    Var31(instructionVar31),
    Var32(instructionVar32),
    Var33(instructionVar33),
    Var34(instructionVar34),
    Var35(instructionVar35),
    Var36(instructionVar36),
    Var37(instructionVar37),
    Var38(instructionVar38),
    Var39(instructionVar39),
    Var40(instructionVar40),
    Var41(instructionVar41),
    Var42(instructionVar42),
    Var43(instructionVar43),
    Var44(instructionVar44),
    Var45(instructionVar45),
    Var46(instructionVar46),
    Var47(instructionVar47),
    Var48(instructionVar48),
    Var49(instructionVar49),
    Var50(instructionVar50),
    Var51(instructionVar51),
    Var52(instructionVar52),
    Var53(instructionVar53),
    Var54(instructionVar54),
    Var55(instructionVar55),
    Var56(instructionVar56),
    Var57(instructionVar57),
    Var58(instructionVar58),
    Var59(instructionVar59),
    Var60(instructionVar60),
    Var61(instructionVar61),
    Var62(instructionVar62),
    Var63(instructionVar63),
    Var64(instructionVar64),
    Var65(instructionVar65),
    Var66(instructionVar66),
    Var67(instructionVar67),
    Var68(instructionVar68),
    Var69(instructionVar69),
    Var70(instructionVar70),
    Var71(instructionVar71),
    Var72(instructionVar72),
    Var73(instructionVar73),
    Var74(instructionVar74),
    Var75(instructionVar75),
    Var76(instructionVar76),
    Var77(instructionVar77),
    Var78(instructionVar78),
    Var79(instructionVar79),
    Var80(instructionVar80),
    Var81(instructionVar81),
    Var82(instructionVar82),
    Var83(instructionVar83),
    Var84(instructionVar84),
    Var85(instructionVar85),
    Var86(instructionVar86),
    Var87(instructionVar87),
    Var88(instructionVar88),
    Var89(instructionVar89),
    Var90(instructionVar90),
    Var91(instructionVar91),
    Var92(instructionVar92),
    Var93(instructionVar93),
    Var94(instructionVar94),
    Var95(instructionVar95),
    Var96(instructionVar96),
    Var97(instructionVar97),
    Var98(instructionVar98),
    Var99(instructionVar99),
    Var100(instructionVar100),
    Var101(instructionVar101),
    Var102(instructionVar102),
    Var103(instructionVar103),
    Var104(instructionVar104),
    Var105(instructionVar105),
    Var106(instructionVar106),
    Var107(instructionVar107),
    Var108(instructionVar108),
    Var109(instructionVar109),
    Var110(instructionVar110),
    Var111(instructionVar111),
    Var112(instructionVar112),
    Var113(instructionVar113),
    Var114(instructionVar114),
    Var115(instructionVar115),
    Var116(instructionVar116),
    Var117(instructionVar117),
    Var118(instructionVar118),
    Var119(instructionVar119),
    Var120(instructionVar120),
    Var121(instructionVar121),
    Var122(instructionVar122),
    Var123(instructionVar123),
    Var124(instructionVar124),
    Var125(instructionVar125),
    Var126(instructionVar126),
    Var127(instructionVar127),
    Var128(instructionVar128),
    Var129(instructionVar129),
    Var130(instructionVar130),
    Var131(instructionVar131),
    Var132(instructionVar132),
    Var133(instructionVar133),
    Var134(instructionVar134),
    Var135(instructionVar135),
    Var136(instructionVar136),
    Var137(instructionVar137),
    Var138(instructionVar138),
    Var139(instructionVar139),
    Var140(instructionVar140),
    Var141(instructionVar141),
    Var142(instructionVar142),
    Var143(instructionVar143),
    Var144(instructionVar144),
    Var145(instructionVar145),
    Var146(instructionVar146),
    Var147(instructionVar147),
    Var148(instructionVar148),
    Var149(instructionVar149),
    Var150(instructionVar150),
    Var151(instructionVar151),
    Var152(instructionVar152),
    Var153(instructionVar153),
    Var154(instructionVar154),
    Var155(instructionVar155),
    Var156(instructionVar156),
    Var157(instructionVar157),
    Var158(instructionVar158),
    Var159(instructionVar159),
    Var160(instructionVar160),
    Var161(instructionVar161),
    Var162(instructionVar162),
    Var163(instructionVar163),
    Var164(instructionVar164),
    Var165(instructionVar165),
    Var166(instructionVar166),
    Var167(instructionVar167),
    Var168(instructionVar168),
    Var169(instructionVar169),
    Var170(instructionVar170),
    Var171(instructionVar171),
    Var172(instructionVar172),
    Var173(instructionVar173),
    Var174(instructionVar174),
    Var175(instructionVar175),
    Var176(instructionVar176),
    Var177(instructionVar177),
    Var178(instructionVar178),
    Var179(instructionVar179),
    Var180(instructionVar180),
    Var181(instructionVar181),
    Var182(instructionVar182),
    Var183(instructionVar183),
    Var184(instructionVar184),
    Var185(instructionVar185),
    Var186(instructionVar186),
    Var187(instructionVar187),
    Var188(instructionVar188),
    Var189(instructionVar189),
    Var190(instructionVar190),
    Var191(instructionVar191),
    Var192(instructionVar192),
    Var193(instructionVar193),
    Var194(instructionVar194),
    Var195(instructionVar195),
    Var196(instructionVar196),
    Var197(instructionVar197),
    Var198(instructionVar198),
    Var199(instructionVar199),
    Var200(instructionVar200),
    Var201(instructionVar201),
    Var202(instructionVar202),
    Var203(instructionVar203),
    Var204(instructionVar204),
    Var205(instructionVar205),
    Var206(instructionVar206),
    Var207(instructionVar207),
    Var208(instructionVar208),
    Var209(instructionVar209),
    Var210(instructionVar210),
    Var211(instructionVar211),
    Var212(instructionVar212),
    Var213(instructionVar213),
    Var214(instructionVar214),
    Var215(instructionVar215),
    Var216(instructionVar216),
    Var217(instructionVar217),
    Var218(instructionVar218),
    Var219(instructionVar219),
    Var220(instructionVar220),
    Var221(instructionVar221),
    Var222(instructionVar222),
    Var223(instructionVar223),
    Var224(instructionVar224),
    Var225(instructionVar225),
    Var226(instructionVar226),
    Var227(instructionVar227),
    Var228(instructionVar228),
    Var229(instructionVar229),
    Var230(instructionVar230),
    Var231(instructionVar231),
    Var232(instructionVar232),
    Var233(instructionVar233),
    Var234(instructionVar234),
    Var235(instructionVar235),
    Var236(instructionVar236),
    Var237(instructionVar237),
    Var238(instructionVar238),
    Var239(instructionVar239),
    Var240(instructionVar240),
    Var241(instructionVar241),
    Var242(instructionVar242),
    Var243(instructionVar243),
    Var244(instructionVar244),
    Var245(instructionVar245),
    Var246(instructionVar246),
    Var247(instructionVar247),
    Var248(instructionVar248),
    Var249(instructionVar249),
    Var250(instructionVar250),
    Var251(instructionVar251),
    Var252(instructionVar252),
    Var253(instructionVar253),
    Var254(instructionVar254),
    Var255(instructionVar255),
    Var256(instructionVar256),
    Var257(instructionVar257),
    Var258(instructionVar258),
    Var259(instructionVar259),
    Var260(instructionVar260),
    Var261(instructionVar261),
    Var262(instructionVar262),
    Var263(instructionVar263),
    Var264(instructionVar264),
    Var265(instructionVar265),
    Var266(instructionVar266),
    Var267(instructionVar267),
    Var268(instructionVar268),
    Var269(instructionVar269),
    Var270(instructionVar270),
    Var271(instructionVar271),
    Var272(instructionVar272),
    Var273(instructionVar273),
    Var274(instructionVar274),
    Var275(instructionVar275),
    Var276(instructionVar276),
    Var277(instructionVar277),
    Var278(instructionVar278),
    Var279(instructionVar279),
    Var280(instructionVar280),
    Var281(instructionVar281),
    Var282(instructionVar282),
    Var283(instructionVar283),
    Var284(instructionVar284),
    Var285(instructionVar285),
    Var286(instructionVar286),
    Var287(instructionVar287),
    Var288(instructionVar288),
    Var289(instructionVar289),
    Var290(instructionVar290),
    Var291(instructionVar291),
    Var292(instructionVar292),
    Var293(instructionVar293),
    Var294(instructionVar294),
    Var295(instructionVar295),
    Var296(instructionVar296),
    Var297(instructionVar297),
    Var298(instructionVar298),
    Var299(instructionVar299),
    Var300(instructionVar300),
    Var301(instructionVar301),
    Var302(instructionVar302),
    Var303(instructionVar303),
    Var304(instructionVar304),
    Var305(instructionVar305),
    Var306(instructionVar306),
    Var307(instructionVar307),
    Var308(instructionVar308),
    Var309(instructionVar309),
    Var310(instructionVar310),
    Var311(instructionVar311),
    Var312(instructionVar312),
    Var313(instructionVar313),
    Var314(instructionVar314),
    Var315(instructionVar315),
    Var316(instructionVar316),
    Var317(instructionVar317),
    Var318(instructionVar318),
    Var319(instructionVar319),
    Var320(instructionVar320),
    Var321(instructionVar321),
    Var322(instructionVar322),
    Var323(instructionVar323),
    Var324(instructionVar324),
    Var325(instructionVar325),
    Var326(instructionVar326),
    Var327(instructionVar327),
    Var328(instructionVar328),
    Var329(instructionVar329),
    Var330(instructionVar330),
    Var331(instructionVar331),
    Var332(instructionVar332),
    Var333(instructionVar333),
    Var334(instructionVar334),
    Var335(instructionVar335),
    Var336(instructionVar336),
    Var337(instructionVar337),
    Var338(instructionVar338),
    Var339(instructionVar339),
    Var340(instructionVar340),
    Var341(instructionVar341),
    Var342(instructionVar342),
    Var343(instructionVar343),
    Var344(instructionVar344),
    Var345(instructionVar345),
    Var346(instructionVar346),
    Var347(instructionVar347),
    Var348(instructionVar348),
    Var349(instructionVar349),
    Var350(instructionVar350),
    Var351(instructionVar351),
    Var352(instructionVar352),
    Var353(instructionVar353),
    Var354(instructionVar354),
    Var355(instructionVar355),
    Var356(instructionVar356),
    Var357(instructionVar357),
    Var358(instructionVar358),
    Var359(instructionVar359),
    Var360(instructionVar360),
    Var361(instructionVar361),
    Var362(instructionVar362),
    Var363(instructionVar363),
    Var364(instructionVar364),
    Var365(instructionVar365),
    Var366(instructionVar366),
    Var367(instructionVar367),
    Var368(instructionVar368),
    Var369(instructionVar369),
    Var370(instructionVar370),
    Var371(instructionVar371),
    Var372(instructionVar372),
    Var373(instructionVar373),
    Var374(instructionVar374),
    Var375(instructionVar375),
    Var376(instructionVar376),
    Var377(instructionVar377),
    Var378(instructionVar378),
    Var379(instructionVar379),
    Var380(instructionVar380),
    Var381(instructionVar381),
    Var382(instructionVar382),
    Var383(instructionVar383),
    Var384(instructionVar384),
    Var385(instructionVar385),
    Var386(instructionVar386),
    Var387(instructionVar387),
    Var388(instructionVar388),
    Var389(instructionVar389),
    Var390(instructionVar390),
    Var391(instructionVar391),
    Var392(instructionVar392),
    Var393(instructionVar393),
    Var394(instructionVar394),
    Var395(instructionVar395),
    Var396(instructionVar396),
    Var397(instructionVar397),
    Var398(instructionVar398),
    Var399(instructionVar399),
    Var400(instructionVar400),
    Var401(instructionVar401),
    Var402(instructionVar402),
    Var403(instructionVar403),
    Var404(instructionVar404),
    Var405(instructionVar405),
    Var406(instructionVar406),
    Var407(instructionVar407),
    Var408(instructionVar408),
}
impl instruction {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
            Self::Var3(x) => x.display_extend(display, context),
            Self::Var4(x) => x.display_extend(display, context),
            Self::Var5(x) => x.display_extend(display, context),
            Self::Var6(x) => x.display_extend(display, context),
            Self::Var7(x) => x.display_extend(display, context),
            Self::Var8(x) => x.display_extend(display, context),
            Self::Var9(x) => x.display_extend(display, context),
            Self::Var10(x) => x.display_extend(display, context),
            Self::Var11(x) => x.display_extend(display, context),
            Self::Var12(x) => x.display_extend(display, context),
            Self::Var13(x) => x.display_extend(display, context),
            Self::Var14(x) => x.display_extend(display, context),
            Self::Var15(x) => x.display_extend(display, context),
            Self::Var16(x) => x.display_extend(display, context),
            Self::Var17(x) => x.display_extend(display, context),
            Self::Var18(x) => x.display_extend(display, context),
            Self::Var19(x) => x.display_extend(display, context),
            Self::Var20(x) => x.display_extend(display, context),
            Self::Var21(x) => x.display_extend(display, context),
            Self::Var22(x) => x.display_extend(display, context),
            Self::Var23(x) => x.display_extend(display, context),
            Self::Var24(x) => x.display_extend(display, context),
            Self::Var25(x) => x.display_extend(display, context),
            Self::Var26(x) => x.display_extend(display, context),
            Self::Var27(x) => x.display_extend(display, context),
            Self::Var28(x) => x.display_extend(display, context),
            Self::Var29(x) => x.display_extend(display, context),
            Self::Var30(x) => x.display_extend(display, context),
            Self::Var31(x) => x.display_extend(display, context),
            Self::Var32(x) => x.display_extend(display, context),
            Self::Var33(x) => x.display_extend(display, context),
            Self::Var34(x) => x.display_extend(display, context),
            Self::Var35(x) => x.display_extend(display, context),
            Self::Var36(x) => x.display_extend(display, context),
            Self::Var37(x) => x.display_extend(display, context),
            Self::Var38(x) => x.display_extend(display, context),
            Self::Var39(x) => x.display_extend(display, context),
            Self::Var40(x) => x.display_extend(display, context),
            Self::Var41(x) => x.display_extend(display, context),
            Self::Var42(x) => x.display_extend(display, context),
            Self::Var43(x) => x.display_extend(display, context),
            Self::Var44(x) => x.display_extend(display, context),
            Self::Var45(x) => x.display_extend(display, context),
            Self::Var46(x) => x.display_extend(display, context),
            Self::Var47(x) => x.display_extend(display, context),
            Self::Var48(x) => x.display_extend(display, context),
            Self::Var49(x) => x.display_extend(display, context),
            Self::Var50(x) => x.display_extend(display, context),
            Self::Var51(x) => x.display_extend(display, context),
            Self::Var52(x) => x.display_extend(display, context),
            Self::Var53(x) => x.display_extend(display, context),
            Self::Var54(x) => x.display_extend(display, context),
            Self::Var55(x) => x.display_extend(display, context),
            Self::Var56(x) => x.display_extend(display, context),
            Self::Var57(x) => x.display_extend(display, context),
            Self::Var58(x) => x.display_extend(display, context),
            Self::Var59(x) => x.display_extend(display, context),
            Self::Var60(x) => x.display_extend(display, context),
            Self::Var61(x) => x.display_extend(display, context),
            Self::Var62(x) => x.display_extend(display, context),
            Self::Var63(x) => x.display_extend(display, context),
            Self::Var64(x) => x.display_extend(display, context),
            Self::Var65(x) => x.display_extend(display, context),
            Self::Var66(x) => x.display_extend(display, context),
            Self::Var67(x) => x.display_extend(display, context),
            Self::Var68(x) => x.display_extend(display, context),
            Self::Var69(x) => x.display_extend(display, context),
            Self::Var70(x) => x.display_extend(display, context),
            Self::Var71(x) => x.display_extend(display, context),
            Self::Var72(x) => x.display_extend(display, context),
            Self::Var73(x) => x.display_extend(display, context),
            Self::Var74(x) => x.display_extend(display, context),
            Self::Var75(x) => x.display_extend(display, context),
            Self::Var76(x) => x.display_extend(display, context),
            Self::Var77(x) => x.display_extend(display, context),
            Self::Var78(x) => x.display_extend(display, context),
            Self::Var79(x) => x.display_extend(display, context),
            Self::Var80(x) => x.display_extend(display, context),
            Self::Var81(x) => x.display_extend(display, context),
            Self::Var82(x) => x.display_extend(display, context),
            Self::Var83(x) => x.display_extend(display, context),
            Self::Var84(x) => x.display_extend(display, context),
            Self::Var85(x) => x.display_extend(display, context),
            Self::Var86(x) => x.display_extend(display, context),
            Self::Var87(x) => x.display_extend(display, context),
            Self::Var88(x) => x.display_extend(display, context),
            Self::Var89(x) => x.display_extend(display, context),
            Self::Var90(x) => x.display_extend(display, context),
            Self::Var91(x) => x.display_extend(display, context),
            Self::Var92(x) => x.display_extend(display, context),
            Self::Var93(x) => x.display_extend(display, context),
            Self::Var94(x) => x.display_extend(display, context),
            Self::Var95(x) => x.display_extend(display, context),
            Self::Var96(x) => x.display_extend(display, context),
            Self::Var97(x) => x.display_extend(display, context),
            Self::Var98(x) => x.display_extend(display, context),
            Self::Var99(x) => x.display_extend(display, context),
            Self::Var100(x) => x.display_extend(display, context),
            Self::Var101(x) => x.display_extend(display, context),
            Self::Var102(x) => x.display_extend(display, context),
            Self::Var103(x) => x.display_extend(display, context),
            Self::Var104(x) => x.display_extend(display, context),
            Self::Var105(x) => x.display_extend(display, context),
            Self::Var106(x) => x.display_extend(display, context),
            Self::Var107(x) => x.display_extend(display, context),
            Self::Var108(x) => x.display_extend(display, context),
            Self::Var109(x) => x.display_extend(display, context),
            Self::Var110(x) => x.display_extend(display, context),
            Self::Var111(x) => x.display_extend(display, context),
            Self::Var112(x) => x.display_extend(display, context),
            Self::Var113(x) => x.display_extend(display, context),
            Self::Var114(x) => x.display_extend(display, context),
            Self::Var115(x) => x.display_extend(display, context),
            Self::Var116(x) => x.display_extend(display, context),
            Self::Var117(x) => x.display_extend(display, context),
            Self::Var118(x) => x.display_extend(display, context),
            Self::Var119(x) => x.display_extend(display, context),
            Self::Var120(x) => x.display_extend(display, context),
            Self::Var121(x) => x.display_extend(display, context),
            Self::Var122(x) => x.display_extend(display, context),
            Self::Var123(x) => x.display_extend(display, context),
            Self::Var124(x) => x.display_extend(display, context),
            Self::Var125(x) => x.display_extend(display, context),
            Self::Var126(x) => x.display_extend(display, context),
            Self::Var127(x) => x.display_extend(display, context),
            Self::Var128(x) => x.display_extend(display, context),
            Self::Var129(x) => x.display_extend(display, context),
            Self::Var130(x) => x.display_extend(display, context),
            Self::Var131(x) => x.display_extend(display, context),
            Self::Var132(x) => x.display_extend(display, context),
            Self::Var133(x) => x.display_extend(display, context),
            Self::Var134(x) => x.display_extend(display, context),
            Self::Var135(x) => x.display_extend(display, context),
            Self::Var136(x) => x.display_extend(display, context),
            Self::Var137(x) => x.display_extend(display, context),
            Self::Var138(x) => x.display_extend(display, context),
            Self::Var139(x) => x.display_extend(display, context),
            Self::Var140(x) => x.display_extend(display, context),
            Self::Var141(x) => x.display_extend(display, context),
            Self::Var142(x) => x.display_extend(display, context),
            Self::Var143(x) => x.display_extend(display, context),
            Self::Var144(x) => x.display_extend(display, context),
            Self::Var145(x) => x.display_extend(display, context),
            Self::Var146(x) => x.display_extend(display, context),
            Self::Var147(x) => x.display_extend(display, context),
            Self::Var148(x) => x.display_extend(display, context),
            Self::Var149(x) => x.display_extend(display, context),
            Self::Var150(x) => x.display_extend(display, context),
            Self::Var151(x) => x.display_extend(display, context),
            Self::Var152(x) => x.display_extend(display, context),
            Self::Var153(x) => x.display_extend(display, context),
            Self::Var154(x) => x.display_extend(display, context),
            Self::Var155(x) => x.display_extend(display, context),
            Self::Var156(x) => x.display_extend(display, context),
            Self::Var157(x) => x.display_extend(display, context),
            Self::Var158(x) => x.display_extend(display, context),
            Self::Var159(x) => x.display_extend(display, context),
            Self::Var160(x) => x.display_extend(display, context),
            Self::Var161(x) => x.display_extend(display, context),
            Self::Var162(x) => x.display_extend(display, context),
            Self::Var163(x) => x.display_extend(display, context),
            Self::Var164(x) => x.display_extend(display, context),
            Self::Var165(x) => x.display_extend(display, context),
            Self::Var166(x) => x.display_extend(display, context),
            Self::Var167(x) => x.display_extend(display, context),
            Self::Var168(x) => x.display_extend(display, context),
            Self::Var169(x) => x.display_extend(display, context),
            Self::Var170(x) => x.display_extend(display, context),
            Self::Var171(x) => x.display_extend(display, context),
            Self::Var172(x) => x.display_extend(display, context),
            Self::Var173(x) => x.display_extend(display, context),
            Self::Var174(x) => x.display_extend(display, context),
            Self::Var175(x) => x.display_extend(display, context),
            Self::Var176(x) => x.display_extend(display, context),
            Self::Var177(x) => x.display_extend(display, context),
            Self::Var178(x) => x.display_extend(display, context),
            Self::Var179(x) => x.display_extend(display, context),
            Self::Var180(x) => x.display_extend(display, context),
            Self::Var181(x) => x.display_extend(display, context),
            Self::Var182(x) => x.display_extend(display, context),
            Self::Var183(x) => x.display_extend(display, context),
            Self::Var184(x) => x.display_extend(display, context),
            Self::Var185(x) => x.display_extend(display, context),
            Self::Var186(x) => x.display_extend(display, context),
            Self::Var187(x) => x.display_extend(display, context),
            Self::Var188(x) => x.display_extend(display, context),
            Self::Var189(x) => x.display_extend(display, context),
            Self::Var190(x) => x.display_extend(display, context),
            Self::Var191(x) => x.display_extend(display, context),
            Self::Var192(x) => x.display_extend(display, context),
            Self::Var193(x) => x.display_extend(display, context),
            Self::Var194(x) => x.display_extend(display, context),
            Self::Var195(x) => x.display_extend(display, context),
            Self::Var196(x) => x.display_extend(display, context),
            Self::Var197(x) => x.display_extend(display, context),
            Self::Var198(x) => x.display_extend(display, context),
            Self::Var199(x) => x.display_extend(display, context),
            Self::Var200(x) => x.display_extend(display, context),
            Self::Var201(x) => x.display_extend(display, context),
            Self::Var202(x) => x.display_extend(display, context),
            Self::Var203(x) => x.display_extend(display, context),
            Self::Var204(x) => x.display_extend(display, context),
            Self::Var205(x) => x.display_extend(display, context),
            Self::Var206(x) => x.display_extend(display, context),
            Self::Var207(x) => x.display_extend(display, context),
            Self::Var208(x) => x.display_extend(display, context),
            Self::Var209(x) => x.display_extend(display, context),
            Self::Var210(x) => x.display_extend(display, context),
            Self::Var211(x) => x.display_extend(display, context),
            Self::Var212(x) => x.display_extend(display, context),
            Self::Var213(x) => x.display_extend(display, context),
            Self::Var214(x) => x.display_extend(display, context),
            Self::Var215(x) => x.display_extend(display, context),
            Self::Var216(x) => x.display_extend(display, context),
            Self::Var217(x) => x.display_extend(display, context),
            Self::Var218(x) => x.display_extend(display, context),
            Self::Var219(x) => x.display_extend(display, context),
            Self::Var220(x) => x.display_extend(display, context),
            Self::Var221(x) => x.display_extend(display, context),
            Self::Var222(x) => x.display_extend(display, context),
            Self::Var223(x) => x.display_extend(display, context),
            Self::Var224(x) => x.display_extend(display, context),
            Self::Var225(x) => x.display_extend(display, context),
            Self::Var226(x) => x.display_extend(display, context),
            Self::Var227(x) => x.display_extend(display, context),
            Self::Var228(x) => x.display_extend(display, context),
            Self::Var229(x) => x.display_extend(display, context),
            Self::Var230(x) => x.display_extend(display, context),
            Self::Var231(x) => x.display_extend(display, context),
            Self::Var232(x) => x.display_extend(display, context),
            Self::Var233(x) => x.display_extend(display, context),
            Self::Var234(x) => x.display_extend(display, context),
            Self::Var235(x) => x.display_extend(display, context),
            Self::Var236(x) => x.display_extend(display, context),
            Self::Var237(x) => x.display_extend(display, context),
            Self::Var238(x) => x.display_extend(display, context),
            Self::Var239(x) => x.display_extend(display, context),
            Self::Var240(x) => x.display_extend(display, context),
            Self::Var241(x) => x.display_extend(display, context),
            Self::Var242(x) => x.display_extend(display, context),
            Self::Var243(x) => x.display_extend(display, context),
            Self::Var244(x) => x.display_extend(display, context),
            Self::Var245(x) => x.display_extend(display, context),
            Self::Var246(x) => x.display_extend(display, context),
            Self::Var247(x) => x.display_extend(display, context),
            Self::Var248(x) => x.display_extend(display, context),
            Self::Var249(x) => x.display_extend(display, context),
            Self::Var250(x) => x.display_extend(display, context),
            Self::Var251(x) => x.display_extend(display, context),
            Self::Var252(x) => x.display_extend(display, context),
            Self::Var253(x) => x.display_extend(display, context),
            Self::Var254(x) => x.display_extend(display, context),
            Self::Var255(x) => x.display_extend(display, context),
            Self::Var256(x) => x.display_extend(display, context),
            Self::Var257(x) => x.display_extend(display, context),
            Self::Var258(x) => x.display_extend(display, context),
            Self::Var259(x) => x.display_extend(display, context),
            Self::Var260(x) => x.display_extend(display, context),
            Self::Var261(x) => x.display_extend(display, context),
            Self::Var262(x) => x.display_extend(display, context),
            Self::Var263(x) => x.display_extend(display, context),
            Self::Var264(x) => x.display_extend(display, context),
            Self::Var265(x) => x.display_extend(display, context),
            Self::Var266(x) => x.display_extend(display, context),
            Self::Var267(x) => x.display_extend(display, context),
            Self::Var268(x) => x.display_extend(display, context),
            Self::Var269(x) => x.display_extend(display, context),
            Self::Var270(x) => x.display_extend(display, context),
            Self::Var271(x) => x.display_extend(display, context),
            Self::Var272(x) => x.display_extend(display, context),
            Self::Var273(x) => x.display_extend(display, context),
            Self::Var274(x) => x.display_extend(display, context),
            Self::Var275(x) => x.display_extend(display, context),
            Self::Var276(x) => x.display_extend(display, context),
            Self::Var277(x) => x.display_extend(display, context),
            Self::Var278(x) => x.display_extend(display, context),
            Self::Var279(x) => x.display_extend(display, context),
            Self::Var280(x) => x.display_extend(display, context),
            Self::Var281(x) => x.display_extend(display, context),
            Self::Var282(x) => x.display_extend(display, context),
            Self::Var283(x) => x.display_extend(display, context),
            Self::Var284(x) => x.display_extend(display, context),
            Self::Var285(x) => x.display_extend(display, context),
            Self::Var286(x) => x.display_extend(display, context),
            Self::Var287(x) => x.display_extend(display, context),
            Self::Var288(x) => x.display_extend(display, context),
            Self::Var289(x) => x.display_extend(display, context),
            Self::Var290(x) => x.display_extend(display, context),
            Self::Var291(x) => x.display_extend(display, context),
            Self::Var292(x) => x.display_extend(display, context),
            Self::Var293(x) => x.display_extend(display, context),
            Self::Var294(x) => x.display_extend(display, context),
            Self::Var295(x) => x.display_extend(display, context),
            Self::Var296(x) => x.display_extend(display, context),
            Self::Var297(x) => x.display_extend(display, context),
            Self::Var298(x) => x.display_extend(display, context),
            Self::Var299(x) => x.display_extend(display, context),
            Self::Var300(x) => x.display_extend(display, context),
            Self::Var301(x) => x.display_extend(display, context),
            Self::Var302(x) => x.display_extend(display, context),
            Self::Var303(x) => x.display_extend(display, context),
            Self::Var304(x) => x.display_extend(display, context),
            Self::Var305(x) => x.display_extend(display, context),
            Self::Var306(x) => x.display_extend(display, context),
            Self::Var307(x) => x.display_extend(display, context),
            Self::Var308(x) => x.display_extend(display, context),
            Self::Var309(x) => x.display_extend(display, context),
            Self::Var310(x) => x.display_extend(display, context),
            Self::Var311(x) => x.display_extend(display, context),
            Self::Var312(x) => x.display_extend(display, context),
            Self::Var313(x) => x.display_extend(display, context),
            Self::Var314(x) => x.display_extend(display, context),
            Self::Var315(x) => x.display_extend(display, context),
            Self::Var316(x) => x.display_extend(display, context),
            Self::Var317(x) => x.display_extend(display, context),
            Self::Var318(x) => x.display_extend(display, context),
            Self::Var319(x) => x.display_extend(display, context),
            Self::Var320(x) => x.display_extend(display, context),
            Self::Var321(x) => x.display_extend(display, context),
            Self::Var322(x) => x.display_extend(display, context),
            Self::Var323(x) => x.display_extend(display, context),
            Self::Var324(x) => x.display_extend(display, context),
            Self::Var325(x) => x.display_extend(display, context),
            Self::Var326(x) => x.display_extend(display, context),
            Self::Var327(x) => x.display_extend(display, context),
            Self::Var328(x) => x.display_extend(display, context),
            Self::Var329(x) => x.display_extend(display, context),
            Self::Var330(x) => x.display_extend(display, context),
            Self::Var331(x) => x.display_extend(display, context),
            Self::Var332(x) => x.display_extend(display, context),
            Self::Var333(x) => x.display_extend(display, context),
            Self::Var334(x) => x.display_extend(display, context),
            Self::Var335(x) => x.display_extend(display, context),
            Self::Var336(x) => x.display_extend(display, context),
            Self::Var337(x) => x.display_extend(display, context),
            Self::Var338(x) => x.display_extend(display, context),
            Self::Var339(x) => x.display_extend(display, context),
            Self::Var340(x) => x.display_extend(display, context),
            Self::Var341(x) => x.display_extend(display, context),
            Self::Var342(x) => x.display_extend(display, context),
            Self::Var343(x) => x.display_extend(display, context),
            Self::Var344(x) => x.display_extend(display, context),
            Self::Var345(x) => x.display_extend(display, context),
            Self::Var346(x) => x.display_extend(display, context),
            Self::Var347(x) => x.display_extend(display, context),
            Self::Var348(x) => x.display_extend(display, context),
            Self::Var349(x) => x.display_extend(display, context),
            Self::Var350(x) => x.display_extend(display, context),
            Self::Var351(x) => x.display_extend(display, context),
            Self::Var352(x) => x.display_extend(display, context),
            Self::Var353(x) => x.display_extend(display, context),
            Self::Var354(x) => x.display_extend(display, context),
            Self::Var355(x) => x.display_extend(display, context),
            Self::Var356(x) => x.display_extend(display, context),
            Self::Var357(x) => x.display_extend(display, context),
            Self::Var358(x) => x.display_extend(display, context),
            Self::Var359(x) => x.display_extend(display, context),
            Self::Var360(x) => x.display_extend(display, context),
            Self::Var361(x) => x.display_extend(display, context),
            Self::Var362(x) => x.display_extend(display, context),
            Self::Var363(x) => x.display_extend(display, context),
            Self::Var364(x) => x.display_extend(display, context),
            Self::Var365(x) => x.display_extend(display, context),
            Self::Var366(x) => x.display_extend(display, context),
            Self::Var367(x) => x.display_extend(display, context),
            Self::Var368(x) => x.display_extend(display, context),
            Self::Var369(x) => x.display_extend(display, context),
            Self::Var370(x) => x.display_extend(display, context),
            Self::Var371(x) => x.display_extend(display, context),
            Self::Var372(x) => x.display_extend(display, context),
            Self::Var373(x) => x.display_extend(display, context),
            Self::Var374(x) => x.display_extend(display, context),
            Self::Var375(x) => x.display_extend(display, context),
            Self::Var376(x) => x.display_extend(display, context),
            Self::Var377(x) => x.display_extend(display, context),
            Self::Var378(x) => x.display_extend(display, context),
            Self::Var379(x) => x.display_extend(display, context),
            Self::Var380(x) => x.display_extend(display, context),
            Self::Var381(x) => x.display_extend(display, context),
            Self::Var382(x) => x.display_extend(display, context),
            Self::Var383(x) => x.display_extend(display, context),
            Self::Var384(x) => x.display_extend(display, context),
            Self::Var385(x) => x.display_extend(display, context),
            Self::Var386(x) => x.display_extend(display, context),
            Self::Var387(x) => x.display_extend(display, context),
            Self::Var388(x) => x.display_extend(display, context),
            Self::Var389(x) => x.display_extend(display, context),
            Self::Var390(x) => x.display_extend(display, context),
            Self::Var391(x) => x.display_extend(display, context),
            Self::Var392(x) => x.display_extend(display, context),
            Self::Var393(x) => x.display_extend(display, context),
            Self::Var394(x) => x.display_extend(display, context),
            Self::Var395(x) => x.display_extend(display, context),
            Self::Var396(x) => x.display_extend(display, context),
            Self::Var397(x) => x.display_extend(display, context),
            Self::Var398(x) => x.display_extend(display, context),
            Self::Var399(x) => x.display_extend(display, context),
            Self::Var400(x) => x.display_extend(display, context),
            Self::Var401(x) => x.display_extend(display, context),
            Self::Var402(x) => x.display_extend(display, context),
            Self::Var403(x) => x.display_extend(display, context),
            Self::Var404(x) => x.display_extend(display, context),
            Self::Var405(x) => x.display_extend(display, context),
            Self::Var406(x) => x.display_extend(display, context),
            Self::Var407(x) => x.display_extend(display, context),
            Self::Var408(x) => x.display_extend(display, context),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = instructionVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var3(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var4(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var5(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var6(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var7(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar8::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var8(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar9::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var9(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar10::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var10(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar11::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var11(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar12::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var12(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar13::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var13(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar14::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var14(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar15::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var15(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar16::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var16(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar17::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var17(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar18::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var18(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar19::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var19(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar20::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var20(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar21::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var21(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar22::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var22(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar23::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var23(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar24::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var24(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar25::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var25(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar26::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var26(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar27::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var27(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar28::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var28(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar29::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var29(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar30::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var30(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar31::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var31(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar32::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var32(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar33::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var33(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar34::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var34(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar35::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var35(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar36::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var36(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar37::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var37(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar38::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var38(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar39::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var39(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar40::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var40(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar41::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var41(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar42::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var42(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar43::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var43(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar44::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var44(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar45::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var45(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar46::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var46(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar47::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var47(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar48::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var48(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar49::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var49(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar50::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var50(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar51::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var51(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar52::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var52(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar53::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var53(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar54::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var54(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar55::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var55(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar56::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var56(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar57::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var57(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar58::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var58(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar59::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var59(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar60::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var60(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar61::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var61(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar62::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var62(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar63::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var63(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar64::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var64(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar65::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var65(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar66::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var66(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar67::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var67(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar68::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var68(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar69::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var69(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar70::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var70(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar71::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var71(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar72::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var72(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar73::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var73(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar74::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var74(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar75::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var75(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar76::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var76(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar77::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var77(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar78::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var78(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar79::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var79(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar80::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var80(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar81::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var81(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar82::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var82(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar83::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var83(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar84::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var84(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar85::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var85(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar86::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var86(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar87::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var87(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar88::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var88(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar89::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var89(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar90::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var90(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar91::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var91(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar92::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var92(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar93::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var93(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar94::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var94(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar95::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var95(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar96::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var96(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar97::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var97(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar98::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var98(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar99::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var99(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar100::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var100(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar101::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var101(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar102::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var102(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar103::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var103(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar104::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var104(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar105::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var105(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar106::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var106(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar107::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var107(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar108::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var108(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar109::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var109(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar110::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var110(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar111::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var111(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar112::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var112(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar113::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var113(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar114::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var114(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar115::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var115(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar116::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var116(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar117::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var117(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar118::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var118(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar119::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var119(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar120::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var120(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar121::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var121(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar122::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var122(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar123::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var123(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar124::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var124(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar125::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var125(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar126::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var126(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar127::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var127(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar128::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var128(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar129::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var129(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar130::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var130(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar131::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var131(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar132::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var132(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar133::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var133(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar134::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var134(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar135::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var135(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar136::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var136(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar137::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var137(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar138::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var138(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar139::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var139(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar140::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var140(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar141::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var141(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar142::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var142(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar143::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var143(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar144::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var144(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar145::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var145(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar146::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var146(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar147::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var147(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar148::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var148(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar149::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var149(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar150::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var150(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar151::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var151(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar152::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var152(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar153::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var153(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar154::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var154(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar155::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var155(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar156::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var156(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar157::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var157(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar158::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var158(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar159::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var159(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar160::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var160(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar161::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var161(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar162::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var162(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar163::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var163(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar164::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var164(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar165::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var165(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar166::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var166(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar167::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var167(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar168::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var168(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar169::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var169(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar170::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var170(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar171::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var171(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar172::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var172(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar173::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var173(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar174::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var174(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar175::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var175(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar176::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var176(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar177::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var177(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar178::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var178(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar179::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var179(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar180::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var180(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar181::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var181(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar182::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var182(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar183::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var183(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar184::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var184(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar185::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var185(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar186::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var186(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar187::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var187(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar188::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var188(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar189::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var189(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar190::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var190(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar191::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var191(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar192::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var192(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar193::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var193(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar194::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var194(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar195::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var195(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar196::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var196(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar197::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var197(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar198::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var198(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar199::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var199(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar200::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var200(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar201::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var201(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar202::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var202(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar203::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var203(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar204::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var204(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar205::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var205(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar206::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var206(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar207::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var207(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar208::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var208(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar209::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var209(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar210::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var210(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar211::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var211(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar212::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var212(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar213::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var213(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar214::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var214(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar215::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var215(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar216::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var216(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar217::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var217(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar218::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var218(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar219::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var219(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar220::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var220(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar221::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var221(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar222::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var222(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar223::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var223(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar224::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var224(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar225::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var225(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar226::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var226(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar227::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var227(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar228::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var228(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar229::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var229(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar230::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var230(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar231::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var231(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar232::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var232(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar233::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var233(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar234::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var234(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar235::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var235(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar236::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var236(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar237::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var237(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar238::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var238(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar239::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var239(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar240::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var240(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar241::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var241(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar242::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var242(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar243::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var243(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar244::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var244(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar245::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var245(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar246::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var246(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar247::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var247(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar248::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var248(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar249::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var249(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar250::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var250(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar251::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var251(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar252::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var252(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar253::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var253(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar254::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var254(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar255::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var255(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar256::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var256(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar257::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var257(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar258::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var258(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar259::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var259(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar260::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var260(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar261::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var261(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar262::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var262(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar263::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var263(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar264::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var264(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar265::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var265(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar266::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var266(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar267::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var267(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar268::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var268(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar269::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var269(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar270::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var270(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar271::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var271(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar272::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var272(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar273::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var273(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar274::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var274(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar275::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var275(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar276::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var276(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar277::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var277(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar278::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var278(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar279::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var279(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar280::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var280(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar281::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var281(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar282::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var282(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar283::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var283(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar284::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var284(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar285::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var285(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar286::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var286(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar287::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var287(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar288::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var288(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar289::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var289(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar290::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var290(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar291::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var291(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar292::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var292(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar293::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var293(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar294::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var294(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar295::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var295(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar296::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var296(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar297::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var297(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar298::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var298(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar299::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var299(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar300::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var300(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar301::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var301(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar302::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var302(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar303::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var303(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar304::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var304(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar305::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var305(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar306::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var306(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar307::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var307(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar308::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var308(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar309::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var309(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar310::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var310(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar311::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var311(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar312::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var312(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar313::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var313(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar314::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var314(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar315::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var315(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar316::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var316(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar317::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var317(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar318::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var318(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar319::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var319(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar320::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var320(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar321::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var321(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar322::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var322(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar323::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var323(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar324::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var324(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar325::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var325(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar326::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var326(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar327::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var327(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar328::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var328(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar329::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var329(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar330::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var330(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar331::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var331(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar332::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var332(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar333::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var333(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar334::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var334(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar335::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var335(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar336::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var336(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar337::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var337(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar338::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var338(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar339::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var339(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar340::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var340(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar341::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var341(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar342::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var342(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar343::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var343(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar344::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var344(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar345::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var345(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar346::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var346(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar347::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var347(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar348::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var348(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar349::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var349(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar350::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var350(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar351::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var351(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar352::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var352(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar353::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var353(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar354::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var354(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar355::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var355(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar356::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var356(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar357::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var357(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar358::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var358(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar359::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var359(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar360::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var360(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar361::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var361(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar362::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var362(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar363::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var363(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar364::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var364(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar365::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var365(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar366::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var366(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar367::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var367(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar368::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var368(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar369::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var369(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar370::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var370(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar371::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var371(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar372::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var372(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar373::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var373(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar374::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var374(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar375::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var375(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar376::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var376(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar377::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var377(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar378::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var378(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar379::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var379(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar380::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var380(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar381::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var381(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar382::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var382(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar383::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var383(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar384::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var384(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar385::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var385(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar386::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var386(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar387::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var387(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar388::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var388(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar389::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var389(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar390::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var390(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar391::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var391(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar392::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var392(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar393::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var393(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar394::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var394(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar395::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var395(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar396::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var396(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar397::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var397(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar398::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var398(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar399::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var399(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar400::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var400(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar401::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var401(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar402::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var402(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar403::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var403(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar404::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var404(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar405::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var405(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar406::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var406(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar407::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var407(parsed)));
        }
        if let Some((inst_next, parsed)) = instructionVar408::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var408(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1187:1"]
#[derive(Clone, Debug)]
pub struct ldec4Var0 {
    ldec5: ldec5,
}
impl ldec4Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldec5 } = self;
        ldec5.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0404() != (0u64 as i64) as u8 {
                return None;
            }
            let ldec5 = if let Some((len, table)) = ldec5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldec5), (), block_len))
        };
        let ((mut ldec5), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldec5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1185:1"]
#[derive(Clone, Debug)]
pub struct ldec4Var1 {
    ldec5: ldec5,
}
impl ldec4Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldec5 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r4),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        ldec5.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            let ldec5 = if let Some((len, table)) = ldec5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldec5), (), block_len))
        };
        let ((mut ldec5), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldec5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1186:1"]
#[derive(Clone, Debug)]
pub struct ldec4Var2 {}
impl ldec4Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0515() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table ldec4"]
#[derive(Clone, Debug)]
pub enum ldec4 {
    Var0(ldec4Var0),
    Var1(ldec4Var1),
    Var2(ldec4Var2),
}
impl ldec4 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = ldec4Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = ldec4Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = ldec4Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1237:1"]
#[derive(Clone, Debug)]
pub struct sdec4Var0 {
    sdec5: sdec5,
}
impl sdec4Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sdec5 } = self;
        sdec5.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0404() != (0u64 as i64) as u8 {
                return None;
            }
            let sdec5 = if let Some((len, table)) = sdec5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sdec5), (), block_len))
        };
        let ((mut sdec5), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sdec5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1235:1"]
#[derive(Clone, Debug)]
pub struct sdec4Var1 {
    sdec5: sdec5,
}
impl sdec4Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sdec5 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r4),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        sdec5.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            let sdec5 = if let Some((len, table)) = sdec5::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sdec5), (), block_len))
        };
        let ((mut sdec5), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sdec5 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1236:1"]
#[derive(Clone, Debug)]
pub struct sdec4Var2 {}
impl sdec4Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0515() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table sdec4"]
#[derive(Clone, Debug)]
pub enum sdec4 {
    Var0(sdec4Var0),
    Var1(sdec4Var1),
    Var2(sdec4Var2),
}
impl sdec4 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = sdec4Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = sdec4Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = sdec4Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1163:1"]
#[derive(Clone, Debug)]
pub struct ldec12Var0 {
    ldec13: ldec13,
}
impl ldec12Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldec13 } = self;
        ldec13.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1212() != (0u64 as i64) as u8 {
                return None;
            }
            let ldec13 = if let Some((len, table)) = ldec13::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldec13), (), block_len))
        };
        let ((mut ldec13), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldec13 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1161:1"]
#[derive(Clone, Debug)]
pub struct ldec12Var1 {
    ldec13: ldec13,
}
impl ldec12Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldec13 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r12),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        ldec13.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1212() != (1u64 as i64) as u8 {
                return None;
            }
            let ldec13 = if let Some((len, table)) = ldec13::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldec13), (), block_len))
        };
        let ((mut ldec13), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldec13 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1162:1"]
#[derive(Clone, Debug)]
pub struct ldec12Var2 {}
impl ldec12Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r12)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1212() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1315() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table ldec12"]
#[derive(Clone, Debug)]
pub enum ldec12 {
    Var0(ldec12Var0),
    Var1(ldec12Var1),
    Var2(ldec12Var2),
}
impl ldec12 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = ldec12Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = ldec12Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = ldec12Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:883:1"]
#[derive(Clone, Debug)]
pub struct thsdec3Var0 {}
impl thsdec3Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0303() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0415() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:885:1"]
#[derive(Clone, Debug)]
pub struct thsdec3Var1 {
    thsdec4: thsdec4,
}
impl thsdec3Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thsdec4 } = self;
        thsdec4.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0303() != (0u64 as i64) as u8 {
                return None;
            }
            let thsdec4 = if let Some((len, table)) = thsdec4::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thsdec4), (), block_len))
        };
        let ((mut thsdec4), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thsdec4 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:884:1"]
#[derive(Clone, Debug)]
pub struct thsdec3Var2 {
    thsdec4: thsdec4,
}
impl thsdec3Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thsdec4 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r3),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        thsdec4.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0303() != (1u64 as i64) as u8 {
                return None;
            }
            let thsdec4 = if let Some((len, table)) = thsdec4::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thsdec4), (), block_len))
        };
        let ((mut thsdec4), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thsdec4 }))
    }
}
#[doc = "Table thsdec3"]
#[derive(Clone, Debug)]
pub enum thsdec3 {
    Var0(thsdec3Var0),
    Var1(thsdec3Var1),
    Var2(thsdec3Var2),
}
impl thsdec3 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thsdec3Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thsdec3Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = thsdec3Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:626:1"]
#[derive(Clone, Debug)]
pub struct ccVar0 {}
impl ccVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("le")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.cond() != (13u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:625:1"]
#[derive(Clone, Debug)]
pub struct ccVar1 {}
impl ccVar1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("gt")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.cond() != (12u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:624:1"]
#[derive(Clone, Debug)]
pub struct ccVar2 {}
impl ccVar2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("lt")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.cond() != (11u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:623:1"]
#[derive(Clone, Debug)]
pub struct ccVar3 {}
impl ccVar3 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ge")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.cond() != (10u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:622:1"]
#[derive(Clone, Debug)]
pub struct ccVar4 {}
impl ccVar4 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ls")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.cond() != (9u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:621:1"]
#[derive(Clone, Debug)]
pub struct ccVar5 {}
impl ccVar5 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("hi")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.cond() != (8u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:620:1"]
#[derive(Clone, Debug)]
pub struct ccVar6 {}
impl ccVar6 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("vc")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.cond() != (7u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:619:1"]
#[derive(Clone, Debug)]
pub struct ccVar7 {}
impl ccVar7 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("vs")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.cond() != (6u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:618:1"]
#[derive(Clone, Debug)]
pub struct ccVar8 {}
impl ccVar8 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("pl")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.cond() != (5u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:617:1"]
#[derive(Clone, Debug)]
pub struct ccVar9 {}
impl ccVar9 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("mi")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.cond() != (4u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:616:1"]
#[derive(Clone, Debug)]
pub struct ccVar10 {}
impl ccVar10 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cc")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.cond() != (3u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:615:1"]
#[derive(Clone, Debug)]
pub struct ccVar11 {}
impl ccVar11 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("cs")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.cond() != (2u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:614:1"]
#[derive(Clone, Debug)]
pub struct ccVar12 {}
impl ccVar12 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("ne")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.cond() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:613:1"]
#[derive(Clone, Debug)]
pub struct ccVar13 {}
impl ccVar13 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("eq")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.cond() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table cc"]
#[derive(Clone, Debug)]
pub enum cc {
    Var0(ccVar0),
    Var1(ccVar1),
    Var2(ccVar2),
    Var3(ccVar3),
    Var4(ccVar4),
    Var5(ccVar5),
    Var6(ccVar6),
    Var7(ccVar7),
    Var8(ccVar8),
    Var9(ccVar9),
    Var10(ccVar10),
    Var11(ccVar11),
    Var12(ccVar12),
    Var13(ccVar13),
}
impl cc {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
            Self::Var3(x) => x.display_extend(display, context),
            Self::Var4(x) => x.display_extend(display, context),
            Self::Var5(x) => x.display_extend(display, context),
            Self::Var6(x) => x.display_extend(display, context),
            Self::Var7(x) => x.display_extend(display, context),
            Self::Var8(x) => x.display_extend(display, context),
            Self::Var9(x) => x.display_extend(display, context),
            Self::Var10(x) => x.display_extend(display, context),
            Self::Var11(x) => x.display_extend(display, context),
            Self::Var12(x) => x.display_extend(display, context),
            Self::Var13(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = ccVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = ccVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = ccVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        if let Some((inst_next, parsed)) = ccVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var3(parsed)));
        }
        if let Some((inst_next, parsed)) = ccVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var4(parsed)));
        }
        if let Some((inst_next, parsed)) = ccVar5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var5(parsed)));
        }
        if let Some((inst_next, parsed)) = ccVar6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var6(parsed)));
        }
        if let Some((inst_next, parsed)) = ccVar7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var7(parsed)));
        }
        if let Some((inst_next, parsed)) = ccVar8::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var8(parsed)));
        }
        if let Some((inst_next, parsed)) = ccVar9::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var9(parsed)));
        }
        if let Some((inst_next, parsed)) = ccVar10::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var10(parsed)));
        }
        if let Some((inst_next, parsed)) = ccVar11::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var11(parsed)));
        }
        if let Some((inst_next, parsed)) = ccVar12::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var12(parsed)));
        }
        if let Some((inst_next, parsed)) = ccVar13::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var13(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1175:1"]
#[derive(Clone, Debug)]
pub struct ldec8Var0 {
    ldec9: ldec9,
}
impl ldec8Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldec9 } = self;
        ldec9.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0808() != (0u64 as i64) as u8 {
                return None;
            }
            let ldec9 = if let Some((len, table)) = ldec9::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldec9), (), block_len))
        };
        let ((mut ldec9), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldec9 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1173:1"]
#[derive(Clone, Debug)]
pub struct ldec8Var1 {
    ldec9: ldec9,
}
impl ldec8Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldec9 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r8),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        ldec9.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0808() != (1u64 as i64) as u8 {
                return None;
            }
            let ldec9 = if let Some((len, table)) = ldec9::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldec9), (), block_len))
        };
        let ((mut ldec9), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldec9 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1174:1"]
#[derive(Clone, Debug)]
pub struct ldec8Var2 {}
impl ldec8Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r8)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0808() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0915() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table ldec8"]
#[derive(Clone, Debug)]
pub enum ldec8 {
    Var0(ldec8Var0),
    Var1(ldec8Var1),
    Var2(ldec8Var2),
}
impl ldec8 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = ldec8Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = ldec8Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = ldec8Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:368:1"]
#[derive(Clone, Debug)]
pub struct Immed8Var0 {
    immed8: u8,
}
impl Immed8Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { immed8 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Literal("#"),
            DisplayElement::Unsigned(true, u64::try_from(*immed8).unwrap()),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let immed8 = token_parser.immed8();
            *context = context_current;
            Some(((), (immed8), block_len))
        };
        let ((), (immed8), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { immed8 }))
    }
}
#[doc = "Table Immed8"]
#[derive(Clone, Debug)]
pub enum Immed8 {
    Var0(Immed8Var0),
}
impl Immed8 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = Immed8Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:574:1"]
#[derive(Clone, Debug)]
pub struct ThAddr24Var0 {
    reloc: i64,
}
impl ThAddr24Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { reloc } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Signed(true, *reloc)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut reloc = 0i64;
        reloc = ((i64::try_from(inst_start).unwrap() + (4u64 as i64))
            + ((((((-(1u64 as i64)) << (24u64 as i64))
                | (i64::try_from(part2J1).unwrap() << (23u64 as i64)))
                | (i64::try_from(part2J2).unwrap() << (22u64 as i64)))
                | (i64::try_from(offset10).unwrap() << (12u64 as i64)))
                | (i64::try_from(part2off).unwrap() << (1u64 as i64))));
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let offset10 = token_parser.offset10();
            if token_parser.offset10S() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (offset10), block_len))
        };
        let ((), (offset10), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let part2J1 = token_parser.part2J1();
            let part2J2 = token_parser.part2J2();
            let part2off = token_parser.part2off();
            *context = context_current;
            Some(((), (part2J1, part2J2, part2off), block_len))
        };
        let ((), (part2J1, part2J2, part2off), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let reloc = 0i64;
        *context = context_current;
        Some((inst_len, Self { reloc }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:568:1"]
#[derive(Clone, Debug)]
pub struct ThAddr24Var1 {
    reloc: i64,
}
impl ThAddr24Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { reloc } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Signed(true, *reloc)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut reloc = 0i64;
        reloc = ((i64::try_from(inst_start).unwrap() + (4u64 as i64))
            + (((((i64::try_from(part2J1).unwrap() ^ (1u64 as i64))
                << (23u64 as i64))
                | ((i64::try_from(part2J2).unwrap() ^ (1u64 as i64))
                    << (22u64 as i64)))
                | (i64::try_from(offset10).unwrap() << (12u64 as i64)))
                | (i64::try_from(part2off).unwrap() << (1u64 as i64))));
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let offset10 = token_parser.offset10();
            if token_parser.offset10S() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (offset10), block_len))
        };
        let ((), (offset10), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let mut block_1 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let part2J1 = token_parser.part2J1();
            let part2J2 = token_parser.part2J2();
            let part2off = token_parser.part2off();
            *context = context_current;
            Some(((), (part2J1, part2J2, part2off), block_len))
        };
        let ((), (part2J1, part2J2, part2off), block_len) =
            block_1(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let reloc = 0i64;
        *context = context_current;
        Some((inst_len, Self { reloc }))
    }
}
#[doc = "Table ThAddr24"]
#[derive(Clone, Debug)]
pub enum ThAddr24 {
    Var0(ThAddr24Var0),
    Var1(ThAddr24Var1),
}
impl ThAddr24 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = ThAddr24Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = ThAddr24Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1160:1"]
#[derive(Clone, Debug)]
pub struct ldec13Var0 {
    ldec14: ldec14,
}
impl ldec13Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldec14 } = self;
        ldec14.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1313() != (0u64 as i64) as u8 {
                return None;
            }
            let ldec14 = if let Some((len, table)) = ldec14::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldec14), (), block_len))
        };
        let ((mut ldec14), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldec14 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1158:1"]
#[derive(Clone, Debug)]
pub struct ldec13Var1 {
    ldec14: ldec14,
}
impl ldec13Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldec14 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::sp),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        ldec14.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1313() != (1u64 as i64) as u8 {
                return None;
            }
            let ldec14 = if let Some((len, table)) = ldec14::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldec14), (), block_len))
        };
        let ((mut ldec14), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldec14 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1159:1"]
#[derive(Clone, Debug)]
pub struct ldec13Var2 {}
impl ldec13Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::sp)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1313() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1415() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table ldec13"]
#[derive(Clone, Debug)]
pub enum ldec13 {
    Var0(ldec13Var0),
    Var1(ldec13Var1),
    Var2(ldec13Var2),
}
impl ldec13 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = ldec13Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = ldec13Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = ldec13Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1231:1"]
#[derive(Clone, Debug)]
pub struct sdec6Var0 {
    sdec7: sdec7,
}
impl sdec6Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sdec7 } = self;
        sdec7.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0606() != (0u64 as i64) as u8 {
                return None;
            }
            let sdec7 = if let Some((len, table)) = sdec7::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sdec7), (), block_len))
        };
        let ((mut sdec7), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sdec7 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1229:1"]
#[derive(Clone, Debug)]
pub struct sdec6Var1 {
    sdec7: sdec7,
}
impl sdec6Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { sdec7 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r6),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        sdec7.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0606() != (1u64 as i64) as u8 {
                return None;
            }
            let sdec7 = if let Some((len, table)) = sdec7::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((sdec7), (), block_len))
        };
        let ((mut sdec7), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { sdec7 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1230:1"]
#[derive(Clone, Debug)]
pub struct sdec6Var2 {}
impl sdec6Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c0606() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0715() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table sdec6"]
#[derive(Clone, Debug)]
pub enum sdec6 {
    Var0(sdec6Var0),
    Var1(sdec6Var1),
    Var2(sdec6Var2),
}
impl sdec6 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = sdec6Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = sdec6Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = sdec6Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:610:1"]
#[derive(Clone, Debug)]
pub struct rsVar0 {}
impl rsVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.Rs() != (15u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:611:1"]
#[derive(Clone, Debug)]
pub struct rsVar1 {
    Rs: u8,
}
impl rsVar1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { Rs } = self;
        let extend: [DisplayElement; 1usize] =
            [meaning_94047766862464(usize::try_from(*Rs).unwrap())];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let Rs = token_parser.Rs();
            *context = context_current;
            Some(((), (Rs), block_len))
        };
        let ((), (Rs), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { Rs }))
    }
}
#[doc = "Table rs"]
#[derive(Clone, Debug)]
pub enum rs {
    Var0(rsVar0),
    Var1(rsVar1),
}
impl rs {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = rsVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = rsVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:928:1"]
#[derive(Clone, Debug)]
pub struct RnIndirect4Var0 {
    immval: i64,
    Rn0305: u8,
}
impl RnIndirect4Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { immval, Rn0305 } = self;
        let extend: [DisplayElement; 6usize] = [
            DisplayElement::Literal("["),
            meaning_94047783056016(usize::try_from(*Rn0305).unwrap()),
            DisplayElement::Literal(","),
            DisplayElement::Literal("#"),
            DisplayElement::Signed(true, *immval),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut immval = 0i64;
        immval = (i64::try_from(immed5).unwrap() * (4u64 as i64));
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let Rn0305 = token_parser.Rn0305();
            let immed5 = token_parser.immed5();
            *context = context_current;
            Some(((), (immed5, Rn0305), block_len))
        };
        let ((), (immed5, Rn0305), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let immval = 0i64;
        *context = context_current;
        Some((inst_len, Self { immval, Rn0305 }))
    }
}
#[doc = "Table RnIndirect4"]
#[derive(Clone, Debug)]
pub enum RnIndirect4 {
    Var0(RnIndirect4Var0),
}
impl RnIndirect4 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = RnIndirect4Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1461:1"]
#[derive(Clone, Debug)]
pub struct spsrmaskVar0 {}
impl spsrmaskVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_cxsf")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.mask() != (15u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1460:1"]
#[derive(Clone, Debug)]
pub struct spsrmaskVar1 {}
impl spsrmaskVar1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_xsf")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.mask() != (14u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1459:1"]
#[derive(Clone, Debug)]
pub struct spsrmaskVar2 {}
impl spsrmaskVar2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_csf")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.mask() != (13u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1458:1"]
#[derive(Clone, Debug)]
pub struct spsrmaskVar3 {}
impl spsrmaskVar3 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_sf")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.mask() != (12u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1457:1"]
#[derive(Clone, Debug)]
pub struct spsrmaskVar4 {}
impl spsrmaskVar4 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_cxf")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.mask() != (11u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1456:1"]
#[derive(Clone, Debug)]
pub struct spsrmaskVar5 {}
impl spsrmaskVar5 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_xf")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.mask() != (10u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1455:1"]
#[derive(Clone, Debug)]
pub struct spsrmaskVar6 {}
impl spsrmaskVar6 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_cf")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.mask() != (9u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1454:1"]
#[derive(Clone, Debug)]
pub struct spsrmaskVar7 {}
impl spsrmaskVar7 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_f")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.mask() != (8u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1453:1"]
#[derive(Clone, Debug)]
pub struct spsrmaskVar8 {}
impl spsrmaskVar8 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_cxs")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.mask() != (7u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1452:1"]
#[derive(Clone, Debug)]
pub struct spsrmaskVar9 {}
impl spsrmaskVar9 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_xs")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.mask() != (6u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1451:1"]
#[derive(Clone, Debug)]
pub struct spsrmaskVar10 {}
impl spsrmaskVar10 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_cs")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.mask() != (5u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1450:1"]
#[derive(Clone, Debug)]
pub struct spsrmaskVar11 {}
impl spsrmaskVar11 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_s")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.mask() != (4u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1449:1"]
#[derive(Clone, Debug)]
pub struct spsrmaskVar12 {}
impl spsrmaskVar12 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_cx")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.mask() != (3u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1448:1"]
#[derive(Clone, Debug)]
pub struct spsrmaskVar13 {}
impl spsrmaskVar13 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_x")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.mask() != (2u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1447:1"]
#[derive(Clone, Debug)]
pub struct spsrmaskVar14 {}
impl spsrmaskVar14 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Literal("spsr_c")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.mask() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1446:1"]
#[derive(Clone, Debug)]
pub struct spsrmaskVar15 {}
impl spsrmaskVar15 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.mask() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table spsrmask"]
#[derive(Clone, Debug)]
pub enum spsrmask {
    Var0(spsrmaskVar0),
    Var1(spsrmaskVar1),
    Var2(spsrmaskVar2),
    Var3(spsrmaskVar3),
    Var4(spsrmaskVar4),
    Var5(spsrmaskVar5),
    Var6(spsrmaskVar6),
    Var7(spsrmaskVar7),
    Var8(spsrmaskVar8),
    Var9(spsrmaskVar9),
    Var10(spsrmaskVar10),
    Var11(spsrmaskVar11),
    Var12(spsrmaskVar12),
    Var13(spsrmaskVar13),
    Var14(spsrmaskVar14),
    Var15(spsrmaskVar15),
}
impl spsrmask {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
            Self::Var3(x) => x.display_extend(display, context),
            Self::Var4(x) => x.display_extend(display, context),
            Self::Var5(x) => x.display_extend(display, context),
            Self::Var6(x) => x.display_extend(display, context),
            Self::Var7(x) => x.display_extend(display, context),
            Self::Var8(x) => x.display_extend(display, context),
            Self::Var9(x) => x.display_extend(display, context),
            Self::Var10(x) => x.display_extend(display, context),
            Self::Var11(x) => x.display_extend(display, context),
            Self::Var12(x) => x.display_extend(display, context),
            Self::Var13(x) => x.display_extend(display, context),
            Self::Var14(x) => x.display_extend(display, context),
            Self::Var15(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var14(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var15(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = spsrmaskVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = spsrmaskVar1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = spsrmaskVar2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        if let Some((inst_next, parsed)) = spsrmaskVar3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var3(parsed)));
        }
        if let Some((inst_next, parsed)) = spsrmaskVar4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var4(parsed)));
        }
        if let Some((inst_next, parsed)) = spsrmaskVar5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var5(parsed)));
        }
        if let Some((inst_next, parsed)) = spsrmaskVar6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var6(parsed)));
        }
        if let Some((inst_next, parsed)) = spsrmaskVar7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var7(parsed)));
        }
        if let Some((inst_next, parsed)) = spsrmaskVar8::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var8(parsed)));
        }
        if let Some((inst_next, parsed)) = spsrmaskVar9::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var9(parsed)));
        }
        if let Some((inst_next, parsed)) = spsrmaskVar10::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var10(parsed)));
        }
        if let Some((inst_next, parsed)) = spsrmaskVar11::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var11(parsed)));
        }
        if let Some((inst_next, parsed)) = spsrmaskVar12::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var12(parsed)));
        }
        if let Some((inst_next, parsed)) = spsrmaskVar13::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var13(parsed)));
        }
        if let Some((inst_next, parsed)) = spsrmaskVar14::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var14(parsed)));
        }
        if let Some((inst_next, parsed)) = spsrmaskVar15::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var15(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:974:1"]
#[derive(Clone, Debug)]
pub struct addrmode3Var0 {
    reloff: i64,
}
impl addrmode3Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { reloff } = self;
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            DisplayElement::Signed(true, *reloff),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut reloff = 0i64;
        reloff = ((i64::try_from(inst_start).unwrap() + (8u64 as i64))
            - ((i64::try_from(immedH).unwrap() << (4u64 as i64))
                | i64::try_from(immedL).unwrap()));
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let immedH = token_parser.immedH();
            let immedL = token_parser.immedL();
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2122() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1619() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0707() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (immedL, immedH), block_len))
        };
        let ((), (immedL, immedH), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let reloff = 0i64;
        *context = context_current;
        Some((inst_len, Self { reloff }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:968:1"]
#[derive(Clone, Debug)]
pub struct addrmode3Var1 {
    reloff: i64,
}
impl addrmode3Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { reloff } = self;
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            DisplayElement::Signed(true, *reloff),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut reloff = 0i64;
        reloff = ((i64::try_from(inst_start).unwrap() + (8u64 as i64))
            + ((i64::try_from(immedH).unwrap() << (4u64 as i64))
                | i64::try_from(immedL).unwrap()));
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let immedH = token_parser.immedH();
            let immedL = token_parser.immedL();
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2122() != (2u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1619() != (15u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0707() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (immedH, immedL), block_len))
        };
        let ((), (immedH, immedL), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let reloff = 0i64;
        *context = context_current;
        Some((inst_len, Self { reloff }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1030:1"]
#[derive(Clone, Debug)]
pub struct addrmode3Var2 {
    rn: rn,
    noff8: i64,
}
impl addrmode3Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, noff8 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("],"),
            DisplayElement::Literal("#"),
            DisplayElement::Signed(true, *noff8),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut noff8 = 0i64;
        noff8 = (-((i64::try_from(immedH).unwrap() << (4u64 as i64))
            | i64::try_from(immedL).unwrap()));
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let immedH = token_parser.immedH();
            let immedL = token_parser.immedL();
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2122() != (2u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c0707() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((rn), (immedH, immedL), block_len))
        };
        let ((mut rn), (immedH, immedL), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let noff8 = 0i64;
        *context = context_current;
        Some((inst_len, Self { rn, noff8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1024:1"]
#[derive(Clone, Debug)]
pub struct addrmode3Var3 {
    rn: rn,
    off8: i64,
}
impl addrmode3Var3 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, off8 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("],"),
            DisplayElement::Literal("#"),
            DisplayElement::Signed(true, *off8),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut off8 = 0i64;
        off8 = ((i64::try_from(immedH).unwrap() << (4u64 as i64))
            | i64::try_from(immedL).unwrap());
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let immedH = token_parser.immedH();
            let immedL = token_parser.immedL();
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2122() != (2u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c0707() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((rn), (immedH, immedL), block_len))
        };
        let ((mut rn), (immedH, immedL), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let off8 = 0i64;
        *context = context_current;
        Some((inst_len, Self { rn, off8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1008:1"]
#[derive(Clone, Debug)]
pub struct addrmode3Var4 {
    rn: rn,
    noff8: i64,
}
impl addrmode3Var4 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, noff8 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal("#"),
            DisplayElement::Signed(true, *noff8),
            DisplayElement::Literal("]!"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut noff8 = 0i64;
        noff8 = (-((i64::try_from(immedH).unwrap() << (4u64 as i64))
            | i64::try_from(immedL).unwrap()));
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let immedH = token_parser.immedH();
            let immedL = token_parser.immedL();
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2122() != (3u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c0707() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((rn), (immedH, immedL), block_len))
        };
        let ((mut rn), (immedH, immedL), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let noff8 = 0i64;
        *context = context_current;
        Some((inst_len, Self { rn, noff8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1002:1"]
#[derive(Clone, Debug)]
pub struct addrmode3Var5 {
    rn: rn,
    off8: i64,
}
impl addrmode3Var5 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, off8 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal("#"),
            DisplayElement::Signed(true, *off8),
            DisplayElement::Literal("]!"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut off8 = 0i64;
        off8 = ((i64::try_from(immedH).unwrap() << (4u64 as i64))
            | i64::try_from(immedL).unwrap());
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let immedH = token_parser.immedH();
            let immedL = token_parser.immedL();
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2122() != (3u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c0707() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((rn), (immedL, immedH), block_len))
        };
        let ((mut rn), (immedL, immedH), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let off8 = 0i64;
        *context = context_current;
        Some((inst_len, Self { rn, off8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:986:1"]
#[derive(Clone, Debug)]
pub struct addrmode3Var6 {
    rn: rn,
    noff8: i64,
}
impl addrmode3Var6 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, noff8 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal("#"),
            DisplayElement::Signed(true, *noff8),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut noff8 = 0i64;
        noff8 = (-((i64::try_from(immedH).unwrap() << (4u64 as i64))
            | i64::try_from(immedL).unwrap()));
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let immedH = token_parser.immedH();
            let immedL = token_parser.immedL();
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2122() != (2u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c0707() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((rn), (immedH, immedL), block_len))
        };
        let ((mut rn), (immedH, immedL), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let noff8 = 0i64;
        *context = context_current;
        Some((inst_len, Self { rn, noff8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:980:1"]
#[derive(Clone, Debug)]
pub struct addrmode3Var7 {
    rn: rn,
    off8: i64,
}
impl addrmode3Var7 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, off8 } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Literal(","),
            DisplayElement::Literal("#"),
            DisplayElement::Signed(true, *off8),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut off8 = 0i64;
        off8 = ((i64::try_from(immedH).unwrap() << (4u64 as i64))
            | i64::try_from(immedL).unwrap());
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let immedH = token_parser.immedH();
            let immedL = token_parser.immedL();
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2122() != (2u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c0707() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((rn), (immedL, immedH), block_len))
        };
        let ((mut rn), (immedL, immedH), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let off8 = 0i64;
        *context = context_current;
        Some((inst_len, Self { rn, off8 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1041:1"]
#[derive(Clone, Debug)]
pub struct addrmode3Var8 {
    rn: rn,
    rm: rm,
}
impl addrmode3Var8 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, rm } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("],-")];
        display.extend_from_slice(&extend);
        rm.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2122() != (0u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c0811() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0707() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, rm), (), block_len))
        };
        let ((mut rn, mut rm), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rn, rm }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1036:1"]
#[derive(Clone, Debug)]
pub struct addrmode3Var9 {
    rn: rn,
    rm: rm,
}
impl addrmode3Var9 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rn, rm } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("],")];
        display.extend_from_slice(&extend);
        rm.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2122() != (0u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c0811() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0707() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, rm), (), block_len))
        };
        let ((mut rn, mut rm), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rn, rm }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1019:1"]
#[derive(Clone, Debug)]
pub struct addrmode3Var10 {
    rm: rm,
    rn: rn,
}
impl addrmode3Var10 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rm, rn } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",-")];
        display.extend_from_slice(&extend);
        rm.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("]!")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2122() != (1u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c0811() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0707() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, rm), (), block_len))
        };
        let ((mut rn, mut rm), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rm, rn }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1014:1"]
#[derive(Clone, Debug)]
pub struct addrmode3Var11 {
    rm: rm,
    rn: rn,
}
impl addrmode3Var11 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rm, rn } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        rm.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("]!")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2122() != (1u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c0811() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0707() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rn, rm), (), block_len))
        };
        let ((mut rn, mut rm), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rm, rn }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:997:1"]
#[derive(Clone, Debug)]
pub struct addrmode3Var12 {
    rm: rm,
    rn: rn,
}
impl addrmode3Var12 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rm, rn } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",-")];
        display.extend_from_slice(&extend);
        rm.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("]")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2122() != (0u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c0811() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0707() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rm, rn), (), block_len))
        };
        let ((mut rm, mut rn), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rm, rn }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:992:1"]
#[derive(Clone, Debug)]
pub struct addrmode3Var13 {
    rm: rm,
    rn: rn,
}
impl addrmode3Var13 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { rm, rn } = self;
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("[")];
        display.extend_from_slice(&extend);
        rn.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal(",")];
        display.extend_from_slice(&extend);
        rm.display_extend(display, context);
        let extend: [DisplayElement; 1usize] = [DisplayElement::Literal("]")];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.P24() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c2122() != (0u64 as i64) as u8 {
                return None;
            }
            let rn = if let Some((len, table)) =
                rn::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            if token_parser.c0811() != (0u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0707() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c0404() != (1u64 as i64) as u8 {
                return None;
            }
            let rm = if let Some((len, table)) =
                rm::parse(tokens, &mut context_current, inst_start, global_set)
            {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((rm, rn), (), block_len))
        };
        let ((mut rm, mut rn), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { rm, rn }))
    }
}
#[doc = "Table addrmode3"]
#[derive(Clone, Debug)]
pub enum addrmode3 {
    Var0(addrmode3Var0),
    Var1(addrmode3Var1),
    Var2(addrmode3Var2),
    Var3(addrmode3Var3),
    Var4(addrmode3Var4),
    Var5(addrmode3Var5),
    Var6(addrmode3Var6),
    Var7(addrmode3Var7),
    Var8(addrmode3Var8),
    Var9(addrmode3Var9),
    Var10(addrmode3Var10),
    Var11(addrmode3Var11),
    Var12(addrmode3Var12),
    Var13(addrmode3Var13),
}
impl addrmode3 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
            Self::Var3(x) => x.display_extend(display, context),
            Self::Var4(x) => x.display_extend(display, context),
            Self::Var5(x) => x.display_extend(display, context),
            Self::Var6(x) => x.display_extend(display, context),
            Self::Var7(x) => x.display_extend(display, context),
            Self::Var8(x) => x.display_extend(display, context),
            Self::Var9(x) => x.display_extend(display, context),
            Self::Var10(x) => x.display_extend(display, context),
            Self::Var11(x) => x.display_extend(display, context),
            Self::Var12(x) => x.display_extend(display, context),
            Self::Var13(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var3(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var4(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var5(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var6(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var7(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var8(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var9(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var10(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var11(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var12(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var13(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = addrmode3Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode3Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode3Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode3Var3::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var3(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode3Var4::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var4(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode3Var5::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var5(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode3Var6::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var6(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode3Var7::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var7(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode3Var8::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var8(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode3Var9::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var9(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode3Var10::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var10(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode3Var11::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var11(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode3Var12::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var12(parsed)));
        }
        if let Some((inst_next, parsed)) = addrmode3Var13::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var13(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:371:1"]
#[derive(Clone, Debug)]
pub struct Pcrel8Var0 {
    reloc: i64,
}
impl Pcrel8Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { reloc } = self;
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            DisplayElement::Signed(true, *reloc),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut reloc = 0i64;
        reloc = ((((i64::try_from(inst_start).unwrap() + (4u64 as i64))
            & (4294967292u64 as i64))
            + (4u64 as i64))
            * i64::try_from(immed8).unwrap());
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let immed8 = token_parser.immed8();
            *context = context_current;
            Some(((), (immed8), block_len))
        };
        let ((), (immed8), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let reloc = 0i64;
        *context = context_current;
        Some((inst_len, Self { reloc }))
    }
}
#[doc = "Table Pcrel8"]
#[derive(Clone, Debug)]
pub enum Pcrel8 {
    Var0(Pcrel8Var0),
}
impl Pcrel8 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = Pcrel8Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1974:1"]
#[derive(Clone, Debug)]
pub struct ArmPCRelImmed12Var0 {
    reloff: i64,
}
impl ArmPCRelImmed12Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { reloff } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Signed(true, *reloff)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut reloff = 0i64;
        reloff = ((i64::try_from(inst_start).unwrap() + (8u64 as i64))
            - (((i64::try_from(immed).unwrap()
                << (((32u64 as i64) - i64::try_from(rotate).unwrap())
                    * (2u64 as i64)))
                | (i64::try_from(immed).unwrap()
                    >> (i64::try_from(rotate).unwrap() * (2u64 as i64))))
                & (4294967295u64 as i64)));
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let immed = token_parser.immed();
            let rotate = token_parser.rotate();
            if token_parser.U23() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (rotate, immed), block_len))
        };
        let ((), (rotate, immed), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let reloff = 0i64;
        *context = context_current;
        Some((inst_len, Self { reloff }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1968:1"]
#[derive(Clone, Debug)]
pub struct ArmPCRelImmed12Var1 {
    reloff: i64,
}
impl ArmPCRelImmed12Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { reloff } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Signed(true, *reloff)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut reloff = 0i64;
        reloff = ((i64::try_from(inst_start).unwrap() + (8u64 as i64))
            + (((i64::try_from(immed).unwrap()
                << (((32u64 as i64) - i64::try_from(rotate).unwrap())
                    * (2u64 as i64)))
                | (i64::try_from(immed).unwrap()
                    >> (i64::try_from(rotate).unwrap() * (2u64 as i64))))
                & (4294967295u64 as i64)));
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let immed = token_parser.immed();
            let rotate = token_parser.rotate();
            if token_parser.U23() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (immed, rotate), block_len))
        };
        let ((), (immed, rotate), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let reloff = 0i64;
        *context = context_current;
        Some((inst_len, Self { reloff }))
    }
}
#[doc = "Table ArmPCRelImmed12"]
#[derive(Clone, Debug)]
pub enum ArmPCRelImmed12 {
    Var0(ArmPCRelImmed12Var0),
    Var1(ArmPCRelImmed12Var1),
}
impl ArmPCRelImmed12 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = ArmPCRelImmed12Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = ArmPCRelImmed12Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1204:1"]
#[derive(Clone, Debug)]
pub struct sdec15Var0 {}
impl sdec15Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1515() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1203:1"]
#[derive(Clone, Debug)]
pub struct sdec15Var1 {}
impl sdec15Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1515() != (1u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table sdec15"]
#[derive(Clone, Debug)]
pub enum sdec15 {
    Var0(sdec15Var0),
    Var1(sdec15Var1),
}
impl sdec15 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = sdec15Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = sdec15Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:642:1"]
#[derive(Clone, Debug)]
pub struct Addr24Var0 {
    reloc: i64,
    addr24: i32,
}
impl Addr24Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { reloc, addr24 } = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Signed(true, *reloc)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { reloc, addr24 } = self;
        *reloc = ((i64::try_from(inst_next).unwrap() + (4u64 as i64))
            + ((4u64 as i64) * i64::try_from(*addr24).unwrap()));
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            let addr24 = token_parser.addr24();
            *context = context_current;
            Some(((), (addr24), block_len))
        };
        let ((), (addr24), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let reloc = 0i64;
        *context = context_current;
        Some((inst_len, Self { reloc, addr24 }))
    }
}
#[doc = "Table Addr24"]
#[derive(Clone, Debug)]
pub enum Addr24 {
    Var0(Addr24Var0),
}
impl Addr24 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = Addr24Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:874:1"]
#[derive(Clone, Debug)]
pub struct thsdec6Var0 {}
impl thsdec6Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0606() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.thc0715() != (0u64 as i64) as u16 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:876:1"]
#[derive(Clone, Debug)]
pub struct thsdec6Var1 {
    thsdec7: thsdec7,
}
impl thsdec6Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thsdec7 } = self;
        thsdec7.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0606() != (0u64 as i64) as u8 {
                return None;
            }
            let thsdec7 = if let Some((len, table)) = thsdec7::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thsdec7), (), block_len))
        };
        let ((mut thsdec7), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thsdec7 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:875:1"]
#[derive(Clone, Debug)]
pub struct thsdec6Var2 {
    thsdec7: thsdec7,
}
impl thsdec6Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { thsdec7 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r6),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        thsdec7.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            if token_parser.thc0606() != (1u64 as i64) as u8 {
                return None;
            }
            let thsdec7 = if let Some((len, table)) = thsdec7::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((thsdec7), (), block_len))
        };
        let ((mut thsdec7), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { thsdec7 }))
    }
}
#[doc = "Table thsdec6"]
#[derive(Clone, Debug)]
pub enum thsdec6 {
    Var0(thsdec6Var0),
    Var1(thsdec6Var1),
    Var2(thsdec6Var2),
}
impl thsdec6 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = thsdec6Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = thsdec6Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = thsdec6Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1166:1"]
#[derive(Clone, Debug)]
pub struct ldec11Var0 {
    ldec12: ldec12,
}
impl ldec11Var0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldec12 } = self;
        ldec12.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1111() != (0u64 as i64) as u8 {
                return None;
            }
            let ldec12 = if let Some((len, table)) = ldec12::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldec12), (), block_len))
        };
        let ((mut ldec12), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldec12 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1164:1"]
#[derive(Clone, Debug)]
pub struct ldec11Var1 {
    ldec12: ldec12,
}
impl ldec11Var1 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { ldec12 } = self;
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Register(Register::r11),
            DisplayElement::Literal(","),
        ];
        display.extend_from_slice(&extend);
        ldec12.display_extend(display, context);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1111() != (1u64 as i64) as u8 {
                return None;
            }
            let ldec12 = if let Some((len, table)) = ldec12::parse(
                tokens,
                &mut context_current,
                inst_start,
                global_set,
            ) {
                block_len = len as u32;
                table
            } else {
                return None;
            };
            *context = context_current;
            Some(((ldec12), (), block_len))
        };
        let ((mut ldec12), (), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self { ldec12 }))
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc:1165:1"]
#[derive(Clone, Debug)]
pub struct ldec11Var2 {}
impl ldec11Var2 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self {} = self;
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Register(Register::r11)];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser32::new(tokens)?;
            block_len = 4u64 as u32;
            if token_parser.c1111() != (1u64 as i64) as u8 {
                return None;
            }
            if token_parser.c1215() != (0u64 as i64) as u8 {
                return None;
            }
            *context = context_current;
            Some(((), (), block_len))
        };
        let ((), (), block_len) = block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        *context = context_current;
        Some((inst_len, Self {}))
    }
}
#[doc = "Table ldec11"]
#[derive(Clone, Debug)]
pub enum ldec11 {
    Var0(ldec11Var0),
    Var1(ldec11Var1),
    Var2(ldec11Var2),
}
impl ldec11 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
            Self::Var1(x) => x.display_extend(display, context),
            Self::Var2(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var1(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
            Self::Var2(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = ldec11Var0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        if let Some((inst_next, parsed)) = ldec11Var1::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var1(parsed)));
        }
        if let Some((inst_next, parsed)) = ldec11Var2::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var2(parsed)));
        }
        None
    }
}
#[doc = "Constructor at /home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc:934:1"]
#[derive(Clone, Debug)]
pub struct Pcrel8IndirectVar0 {
    reloc: i64,
}
impl Pcrel8IndirectVar0 {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        let Self { reloc } = self;
        let extend: [DisplayElement; 3usize] = [
            DisplayElement::Literal("["),
            DisplayElement::Signed(true, *reloc),
            DisplayElement::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
    }
    pub fn parse<'a, T>(
        tokens: &'a [u8],
        context: &mut T,
        inst_start: u32,
        global_set: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut inst_len = 0 as u32;
        let mut context_current = context.clone();
        let mut token_current = tokens;
        let mut reloc = 0i64;
        reloc = ((((i64::try_from(inst_start).unwrap() + (4u64 as i64))
            & (4294967292u64 as i64))
            + (4u64 as i64))
            * i64::try_from(immed8).unwrap());
        let mut block_0 = |tokens, context: &mut T| {
            let mut block_len = 0 as u32;
            let mut context_current = context.clone();
            let token_parser = TokenParser16::new(tokens)?;
            block_len = 2u64 as u32;
            let immed8 = token_parser.immed8();
            *context = context_current;
            Some(((), (immed8), block_len))
        };
        let ((), (immed8), block_len) =
            block_0(token_current, &mut context_current)?;
        token_current = &token_current[usize::try_from(block_len).unwrap()..];
        inst_len += block_len;
        let reloc = 0i64;
        *context = context_current;
        Some((inst_len, Self { reloc }))
    }
}
#[doc = "Table Pcrel8Indirect"]
#[derive(Clone, Debug)]
pub enum Pcrel8Indirect {
    Var0(Pcrel8IndirectVar0),
}
impl Pcrel8Indirect {
    pub fn display_extend<T>(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &T,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.display_extend(display, context),
        }
    }
    fn disassembly<'a, T>(
        &mut self,
        context_param: &mut T,
        inst_start: u32,
        inst_next: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) where
        T: ContextTrait + Clone,
    {
        match self {
            Self::Var0(x) => x.disassembly(
                context_param,
                inst_start,
                inst_next,
                global_set_param,
            ),
        }
    }
    pub fn parse<'a, T>(
        tokens_param: &'a [u8],
        context_param: &mut T,
        inst_start: u32,
        global_set_param: &mut impl GlobalSetTrait,
    ) -> Option<(u32, Self)>
    where
        T: ContextTrait + Clone,
    {
        let mut context_current = context_param.clone();
        if let Some((inst_next, parsed)) = Pcrel8IndirectVar0::parse(
            tokens_param,
            &mut context_current,
            inst_start,
            global_set_param,
        ) {
            *context_param = context_current;
            return Some((inst_next, Self::Var0(parsed)));
        }
        None
    }
}
